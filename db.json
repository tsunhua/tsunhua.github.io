{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/kiss/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/images/moon.jpg","path":"css/images/moon.jpg","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/music.png","path":"music.png","modified":0,"renderable":0},{"_id":"source/qrcode.jpg","path":"qrcode.jpg","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/tip_img.png","path":"tip_img.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/kiss/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1623687047362},{"_id":"themes/kiss/_config.yml","hash":"afbc0a78bd8597a589e6ff3d0d65697112ff63e3","modified":1629728759225},{"_id":"themes/kiss/LICENSE","hash":"62aacb980e619f9d4f3d1a99fd314536ae3333d8","modified":1623687047362},{"_id":"themes/kiss/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1623687047362},{"_id":"themes/kiss/README.md","hash":"6bf498ae8b83d9fc9db745c6d0466097b15befc9","modified":1623687047362},{"_id":"themes/kiss/package.json","hash":"34fd08dcb523831b71705c737f7f5b42a24115a8","modified":1635805028566},{"_id":"themes/kiss/languages/default.yml","hash":"92b0b4a119d171b6a0074832785dddb715773dd5","modified":1629728038213},{"_id":"themes/kiss/languages/ja.yml","hash":"4b4460d45c4731327f4b08775afc963a508bd0da","modified":1629728069917},{"_id":"themes/kiss/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1623687047371},{"_id":"themes/kiss/languages/zh-CN.yml","hash":"2c37c7af13aea853a8229348bf350e6d53311e7c","modified":1629728082401},{"_id":"themes/kiss/languages/zh-TW.yml","hash":"9a7a80ae095a9f74377873767b336d2b8f478d10","modified":1629728091321},{"_id":"themes/kiss/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1623687047371},{"_id":"themes/kiss/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1623687047372},{"_id":"themes/kiss/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1623687047371},{"_id":"themes/kiss/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1623687047374},{"_id":"themes/kiss/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1623687047372},{"_id":"themes/kiss/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1623687047372},{"_id":"themes/kiss/layout/_partial/after-footer.ejs","hash":"c8a0b16aa29466bf4c288b48a4b458b2ac69ada7","modified":1623687047364},{"_id":"themes/kiss/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1623687047364},{"_id":"themes/kiss/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1623687047372},{"_id":"themes/kiss/layout/_partial/archive.ejs","hash":"e7685a13665c7beb57a62bee010c14ca9d251fc8","modified":1630854289882},{"_id":"themes/kiss/layout/_partial/footer.ejs","hash":"bcf6b2edb6165b6493119cafcfbc640893c25797","modified":1631294808061},{"_id":"themes/kiss/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1623687047365},{"_id":"themes/kiss/layout/_partial/article.ejs","hash":"f76d3d99a870eb272e02f7d4e6cb286728d65b4d","modified":1623687047364},{"_id":"themes/kiss/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1623687047365},{"_id":"themes/kiss/layout/_partial/head.ejs","hash":"d5609f083587b5c51f1244a2ae82f319547b105f","modified":1623687047365},{"_id":"themes/kiss/layout/_partial/header.ejs","hash":"fcad9eb622ecdd9ff828b90dc9d41da3aee277f5","modified":1629726577716},{"_id":"themes/kiss/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1623687047366},{"_id":"themes/kiss/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1623687047369},{"_id":"themes/kiss/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1623687047368},{"_id":"themes/kiss/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1623687047368},{"_id":"themes/kiss/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1629727377677},{"_id":"themes/kiss/layout/_widget/tagcloud.ejs","hash":"439aee1aa676b2acd9510893206193078112ec7e","modified":1629727999960},{"_id":"themes/kiss/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1623687047369},{"_id":"themes/kiss/layout/_widget/tip.ejs","hash":"d1c3d925c3b878cf62d6149d86559039bb6a115e","modified":1630852802523},{"_id":"themes/kiss/source/css/_extend.styl","hash":"3d0095dfc6c3aaf7028de1aace2599bcb99ede82","modified":1623687047374},{"_id":"themes/kiss/layout/_widget/qrcode.ejs","hash":"8d2e52602a04775d911b5fbaa817c0446afd54ba","modified":1630855026023},{"_id":"themes/kiss/source/css/_variables.styl","hash":"f3624f36c1d39a2f3089586fe0620ad1e538c245","modified":1632845107339},{"_id":"themes/kiss/source/css/style.styl","hash":"d480f717465970cf6dfccdb6d1af18fba16cbdd0","modified":1623687047384},{"_id":"themes/kiss/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1623687047384},{"_id":"themes/kiss/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1623687047384},{"_id":"themes/kiss/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1623687047384},{"_id":"themes/kiss/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1623687047385},{"_id":"themes/kiss/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1623687047385},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1623687047386},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1623687047387},{"_id":"themes/kiss/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1623687047385},{"_id":"themes/kiss/source/js/script.js","hash":"63c21efc77abda2eec546d66ee832fc9776edabd","modified":1623687047387},{"_id":"themes/kiss/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1623687047377},{"_id":"themes/kiss/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1623687047377},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1623687047387},{"_id":"themes/kiss/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1623687047366},{"_id":"themes/kiss/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1623687047366},{"_id":"themes/kiss/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1623687047366},{"_id":"themes/kiss/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1623687047367},{"_id":"themes/kiss/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1629727382769},{"_id":"themes/kiss/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1623687047368},{"_id":"themes/kiss/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1623687047378},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1623687047379},{"_id":"themes/kiss/source/css/_partial/archive.styl","hash":"82f3417081c67faef39660762eef606a147c13b5","modified":1623687047375},{"_id":"themes/kiss/source/css/_partial/article.styl","hash":"97b4fa7d074019b61ac39f4a600d6ed17ac1680a","modified":1623687047375},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1623687047382},{"_id":"themes/kiss/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1623687047375},{"_id":"themes/kiss/source/css/_partial/footer.styl","hash":"2fa87c61bd4f464276719a5361fc2b37c4c0762b","modified":1623687047375},{"_id":"themes/kiss/source/css/_partial/highlight.styl","hash":"238abf0c47e11a15ed411e99a82797cdf86d6f53","modified":1631546461769},{"_id":"themes/kiss/source/css/_partial/header.styl","hash":"1b9c2b2266469f2d6306c060b893d4a58b6c328c","modified":1629724979099},{"_id":"themes/kiss/source/css/_partial/sidebar-aside.styl","hash":"20cb99acd4bed917ba90c297acaa5276a79d4998","modified":1630854840331},{"_id":"themes/kiss/source/css/_partial/sidebar.styl","hash":"f5c4f4f9875693ff0f851838662639c01877450f","modified":1623687047377},{"_id":"themes/kiss/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1623687047376},{"_id":"themes/kiss/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1623687047385},{"_id":"themes/kiss/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1623687047376},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1623687047386},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1623687047385},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1623687047386},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1623687047386},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1623687047386},{"_id":"themes/kiss/package-lock.json","hash":"f51777dde557140978083ba20515306eadda5382","modified":1635805037053},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1623687047381},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1657986359171},{"_id":"source/favicon.ico","hash":"8ea7fb25464a2608b774153fe6731fd8fd82c1b0","modified":1631467742019},{"_id":"source/README.md","hash":"37db7dab750de0dcf6fc53bff077a5058e01ad54","modified":1631467741815},{"_id":"source/music.png","hash":"3ca73e04c922de92ffb44d6fe4c698720f85b041","modified":1631467742019},{"_id":"source/robots.txt","hash":"be8d5ab7132ac74a9375439e438b00b8c91e50b4","modified":1631467742020},{"_id":"source/_posts/.DS_Store","hash":"5038b016b55b1bdf5fdf672abd15fdd9bab10302","modified":1657986674707},{"_id":"source/tip_img.png","hash":"7abdc78506408cd91b8155911d7c49ef1f9149c3","modified":1631467742020},{"_id":"source/_posts/Hello.md","hash":"04e8f02d1fa4488e2cbb0ddcea3e52487f10a5bb","modified":1631467741815},{"_id":"source/qrcode.jpg","hash":"4d4911dcd6a7a71ec57f46f08e7988fdb7bbbfd7","modified":1631467742020},{"_id":"source/_posts/essay/headache.md","hash":"d80f32d89588dd8dfa5f05c7c9ac896447643a71","modified":1631467741816},{"_id":"source/_posts/essay/light-and-heat.md","hash":"90b6d1854d64dcb4e97078ed893389544623b4b2","modified":1631467741816},{"_id":"source/_posts/essay/criteque-of-pure-reason-i.md","hash":"0acaa52d1d8489d9576558ee1f466f25d3027b6b","modified":1657468302293},{"_id":"source/_posts/essay/think-about-me.md","hash":"073554f072b966a9ae765c62ba4b8275ac61b0f8","modified":1636497545216},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin.md","hash":"b40a9bd7bd910c7800ace59cb0211655e102b8a2","modified":1632399323909},{"_id":"source/_posts/essay/.DS_Store","hash":"9fdf0918db3a0362011298a9f8181e71046bdfff","modified":1632329594265},{"_id":"source/_posts/essay/thinking-about-the-cuckoos-nest.md","hash":"84927623ea183a3bc9d50113864c5dbd0575ac71","modified":1657734107519},{"_id":"source/_posts/language/.DS_Store","hash":"c687afa5481aa31ef8d08bff321296a210cc6b13","modified":1635607958865},{"_id":"source/_posts/music/listen-chopin-raindrop.md","hash":"70d0e546a1bf0cc4b9290bc05f4b3214dd1b6f68","modified":1631542665253},{"_id":"source/_posts/essay/visit-qinghui-garden.md","hash":"de9afc8dd0c1effe74912116016e7d4f48234d25","modified":1631628630742},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1632331346361},{"_id":"source/_posts/it/common/net-io.md","hash":"5c71b5472f7b765bc204f93f01a589ef540c7091","modified":1641306579570},{"_id":"source/_posts/it/common/protobuf-intro.md","hash":"fa2ef2b5a320680be491b2d16d17f6098835fe78","modified":1638622923865},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy.md","hash":"73faeb0b29c50ba1162845272418851472b8ca8f","modified":1658240826213},{"_id":"source/_posts/it/common/unicode.md","hash":"12c14356e19fc1693497abd277ded89787dd5884","modified":1640010945797},{"_id":"source/_posts/it/java/java-basic.md","hash":"46cc4c358094d7d7988deac35d0ad050aca991ff","modified":1631542603308},{"_id":"source/_posts/it/java/java-concurrent.md","hash":"a00a31ae4ee491208d7b936ad4872be23ad62d2a","modified":1631542591359},{"_id":"source/_posts/it/java/java-collection.md","hash":"6a6a313c2b3a9ccb27eee594f7681b83727c1458","modified":1631542598571},{"_id":"source/_posts/it/common/.DS_Store","hash":"1313ffc53d9e34f4d5d25aa7473c28eb0937e135","modified":1658158451533},{"_id":"source/_posts/it/java/java-jvm.md","hash":"1039a33f51b5310d975729e6a9a6dfaf118c764d","modified":1631542536074},{"_id":"source/_posts/it/go/go-basic.md","hash":"d1511b8e05042680754c01ace4e3eae49f5c7269","modified":1631542473804},{"_id":"source/_posts/it/go/go-design-and-implementation-01.md","hash":"8b2980242c1eb99ee3f75e7292fba948c5306665","modified":1631542399837},{"_id":"source/_posts/it/go/concurrency-in-go.md","hash":"6d9ef3e2781547a5be74684106ac413ff21128eb","modified":1632751566652},{"_id":"source/_posts/it/go/go-scheduler.md","hash":"b49522b44a1072ceb9dd9c879a06c9c567f3c312","modified":1641306562579},{"_id":"source/_posts/it/go/go-memory-model.md","hash":"d9cde7d86adefcfeec23bbd0a003b775dc75bc6b","modified":1641306544413},{"_id":"source/_posts/it/go/zodiac-ganzhi-go.md","hash":"b044fb04338da3191851c9831696d808e605fcba","modified":1631542351741},{"_id":"source/_posts/it/go/go-design-and-implementation-02.md","hash":"b82eb5da9b4b7fb96583ab0257053b7abc08d46d","modified":1631542424428},{"_id":"source/_posts/language/min/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1632329565565},{"_id":"source/_posts/it/go/go-tool-pprof.md","hash":"e56f8dd1e04bb9728d017602c5ec5617643c9295","modified":1638625588144},{"_id":"source/_posts/language/jp/keitai-de-nihongo.md","hash":"8404e88ff0531e3bf7f708ae1eb5aa55758998da","modified":1631542195440},{"_id":"source/_posts/language/min/nng-ua-khou-thau.md","hash":"77d66480ff27d22f0695c3735836c7d32055129a","modified":1632930219497},{"_id":"source/_posts/language/min/nang-tu-kang-im.md","hash":"c245fc92bc98fc286221f121782f9431f4b6c260","modified":1632923832979},{"_id":"source/_posts/language/min/phua-ting-tsu-ui-tang-thong-phou.md","hash":"80b0a88d64f705b72c664babdc9233ca7f25c346","modified":1635897436649},{"_id":"source/_posts/language/min/how-to-select-pinyin-for-minnan-language.md","hash":"0429f0139e642d92b50e63231340c4af73fe640b","modified":1631889254564},{"_id":"source/_posts/language/min/sigêng-giamgia.md","hash":"12f2913391fe66fc4488570c15a9958914ae96d9","modified":1635782510442},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung.md","hash":"408bf5c5a2f4a47053e0c254478df94dd7c8abb9","modified":1631541914894},{"_id":"source/_posts/music/listen-chopin-raindrop/cdefgab.jpg","hash":"ce62e60f342c7565b3836eaeffe1bdcdb8e25fb1","modified":1631467742019},{"_id":"source/_posts/language/min/teochew-kahtsi-vowel.md","hash":"98b1d22693b8ab151398b7f4938122e578c3e05b","modified":1631542089753},{"_id":"source/_posts/language/min/tsheng-pheng-ngak-tshng-ku.md","hash":"e1226e1a57025497d7da4eba8c5be1407eff4220","modified":1635807240524},{"_id":"source/_posts/music/listen-chopin-raindrop/piano-keys.gif","hash":"db1a2b3d591cfb88fe67069f81b91746aa38039a","modified":1631467742019},{"_id":"source/_posts/it/common/protobuf-intro/protobuf-field-structure.jpeg","hash":"e20d5e73f2d2053c033cb2ff48e8a3aa17422ad1","modified":1638622785496},{"_id":"source/_posts/it/common/protobuf-intro/w644.jpeg","hash":"4a02d1904b5f910e3f88fef940271b6a9be79bfb","modified":1637501632689},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/4+1-views.png","hash":"8e124e0e904671e7f84a9f16add2449a9d9597ef","modified":1658158406452},{"_id":"source/_posts/it/java/java-basic/20201114_101407.png","hash":"1cdd3a0dc66cb17e34926515dbd121738708761c","modified":1631467741825},{"_id":"source/_posts/it/java/java-collection/Untitled 1.png","hash":"bd4f8e27ff98fce5547f1f4b277ad4debc4f2ca9","modified":1631467741835},{"_id":"source/_posts/it/java/java-collection/Untitled 2.png","hash":"7ff8b589f12130fb2e71530aa5e43aff912ac2a6","modified":1631467741836},{"_id":"source/_posts/it/java/java-collection/Untitled 3.png","hash":"b032986e28a9202479cd743464809b53668cd6b4","modified":1631467741836},{"_id":"source/_posts/it/java/java-concurrent/Untitled 1.png","hash":"5ee21cd407a58fee19858e8672eb69a0b92be4bc","modified":1631467741846},{"_id":"source/_posts/it/java/java-concurrent/Untitled 2.png","hash":"c7b8bcef572daacf2c202a295827a98c03c1548b","modified":1631467741846},{"_id":"source/_posts/it/java/java-concurrent/Untitled 6.png","hash":"54d690bd771379a73a3be2685cb3e9a1a214a616","modified":1631467741852},{"_id":"source/_posts/it/java/java-concurrent/Untitled 8.png","hash":"9bddd2e37f2204ca9d4e47fe883f8910aa9ea2f6","modified":1631467741854},{"_id":"source/_posts/it/java/java-concurrent/Untitled 5.png","hash":"80a8d6ec157951a7b520f8548eff8a0115b6f7b7","modified":1631467741851},{"_id":"source/_posts/it/java/java-jvm/Untitled 2.png","hash":"8d075c8ac9b695152a2d0e8b791061e6ece9df5c","modified":1631467741859},{"_id":"source/_posts/it/java/java-jvm/Untitled 1.png","hash":"e426df900a411215d6bd08b7498b2b87d39dd3df","modified":1631467741859},{"_id":"source/_posts/it/java/java-jvm/Untitled 5.png","hash":"4b1f55e64a2ed3f8af270214698d0ab78cfe6872","modified":1631467741861},{"_id":"source/_posts/it/go/go-basic/Untitled 1.png","hash":"8d2673b96de7b480d61efc015b64e63e38646026","modified":1631467741818},{"_id":"source/_posts/it/go/go-basic/Untitled.png","hash":"4d1c3a7b3408b4d17f7976d3b4fec4cbf2c1fa8a","modified":1631467741818},{"_id":"source/_posts/it/java/java-jvm/Untitled 8.png","hash":"c4aa675c8aa3cc5103cad6a4063efe6f09300bdb","modified":1631467741863},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 2.png","hash":"2c6e57169c2be5b1246a167e4789898cf617b257","modified":1631467741819},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled.png","hash":"86692657ad38d318606d0426de6d0e51579f6a41","modified":1631467741820},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 1.png","hash":"5c7c2d5aae780ddeaa387abafd1acb505780450f","modified":1631467741819},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled 1.png","hash":"9885679f1918d3815db19c046c9a932ebd037161","modified":1631467741821},{"_id":"source/_posts/it/go/go-scheduler/mpg.png","hash":"089d67e28ce11755a25ef35ecb2c185b616708bf","modified":1641300634925},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled.png","hash":"423a6f48a17f1bc2261301efa14a9c069eac008f","modified":1631467741823},{"_id":"source/_posts/it/go/go-scheduler/steal.jpg","hash":"2e735f25a3358d492aa8df6457801da96329c5db","modified":1641300586608},{"_id":"source/_posts/it/go/go-scheduler/syscall.jpg","hash":"2e276fca5fda66e4e8c5237212d614b9964bdc97","modified":1641300578367},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/image.jpg","hash":"25485c91b50a52a36c1dc24f638d219768b6034b","modified":1631467741951},{"_id":"source/_posts/language/min/how-to-select-pinyin-for-minnan-language/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1631882984043},{"_id":"source/_posts/language/min/how-to-select-pinyin-for-minnan-language/W系統和C系統.jpeg","hash":"f40db652028acd90d2cfbbce11356984f1c903c0","modified":1631882284781},{"_id":"source/_posts/language/min/nang-tu-kang-im/ang.jpg","hash":"197b9c6abd0ed59882c7df805e29ef286765e8c6","modified":1632846944091},{"_id":"source/_posts/language/min/sigêng-giamgia/202010060948.jpg","hash":"abcd4e4bc5aeb9b8a1263329adae6b525101d7f6","modified":1631467741969},{"_id":"themes/kiss/source/css/images/moon.jpg","hash":"798c8924ee26b8f402054d6ed5743a18ba9226df","modified":1623687047384},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1623687047380},{"_id":"source/_posts/it/.DS_Store","hash":"163e27d1bb82d20a75a3f9cb128f186c963cdb53","modified":1658238604009},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao.md","hash":"f095fe0c482e1cb208d9cf1db7eb418a814eb8fb","modified":1641390410478},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/3-views-data.png","hash":"4cf35c429f7705eb452b5bbfecbc7daf7e79a8ea","modified":1658158393121},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/5-views.png","hash":"14086b71f591b7dd969b68c653556a82356fb63d","modified":1658158413785},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/3-views-processing.png","hash":"e9b8a98c80c7f0cb5b296564b80287b2d1dc849d","modified":1658158380725},{"_id":"source/_posts/it/java/java-basic/20201202_24328.png","hash":"c992fe54e126ad45512d012b8bf6dcb6a5e36533","modified":1631467741826},{"_id":"source/_posts/it/java/java-basic/Untitled.png","hash":"7feeb782152cb8ddc3c2fb39626145920a92062a","modified":1631467741834},{"_id":"source/_posts/it/java/java-basic/Untitled 1.png","hash":"b0ff3f9c9afb47aa3ec4ae861b96f91ba225de2a","modified":1631467741827},{"_id":"source/_posts/it/java/java-collection/Untitled 6.png","hash":"e31adbdb1887144a8308143ae300d74e0eda4180","modified":1631467741839},{"_id":"source/_posts/it/java/java-collection/Untitled 4.png","hash":"2ddf731a2d67a0b5ff4ee6fbe7f77c5e0afcb484","modified":1631467741837},{"_id":"source/_posts/it/java/java-jvm/Untitled 3.png","hash":"d29574c8d20167f90d055f9f0ac2c722b7e6f0a1","modified":1631467741860},{"_id":"source/_posts/it/java/java-concurrent/_2020-11-16_8.54.01.png","hash":"a36fdf28a8d9266e036f023d2ec8b8ccc5fae2be","modified":1631467741858},{"_id":"source/_posts/it/java/java-jvm/Untitled 4.png","hash":"de2ef5d859f0a9ead28d2269a7fcb80144edc50b","modified":1631467741860},{"_id":"source/_posts/it/java/java-jvm/Untitled 6.png","hash":"d0cced7f09cb7294e019f799a4d1a3adc17c2869","modified":1631467741862},{"_id":"source/_posts/it/java/java-jvm/Untitled 7.png","hash":"32c58be0d5c7b712f7e58c8167c61ff08fd17acf","modified":1631467741863},{"_id":"source/_posts/it/java/java-jvm/Untitled.png","hash":"30643ff19ac17d3c1dbc1626e98dc62df66e1f8d","modified":1631467741864},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 3.png","hash":"cd178b4c15e5bfe7911b1ddbac1efec4a2acc021","modified":1631467741820},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 14.png","hash":"c031c4e755ad4353a46a75183c932128b761e1dc","modified":1631467741871},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 19.png","hash":"c16a8ba5c538423f71699882c6634659bacfb5d5","modified":1631467741875},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 24.png","hash":"9d1ac5223de4f99edf222262252859595c85e321","modified":1631467741880},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 25.png","hash":"473d101fffa104e34cb2cbcc0a428e22c966baba","modified":1631467741880},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 3.png","hash":"085783bec7fc8cb4854543ac682af44cfff6bafa","modified":1631467741885},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 33.png","hash":"0a62ed95f5733e84831d7f5ac376fa9b76e3f049","modified":1631467741888},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 35.png","hash":"08c60dbe8acb355436cad441be2a1bcb3e7b56a9","modified":1631467741889},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 48.png","hash":"d2062951eea06f120c39f9a8cf768d487b8ceb86","modified":1631467741903},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 6.png","hash":"76c65edad08c094999bc714db41ae7b70d951a7a","modified":1631467741916},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 78.png","hash":"83ad7cc6852b8873045410e47a217446ca9e4ba6","modified":1631467741936},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png","hash":"6d446cd3dc8c2f0cfefc0f464ffde9e6ca69605a","modified":1631467741946},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png","hash":"6af3c6177c3f35b4b260ec4220f6fc2a0b0136a7","modified":1631467741948},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled 2.png","hash":"f720ad260caf80e151140805c93957466f39d143","modified":1631467741822},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 11.png","hash":"3829cd163a7291869beec1e2831716e6e598faa7","modified":1631467741868},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 17.png","hash":"2663c8e8c1e6aa3d12a85ba81953cf0ffb2940c3","modified":1631467741873},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 34.png","hash":"4aff07d5b6421154804c83b5e0af12be66ce8b90","modified":1631467741889},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 32.png","hash":"c931893d53d20cf62d464771534063cd1a00a355","modified":1631467741887},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 37.png","hash":"bfd23dc52065cf9689a7672d36ccaee6b3838bad","modified":1631467741891},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 36.png","hash":"b439479608c12b3f6be283eafbd7874dd6827a8d","modified":1631467741890},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 47.png","hash":"89edb396e3c2aaf9db45c548acfcb88fcbfc926f","modified":1631467741902},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 57.png","hash":"b13d2f1d8fee58b64f92213b04f9795a89eb4aae","modified":1631467741912},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 7.png","hash":"6adf698e1f241cdcdd8ff25fcb75ff2862bf3844","modified":1631467741927},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 69.png","hash":"3daee4980804c94b5cd365391a27eff387c80dd2","modified":1631467741926},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 68.png","hash":"3be7c232b4c4ab85d2e288b76ca2a733b3bbfdd5","modified":1631467741925},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 71.png","hash":"b4028b014c0cd25ece3417aa5180a2a14900fffb","modified":1631467741928},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 75.png","hash":"528dcde670ccedbec01fb84d3d4a260127c16c69","modified":1631467741933},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 9.png","hash":"6313844c0aa524cc0b4cbf068b905b49e9ec0509","modified":1631467741944},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png","hash":"d1d67355871a937680ed4207eadd21b280a1be13","modified":1631467741947},{"_id":"source/_posts/language/min/sigêng-giamgia/蒹葭.m4a","hash":"9b489081647694ae1fa69bf4712934565c8a11e3","modified":1631467741970},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3829.jpg","hash":"188a2adc9bbb7fe02fe436081018159b3a887858","modified":1632330740763},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3721.jpg","hash":"a75e29f9f9f91ec67d605ad9ff32fc3e244dd21a","modified":1631544958360},{"_id":"source/_posts/it/java/java-concurrent/Untitled.png","hash":"25e267c1e2f72f077e365bd816d4f62573075511","modified":1631467741855},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 13.png","hash":"aceae21957f9e7de9c3edcc036108460c467fb3d","modified":1631467741870},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 15.png","hash":"50d64d23162ea40b27fe41fdf8c82771f2a8fe9d","modified":1631467741871},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 22.png","hash":"f358240f31acc27c0073202245c38fb31db00c7b","modified":1631467741878},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 23.png","hash":"2c989d254cb3106335df80439190bf9e6e03db1d","modified":1631467741879},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 30.png","hash":"f76a5d94bbc1244d43763e57b394e49adee9d27a","modified":1631467741886},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 4.png","hash":"9b66fec364c2b5695f84aa4bf68d678d8d3e81d3","modified":1631467741894},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 5.png","hash":"ca731ffd8b5571c1c8d0f1076997b772247b139a","modified":1631467741905},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 52.png","hash":"4101f0dc6ee2d6fe4c170903ad1712e82f9d107b","modified":1631467741908},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 53.png","hash":"3f14fc60a521be89c7636fb3c58bb48126dd376a","modified":1631467741909},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 62.png","hash":"3ae22b6d0c3e2edebba674eae8ad25386e1f01b0","modified":1631467741920},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 66.png","hash":"d7f561114775c599d4a034b20417c75e6bfa748d","modified":1631467741924},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 8.png","hash":"83687c527fe71b1f2112e573d88fd3e4a9f32acc","modified":1631467741938},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png","hash":"2b572a253d76fbf45c2c9bfe20bda2213ca9f0df","modified":1631467741950},{"_id":"source/_posts/language/min/how-to-select-pinyin-for-minnan-language/聲調.png","hash":"a3710ed97870789ee0b57e78c0adbf0549f79470","modified":1631882888602},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3826.jpg","hash":"32048240b87c34d0fff7955de07b0d09a826ac2d","modified":1632330739666},{"_id":"source/_posts/language/min/tsheng-pheng-ngak-tshng-ku/清平樂·村居.m4a","hash":"889ce25b6435b3a0ee50cf551f8f82c496409465","modified":1635807200465},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3853.jpg","hash":"c83172f55a0bac7fd6cf3a73b1992566dd90cd31","modified":1632330741791},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3965.jpg","hash":"103c11e61889fd97b155b03e482d8c66ce8fb470","modified":1632330757635},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3976.jpg","hash":"c9b2ae5c4dbbfc7b0abc0ae32d819b4462dbce54","modified":1632330759014},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3979.jpg","hash":"c31e8bed0ecc0b35b621f93d482538c1256b1746","modified":1632330760174},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3734.jpg","hash":"abba5009ac43f79d43bdbd7c826e6db0f9bac213","modified":1631544963114},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3736.jpg","hash":"6a7bf92b15b907e092a8e92d017f0eea926e685c","modified":1631544964666},{"_id":"source/_posts/essay/think-about-me/IMG_4140.JPG","hash":"e7761b9a90906b15146f4418af723d8ad1075fee","modified":1636497426368},{"_id":"source/_posts/it/java/java-basic/Untitled 4.png","hash":"af3906ce47f968ea8aded65e377c5f643aa110a8","modified":1631467741834},{"_id":"source/_posts/it/java/java-collection/Untitled 5.png","hash":"922d23d15cb96dffebb5d71187bc17d8f61ae1a1","modified":1631467741838},{"_id":"source/_posts/it/java/java-concurrent/Untitled 3.png","hash":"57b6e1f1ac7c3853bfceb465e28d4396fa3a87a7","modified":1631467741848},{"_id":"source/_posts/it/java/java-concurrent/Untitled 7.png","hash":"66903a5c2006db99d736a25c1c3eef004b9397ff","modified":1631467741854},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 2.png","hash":"519b6e027a590c70b1b198654aa728a746fd3998","modified":1631467741876},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 21.png","hash":"6fbe1b88fbd94c918b899c527ccb8eb2ffdf2af9","modified":1631467741878},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 20.png","hash":"fe003a15de6ac2c8a2af1752399e3fd153bbce15","modified":1631467741877},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 26.png","hash":"3c7419dab2c33da1f0002c5b1696b8a03dcea9fb","modified":1631467741881},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 27.png","hash":"5a928dbd10c1bac4035b20adfbc00cca33b8e44a","modified":1631467741882},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 28.png","hash":"79bd3025d83d6d866be4dcae7a7792b867ee9a7c","modified":1631467741883},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 38.png","hash":"b98bc1e15937512b80964eda63d08735c0948eb9","modified":1631467741892},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 43.png","hash":"9bc088b22cdf937ea561957da666baab2d0b6a0f","modified":1631467741898},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 44.png","hash":"cef5bd836f351b573e4dcc44dbeb0de723ae2025","modified":1631467741899},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 41.png","hash":"c8d4e9d171aafe3c6fd6e48394bde794f22e251d","modified":1631467741896},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 46.png","hash":"95e3359d1e4533c003d152a6bb961f563fa2162c","modified":1631467741901},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 50.png","hash":"bdc548956525a96a5d18d29033e7663fbb566343","modified":1631467741906},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 51.png","hash":"4bff800cc7223a87753f6f73c38312e7cabeaf87","modified":1631467741907},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 54.png","hash":"6eede5ec4373456f5787bd1e1b882b676fdb302d","modified":1631467741910},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 56.png","hash":"12431dbde1395e173bec555c4d42e69a6d8aab09","modified":1631467741912},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 58.png","hash":"0f7f03c55e1b404719a866fba8eab819aee2368b","modified":1631467741913},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 64.png","hash":"007b0160bbe3976d2fd82f347df4e1237840613e","modified":1631467741922},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 65.png","hash":"fbeaa7c8f90ae484da43a7358513773ad4844511","modified":1631467741923},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 63.png","hash":"ff3a9515c5193968899aac10aadbd48526886c29","modified":1631467741921},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 70.png","hash":"a3960ec9ec05c8c97444b43cd35d4b4c4c2dabe1","modified":1631467741928},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 74.png","hash":"5748dbbe314cc185a52b17d25bcae6eb9fe1b3d8","modified":1631467741932},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 76.png","hash":"e677073faf1a318ab9f98c290052e54995f259b7","modified":1631467741934},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 77.png","hash":"4bf008561f52989192e1c4de1212a016d02fefcb","modified":1631467741935},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 80.png","hash":"9ee915ef146da9faed3659510774dc4360882c01","modified":1631467741939},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 81.png","hash":"9f5cdd07cadbc48ab4ad165205a94c4f6e51cc78","modified":1631467741940},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 83.png","hash":"e4c62a60a52f63b976d23f8a1992e1880d9f987c","modified":1631467741941},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 84.png","hash":"bf46c1323d5a946c2e069914c22827702e7a5a0d","modified":1631467741942},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled.png","hash":"60508247f23f0e5b48e864dc7901864db0ff847a","modified":1631467741945},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3925.jpg","hash":"d5d52ec113a3aae76d2defbb4ea064405c1c87c6","modified":1632330748444},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3956.jpg","hash":"cd0d33228f626f2933821d42018ffe22de1ff24d","modified":1632330755029},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3929.jpg","hash":"be23567042a85be581c9466153e9e2c87a43b113","modified":1632330749522},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3937.jpg","hash":"2a6148525e5afd6fbed2e626de7409c2901327e0","modified":1632330753655},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3726.jpg","hash":"ac1cb5ee43def5484fbab1b032a74495b052660b","modified":1631544959479},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3739.jpg","hash":"6515a2341c502b7a49ddf255221ddb97b8fba359","modified":1631544965704},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3744.jpg","hash":"8f88c146cfa4040903b8bbe0aa032acaaa8cd0a2","modified":1631544967796},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3751.jpg","hash":"deff9cf07ecc76dc9f424b38ae41c5b5f30b8750","modified":1631544969036},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3768.jpg","hash":"72c3e58c9bb63d75f001313de36904d20e3342da","modified":1631544972341},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 10.png","hash":"bedefa716e3db4de9f51414ed9e4c9026e8eb479","modified":1631467741868},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 31.png","hash":"bb603ebd66a0d470070445350f39fb6bdba8853a","modified":1631467741887},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 39.png","hash":"729db0180e0e1efcdbae62fda904ae0c07a9001e","modified":1631467741893},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 42.png","hash":"95fcccd01eb74b43ad75991e48294606c697ecaf","modified":1631467741897},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 45.png","hash":"f25020d5b4da4f8639fc8118ba42c93187d7be5f","modified":1631467741900},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 55.png","hash":"9d10d7f96b9a1655249a761f206743a272bfe3f7","modified":1631467741911},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 59.png","hash":"34e3b95cc544ee86a26fdd1a809ba1c3cee940ce","modified":1631467741915},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 60.png","hash":"f52b7c94902735215de69da3d178a6b670adac8f","modified":1631467741917},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 67.png","hash":"203576af7229e5872973befb580be0be57213bd8","modified":1631467741925},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 73.png","hash":"1acabc9e3890c02ef0b0cb5be555aa56eb79d19f","modified":1631467741931},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 79.png","hash":"bd9378249cd99b18a4c91c7a2dfde7ed2f2da310","modified":1631467741937},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 82.png","hash":"40a4c797c671b85c7d1ed1d04c615731b63d85ab","modified":1631467741941},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 85.png","hash":"5cbbe80c24cf9a7f463899d7ec0ace2a1ccf98ab","modified":1631467741944},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3860.jpg","hash":"5f11c8e0a1127b2cb50ce040bdfddc04a2ece971","modified":1632330742771},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3916.jpg","hash":"b57a9de922da6f6cd421d39ebdccf986c430c10c","modified":1632330747408},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3717.jpg","hash":"c0a5272a5c9a10d08b761aa302cdad89bf01765e","modified":1631544956989},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3732.jpg","hash":"8b996ab53238a711c22eed4157f1de5c2fe9a9c0","modified":1631544961793},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3742.jpg","hash":"438f86f7016df155198cfe7586843f084b46bb17","modified":1631544966727},{"_id":"source/_posts/it/java/java-basic/Untitled 3.png","hash":"f21a829671bd0c8e3bcab7d20e7a390363509871","modified":1631467741831},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 1.png","hash":"58d9e174a9d27c1516a3f42ebcbab4ab6bbc9d0d","modified":1631467741867},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 18.png","hash":"06780da5ca0e65135af591a8119441b5b30c0ed4","modified":1631467741874},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 29.png","hash":"8b491d854a87196fe33c712e100091af26d425cf","modified":1631467741884},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 40.png","hash":"9de8f883a4da464eb5633420a6d2455e6c285ee5","modified":1631467741895},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 49.png","hash":"d6694d18e81f9feb8ca72b949075072303d75c58","modified":1631467741904},{"_id":"source/_posts/language/min/how-to-select-pinyin-for-minnan-language/聲母.png","hash":"f5c2662e8751fe1503201a56ede264debc4cacce","modified":1631882737209},{"_id":"source/_posts/language/min/how-to-select-pinyin-for-minnan-language/韻母.png","hash":"06e4adcabb49f3ebfefc093045755ba487cb857a","modified":1631883448638},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3886.jpg","hash":"20d0807d14725fe544259028d9e46aa9e621aa9f","modified":1632330745024},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3763.jpg","hash":"8d85e23c9ae8bf270c174626be07259212f96441","modified":1631544969987},{"_id":"source/_posts/it/java/java-concurrent/Untitled 4.png","hash":"2a18d5e552e56e6ff06599b120e0a2c3f53aa398","modified":1631467741851},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 16.png","hash":"5a78574cd85d20cb5add7255fcc5adb24f69cba9","modified":1631467741873},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 61.png","hash":"c5a73db614a03510c36123b25218cf69e1d41f5d","modified":1631467741919},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3912.jpg","hash":"1f5adf0b89ed905916d5f0ac8279727407bac414","modified":1632330746252},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3985.jpg","hash":"053daade4fbe014b4299cff2e4cc524c8ffa014b","modified":1632330761539},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3730.jpg","hash":"cd5ca62ecc0d4dd13c0a3ed2b3aae8964d0c7349","modified":1631544960585},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3766.jpg","hash":"187bd60b2717cf9463e6713625f09bee6ac2d305","modified":1631544971271},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 12.png","hash":"c000a526b62c3ad898d08a573e9c19f408b160cd","modified":1631467741869},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3778.jpg","hash":"0ce6ac4000686737d24fb8c6f78a488df053de3c","modified":1631544973605},{"_id":"source/_posts/it/go/go-tool-pprof/callgraph.png","hash":"eaf915dd0002eda556cdc2134b88f14156353746","modified":1638623549916},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3931.jpg","hash":"2dcf0fa0d19aa3e676d56ff835bf169173ae039c","modified":1632330750894},{"_id":"source/_posts/language/min/teochew-kahtsi-vowel/202010042112.png","hash":"0b9ffd6564070d7d913668a0aa3dfa827eab26e8","modified":1631467741973},{"_id":"source/_posts/it/java/java-basic/Untitled 2.png","hash":"36b1886c415bc0d597baaa227f833144132032ff","modified":1631467741829},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3874.jpg","hash":"1fba34b3a0435a4babd411d46768985c41b96648","modified":1632330743898},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3957.jpg","hash":"eb0d27f81ca094ecdf48b4c7fd9088a4333048b5","modified":1632330756509},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 72.png","hash":"fb429bdb55a01d0b44dc43cda0ae70afeeda6b69","modified":1631467741930},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3934.jpg","hash":"9089dbe4d9f17aa2a44c60eac05aaa2334523477","modified":1632330752297},{"_id":"source/_posts/it/java/java-collection/Untitled.png","hash":"7a36813b6140feab84abce77938e837272413355","modified":1631467741843},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png","hash":"8fd5a50fb29b7d581d4cc3c99f25aba06d3a9b95","modified":1631467742001},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png","hash":"1ff30cad5d55cf8320e0965be31810db278f4522","modified":1631467742010},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png","hash":"4c88e38f46e12a86b53682f31d3aa56cb8b66e2b","modified":1631467742017},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg","hash":"b2caf9cdcaa183f435adf33d67d1915af116faa2","modified":1631467741966},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png","hash":"6cfc945d1177754ccf8834ca1be4309bd5b512a7","modified":1631467741990},{"_id":"public/atom.xml","hash":"28176a873cee6e963361a892c00879cb3702ff35","modified":1658241040386},{"_id":"public/it/common/net-io/index.html","hash":"8f975d0c5598638c786eaa689a446652a5c1ec7c","modified":1658160471953},{"_id":"public/it/go/go-scheduler/index.html","hash":"239d22357985b99e1b19f297eef5ee38df17c119","modified":1658160471953},{"_id":"public/essay/think-about-me/index.html","hash":"bf585fff4abd0dd7bf88468cd80069758c46f7d5","modified":1658160471953},{"_id":"public/language/min/phua-ting-tsu-ui-tang-thong-phou/index.html","hash":"d2e4c858b99cc935c9eb47dd91a076f959780beb","modified":1658160471953},{"_id":"public/language/min/tsheng-pheng-ngak-tshng-ku/index.html","hash":"00476422a6761578eba490e3855f4c27e0495ff1","modified":1658160471953},{"_id":"public/language/min/nng-ua-khou-thau/index.html","hash":"a8a77204e616e1ebd01be8fbaee8a20d36f98296","modified":1658160471953},{"_id":"public/language/min/nang-tu-kang-im/index.html","hash":"4483243d9d45e2adeab1a97f31007de0fc9315fc","modified":1658160471953},{"_id":"public/essay/headache/index.html","hash":"857867a358f107ce7a697f01ca01e90c3ceb5c14","modified":1658160471953},{"_id":"public/essay/light-and-heat/index.html","hash":"cd40e1fb75647c14a43a14b75e781dde3d4b5ef9","modified":1658160471953},{"_id":"public/Hello/index.html","hash":"1e5118bb6dbad9dc9402295b05f703dd8a8d03e3","modified":1658160471953},{"_id":"public/archives/index.html","hash":"039320b93ca233757ec4104b11af1e10e19ecc8b","modified":1658160471953},{"_id":"public/archives/page/2/index.html","hash":"0c4054c37726334c9efb3d7a340012061b57ae92","modified":1658160471953},{"_id":"public/archives/page/3/index.html","hash":"c7723d48887d4c7db4c61b615636ae8296f49653","modified":1658160471953},{"_id":"public/archives/page/4/index.html","hash":"6bcfdc467f578ff71081324a2f7e6d3cf960af87","modified":1658160471953},{"_id":"public/archives/2019/index.html","hash":"33fd6a21f014b789eae6d1f19633940de6abadcf","modified":1658160471953},{"_id":"public/archives/2019/09/index.html","hash":"6cd398ea230b85a11ef9362c2afe678f23e121cf","modified":1658160471953},{"_id":"public/archives/2020/index.html","hash":"47918f1f2bdea36ad4d6ef4fb3c1a3a534bc1d4a","modified":1658160471953},{"_id":"public/archives/2020/page/2/index.html","hash":"118ff639375802e8fb331450e3d1e664da556c47","modified":1658160471953},{"_id":"public/archives/2020/10/index.html","hash":"cf8d43385295578f821d807c864a2b19e3e5200c","modified":1658160471953},{"_id":"public/archives/2020/11/index.html","hash":"1086d66b1658e7e7c8778bab6315a2c63fc4dd11","modified":1658160471953},{"_id":"public/archives/2020/12/index.html","hash":"af996f97cb7b0e5683a3e3392a47149fed8910d2","modified":1658160471953},{"_id":"public/archives/2021/index.html","hash":"87b293f36de4764e5ab33d5e553a1e2c1bc99986","modified":1658160471953},{"_id":"public/archives/2021/page/2/index.html","hash":"93052c22649a8a2eb3ffdebdd87d39cbace6a727","modified":1658160471953},{"_id":"public/archives/2021/01/index.html","hash":"034572911bbcc9ea46cf2912914238a1554b91e3","modified":1658160471953},{"_id":"public/archives/2021/09/index.html","hash":"cc5ccb123250263d6aa79fb10ba83f3e6ab4315b","modified":1658160471953},{"_id":"public/archives/2021/10/index.html","hash":"e37098eb27cfca15ee63150afd94e3723693f09d","modified":1658160471953},{"_id":"public/archives/2021/11/index.html","hash":"04ea9d7b46b4b13ee72f9a027b03810ee1df85e1","modified":1658160471953},{"_id":"public/archives/2021/12/index.html","hash":"6ddbd7794f7a55c8a2539c925d7b7793e5eca999","modified":1658160471953},{"_id":"public/archives/2022/index.html","hash":"7118a7d12b1a2557822da6448a93dcaae053356f","modified":1658160471953},{"_id":"public/archives/2022/07/index.html","hash":"08b4a23fa66bae39b7de0958d3dcd7840ca6a93d","modified":1658160471953},{"_id":"public/tags/Hello/index.html","hash":"a3aadd494d37440468362b73bb470dd2787b16f0","modified":1658160471953},{"_id":"public/tags/隨筆/index.html","hash":"15551f30cbfe72a81b2b7289363ddb6874c52dcf","modified":1658160471953},{"_id":"public/tags/遊記/index.html","hash":"b92a2f2bcdfaf4e167f2bd78f02295f076ef1bce","modified":1658160471953},{"_id":"public/tags/普通話/index.html","hash":"bc3b0fb22bc20ab61aab41102697dc46c70f0ae8","modified":1658160471953},{"_id":"public/tags/哲學/index.html","hash":"49b136d109eeae6b97ff04b02af84d09a5b741b5","modified":1658160471953},{"_id":"public/tags/我思/index.html","hash":"cdb77eb41e773855a5eba3a5ad1dd8671ae44825","modified":1658160471953},{"_id":"public/tags/電影/index.html","hash":"12947d50992ccc6e2de4124da48e960fa624e0fb","modified":1658160471953},{"_id":"public/tags/聆聽音樂/index.html","hash":"5ea93236d2c3ed9caef650157549065d3ca85096","modified":1658160471953},{"_id":"public/tags/閩南語/index.html","hash":"8ed17ab00a4509540cf45f6eab6d954bc028a42d","modified":1658160471953},{"_id":"public/tags/甲子話/index.html","hash":"b387ff7b97eb5b9a088e4617c0e4b34866c155b1","modified":1658160471953},{"_id":"public/tags/net/index.html","hash":"de84a5b5c0b4e0cf9d728725b47a1d81861ada59","modified":1658160471953},{"_id":"public/tags/軟件架構/index.html","hash":"47f26f5844c70c9030fcf37200efd6df3f1441db","modified":1658160471953},{"_id":"public/tags/Unicode/index.html","hash":"d3b2831f8c4f9eba2b73d3b5cd8fb5cfd4b40283","modified":1658160471953},{"_id":"public/tags/UTF-8/index.html","hash":"00894dd7259a8a8cc4d351e4f0becd4acbeb0ffc","modified":1658160471953},{"_id":"public/tags/UTF-16/index.html","hash":"21ba9a71472bfecfab30c52f95ecbbf2335cb5fa","modified":1658160471953},{"_id":"public/tags/BOM/index.html","hash":"b66197362291be96b7f3125337dcbb58d9e2c719","modified":1658160471953},{"_id":"public/tags/Go/index.html","hash":"32930b584506139e4a8b0fbd02eefc03f62e907e","modified":1658160471953},{"_id":"public/tags/TODO/index.html","hash":"485444e0ce1202681e8af6d61ee00c8c51fe2f58","modified":1658160471953},{"_id":"public/tags/pprof/index.html","hash":"41a487f40df8b77e5a7c25ff816ca70023051c2f","modified":1658160471953},{"_id":"public/tags/十二生肖/index.html","hash":"a502724f7d820d82352e23d70a512a0a5101fde3","modified":1658160471953},{"_id":"public/tags/干支紀年法/index.html","hash":"cd72800ac39fefc9b282aef4bf986302c4f7d797","modified":1658160471953},{"_id":"public/tags/日本語/index.html","hash":"5e1ff9c69301fa2c78f4ce6254a48a197855047b","modified":1658160471953},{"_id":"public/tags/魏晉風流/index.html","hash":"5177a0fb9104acad04c375d0cdaaf445ff355875","modified":1658160471953},{"_id":"public/tags/宋詞/index.html","hash":"560a4ea17e811264749c752c317208a0862797b7","modified":1658160471953},{"_id":"public/tags/詩經/index.html","hash":"021efac3efa18d0f3008a2c604d072032f74de6f","modified":1658160471953},{"_id":"public/tags/潮州話/index.html","hash":"725aa42890dccae69cd75c9a27f0c905498230a5","modified":1658160471953},{"_id":"public/tags/潮劇/index.html","hash":"7f8308d2c8b3d303438665b3fe3a8f1f5ae6d755","modified":1658160471953},{"_id":"public/tags/protobuf/index.html","hash":"533cfebf44ddf3ab0b748d6a2be4cca26e85a542","modified":1658160471953},{"_id":"public/tags/JSON/index.html","hash":"5bfb8909ae71893917f560aedb9ae321659fe5fc","modified":1658160471953},{"_id":"public/tags/Java/index.html","hash":"a6668cbe1641d1f5cd9cafab73aa22856ffc9bd9","modified":1658160471953},{"_id":"public/it/common/software-architecture-and-kants-philosophy/index.html","hash":"b26f036d3bbbdf9a8d9eae0082987d9671c26d99","modified":1658241040386},{"_id":"public/essay/thinking-about-the-cuckoos-nest/index.html","hash":"ce7a6bad5a0e1faf2bc36ea0faf5bedef74a74f6","modified":1658160471953},{"_id":"public/essay/criteque-of-pure-reason-i/index.html","hash":"7f2fe63ecbd594c78d0400740c74879dd71ee0d9","modified":1658160471953},{"_id":"public/it/go/go-memory-model/index.html","hash":"f675ab19f413fc1cf38c00fc989efca1b219c9cb","modified":1658160471953},{"_id":"public/it/common/unicode/index.html","hash":"ae7d93f9d854b0536820cb671dc88a3e0717ee97","modified":1658160471953},{"_id":"public/it/go/go-tool-pprof/index.html","hash":"7d5af299fc2a8d0c5b3d584e961908d68a032af6","modified":1658160471953},{"_id":"public/it/common/protobuf-intro/index.html","hash":"c31e7ef1090755d0b6310d1833a12007c801a908","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/index.html","hash":"6d84174fb8da42dfabb1a92813c9e10f2f710b27","modified":1658160471953},{"_id":"public/language/min/how-to-select-pinyin-for-minnan-language/index.html","hash":"c6fe896fd05dccd2d3f02f31f3ccb8b80746f795","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/index.html","hash":"2a734f2cf6f0cf9b35dc16cc6369eed333de3c62","modified":1658160471953},{"_id":"public/it/go/concurrency-in-go/index.html","hash":"2972ea927886d27fab12cba01ade56fa599401f6","modified":1658160471953},{"_id":"public/it/go/go-design-and-implementation-02/index.html","hash":"e687f4f853c094630b002d46fd2d8864a0e6c3c5","modified":1658160471953},{"_id":"public/it/go/go-design-and-implementation-01/index.html","hash":"943213802046ea416b85f455bb3e8dbb660eedc6","modified":1658160471953},{"_id":"public/it/go/zodiac-ganzhi-go/index.html","hash":"1fcdcddb8ab3986457af44c93716005e83aee16c","modified":1658160471953},{"_id":"public/it/go/go-basic/index.html","hash":"36e27ac5a011030da0df6430b726520aa2dab525","modified":1658160471953},{"_id":"public/it/java/java-jvm/index.html","hash":"71933012bdd42d8855b7b7b18c04bbfc134b35e8","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/index.html","hash":"90d5172c2be80cb19ad704b24cd28aed53f3c413","modified":1658160471953},{"_id":"public/it/java/java-collection/index.html","hash":"aaa60e2d57d24d3d54a7c3617b45ffd5b41b9e05","modified":1658160471953},{"_id":"public/it/java/java-basic/index.html","hash":"bfed3be7025ae384d536a6389cff09ec4a533292","modified":1658160471953},{"_id":"public/it/java/java-concurrent/index.html","hash":"c90a003faabb02b0095afdbf7aea3dee9c9858b0","modified":1658160471953},{"_id":"public/language/min/teochew-kahtsi-vowel/index.html","hash":"a7916f8ba53e16a4cbbbb9d942893daf554d6fce","modified":1658160471953},{"_id":"public/language/min/teochew-opera-ghêgdengcung/index.html","hash":"6b961b0d7b62fe1259060cb828674cabb5568503","modified":1658160471953},{"_id":"public/music/listen-chopin-raindrop/index.html","hash":"c046af60f7a8ca35a1b76a66a84ea4f1a1652cfc","modified":1658160471953},{"_id":"public/language/min/sigêng-giamgia/index.html","hash":"e8a04a6cec1e82b4deab2aa624fd06cf0a5abda1","modified":1658160471953},{"_id":"public/language/jp/keitai-de-nihongo/index.html","hash":"9daf5dfd4c0c01d4f62bc301c0c4817e321c433e","modified":1658160471953},{"_id":"public/index.html","hash":"23de14cf2b61d35dd731ac37846b28a5c71362cc","modified":1658160471953},{"_id":"public/page/3/index.html","hash":"068c1aaee27dd555bd83493b378f4bc2a50f8a85","modified":1658160471953},{"_id":"public/page/2/index.html","hash":"4b400a6df89c6485b18d3f0ca4aa9b789082cca0","modified":1658160471953},{"_id":"public/page/4/index.html","hash":"2991a34a23af4058c3d7c8b14d1fd266da1ca692","modified":1658160471953},{"_id":"public/page/5/index.html","hash":"23c32a36b51382f1f34e0fd2f80aef2ed7604ed1","modified":1658160471953},{"_id":"public/page/6/index.html","hash":"9e428f16b8d7b012c786e88d7e4b7aa8484f44ce","modified":1658160471953},{"_id":"public/page/7/index.html","hash":"7d84bf572a94c4f84892b116e3115d3e2983f016","modified":1658160471953},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1658160471953},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1658160471953},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1658160471953},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1658160471953},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1658160471953},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1658160471953},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1658160471953},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1658160471953},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1658160471953},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1658160471953},{"_id":"public/README.md","hash":"37db7dab750de0dcf6fc53bff077a5058e01ad54","modified":1658160471953},{"_id":"public/favicon.ico","hash":"8ea7fb25464a2608b774153fe6731fd8fd82c1b0","modified":1658160471953},{"_id":"public/qrcode.jpg","hash":"4d4911dcd6a7a71ec57f46f08e7988fdb7bbbfd7","modified":1658160471953},{"_id":"public/robots.txt","hash":"be8d5ab7132ac74a9375439e438b00b8c91e50b4","modified":1658160471953},{"_id":"public/tip_img.png","hash":"7abdc78506408cd91b8155911d7c49ef1f9149c3","modified":1658160471953},{"_id":"public/music.png","hash":"3ca73e04c922de92ffb44d6fe4c698720f85b041","modified":1658160471953},{"_id":"public/music/listen-chopin-raindrop/cdefgab.jpg","hash":"ce62e60f342c7565b3836eaeffe1bdcdb8e25fb1","modified":1658160471953},{"_id":"public/music/listen-chopin-raindrop/piano-keys.gif","hash":"db1a2b3d591cfb88fe67069f81b91746aa38039a","modified":1658160471953},{"_id":"public/it/common/software-architecture-and-kants-philosophy/4+1-views.png","hash":"8e124e0e904671e7f84a9f16add2449a9d9597ef","modified":1658160471953},{"_id":"public/it/go/go-design-and-implementation-01/Untitled 1.png","hash":"5c7c2d5aae780ddeaa387abafd1acb505780450f","modified":1658160471953},{"_id":"public/it/go/go-scheduler/steal.jpg","hash":"2e735f25a3358d492aa8df6457801da96329c5db","modified":1658160471953},{"_id":"public/it/go/go-design-and-implementation-01/Untitled.png","hash":"86692657ad38d318606d0426de6d0e51579f6a41","modified":1658160471953},{"_id":"public/it/go/go-scheduler/syscall.jpg","hash":"2e276fca5fda66e4e8c5237212d614b9964bdc97","modified":1658160471953},{"_id":"public/it/go/go-design-and-implementation-02/Untitled.png","hash":"423a6f48a17f1bc2261301efa14a9c069eac008f","modified":1658160471953},{"_id":"public/it/go/go-design-and-implementation-02/Untitled 1.png","hash":"9885679f1918d3815db19c046c9a932ebd037161","modified":1658160471953},{"_id":"public/it/go/go-design-and-implementation-01/Untitled 2.png","hash":"2c6e57169c2be5b1246a167e4789898cf617b257","modified":1658160471953},{"_id":"public/language/min/how-to-select-pinyin-for-minnan-language/W系統和C系統.jpeg","hash":"f40db652028acd90d2cfbbce11356984f1c903c0","modified":1658160471953},{"_id":"public/language/min/nang-tu-kang-im/ang.jpg","hash":"197b9c6abd0ed59882c7df805e29ef286765e8c6","modified":1658160471953},{"_id":"public/it/common/protobuf-intro/protobuf-field-structure.jpeg","hash":"e20d5e73f2d2053c033cb2ff48e8a3aa17422ad1","modified":1658160471953},{"_id":"public/it/common/protobuf-intro/w644.jpeg","hash":"4a02d1904b5f910e3f88fef940271b6a9be79bfb","modified":1658160471953},{"_id":"public/it/java/java-collection/Untitled 1.png","hash":"bd4f8e27ff98fce5547f1f4b277ad4debc4f2ca9","modified":1658160471953},{"_id":"public/it/java/java-collection/Untitled 3.png","hash":"b032986e28a9202479cd743464809b53668cd6b4","modified":1658160471953},{"_id":"public/it/java/java-collection/Untitled 2.png","hash":"7ff8b589f12130fb2e71530aa5e43aff912ac2a6","modified":1658160471953},{"_id":"public/it/go/go-basic/Untitled 1.png","hash":"8d2673b96de7b480d61efc015b64e63e38646026","modified":1658160471953},{"_id":"public/it/go/go-basic/Untitled.png","hash":"4d1c3a7b3408b4d17f7976d3b4fec4cbf2c1fa8a","modified":1658160471953},{"_id":"public/it/java/java-jvm/Untitled 1.png","hash":"e426df900a411215d6bd08b7498b2b87d39dd3df","modified":1658160471953},{"_id":"public/it/java/java-jvm/Untitled 2.png","hash":"8d075c8ac9b695152a2d0e8b791061e6ece9df5c","modified":1658160471953},{"_id":"public/it/java/java-jvm/Untitled 5.png","hash":"4b1f55e64a2ed3f8af270214698d0ab78cfe6872","modified":1658160471953},{"_id":"public/it/java/java-jvm/Untitled 8.png","hash":"c4aa675c8aa3cc5103cad6a4063efe6f09300bdb","modified":1658160471953},{"_id":"public/it/java/java-basic/20201114_101407.png","hash":"1cdd3a0dc66cb17e34926515dbd121738708761c","modified":1658160471953},{"_id":"public/it/java/java-concurrent/Untitled 1.png","hash":"5ee21cd407a58fee19858e8672eb69a0b92be4bc","modified":1658160471953},{"_id":"public/it/java/java-concurrent/Untitled 2.png","hash":"c7b8bcef572daacf2c202a295827a98c03c1548b","modified":1658160471953},{"_id":"public/it/go/go-scheduler/mpg.png","hash":"089d67e28ce11755a25ef35ecb2c185b616708bf","modified":1658160471953},{"_id":"public/language/min/sigêng-giamgia/202010060948.jpg","hash":"abcd4e4bc5aeb9b8a1263329adae6b525101d7f6","modified":1658160471953},{"_id":"public/it/java/java-concurrent/Untitled 8.png","hash":"9bddd2e37f2204ca9d4e47fe883f8910aa9ea2f6","modified":1658160471953},{"_id":"public/it/java/java-concurrent/Untitled 5.png","hash":"80a8d6ec157951a7b520f8548eff8a0115b6f7b7","modified":1658160471953},{"_id":"public/it/java/java-concurrent/Untitled 6.png","hash":"54d690bd771379a73a3be2685cb3e9a1a214a616","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/image.jpg","hash":"25485c91b50a52a36c1dc24f638d219768b6034b","modified":1658160471953},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1658160471953},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1658160471953},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1658160471953},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1658160471953},{"_id":"public/it/common/software-architecture-and-kants-philosophy/3-views-data.png","hash":"4cf35c429f7705eb452b5bbfecbc7daf7e79a8ea","modified":1658160471953},{"_id":"public/it/common/software-architecture-and-kants-philosophy/3-views-processing.png","hash":"e9b8a98c80c7f0cb5b296564b80287b2d1dc849d","modified":1658160471953},{"_id":"public/it/common/software-architecture-and-kants-philosophy/5-views.png","hash":"14086b71f591b7dd969b68c653556a82356fb63d","modified":1658160471953},{"_id":"public/it/go/go-design-and-implementation-01/Untitled 3.png","hash":"cd178b4c15e5bfe7911b1ddbac1efec4a2acc021","modified":1658160471953},{"_id":"public/it/java/java-collection/Untitled 6.png","hash":"e31adbdb1887144a8308143ae300d74e0eda4180","modified":1658160471953},{"_id":"public/it/java/java-collection/Untitled 4.png","hash":"2ddf731a2d67a0b5ff4ee6fbe7f77c5e0afcb484","modified":1658160471953},{"_id":"public/it/java/java-jvm/Untitled 3.png","hash":"d29574c8d20167f90d055f9f0ac2c722b7e6f0a1","modified":1658160471953},{"_id":"public/it/java/java-jvm/Untitled 4.png","hash":"de2ef5d859f0a9ead28d2269a7fcb80144edc50b","modified":1658160471953},{"_id":"public/it/java/java-jvm/Untitled 7.png","hash":"32c58be0d5c7b712f7e58c8167c61ff08fd17acf","modified":1658160471953},{"_id":"public/it/java/java-jvm/Untitled 6.png","hash":"d0cced7f09cb7294e019f799a4d1a3adc17c2869","modified":1658160471953},{"_id":"public/it/java/java-jvm/Untitled.png","hash":"30643ff19ac17d3c1dbc1626e98dc62df66e1f8d","modified":1658160471953},{"_id":"public/it/java/java-basic/20201202_24328.png","hash":"c992fe54e126ad45512d012b8bf6dcb6a5e36533","modified":1658160471953},{"_id":"public/it/java/java-basic/Untitled 1.png","hash":"b0ff3f9c9afb47aa3ec4ae861b96f91ba225de2a","modified":1658160471953},{"_id":"public/it/java/java-basic/Untitled.png","hash":"7feeb782152cb8ddc3c2fb39626145920a92062a","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 14.png","hash":"c031c4e755ad4353a46a75183c932128b761e1dc","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 19.png","hash":"c16a8ba5c538423f71699882c6634659bacfb5d5","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 24.png","hash":"9d1ac5223de4f99edf222262252859595c85e321","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 25.png","hash":"473d101fffa104e34cb2cbcc0a428e22c966baba","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 3.png","hash":"085783bec7fc8cb4854543ac682af44cfff6bafa","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 33.png","hash":"0a62ed95f5733e84831d7f5ac376fa9b76e3f049","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 35.png","hash":"08c60dbe8acb355436cad441be2a1bcb3e7b56a9","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 48.png","hash":"d2062951eea06f120c39f9a8cf768d487b8ceb86","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 6.png","hash":"76c65edad08c094999bc714db41ae7b70d951a7a","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 78.png","hash":"83ad7cc6852b8873045410e47a217446ca9e4ba6","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png","hash":"6d446cd3dc8c2f0cfefc0f464ffde9e6ca69605a","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png","hash":"6af3c6177c3f35b4b260ec4220f6fc2a0b0136a7","modified":1658160471953},{"_id":"public/it/go/go-design-and-implementation-02/Untitled 2.png","hash":"f720ad260caf80e151140805c93957466f39d143","modified":1658160471953},{"_id":"public/language/min/sigêng-giamgia/蒹葭.m4a","hash":"9b489081647694ae1fa69bf4712934565c8a11e3","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 11.png","hash":"3829cd163a7291869beec1e2831716e6e598faa7","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 30.png","hash":"f76a5d94bbc1244d43763e57b394e49adee9d27a","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 32.png","hash":"c931893d53d20cf62d464771534063cd1a00a355","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 34.png","hash":"4aff07d5b6421154804c83b5e0af12be66ce8b90","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 36.png","hash":"b439479608c12b3f6be283eafbd7874dd6827a8d","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 37.png","hash":"bfd23dc52065cf9689a7672d36ccaee6b3838bad","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 22.png","hash":"f358240f31acc27c0073202245c38fb31db00c7b","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 5.png","hash":"ca731ffd8b5571c1c8d0f1076997b772247b139a","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 57.png","hash":"b13d2f1d8fee58b64f92213b04f9795a89eb4aae","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 68.png","hash":"3be7c232b4c4ab85d2e288b76ca2a733b3bbfdd5","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 69.png","hash":"3daee4980804c94b5cd365391a27eff387c80dd2","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 7.png","hash":"6adf698e1f241cdcdd8ff25fcb75ff2862bf3844","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 71.png","hash":"b4028b014c0cd25ece3417aa5180a2a14900fffb","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 75.png","hash":"528dcde670ccedbec01fb84d3d4a260127c16c69","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 47.png","hash":"89edb396e3c2aaf9db45c548acfcb88fcbfc926f","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 9.png","hash":"6313844c0aa524cc0b4cbf068b905b49e9ec0509","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png","hash":"d1d67355871a937680ed4207eadd21b280a1be13","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png","hash":"2b572a253d76fbf45c2c9bfe20bda2213ca9f0df","modified":1658160471953},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1658160471953},{"_id":"public/js/script.js","hash":"63c21efc77abda2eec546d66ee832fc9776edabd","modified":1658160471953},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1658160471953},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1658160471953},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1658160471953},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1658160471953},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1658160471953},{"_id":"public/css/style.css","hash":"6065e5daa86ea91d442ddd9cc110a7b29bb2313a","modified":1658160471953},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1658160471953},{"_id":"public/css/images/moon.jpg","hash":"798c8924ee26b8f402054d6ed5743a18ba9226df","modified":1658160471953},{"_id":"public/essay/think-about-me/IMG_4140.JPG","hash":"e7761b9a90906b15146f4418af723d8ad1075fee","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3829.jpg","hash":"188a2adc9bbb7fe02fe436081018159b3a887858","modified":1658160471953},{"_id":"public/language/min/how-to-select-pinyin-for-minnan-language/聲調.png","hash":"a3710ed97870789ee0b57e78c0adbf0549f79470","modified":1658160471953},{"_id":"public/language/min/tsheng-pheng-ngak-tshng-ku/清平樂·村居.m4a","hash":"889ce25b6435b3a0ee50cf551f8f82c496409465","modified":1658160471953},{"_id":"public/it/java/java-collection/Untitled 5.png","hash":"922d23d15cb96dffebb5d71187bc17d8f61ae1a1","modified":1658160471953},{"_id":"public/it/java/java-concurrent/Untitled.png","hash":"25e267c1e2f72f077e365bd816d4f62573075511","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 10.png","hash":"bedefa716e3db4de9f51414ed9e4c9026e8eb479","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 17.png","hash":"2663c8e8c1e6aa3d12a85ba81953cf0ffb2940c3","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 21.png","hash":"6fbe1b88fbd94c918b899c527ccb8eb2ffdf2af9","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 23.png","hash":"2c989d254cb3106335df80439190bf9e6e03db1d","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 4.png","hash":"9b66fec364c2b5695f84aa4bf68d678d8d3e81d3","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 46.png","hash":"95e3359d1e4533c003d152a6bb961f563fa2162c","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 53.png","hash":"3f14fc60a521be89c7636fb3c58bb48126dd376a","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 52.png","hash":"4101f0dc6ee2d6fe4c170903ad1712e82f9d107b","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 51.png","hash":"4bff800cc7223a87753f6f73c38312e7cabeaf87","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 62.png","hash":"3ae22b6d0c3e2edebba674eae8ad25386e1f01b0","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 66.png","hash":"d7f561114775c599d4a034b20417c75e6bfa748d","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 8.png","hash":"83687c527fe71b1f2112e573d88fd3e4a9f32acc","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled.png","hash":"60508247f23f0e5b48e864dc7901864db0ff847a","modified":1658160471953},{"_id":"public/assets/js/DPlayer.min.js","hash":"490148a22ab2b03a880495cc733ecd1840c02ed6","modified":1658160471953},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3721.jpg","hash":"a75e29f9f9f91ec67d605ad9ff32fc3e244dd21a","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3734.jpg","hash":"abba5009ac43f79d43bdbd7c826e6db0f9bac213","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3736.jpg","hash":"6a7bf92b15b907e092a8e92d017f0eea926e685c","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3751.jpg","hash":"deff9cf07ecc76dc9f424b38ae41c5b5f30b8750","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3826.jpg","hash":"32048240b87c34d0fff7955de07b0d09a826ac2d","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3925.jpg","hash":"d5d52ec113a3aae76d2defbb4ea064405c1c87c6","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3929.jpg","hash":"be23567042a85be581c9466153e9e2c87a43b113","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3965.jpg","hash":"103c11e61889fd97b155b03e482d8c66ce8fb470","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3979.jpg","hash":"c31e8bed0ecc0b35b621f93d482538c1256b1746","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3976.jpg","hash":"c9b2ae5c4dbbfc7b0abc0ae32d819b4462dbce54","modified":1658160471953},{"_id":"public/it/java/java-concurrent/Untitled 3.png","hash":"57b6e1f1ac7c3853bfceb465e28d4396fa3a87a7","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 15.png","hash":"50d64d23162ea40b27fe41fdf8c82771f2a8fe9d","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 2.png","hash":"519b6e027a590c70b1b198654aa728a746fd3998","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 18.png","hash":"06780da5ca0e65135af591a8119441b5b30c0ed4","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 20.png","hash":"fe003a15de6ac2c8a2af1752399e3fd153bbce15","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 27.png","hash":"5a928dbd10c1bac4035b20adfbc00cca33b8e44a","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 28.png","hash":"79bd3025d83d6d866be4dcae7a7792b867ee9a7c","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 39.png","hash":"729db0180e0e1efcdbae62fda904ae0c07a9001e","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 41.png","hash":"c8d4e9d171aafe3c6fd6e48394bde794f22e251d","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 31.png","hash":"bb603ebd66a0d470070445350f39fb6bdba8853a","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 45.png","hash":"f25020d5b4da4f8639fc8118ba42c93187d7be5f","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 43.png","hash":"9bc088b22cdf937ea561957da666baab2d0b6a0f","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 44.png","hash":"cef5bd836f351b573e4dcc44dbeb0de723ae2025","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 54.png","hash":"6eede5ec4373456f5787bd1e1b882b676fdb302d","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 50.png","hash":"bdc548956525a96a5d18d29033e7663fbb566343","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 58.png","hash":"0f7f03c55e1b404719a866fba8eab819aee2368b","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 56.png","hash":"12431dbde1395e173bec555c4d42e69a6d8aab09","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 63.png","hash":"ff3a9515c5193968899aac10aadbd48526886c29","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 67.png","hash":"203576af7229e5872973befb580be0be57213bd8","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 65.png","hash":"fbeaa7c8f90ae484da43a7358513773ad4844511","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 70.png","hash":"a3960ec9ec05c8c97444b43cd35d4b4c4c2dabe1","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 74.png","hash":"5748dbbe314cc185a52b17d25bcae6eb9fe1b3d8","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 73.png","hash":"1acabc9e3890c02ef0b0cb5be555aa56eb79d19f","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 77.png","hash":"4bf008561f52989192e1c4de1212a016d02fefcb","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 81.png","hash":"9f5cdd07cadbc48ab4ad165205a94c4f6e51cc78","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 80.png","hash":"9ee915ef146da9faed3659510774dc4360882c01","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 84.png","hash":"bf46c1323d5a946c2e069914c22827702e7a5a0d","modified":1658160471953},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3744.jpg","hash":"8f88c146cfa4040903b8bbe0aa032acaaa8cd0a2","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3768.jpg","hash":"72c3e58c9bb63d75f001313de36904d20e3342da","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3853.jpg","hash":"c83172f55a0bac7fd6cf3a73b1992566dd90cd31","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3937.jpg","hash":"2a6148525e5afd6fbed2e626de7409c2901327e0","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3956.jpg","hash":"cd0d33228f626f2933821d42018ffe22de1ff24d","modified":1658160471953},{"_id":"public/it/java/java-basic/Untitled 4.png","hash":"af3906ce47f968ea8aded65e377c5f643aa110a8","modified":1658160471953},{"_id":"public/it/java/java-concurrent/Untitled 7.png","hash":"66903a5c2006db99d736a25c1c3eef004b9397ff","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 1.png","hash":"58d9e174a9d27c1516a3f42ebcbab4ab6bbc9d0d","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 12.png","hash":"c000a526b62c3ad898d08a573e9c19f408b160cd","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 26.png","hash":"3c7419dab2c33da1f0002c5b1696b8a03dcea9fb","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 38.png","hash":"b98bc1e15937512b80964eda63d08735c0948eb9","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 40.png","hash":"9de8f883a4da464eb5633420a6d2455e6c285ee5","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 55.png","hash":"9d10d7f96b9a1655249a761f206743a272bfe3f7","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 60.png","hash":"f52b7c94902735215de69da3d178a6b670adac8f","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 64.png","hash":"007b0160bbe3976d2fd82f347df4e1237840613e","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 49.png","hash":"d6694d18e81f9feb8ca72b949075072303d75c58","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 76.png","hash":"e677073faf1a318ab9f98c290052e54995f259b7","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 79.png","hash":"bd9378249cd99b18a4c91c7a2dfde7ed2f2da310","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 82.png","hash":"40a4c797c671b85c7d1ed1d04c615731b63d85ab","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 85.png","hash":"5cbbe80c24cf9a7f463899d7ec0ace2a1ccf98ab","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 83.png","hash":"e4c62a60a52f63b976d23f8a1992e1880d9f987c","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3732.jpg","hash":"8b996ab53238a711c22eed4157f1de5c2fe9a9c0","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3886.jpg","hash":"20d0807d14725fe544259028d9e46aa9e621aa9f","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3912.jpg","hash":"1f5adf0b89ed905916d5f0ac8279727407bac414","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3916.jpg","hash":"b57a9de922da6f6cd421d39ebdccf986c430c10c","modified":1658160471953},{"_id":"public/language/min/how-to-select-pinyin-for-minnan-language/韻母.png","hash":"06e4adcabb49f3ebfefc093045755ba487cb857a","modified":1658160471953},{"_id":"public/it/java/java-basic/Untitled 3.png","hash":"f21a829671bd0c8e3bcab7d20e7a390363509871","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 16.png","hash":"5a78574cd85d20cb5add7255fcc5adb24f69cba9","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 29.png","hash":"8b491d854a87196fe33c712e100091af26d425cf","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 13.png","hash":"aceae21957f9e7de9c3edcc036108460c467fb3d","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 59.png","hash":"34e3b95cc544ee86a26fdd1a809ba1c3cee940ce","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 61.png","hash":"c5a73db614a03510c36123b25218cf69e1d41f5d","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3860.jpg","hash":"5f11c8e0a1127b2cb50ce040bdfddc04a2ece971","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3726.jpg","hash":"ac1cb5ee43def5484fbab1b032a74495b052660b","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3717.jpg","hash":"c0a5272a5c9a10d08b761aa302cdad89bf01765e","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3739.jpg","hash":"6515a2341c502b7a49ddf255221ddb97b8fba359","modified":1658160471953},{"_id":"public/it/java/java-concurrent/Untitled 4.png","hash":"2a18d5e552e56e6ff06599b120e0a2c3f53aa398","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 42.png","hash":"95fcccd01eb74b43ad75991e48294606c697ecaf","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3763.jpg","hash":"8d85e23c9ae8bf270c174626be07259212f96441","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3778.jpg","hash":"0ce6ac4000686737d24fb8c6f78a488df053de3c","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3742.jpg","hash":"438f86f7016df155198cfe7586843f084b46bb17","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3985.jpg","hash":"053daade4fbe014b4299cff2e4cc524c8ffa014b","modified":1658160471953},{"_id":"public/language/min/how-to-select-pinyin-for-minnan-language/聲母.png","hash":"f5c2662e8751fe1503201a56ede264debc4cacce","modified":1658160471953},{"_id":"public/it/go/go-tool-pprof/callgraph.png","hash":"eaf915dd0002eda556cdc2134b88f14156353746","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3730.jpg","hash":"cd5ca62ecc0d4dd13c0a3ed2b3aae8964d0c7349","modified":1658160471953},{"_id":"public/it/java/java-basic/Untitled 2.png","hash":"36b1886c415bc0d597baaa227f833144132032ff","modified":1658160471953},{"_id":"public/language/min/teochew-kahtsi-vowel/202010042112.png","hash":"0b9ffd6564070d7d913668a0aa3dfa827eab26e8","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3874.jpg","hash":"1fba34b3a0435a4babd411d46768985c41b96648","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3934.jpg","hash":"9089dbe4d9f17aa2a44c60eac05aaa2334523477","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 72.png","hash":"fb429bdb55a01d0b44dc43cda0ae70afeeda6b69","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3957.jpg","hash":"eb0d27f81ca094ecdf48b4c7fd9088a4333048b5","modified":1658160471953},{"_id":"public/essay/seeing-and-hearing-in-guilin/IMG_3931.jpg","hash":"2dcf0fa0d19aa3e676d56ff835bf169173ae039c","modified":1658160471953},{"_id":"public/essay/visit-qinghui-garden/IMG_3766.jpg","hash":"187bd60b2717cf9463e6713625f09bee6ac2d305","modified":1658160471953},{"_id":"public/it/java/java-collection/Untitled.png","hash":"7a36813b6140feab84abce77938e837272413355","modified":1658160471953},{"_id":"public/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png","hash":"1ff30cad5d55cf8320e0965be31810db278f4522","modified":1658160471953},{"_id":"public/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png","hash":"4c88e38f46e12a86b53682f31d3aa56cb8b66e2b","modified":1658160471953},{"_id":"public/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png","hash":"8fd5a50fb29b7d581d4cc3c99f25aba06d3a9b95","modified":1658160471953},{"_id":"public/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png","hash":"6cfc945d1177754ccf8834ca1be4309bd5b512a7","modified":1658160471953},{"_id":"public/language/min/gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg","hash":"b2caf9cdcaa183f435adf33d67d1915af116faa2","modified":1658160471953},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/c4-model.jpg","hash":"477164e8cebc8cc84a2a1b2a3fdfda44e36ea615","modified":1658238685109},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1658238708308},{"_id":"public/it/common/software-architecture-and-kants-philosophy/c4-model.jpg","hash":"477164e8cebc8cc84a2a1b2a3fdfda44e36ea615","modified":1658241040386}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","date":"2019-09-01T09:02:23.000Z","_content":"\n汝好，世界\n\n幸會，世界\n\n您好，世界\n\nHello World\n\nこんにちは、世界\n\n\n\n\n\n","source":"_posts/Hello.md","raw":"---\ntitle: Hello World\ndate: 2019-09-01 17:02:23\ntags: Hello\n---\n\n汝好，世界\n\n幸會，世界\n\n您好，世界\n\nHello World\n\nこんにちは、世界\n\n\n\n\n\n","slug":"Hello","published":1,"updated":"2021-09-12T17:29:01.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxled00001n9k2a48cr5n","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>汝好，世界</p>\n<p>幸會，世界</p>\n<p>您好，世界</p>\n<p>Hello World</p>\n<p>こんにちは、世界</p>\n","site":{"data":{}},"excerpt":"","more":"<p>汝好，世界</p>\n<p>幸會，世界</p>\n<p>您好，世界</p>\n<p>Hello World</p>\n<p>こんにちは、世界</p>\n"},{"title":"頭痛","p":"essay/headache","date":"2021-09-10T16:26:47.000Z","_content":"\n頭好痛啊，顱骨一陣陣地刺痛，頭顱恐怕要炸裂了。\n腿挪不動了，腳一步步仍在原地，腿腳肯定被下咒了。\n\n身體雖困於此，靈魂卻在外遊來蕩去。\n想出去找回靈魂，卻不知去向何方。\n\n<!--more-->\n\n回憶起童年，確信那時候靈魂在體\n成長到底是什麼魔力，令我靈魂出竅\n\n呵...\n\n成長不過是走向死亡的逐漸凋零\n皮囊不再，凌遲般的痛苦\n\n成長究竟是失卻靈魂的逐漸爲奴\n農奴工奴，血肉造的機器\n\n","source":"_posts/essay/headache.md","raw":"---\ntitle: 頭痛\np: essay/headache\ndate: 2021-09-11 00:26:47\ntags: 隨筆\n---\n\n頭好痛啊，顱骨一陣陣地刺痛，頭顱恐怕要炸裂了。\n腿挪不動了，腳一步步仍在原地，腿腳肯定被下咒了。\n\n身體雖困於此，靈魂卻在外遊來蕩去。\n想出去找回靈魂，卻不知去向何方。\n\n<!--more-->\n\n回憶起童年，確信那時候靈魂在體\n成長到底是什麼魔力，令我靈魂出竅\n\n呵...\n\n成長不過是走向死亡的逐漸凋零\n皮囊不再，凌遲般的痛苦\n\n成長究竟是失卻靈魂的逐漸爲奴\n農奴工奴，血肉造的機器\n\n","slug":"essay/headache","published":1,"updated":"2021-09-12T17:29:01.816Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxleh00011n9kftz475pr","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>頭好痛啊，顱骨一陣陣地刺痛，頭顱恐怕要炸裂了。<br>腿挪不動了，腳一步步仍在原地，腿腳肯定被下咒了。</p>\n<p>身體雖困於此，靈魂卻在外遊來蕩去。<br>想出去找回靈魂，卻不知去向何方。</p>\n<span id=\"more\"></span>\n\n<p>回憶起童年，確信那時候靈魂在體<br>成長到底是什麼魔力，令我靈魂出竅</p>\n<p>呵…</p>\n<p>成長不過是走向死亡的逐漸凋零<br>皮囊不再，凌遲般的痛苦</p>\n<p>成長究竟是失卻靈魂的逐漸爲奴<br>農奴工奴，血肉造的機器</p>\n","site":{"data":{}},"excerpt":"<p>頭好痛啊，顱骨一陣陣地刺痛，頭顱恐怕要炸裂了。<br>腿挪不動了，腳一步步仍在原地，腿腳肯定被下咒了。</p>\n<p>身體雖困於此，靈魂卻在外遊來蕩去。<br>想出去找回靈魂，卻不知去向何方。</p>","more":"<p>回憶起童年，確信那時候靈魂在體<br>成長到底是什麼魔力，令我靈魂出竅</p>\n<p>呵…</p>\n<p>成長不過是走向死亡的逐漸凋零<br>皮囊不再，凌遲般的痛苦</p>\n<p>成長究竟是失卻靈魂的逐漸爲奴<br>農奴工奴，血肉造的機器</p>"},{"title":"光和熱","p":"essay/light-and-heat","date":"2021-09-05T14:17:00.000Z","_content":"\n我努力地呼吸\nI try hard to breathe\n仍然覺得氧氣不夠\nMaybe the oxygen is too thin and\n肺部仿佛被什麼東西重重壓著\nSomething heavy presses my lung\n快要令我窒息\nWhich make me suffocating\n\n<!--more-->\n\n我努力地呼吸\nI try hard to breathe\n想到兒時的烏婆嶺\nThink of the Oubo hill\n那兒風吹樹葉陽光正好\nWhere the wind brows the leaves, the sunshine is perfect\n我跑步去到那裡\nAnd I go running\n\n何等光彩奪目\nHow dazzling the sunshine is\n我關掉了空調\nI turn off the air-conditioner \n推開窗\nAnd push the window\n感受光和熱\nFeel the light and heat\n","source":"_posts/essay/light-and-heat.md","raw":"---\ntitle: 光和熱\np: essay/light-and-heat\ndate: 2021-09-05 22:17:00\ntags: 隨筆\n---\n\n我努力地呼吸\nI try hard to breathe\n仍然覺得氧氣不夠\nMaybe the oxygen is too thin and\n肺部仿佛被什麼東西重重壓著\nSomething heavy presses my lung\n快要令我窒息\nWhich make me suffocating\n\n<!--more-->\n\n我努力地呼吸\nI try hard to breathe\n想到兒時的烏婆嶺\nThink of the Oubo hill\n那兒風吹樹葉陽光正好\nWhere the wind brows the leaves, the sunshine is perfect\n我跑步去到那裡\nAnd I go running\n\n何等光彩奪目\nHow dazzling the sunshine is\n我關掉了空調\nI turn off the air-conditioner \n推開窗\nAnd push the window\n感受光和熱\nFeel the light and heat\n","slug":"essay/light-and-heat","published":1,"updated":"2021-09-12T17:29:01.816Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlek00031n9kdo0s2ytt","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>我努力地呼吸<br>I try hard to breathe<br>仍然覺得氧氣不夠<br>Maybe the oxygen is too thin and<br>肺部仿佛被什麼東西重重壓著<br>Something heavy presses my lung<br>快要令我窒息<br>Which make me suffocating</p>\n<span id=\"more\"></span>\n\n<p>我努力地呼吸<br>I try hard to breathe<br>想到兒時的烏婆嶺<br>Think of the Oubo hill<br>那兒風吹樹葉陽光正好<br>Where the wind brows the leaves, the sunshine is perfect<br>我跑步去到那裡<br>And I go running</p>\n<p>何等光彩奪目<br>How dazzling the sunshine is<br>我關掉了空調<br>I turn off the air-conditioner<br>推開窗<br>And push the window<br>感受光和熱<br>Feel the light and heat</p>\n","site":{"data":{}},"excerpt":"<p>我努力地呼吸<br>I try hard to breathe<br>仍然覺得氧氣不夠<br>Maybe the oxygen is too thin and<br>肺部仿佛被什麼東西重重壓著<br>Something heavy presses my lung<br>快要令我窒息<br>Which make me suffocating</p>","more":"<p>我努力地呼吸<br>I try hard to breathe<br>想到兒時的烏婆嶺<br>Think of the Oubo hill<br>那兒風吹樹葉陽光正好<br>Where the wind brows the leaves, the sunshine is perfect<br>我跑步去到那裡<br>And I go running</p>\n<p>何等光彩奪目<br>How dazzling the sunshine is<br>我關掉了空調<br>I turn off the air-conditioner<br>推開窗<br>And push the window<br>感受光和熱<br>Feel the light and heat</p>"},{"title":"桂林見聞","date":"2021-09-22T06:50:26.000Z","p":"essay/seeing-and-hearing-in-guilin","_content":"\n中秋假期，跟著杜同學及其同事大雄前往廣西桂林旅遊，導遊姓張。這是我第一次跟團旅遊，種種見聞令人難忘，不妨一書以待「後之覽者亦將有感於斯文」。\n\n<!--more-->\n\n第一日，早上先在萬福廣場吃了一頓桂林米粉。這米粉咬下去很乾脆地斷了，不粘連，很有口感。隨後坐車到陽朔興坪鎮灕江景區，坐船游灕江。\n\n泛舟灕江中，眼見這山直直聳立又層巒疊嶂，水乾乾淨淨又綠意盎然，杜同學直言其想跳水入江游泳，我深感贊同。然恨游藝不精，未能施行。\n\n![桂林山水](seeing-and-hearing-in-guilin/IMG_3826.jpg)\n\n遊到「20元人民幣背景」時，船停了一會兒，開始提供收費拍照服務，還有付費鸕鶿道具服務。\n\n只見兩隻鸕鶿被綁住腳、綑住喙、套住喙尖後置於一根竹竿之上，遊客擔起竹竿拍照。此時我心裏閃過一想法：放過鸕鶿吧，既然不再需要其捕魚，就令其自由吧。而後又想到這背後可能牽涉到一些以其維生的家庭。思索一番後，我認為還是逐步放棄鸕鶿拍照和表演爲好，文明的社會不應以施虐動物爲樂。\n\n![鸕鶿道具](seeing-and-hearing-in-guilin/IMG_3829.jpg)\n\n中午團餐吃了啤酒魚，味道不錯。\n\n下午到一處靜水區坐「竹筏」`(現在都是用PVC塑料管了，杜同學想體驗真正的竹筏估計要自己造一個了)`遊江，筏上風光旖旎，風徐徐地吹過，相當愜意。\n\n![筏上風光](seeing-and-hearing-in-guilin/IMG_3860.jpg)\n\n遊畢到一古戲樓，樓下有一榕樹，其樹幹被雕刻上凸眼獠牙怪，而其上枝葉正茂。\n\n![樹雕](seeing-and-hearing-in-guilin/IMG_3874.jpg)\n\n遊出戲樓門口前有吆喝摸烏龜。我順手一摸，說是送一銅錢。我拿了就走，沒想到被喊住，說是去一處包裝。去到所指的櫃檯，有一個傢伙吧啦吧啦問屬相開始算命。我心不在焉地聽了，算完他拿出一本子上，說是讓我添些香火錢。我一看，好傢伙！一次都是上百的。我擺擺手，離開了戲樓。\n\n這都 21世紀了，還有人在宣傳烏龜、貔貅和命理，進而撈錢。\n\n又到一景區，門可羅雀，景區內所有的景點都以逍遙爲名，瀑布叫逍遙瀑，湖叫逍遙湖，樓叫逍遙樓。造此景者大概詞窮了，於是通通都是逍遙，看名字就覺得乏味。\n\n景區內有收費坐筏遊湖唱山歌服務，工作人員看我們走上山路，說：上面是遊客出口，下面才是風景。\n\n我看這水這般濁，這筏如此舊，山也不及灕江好看，怎的是風景了？\n\n不一會兒，行到逍遙樓。登上樓，樓內空空如也又破落不堪，底下居然自稱與黃鶴樓齊名。\n\n![「逍遙樓」](seeing-and-hearing-in-guilin/IMG_3886.jpg)\n\n晚上團餐吃了啤酒魚，難吃。\n\n第二日先到一處「博物館」，名曰「抱樸博物館」，掛牌爲3A景區。此館有 A、B 兩區，A 區主要宣傳五行八卦、貔貅、烏龜和戴珠寶的名人，並直通賣大型翡翠珠寶賣場；B 區展出一些化石和玉石。\n\n我深深感覺到「博物館」這個詞遭到了污辱，假博物館之名，行銷售賣貨之實，真真是掛羊頭賣狗肉啊。另外，館內會有工作人員跟著你，向你推薦商品。如果你脫離了跟屁蟲，到處遊蕩，會被路過的工作人員詢問要去哪裏。而我只回答：看看。\n\n翡翠珠寶看膩了，實在無聊得很，只能找一處跟大雄坐著看書去了。\n\n中午團餐又吃了啤酒魚，難吃。\n\n下午又去坐「竹筏」，不過這次另有收費服務，是水槍，開槍費一把 20 元。船夫先用水槍射鄰筏遊客以帶節奏，鄰筏遊客反擊，我們筏上的人巋然不動，船夫不樂。\n\n接著去到銀子岩看溶洞看喀斯特地貌。溶洞少不了人造的燈光，以及收費的拍照服務。實話說這裏確實有不少令人稱奇的景觀。但是經過「博物館」和「竹筏」的折騰之後興味淡了很多。\n\n![銀子岩溶洞奇觀-雪山飞瀑](seeing-and-hearing-in-guilin/IMG_3912.jpg)\n\n![銀子岩溶洞奇觀-「抹布」](seeing-and-hearing-in-guilin/IMG_3916.jpg)\n\n晚上我們逛到一家掛名 CCTV 的店裏吃啤酒魚、釀田螺和香芋扣肉，個人覺得皆不及米飯香。\n\n吃罷，去往陽朔西街。\n\n這街市如此吵鬧，巷子裏滿是酒吧還有拉人的酒吧店員，聒噪不已。我漫步到一巷，甚安靜。有一屋，名爲徐悲鴻故居，大門緊閉。查了下維基百科，了解到原來是抗戰時期徐拋棄妻子，跟情人避亂的所在。\n\n![徐悲鴻故居](seeing-and-hearing-in-guilin/IMG_3925.jpg)\n\n第三日早上打算借車從陽朔到桂林市區然後脫團。\n\n早上睡過頭了，遲了十分鐘左右，導遊居然還在等我們。\n\n等到巴士快開到木龍湖旁邊的「博物館」時，張導遊說：這裏面的老闆有很多礦區，且因為是他贊助了此次旅遊活動，所以團費才這麼便宜，但是裏面的價格較貴，有錢可以去買，不買也進去看看，這樣我才可以簽單。\n\n我心裏一軟，想著：這團費確實便宜，也不好影響張導掙錢。於是就留下了。\n\n進入裏面，實在令人受到莫大的侮辱，寥寥幾個展品，底下還有紙箱擋道，上書「XX老板」，估計是要寄賣的。工作人員引我們進入負一樓，果然是賣場，不過比昨日的小型多了。\n\n一樣的跟屁蟲，但是有不一樣的講解。這次有兩個工作人員值得關注：一個黑臉大媽，一個是紅臉小伙。黑臉大媽負責推銷商品和委屈，紅臉小伙負責斥責黑臉大媽推銷商品並講解如何看玉。這場戲感動了一些遊客，隨後紅臉小伙以一個打到骨折的降價，令幾個遊客紛紛掏出了錢包。同行的東北大爺大媽倒是機警，早早離開，沒有上當。另外值得注意的是這裏售賣的物品沒有發票，只有收據但無公司名頭。\n\n賣貨的居然在教買貨技巧，而買貨的居然信以為真。\n\n看完聽完，工作人員把廁所旁邊的門一開，就進入了木龍湖景區。哈，好一個合謀！\n\n中午去到萬福廣場上的超市，裏面全是特產，一團團人進去又出來。張導遊說：這次你一定要買點東西，不然我鄙視你。我想可能是我拉低了整團的消費水平以及她的收入了，實在不好意思，但是我只會買我想買的東西，絕不會買別人要我買的東西。逛了一圈，帶了點金桂酥和芒果乾之類的，然後用小票跟導遊換了張午餐券，又吃了一頓桂林米粉。\n\n吃完，立馬脫團自由行，前往第一天就想去的白崇禧故居。\n\n從信義橋下沿榕湖繞行，就到了白崇禧故居，然而白崇禧故居連同白公館在景區的導覽圖上竟然無一標註，故居及公館大門緊閉，禁止遊客入內，景區內其他景點如：宋靜江府城牆皆如此。難道這個城市已經忘記了白崇禧了嗎？又或者這個城市的待客之道就是在正常營業時間閉門不接嗎？\n\n![榕湖導覽圖](seeing-and-hearing-in-guilin/IMG_3929.jpg)\n\n![白崇禧故居](seeing-and-hearing-in-guilin/IMG_3931.jpg)\n\n![白公館](seeing-and-hearing-in-guilin/IMG_3934.jpg)\n\n![宋靜江府城牆](seeing-and-hearing-in-guilin/IMG_3937.jpg)\n\n遊來蕩去，又去了李宗仁官邸，這是正常開放的。\n\n![李宗仁官邸](seeing-and-hearing-in-guilin/IMG_3956.jpg)\n\n又行到衫湖旁邊的日月雙塔，這是 2001年始建的銅塔，上標AAAAA國家級旅遊景區，下書桂林市歷史建築。建築在了，可這歷史在哪呢？入塔費 35元，覺得貴了累了又無趣，未上去。\n\n![日月雙塔](seeing-and-hearing-in-guilin/IMG_3957.jpg)\n\n稍作休息後，決定去看梯田。本來跟順風車司機談攏了價格，約好了時間，沒想到司機拖延再三。一怒之下，等到司機終於快開到的時候，取消了訂單。打算北上走走，然後離開廣西。\n\n去到金順昌以及屈臣氏買了些特產，然後去到東西巷吃了日式烤肉還有自帶的月餅，皆美味。\n\n![東西巷](seeing-and-hearing-in-guilin/IMG_3965.jpg)\n\n晚上，從端禮門進入，漫步靖江王府。行到一路牌，上面標註的「逍遙樓」令我猛然一驚，接著隨路走上狀元廊，直通逍遙樓。\n\n![逍遙樓](seeing-and-hearing-in-guilin/IMG_3976.jpg)\n\n見到這逍遙樓，我有點激動，跟杜同學說：此行不虛啊。\n\n![逍遙樓](seeing-and-hearing-in-guilin/IMG_3979.jpg)\n\n樓下石碑說明了這才是真正的與黃鶴樓齊名的逍遙樓`(雖然是重建的)`，樓上燈火璀璨，過道上有不少書畫作品，有一聯曰：「逍遙樓上觀日月，東西巷中話滄桑」，誠然。內部因為過了時間未可入內參觀。登樓賞月拍照者眾，我們也未能免俗。\n\n![逍遙樓石碑](seeing-and-hearing-in-guilin/IMG_3985.jpg)\n\n天熱無風，觀月一會就不想繼續留了。於是乎，打道回府。\n\n","source":"_posts/essay/seeing-and-hearing-in-guilin.md","raw":"---\ntitle: 桂林見聞\ndate: 2021-09-22 14:50:26\np: essay/seeing-and-hearing-in-guilin\ntags:\n- 隨筆\n- 遊記\n- 普通話\n---\n\n中秋假期，跟著杜同學及其同事大雄前往廣西桂林旅遊，導遊姓張。這是我第一次跟團旅遊，種種見聞令人難忘，不妨一書以待「後之覽者亦將有感於斯文」。\n\n<!--more-->\n\n第一日，早上先在萬福廣場吃了一頓桂林米粉。這米粉咬下去很乾脆地斷了，不粘連，很有口感。隨後坐車到陽朔興坪鎮灕江景區，坐船游灕江。\n\n泛舟灕江中，眼見這山直直聳立又層巒疊嶂，水乾乾淨淨又綠意盎然，杜同學直言其想跳水入江游泳，我深感贊同。然恨游藝不精，未能施行。\n\n![桂林山水](seeing-and-hearing-in-guilin/IMG_3826.jpg)\n\n遊到「20元人民幣背景」時，船停了一會兒，開始提供收費拍照服務，還有付費鸕鶿道具服務。\n\n只見兩隻鸕鶿被綁住腳、綑住喙、套住喙尖後置於一根竹竿之上，遊客擔起竹竿拍照。此時我心裏閃過一想法：放過鸕鶿吧，既然不再需要其捕魚，就令其自由吧。而後又想到這背後可能牽涉到一些以其維生的家庭。思索一番後，我認為還是逐步放棄鸕鶿拍照和表演爲好，文明的社會不應以施虐動物爲樂。\n\n![鸕鶿道具](seeing-and-hearing-in-guilin/IMG_3829.jpg)\n\n中午團餐吃了啤酒魚，味道不錯。\n\n下午到一處靜水區坐「竹筏」`(現在都是用PVC塑料管了，杜同學想體驗真正的竹筏估計要自己造一個了)`遊江，筏上風光旖旎，風徐徐地吹過，相當愜意。\n\n![筏上風光](seeing-and-hearing-in-guilin/IMG_3860.jpg)\n\n遊畢到一古戲樓，樓下有一榕樹，其樹幹被雕刻上凸眼獠牙怪，而其上枝葉正茂。\n\n![樹雕](seeing-and-hearing-in-guilin/IMG_3874.jpg)\n\n遊出戲樓門口前有吆喝摸烏龜。我順手一摸，說是送一銅錢。我拿了就走，沒想到被喊住，說是去一處包裝。去到所指的櫃檯，有一個傢伙吧啦吧啦問屬相開始算命。我心不在焉地聽了，算完他拿出一本子上，說是讓我添些香火錢。我一看，好傢伙！一次都是上百的。我擺擺手，離開了戲樓。\n\n這都 21世紀了，還有人在宣傳烏龜、貔貅和命理，進而撈錢。\n\n又到一景區，門可羅雀，景區內所有的景點都以逍遙爲名，瀑布叫逍遙瀑，湖叫逍遙湖，樓叫逍遙樓。造此景者大概詞窮了，於是通通都是逍遙，看名字就覺得乏味。\n\n景區內有收費坐筏遊湖唱山歌服務，工作人員看我們走上山路，說：上面是遊客出口，下面才是風景。\n\n我看這水這般濁，這筏如此舊，山也不及灕江好看，怎的是風景了？\n\n不一會兒，行到逍遙樓。登上樓，樓內空空如也又破落不堪，底下居然自稱與黃鶴樓齊名。\n\n![「逍遙樓」](seeing-and-hearing-in-guilin/IMG_3886.jpg)\n\n晚上團餐吃了啤酒魚，難吃。\n\n第二日先到一處「博物館」，名曰「抱樸博物館」，掛牌爲3A景區。此館有 A、B 兩區，A 區主要宣傳五行八卦、貔貅、烏龜和戴珠寶的名人，並直通賣大型翡翠珠寶賣場；B 區展出一些化石和玉石。\n\n我深深感覺到「博物館」這個詞遭到了污辱，假博物館之名，行銷售賣貨之實，真真是掛羊頭賣狗肉啊。另外，館內會有工作人員跟著你，向你推薦商品。如果你脫離了跟屁蟲，到處遊蕩，會被路過的工作人員詢問要去哪裏。而我只回答：看看。\n\n翡翠珠寶看膩了，實在無聊得很，只能找一處跟大雄坐著看書去了。\n\n中午團餐又吃了啤酒魚，難吃。\n\n下午又去坐「竹筏」，不過這次另有收費服務，是水槍，開槍費一把 20 元。船夫先用水槍射鄰筏遊客以帶節奏，鄰筏遊客反擊，我們筏上的人巋然不動，船夫不樂。\n\n接著去到銀子岩看溶洞看喀斯特地貌。溶洞少不了人造的燈光，以及收費的拍照服務。實話說這裏確實有不少令人稱奇的景觀。但是經過「博物館」和「竹筏」的折騰之後興味淡了很多。\n\n![銀子岩溶洞奇觀-雪山飞瀑](seeing-and-hearing-in-guilin/IMG_3912.jpg)\n\n![銀子岩溶洞奇觀-「抹布」](seeing-and-hearing-in-guilin/IMG_3916.jpg)\n\n晚上我們逛到一家掛名 CCTV 的店裏吃啤酒魚、釀田螺和香芋扣肉，個人覺得皆不及米飯香。\n\n吃罷，去往陽朔西街。\n\n這街市如此吵鬧，巷子裏滿是酒吧還有拉人的酒吧店員，聒噪不已。我漫步到一巷，甚安靜。有一屋，名爲徐悲鴻故居，大門緊閉。查了下維基百科，了解到原來是抗戰時期徐拋棄妻子，跟情人避亂的所在。\n\n![徐悲鴻故居](seeing-and-hearing-in-guilin/IMG_3925.jpg)\n\n第三日早上打算借車從陽朔到桂林市區然後脫團。\n\n早上睡過頭了，遲了十分鐘左右，導遊居然還在等我們。\n\n等到巴士快開到木龍湖旁邊的「博物館」時，張導遊說：這裏面的老闆有很多礦區，且因為是他贊助了此次旅遊活動，所以團費才這麼便宜，但是裏面的價格較貴，有錢可以去買，不買也進去看看，這樣我才可以簽單。\n\n我心裏一軟，想著：這團費確實便宜，也不好影響張導掙錢。於是就留下了。\n\n進入裏面，實在令人受到莫大的侮辱，寥寥幾個展品，底下還有紙箱擋道，上書「XX老板」，估計是要寄賣的。工作人員引我們進入負一樓，果然是賣場，不過比昨日的小型多了。\n\n一樣的跟屁蟲，但是有不一樣的講解。這次有兩個工作人員值得關注：一個黑臉大媽，一個是紅臉小伙。黑臉大媽負責推銷商品和委屈，紅臉小伙負責斥責黑臉大媽推銷商品並講解如何看玉。這場戲感動了一些遊客，隨後紅臉小伙以一個打到骨折的降價，令幾個遊客紛紛掏出了錢包。同行的東北大爺大媽倒是機警，早早離開，沒有上當。另外值得注意的是這裏售賣的物品沒有發票，只有收據但無公司名頭。\n\n賣貨的居然在教買貨技巧，而買貨的居然信以為真。\n\n看完聽完，工作人員把廁所旁邊的門一開，就進入了木龍湖景區。哈，好一個合謀！\n\n中午去到萬福廣場上的超市，裏面全是特產，一團團人進去又出來。張導遊說：這次你一定要買點東西，不然我鄙視你。我想可能是我拉低了整團的消費水平以及她的收入了，實在不好意思，但是我只會買我想買的東西，絕不會買別人要我買的東西。逛了一圈，帶了點金桂酥和芒果乾之類的，然後用小票跟導遊換了張午餐券，又吃了一頓桂林米粉。\n\n吃完，立馬脫團自由行，前往第一天就想去的白崇禧故居。\n\n從信義橋下沿榕湖繞行，就到了白崇禧故居，然而白崇禧故居連同白公館在景區的導覽圖上竟然無一標註，故居及公館大門緊閉，禁止遊客入內，景區內其他景點如：宋靜江府城牆皆如此。難道這個城市已經忘記了白崇禧了嗎？又或者這個城市的待客之道就是在正常營業時間閉門不接嗎？\n\n![榕湖導覽圖](seeing-and-hearing-in-guilin/IMG_3929.jpg)\n\n![白崇禧故居](seeing-and-hearing-in-guilin/IMG_3931.jpg)\n\n![白公館](seeing-and-hearing-in-guilin/IMG_3934.jpg)\n\n![宋靜江府城牆](seeing-and-hearing-in-guilin/IMG_3937.jpg)\n\n遊來蕩去，又去了李宗仁官邸，這是正常開放的。\n\n![李宗仁官邸](seeing-and-hearing-in-guilin/IMG_3956.jpg)\n\n又行到衫湖旁邊的日月雙塔，這是 2001年始建的銅塔，上標AAAAA國家級旅遊景區，下書桂林市歷史建築。建築在了，可這歷史在哪呢？入塔費 35元，覺得貴了累了又無趣，未上去。\n\n![日月雙塔](seeing-and-hearing-in-guilin/IMG_3957.jpg)\n\n稍作休息後，決定去看梯田。本來跟順風車司機談攏了價格，約好了時間，沒想到司機拖延再三。一怒之下，等到司機終於快開到的時候，取消了訂單。打算北上走走，然後離開廣西。\n\n去到金順昌以及屈臣氏買了些特產，然後去到東西巷吃了日式烤肉還有自帶的月餅，皆美味。\n\n![東西巷](seeing-and-hearing-in-guilin/IMG_3965.jpg)\n\n晚上，從端禮門進入，漫步靖江王府。行到一路牌，上面標註的「逍遙樓」令我猛然一驚，接著隨路走上狀元廊，直通逍遙樓。\n\n![逍遙樓](seeing-and-hearing-in-guilin/IMG_3976.jpg)\n\n見到這逍遙樓，我有點激動，跟杜同學說：此行不虛啊。\n\n![逍遙樓](seeing-and-hearing-in-guilin/IMG_3979.jpg)\n\n樓下石碑說明了這才是真正的與黃鶴樓齊名的逍遙樓`(雖然是重建的)`，樓上燈火璀璨，過道上有不少書畫作品，有一聯曰：「逍遙樓上觀日月，東西巷中話滄桑」，誠然。內部因為過了時間未可入內參觀。登樓賞月拍照者眾，我們也未能免俗。\n\n![逍遙樓石碑](seeing-and-hearing-in-guilin/IMG_3985.jpg)\n\n天熱無風，觀月一會就不想繼續留了。於是乎，打道回府。\n\n","slug":"essay/seeing-and-hearing-in-guilin","published":1,"updated":"2021-09-23T12:15:23.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlel00041n9k3ybpf0lo","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>中秋假期，跟著杜同學及其同事大雄前往廣西桂林旅遊，導遊姓張。這是我第一次跟團旅遊，種種見聞令人難忘，不妨一書以待「後之覽者亦將有感於斯文」。</p>\n<span id=\"more\"></span>\n\n<p>第一日，早上先在萬福廣場吃了一頓桂林米粉。這米粉咬下去很乾脆地斷了，不粘連，很有口感。隨後坐車到陽朔興坪鎮灕江景區，坐船游灕江。</p>\n<p>泛舟灕江中，眼見這山直直聳立又層巒疊嶂，水乾乾淨淨又綠意盎然，杜同學直言其想跳水入江游泳，我深感贊同。然恨游藝不精，未能施行。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3826.jpg\" alt=\"桂林山水\"></p>\n<p>遊到「20元人民幣背景」時，船停了一會兒，開始提供收費拍照服務，還有付費鸕鶿道具服務。</p>\n<p>只見兩隻鸕鶿被綁住腳、綑住喙、套住喙尖後置於一根竹竿之上，遊客擔起竹竿拍照。此時我心裏閃過一想法：放過鸕鶿吧，既然不再需要其捕魚，就令其自由吧。而後又想到這背後可能牽涉到一些以其維生的家庭。思索一番後，我認為還是逐步放棄鸕鶿拍照和表演爲好，文明的社會不應以施虐動物爲樂。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3829.jpg\" alt=\"鸕鶿道具\"></p>\n<p>中午團餐吃了啤酒魚，味道不錯。</p>\n<p>下午到一處靜水區坐「竹筏」<code>(現在都是用PVC塑料管了，杜同學想體驗真正的竹筏估計要自己造一個了)</code>遊江，筏上風光旖旎，風徐徐地吹過，相當愜意。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3860.jpg\" alt=\"筏上風光\"></p>\n<p>遊畢到一古戲樓，樓下有一榕樹，其樹幹被雕刻上凸眼獠牙怪，而其上枝葉正茂。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3874.jpg\" alt=\"樹雕\"></p>\n<p>遊出戲樓門口前有吆喝摸烏龜。我順手一摸，說是送一銅錢。我拿了就走，沒想到被喊住，說是去一處包裝。去到所指的櫃檯，有一個傢伙吧啦吧啦問屬相開始算命。我心不在焉地聽了，算完他拿出一本子上，說是讓我添些香火錢。我一看，好傢伙！一次都是上百的。我擺擺手，離開了戲樓。</p>\n<p>這都 21世紀了，還有人在宣傳烏龜、貔貅和命理，進而撈錢。</p>\n<p>又到一景區，門可羅雀，景區內所有的景點都以逍遙爲名，瀑布叫逍遙瀑，湖叫逍遙湖，樓叫逍遙樓。造此景者大概詞窮了，於是通通都是逍遙，看名字就覺得乏味。</p>\n<p>景區內有收費坐筏遊湖唱山歌服務，工作人員看我們走上山路，說：上面是遊客出口，下面才是風景。</p>\n<p>我看這水這般濁，這筏如此舊，山也不及灕江好看，怎的是風景了？</p>\n<p>不一會兒，行到逍遙樓。登上樓，樓內空空如也又破落不堪，底下居然自稱與黃鶴樓齊名。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3886.jpg\" alt=\"「逍遙樓」\"></p>\n<p>晚上團餐吃了啤酒魚，難吃。</p>\n<p>第二日先到一處「博物館」，名曰「抱樸博物館」，掛牌爲3A景區。此館有 A、B 兩區，A 區主要宣傳五行八卦、貔貅、烏龜和戴珠寶的名人，並直通賣大型翡翠珠寶賣場；B 區展出一些化石和玉石。</p>\n<p>我深深感覺到「博物館」這個詞遭到了污辱，假博物館之名，行銷售賣貨之實，真真是掛羊頭賣狗肉啊。另外，館內會有工作人員跟著你，向你推薦商品。如果你脫離了跟屁蟲，到處遊蕩，會被路過的工作人員詢問要去哪裏。而我只回答：看看。</p>\n<p>翡翠珠寶看膩了，實在無聊得很，只能找一處跟大雄坐著看書去了。</p>\n<p>中午團餐又吃了啤酒魚，難吃。</p>\n<p>下午又去坐「竹筏」，不過這次另有收費服務，是水槍，開槍費一把 20 元。船夫先用水槍射鄰筏遊客以帶節奏，鄰筏遊客反擊，我們筏上的人巋然不動，船夫不樂。</p>\n<p>接著去到銀子岩看溶洞看喀斯特地貌。溶洞少不了人造的燈光，以及收費的拍照服務。實話說這裏確實有不少令人稱奇的景觀。但是經過「博物館」和「竹筏」的折騰之後興味淡了很多。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3912.jpg\" alt=\"銀子岩溶洞奇觀-雪山飞瀑\"></p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3916.jpg\" alt=\"銀子岩溶洞奇觀-「抹布」\"></p>\n<p>晚上我們逛到一家掛名 CCTV 的店裏吃啤酒魚、釀田螺和香芋扣肉，個人覺得皆不及米飯香。</p>\n<p>吃罷，去往陽朔西街。</p>\n<p>這街市如此吵鬧，巷子裏滿是酒吧還有拉人的酒吧店員，聒噪不已。我漫步到一巷，甚安靜。有一屋，名爲徐悲鴻故居，大門緊閉。查了下維基百科，了解到原來是抗戰時期徐拋棄妻子，跟情人避亂的所在。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3925.jpg\" alt=\"徐悲鴻故居\"></p>\n<p>第三日早上打算借車從陽朔到桂林市區然後脫團。</p>\n<p>早上睡過頭了，遲了十分鐘左右，導遊居然還在等我們。</p>\n<p>等到巴士快開到木龍湖旁邊的「博物館」時，張導遊說：這裏面的老闆有很多礦區，且因為是他贊助了此次旅遊活動，所以團費才這麼便宜，但是裏面的價格較貴，有錢可以去買，不買也進去看看，這樣我才可以簽單。</p>\n<p>我心裏一軟，想著：這團費確實便宜，也不好影響張導掙錢。於是就留下了。</p>\n<p>進入裏面，實在令人受到莫大的侮辱，寥寥幾個展品，底下還有紙箱擋道，上書「XX老板」，估計是要寄賣的。工作人員引我們進入負一樓，果然是賣場，不過比昨日的小型多了。</p>\n<p>一樣的跟屁蟲，但是有不一樣的講解。這次有兩個工作人員值得關注：一個黑臉大媽，一個是紅臉小伙。黑臉大媽負責推銷商品和委屈，紅臉小伙負責斥責黑臉大媽推銷商品並講解如何看玉。這場戲感動了一些遊客，隨後紅臉小伙以一個打到骨折的降價，令幾個遊客紛紛掏出了錢包。同行的東北大爺大媽倒是機警，早早離開，沒有上當。另外值得注意的是這裏售賣的物品沒有發票，只有收據但無公司名頭。</p>\n<p>賣貨的居然在教買貨技巧，而買貨的居然信以為真。</p>\n<p>看完聽完，工作人員把廁所旁邊的門一開，就進入了木龍湖景區。哈，好一個合謀！</p>\n<p>中午去到萬福廣場上的超市，裏面全是特產，一團團人進去又出來。張導遊說：這次你一定要買點東西，不然我鄙視你。我想可能是我拉低了整團的消費水平以及她的收入了，實在不好意思，但是我只會買我想買的東西，絕不會買別人要我買的東西。逛了一圈，帶了點金桂酥和芒果乾之類的，然後用小票跟導遊換了張午餐券，又吃了一頓桂林米粉。</p>\n<p>吃完，立馬脫團自由行，前往第一天就想去的白崇禧故居。</p>\n<p>從信義橋下沿榕湖繞行，就到了白崇禧故居，然而白崇禧故居連同白公館在景區的導覽圖上竟然無一標註，故居及公館大門緊閉，禁止遊客入內，景區內其他景點如：宋靜江府城牆皆如此。難道這個城市已經忘記了白崇禧了嗎？又或者這個城市的待客之道就是在正常營業時間閉門不接嗎？</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3929.jpg\" alt=\"榕湖導覽圖\"></p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3931.jpg\" alt=\"白崇禧故居\"></p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3934.jpg\" alt=\"白公館\"></p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3937.jpg\" alt=\"宋靜江府城牆\"></p>\n<p>遊來蕩去，又去了李宗仁官邸，這是正常開放的。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3956.jpg\" alt=\"李宗仁官邸\"></p>\n<p>又行到衫湖旁邊的日月雙塔，這是 2001年始建的銅塔，上標AAAAA國家級旅遊景區，下書桂林市歷史建築。建築在了，可這歷史在哪呢？入塔費 35元，覺得貴了累了又無趣，未上去。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3957.jpg\" alt=\"日月雙塔\"></p>\n<p>稍作休息後，決定去看梯田。本來跟順風車司機談攏了價格，約好了時間，沒想到司機拖延再三。一怒之下，等到司機終於快開到的時候，取消了訂單。打算北上走走，然後離開廣西。</p>\n<p>去到金順昌以及屈臣氏買了些特產，然後去到東西巷吃了日式烤肉還有自帶的月餅，皆美味。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3965.jpg\" alt=\"東西巷\"></p>\n<p>晚上，從端禮門進入，漫步靖江王府。行到一路牌，上面標註的「逍遙樓」令我猛然一驚，接著隨路走上狀元廊，直通逍遙樓。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3976.jpg\" alt=\"逍遙樓\"></p>\n<p>見到這逍遙樓，我有點激動，跟杜同學說：此行不虛啊。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3979.jpg\" alt=\"逍遙樓\"></p>\n<p>樓下石碑說明了這才是真正的與黃鶴樓齊名的逍遙樓<code>(雖然是重建的)</code>，樓上燈火璀璨，過道上有不少書畫作品，有一聯曰：「逍遙樓上觀日月，東西巷中話滄桑」，誠然。內部因為過了時間未可入內參觀。登樓賞月拍照者眾，我們也未能免俗。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3985.jpg\" alt=\"逍遙樓石碑\"></p>\n<p>天熱無風，觀月一會就不想繼續留了。於是乎，打道回府。</p>\n","site":{"data":{}},"excerpt":"<p>中秋假期，跟著杜同學及其同事大雄前往廣西桂林旅遊，導遊姓張。這是我第一次跟團旅遊，種種見聞令人難忘，不妨一書以待「後之覽者亦將有感於斯文」。</p>","more":"<p>第一日，早上先在萬福廣場吃了一頓桂林米粉。這米粉咬下去很乾脆地斷了，不粘連，很有口感。隨後坐車到陽朔興坪鎮灕江景區，坐船游灕江。</p>\n<p>泛舟灕江中，眼見這山直直聳立又層巒疊嶂，水乾乾淨淨又綠意盎然，杜同學直言其想跳水入江游泳，我深感贊同。然恨游藝不精，未能施行。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3826.jpg\" alt=\"桂林山水\"></p>\n<p>遊到「20元人民幣背景」時，船停了一會兒，開始提供收費拍照服務，還有付費鸕鶿道具服務。</p>\n<p>只見兩隻鸕鶿被綁住腳、綑住喙、套住喙尖後置於一根竹竿之上，遊客擔起竹竿拍照。此時我心裏閃過一想法：放過鸕鶿吧，既然不再需要其捕魚，就令其自由吧。而後又想到這背後可能牽涉到一些以其維生的家庭。思索一番後，我認為還是逐步放棄鸕鶿拍照和表演爲好，文明的社會不應以施虐動物爲樂。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3829.jpg\" alt=\"鸕鶿道具\"></p>\n<p>中午團餐吃了啤酒魚，味道不錯。</p>\n<p>下午到一處靜水區坐「竹筏」<code>(現在都是用PVC塑料管了，杜同學想體驗真正的竹筏估計要自己造一個了)</code>遊江，筏上風光旖旎，風徐徐地吹過，相當愜意。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3860.jpg\" alt=\"筏上風光\"></p>\n<p>遊畢到一古戲樓，樓下有一榕樹，其樹幹被雕刻上凸眼獠牙怪，而其上枝葉正茂。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3874.jpg\" alt=\"樹雕\"></p>\n<p>遊出戲樓門口前有吆喝摸烏龜。我順手一摸，說是送一銅錢。我拿了就走，沒想到被喊住，說是去一處包裝。去到所指的櫃檯，有一個傢伙吧啦吧啦問屬相開始算命。我心不在焉地聽了，算完他拿出一本子上，說是讓我添些香火錢。我一看，好傢伙！一次都是上百的。我擺擺手，離開了戲樓。</p>\n<p>這都 21世紀了，還有人在宣傳烏龜、貔貅和命理，進而撈錢。</p>\n<p>又到一景區，門可羅雀，景區內所有的景點都以逍遙爲名，瀑布叫逍遙瀑，湖叫逍遙湖，樓叫逍遙樓。造此景者大概詞窮了，於是通通都是逍遙，看名字就覺得乏味。</p>\n<p>景區內有收費坐筏遊湖唱山歌服務，工作人員看我們走上山路，說：上面是遊客出口，下面才是風景。</p>\n<p>我看這水這般濁，這筏如此舊，山也不及灕江好看，怎的是風景了？</p>\n<p>不一會兒，行到逍遙樓。登上樓，樓內空空如也又破落不堪，底下居然自稱與黃鶴樓齊名。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3886.jpg\" alt=\"「逍遙樓」\"></p>\n<p>晚上團餐吃了啤酒魚，難吃。</p>\n<p>第二日先到一處「博物館」，名曰「抱樸博物館」，掛牌爲3A景區。此館有 A、B 兩區，A 區主要宣傳五行八卦、貔貅、烏龜和戴珠寶的名人，並直通賣大型翡翠珠寶賣場；B 區展出一些化石和玉石。</p>\n<p>我深深感覺到「博物館」這個詞遭到了污辱，假博物館之名，行銷售賣貨之實，真真是掛羊頭賣狗肉啊。另外，館內會有工作人員跟著你，向你推薦商品。如果你脫離了跟屁蟲，到處遊蕩，會被路過的工作人員詢問要去哪裏。而我只回答：看看。</p>\n<p>翡翠珠寶看膩了，實在無聊得很，只能找一處跟大雄坐著看書去了。</p>\n<p>中午團餐又吃了啤酒魚，難吃。</p>\n<p>下午又去坐「竹筏」，不過這次另有收費服務，是水槍，開槍費一把 20 元。船夫先用水槍射鄰筏遊客以帶節奏，鄰筏遊客反擊，我們筏上的人巋然不動，船夫不樂。</p>\n<p>接著去到銀子岩看溶洞看喀斯特地貌。溶洞少不了人造的燈光，以及收費的拍照服務。實話說這裏確實有不少令人稱奇的景觀。但是經過「博物館」和「竹筏」的折騰之後興味淡了很多。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3912.jpg\" alt=\"銀子岩溶洞奇觀-雪山飞瀑\"></p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3916.jpg\" alt=\"銀子岩溶洞奇觀-「抹布」\"></p>\n<p>晚上我們逛到一家掛名 CCTV 的店裏吃啤酒魚、釀田螺和香芋扣肉，個人覺得皆不及米飯香。</p>\n<p>吃罷，去往陽朔西街。</p>\n<p>這街市如此吵鬧，巷子裏滿是酒吧還有拉人的酒吧店員，聒噪不已。我漫步到一巷，甚安靜。有一屋，名爲徐悲鴻故居，大門緊閉。查了下維基百科，了解到原來是抗戰時期徐拋棄妻子，跟情人避亂的所在。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3925.jpg\" alt=\"徐悲鴻故居\"></p>\n<p>第三日早上打算借車從陽朔到桂林市區然後脫團。</p>\n<p>早上睡過頭了，遲了十分鐘左右，導遊居然還在等我們。</p>\n<p>等到巴士快開到木龍湖旁邊的「博物館」時，張導遊說：這裏面的老闆有很多礦區，且因為是他贊助了此次旅遊活動，所以團費才這麼便宜，但是裏面的價格較貴，有錢可以去買，不買也進去看看，這樣我才可以簽單。</p>\n<p>我心裏一軟，想著：這團費確實便宜，也不好影響張導掙錢。於是就留下了。</p>\n<p>進入裏面，實在令人受到莫大的侮辱，寥寥幾個展品，底下還有紙箱擋道，上書「XX老板」，估計是要寄賣的。工作人員引我們進入負一樓，果然是賣場，不過比昨日的小型多了。</p>\n<p>一樣的跟屁蟲，但是有不一樣的講解。這次有兩個工作人員值得關注：一個黑臉大媽，一個是紅臉小伙。黑臉大媽負責推銷商品和委屈，紅臉小伙負責斥責黑臉大媽推銷商品並講解如何看玉。這場戲感動了一些遊客，隨後紅臉小伙以一個打到骨折的降價，令幾個遊客紛紛掏出了錢包。同行的東北大爺大媽倒是機警，早早離開，沒有上當。另外值得注意的是這裏售賣的物品沒有發票，只有收據但無公司名頭。</p>\n<p>賣貨的居然在教買貨技巧，而買貨的居然信以為真。</p>\n<p>看完聽完，工作人員把廁所旁邊的門一開，就進入了木龍湖景區。哈，好一個合謀！</p>\n<p>中午去到萬福廣場上的超市，裏面全是特產，一團團人進去又出來。張導遊說：這次你一定要買點東西，不然我鄙視你。我想可能是我拉低了整團的消費水平以及她的收入了，實在不好意思，但是我只會買我想買的東西，絕不會買別人要我買的東西。逛了一圈，帶了點金桂酥和芒果乾之類的，然後用小票跟導遊換了張午餐券，又吃了一頓桂林米粉。</p>\n<p>吃完，立馬脫團自由行，前往第一天就想去的白崇禧故居。</p>\n<p>從信義橋下沿榕湖繞行，就到了白崇禧故居，然而白崇禧故居連同白公館在景區的導覽圖上竟然無一標註，故居及公館大門緊閉，禁止遊客入內，景區內其他景點如：宋靜江府城牆皆如此。難道這個城市已經忘記了白崇禧了嗎？又或者這個城市的待客之道就是在正常營業時間閉門不接嗎？</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3929.jpg\" alt=\"榕湖導覽圖\"></p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3931.jpg\" alt=\"白崇禧故居\"></p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3934.jpg\" alt=\"白公館\"></p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3937.jpg\" alt=\"宋靜江府城牆\"></p>\n<p>遊來蕩去，又去了李宗仁官邸，這是正常開放的。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3956.jpg\" alt=\"李宗仁官邸\"></p>\n<p>又行到衫湖旁邊的日月雙塔，這是 2001年始建的銅塔，上標AAAAA國家級旅遊景區，下書桂林市歷史建築。建築在了，可這歷史在哪呢？入塔費 35元，覺得貴了累了又無趣，未上去。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3957.jpg\" alt=\"日月雙塔\"></p>\n<p>稍作休息後，決定去看梯田。本來跟順風車司機談攏了價格，約好了時間，沒想到司機拖延再三。一怒之下，等到司機終於快開到的時候，取消了訂單。打算北上走走，然後離開廣西。</p>\n<p>去到金順昌以及屈臣氏買了些特產，然後去到東西巷吃了日式烤肉還有自帶的月餅，皆美味。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3965.jpg\" alt=\"東西巷\"></p>\n<p>晚上，從端禮門進入，漫步靖江王府。行到一路牌，上面標註的「逍遙樓」令我猛然一驚，接著隨路走上狀元廊，直通逍遙樓。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3976.jpg\" alt=\"逍遙樓\"></p>\n<p>見到這逍遙樓，我有點激動，跟杜同學說：此行不虛啊。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3979.jpg\" alt=\"逍遙樓\"></p>\n<p>樓下石碑說明了這才是真正的與黃鶴樓齊名的逍遙樓<code>(雖然是重建的)</code>，樓上燈火璀璨，過道上有不少書畫作品，有一聯曰：「逍遙樓上觀日月，東西巷中話滄桑」，誠然。內部因為過了時間未可入內參觀。登樓賞月拍照者眾，我們也未能免俗。</p>\n<p><img src=\"/essay/seeing-and-hearing-in-guilin/IMG_3985.jpg\" alt=\"逍遙樓石碑\"></p>\n<p>天熱無風，觀月一會就不想繼續留了。於是乎，打道回府。</p>"},{"title":"《純粹理性批判》閱讀筆記一：導言","p":"essay/criteque-of-pure-reason-i","date":"2022-07-10T13:41:00.000Z","_content":"\n《純粹理性批判》是德國哲學家康德（Kant）於1781年寫的（1787年再版），在世界上影響深遠，與他寫的另外兩本《實踐理性批判》和《判斷力批判》合稱三大批判。\n\n《純粹理性批判》出版後，頭幾年根本沒人讀懂，因為這本書實在太枯燥無味了，甚至還被誤讀。即使是現在，要讀懂這本書也不是件容易的事。本人閱讀的是商務印書館2011年出版的《漢譯世界學術名著叢書：純粹理性批判》，藍公武譯著。譯文頗有古意，非常簡練，需要慢慢讀、重複讀，不然很容易陷入迷霧。\n\n本書探討的核心問題是先天綜合命題如何可能，又可分為四個問題：\n1. 純粹數學如何可能？\n2. 純粹自然科學如何可能？\n3. 視為自然傾向的玄學（形而上學）如何可能？\n4. 視為學問的玄學（形而上學）如何可能？\n\n<!--more-->\n\n什麼是先天綜合命題？\n\n「先天」是跟「後天」或者說「經驗」相對的。離開一切經驗而能獨存的知識，康德稱之為「先天知識」，進一步地，未雜有經驗事物的先天知識，稱之為「先天純粹知識」；反之，從經驗中得出的知識，則是經驗知識。康德認為我們的認知是從經驗開始的。對象刺激我們的感官，形成表象，再經由我們的悟性處理成為經驗知識。但是並不意味著一切知識都是從經驗中來的。\n\n「先天知識」或稱「先驗知識」是嚴格普遍的且在思維時認為是必然的；「後天知識」或稱「經驗知識」則是假定的，比較普遍的，偶然的。\n\n「綜合命題」也稱之為「綜合判斷」，是跟「分析命題」相對的。分析命題就是在一個包含主賓關係的命題中賓的概念是包含在主的概念中的，例如：紅花是紅的。明顯「紅的」是包含在「紅花」的概念中的，是對其的說明，沒有新的知識。綜合命題是則是賓的概念是不包含在主的概念中的命題，例如：一切事物皆有重量。「重量」的概念並不包含在「一切事物」的概念之中，是對「一切事物」內涵的擴大。當然這個綜合命題是錯誤的，學過物理的都知道「失重」是怎麼一回事。\n\n「一切發生之事都有其原因」這是一個「先天綜合命題」，「原因」是我們無法感受的，因而不可能從經驗中獲取，是「先天」的，且「原因」的概念並不包含在「一切發生之事」的概念當中，所以是「先天綜合命題」。\n\n「一切事物皆有重量」這是一個「後天綜合命題」，「重量」明顯是從經驗得來的知識，是「後天」的，且「重量」的概念並不包含在「一切事物」的概念當中，所以是「後天綜合命題」。\n\n康德認為「先天綜合命題」很重要，是科學的根基，是嚴格普遍、必然且擴大的（不是說明的）知識。\n\n純粹數學的所有命題都是先天綜合命題，例如代數學中的「7+5=12」，「12」的概念並不包含在「7+5」之和的概念中，因而是綜合的；而「7+5=12」能離開一切經驗獨存，是普遍且必然的，是先天的。又如幾何學中的「兩點間之直線為最短線」，「長短」的概念並不包含在「直線」的概念中，因為是綜合的；而「兩點間之直線為最短線」是普遍必然的，是先天的。\n\n純粹自然科學之原理包含先天綜合命題，例如：牛頓第三定律「兩個物體相互作用時，作用力與反作用力相等」。「反作用力」的概念並不包含在「作用力」的概念中，因而是綜合的；而此原理康德認為是必然而普遍的。\n\n玄學，或稱之為形而上學，研究三大主題：神、自由和靈魂不滅。康德認為玄學尚無成就，他想探討是否能將玄學發展成類似數學和自然科學那樣的學問。\n\n康德認為原初的綜合命題不是通過矛盾律得出的，而是從直觀中得到認知的。矛盾律是傳統邏輯的基本規律之一，指的是兩個相反或矛盾的命題，無法同時成立。像「7+5=12」，我們並不是排除了所有的其他可能而得出的，而是直觀上就知道如此。\n\n「純粹理性」也稱之為「悟性」，是我們絕對地先天地知道一切事物的原理；「批判」即審視、研究。說白了這本書就是審視人類認知，有沒有局限性，靠不靠譜。\n\n康德提出的「純粹理性批判」包含「先驗原理論」和「先驗方法論」，「先驗原理論」又可細分為「先驗感性論」和「先驗理性論」。\n","source":"_posts/essay/criteque-of-pure-reason-i.md","raw":"---\ntitle: 《純粹理性批判》閱讀筆記一：導言\np: essay/criteque-of-pure-reason-i\ndate: 2022-07-10 21:41:00\ntags:\n- 隨筆\n- 哲學\n---\n\n《純粹理性批判》是德國哲學家康德（Kant）於1781年寫的（1787年再版），在世界上影響深遠，與他寫的另外兩本《實踐理性批判》和《判斷力批判》合稱三大批判。\n\n《純粹理性批判》出版後，頭幾年根本沒人讀懂，因為這本書實在太枯燥無味了，甚至還被誤讀。即使是現在，要讀懂這本書也不是件容易的事。本人閱讀的是商務印書館2011年出版的《漢譯世界學術名著叢書：純粹理性批判》，藍公武譯著。譯文頗有古意，非常簡練，需要慢慢讀、重複讀，不然很容易陷入迷霧。\n\n本書探討的核心問題是先天綜合命題如何可能，又可分為四個問題：\n1. 純粹數學如何可能？\n2. 純粹自然科學如何可能？\n3. 視為自然傾向的玄學（形而上學）如何可能？\n4. 視為學問的玄學（形而上學）如何可能？\n\n<!--more-->\n\n什麼是先天綜合命題？\n\n「先天」是跟「後天」或者說「經驗」相對的。離開一切經驗而能獨存的知識，康德稱之為「先天知識」，進一步地，未雜有經驗事物的先天知識，稱之為「先天純粹知識」；反之，從經驗中得出的知識，則是經驗知識。康德認為我們的認知是從經驗開始的。對象刺激我們的感官，形成表象，再經由我們的悟性處理成為經驗知識。但是並不意味著一切知識都是從經驗中來的。\n\n「先天知識」或稱「先驗知識」是嚴格普遍的且在思維時認為是必然的；「後天知識」或稱「經驗知識」則是假定的，比較普遍的，偶然的。\n\n「綜合命題」也稱之為「綜合判斷」，是跟「分析命題」相對的。分析命題就是在一個包含主賓關係的命題中賓的概念是包含在主的概念中的，例如：紅花是紅的。明顯「紅的」是包含在「紅花」的概念中的，是對其的說明，沒有新的知識。綜合命題是則是賓的概念是不包含在主的概念中的命題，例如：一切事物皆有重量。「重量」的概念並不包含在「一切事物」的概念之中，是對「一切事物」內涵的擴大。當然這個綜合命題是錯誤的，學過物理的都知道「失重」是怎麼一回事。\n\n「一切發生之事都有其原因」這是一個「先天綜合命題」，「原因」是我們無法感受的，因而不可能從經驗中獲取，是「先天」的，且「原因」的概念並不包含在「一切發生之事」的概念當中，所以是「先天綜合命題」。\n\n「一切事物皆有重量」這是一個「後天綜合命題」，「重量」明顯是從經驗得來的知識，是「後天」的，且「重量」的概念並不包含在「一切事物」的概念當中，所以是「後天綜合命題」。\n\n康德認為「先天綜合命題」很重要，是科學的根基，是嚴格普遍、必然且擴大的（不是說明的）知識。\n\n純粹數學的所有命題都是先天綜合命題，例如代數學中的「7+5=12」，「12」的概念並不包含在「7+5」之和的概念中，因而是綜合的；而「7+5=12」能離開一切經驗獨存，是普遍且必然的，是先天的。又如幾何學中的「兩點間之直線為最短線」，「長短」的概念並不包含在「直線」的概念中，因為是綜合的；而「兩點間之直線為最短線」是普遍必然的，是先天的。\n\n純粹自然科學之原理包含先天綜合命題，例如：牛頓第三定律「兩個物體相互作用時，作用力與反作用力相等」。「反作用力」的概念並不包含在「作用力」的概念中，因而是綜合的；而此原理康德認為是必然而普遍的。\n\n玄學，或稱之為形而上學，研究三大主題：神、自由和靈魂不滅。康德認為玄學尚無成就，他想探討是否能將玄學發展成類似數學和自然科學那樣的學問。\n\n康德認為原初的綜合命題不是通過矛盾律得出的，而是從直觀中得到認知的。矛盾律是傳統邏輯的基本規律之一，指的是兩個相反或矛盾的命題，無法同時成立。像「7+5=12」，我們並不是排除了所有的其他可能而得出的，而是直觀上就知道如此。\n\n「純粹理性」也稱之為「悟性」，是我們絕對地先天地知道一切事物的原理；「批判」即審視、研究。說白了這本書就是審視人類認知，有沒有局限性，靠不靠譜。\n\n康德提出的「純粹理性批判」包含「先驗原理論」和「先驗方法論」，「先驗原理論」又可細分為「先驗感性論」和「先驗理性論」。\n","slug":"essay/criteque-of-pure-reason-i","published":1,"updated":"2022-07-10T15:51:42.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlem00051n9kgtgyd2ic","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>《純粹理性批判》是德國哲學家康德（Kant）於1781年寫的（1787年再版），在世界上影響深遠，與他寫的另外兩本《實踐理性批判》和《判斷力批判》合稱三大批判。</p>\n<p>《純粹理性批判》出版後，頭幾年根本沒人讀懂，因為這本書實在太枯燥無味了，甚至還被誤讀。即使是現在，要讀懂這本書也不是件容易的事。本人閱讀的是商務印書館2011年出版的《漢譯世界學術名著叢書：純粹理性批判》，藍公武譯著。譯文頗有古意，非常簡練，需要慢慢讀、重複讀，不然很容易陷入迷霧。</p>\n<p>本書探討的核心問題是先天綜合命題如何可能，又可分為四個問題：</p>\n<ol>\n<li>純粹數學如何可能？</li>\n<li>純粹自然科學如何可能？</li>\n<li>視為自然傾向的玄學（形而上學）如何可能？</li>\n<li>視為學問的玄學（形而上學）如何可能？</li>\n</ol>\n<span id=\"more\"></span>\n\n<p>什麼是先天綜合命題？</p>\n<p>「先天」是跟「後天」或者說「經驗」相對的。離開一切經驗而能獨存的知識，康德稱之為「先天知識」，進一步地，未雜有經驗事物的先天知識，稱之為「先天純粹知識」；反之，從經驗中得出的知識，則是經驗知識。康德認為我們的認知是從經驗開始的。對象刺激我們的感官，形成表象，再經由我們的悟性處理成為經驗知識。但是並不意味著一切知識都是從經驗中來的。</p>\n<p>「先天知識」或稱「先驗知識」是嚴格普遍的且在思維時認為是必然的；「後天知識」或稱「經驗知識」則是假定的，比較普遍的，偶然的。</p>\n<p>「綜合命題」也稱之為「綜合判斷」，是跟「分析命題」相對的。分析命題就是在一個包含主賓關係的命題中賓的概念是包含在主的概念中的，例如：紅花是紅的。明顯「紅的」是包含在「紅花」的概念中的，是對其的說明，沒有新的知識。綜合命題是則是賓的概念是不包含在主的概念中的命題，例如：一切事物皆有重量。「重量」的概念並不包含在「一切事物」的概念之中，是對「一切事物」內涵的擴大。當然這個綜合命題是錯誤的，學過物理的都知道「失重」是怎麼一回事。</p>\n<p>「一切發生之事都有其原因」這是一個「先天綜合命題」，「原因」是我們無法感受的，因而不可能從經驗中獲取，是「先天」的，且「原因」的概念並不包含在「一切發生之事」的概念當中，所以是「先天綜合命題」。</p>\n<p>「一切事物皆有重量」這是一個「後天綜合命題」，「重量」明顯是從經驗得來的知識，是「後天」的，且「重量」的概念並不包含在「一切事物」的概念當中，所以是「後天綜合命題」。</p>\n<p>康德認為「先天綜合命題」很重要，是科學的根基，是嚴格普遍、必然且擴大的（不是說明的）知識。</p>\n<p>純粹數學的所有命題都是先天綜合命題，例如代數學中的「7+5=12」，「12」的概念並不包含在「7+5」之和的概念中，因而是綜合的；而「7+5=12」能離開一切經驗獨存，是普遍且必然的，是先天的。又如幾何學中的「兩點間之直線為最短線」，「長短」的概念並不包含在「直線」的概念中，因為是綜合的；而「兩點間之直線為最短線」是普遍必然的，是先天的。</p>\n<p>純粹自然科學之原理包含先天綜合命題，例如：牛頓第三定律「兩個物體相互作用時，作用力與反作用力相等」。「反作用力」的概念並不包含在「作用力」的概念中，因而是綜合的；而此原理康德認為是必然而普遍的。</p>\n<p>玄學，或稱之為形而上學，研究三大主題：神、自由和靈魂不滅。康德認為玄學尚無成就，他想探討是否能將玄學發展成類似數學和自然科學那樣的學問。</p>\n<p>康德認為原初的綜合命題不是通過矛盾律得出的，而是從直觀中得到認知的。矛盾律是傳統邏輯的基本規律之一，指的是兩個相反或矛盾的命題，無法同時成立。像「7+5=12」，我們並不是排除了所有的其他可能而得出的，而是直觀上就知道如此。</p>\n<p>「純粹理性」也稱之為「悟性」，是我們絕對地先天地知道一切事物的原理；「批判」即審視、研究。說白了這本書就是審視人類認知，有沒有局限性，靠不靠譜。</p>\n<p>康德提出的「純粹理性批判」包含「先驗原理論」和「先驗方法論」，「先驗原理論」又可細分為「先驗感性論」和「先驗理性論」。</p>\n","site":{"data":{}},"excerpt":"<p>《純粹理性批判》是德國哲學家康德（Kant）於1781年寫的（1787年再版），在世界上影響深遠，與他寫的另外兩本《實踐理性批判》和《判斷力批判》合稱三大批判。</p>\n<p>《純粹理性批判》出版後，頭幾年根本沒人讀懂，因為這本書實在太枯燥無味了，甚至還被誤讀。即使是現在，要讀懂這本書也不是件容易的事。本人閱讀的是商務印書館2011年出版的《漢譯世界學術名著叢書：純粹理性批判》，藍公武譯著。譯文頗有古意，非常簡練，需要慢慢讀、重複讀，不然很容易陷入迷霧。</p>\n<p>本書探討的核心問題是先天綜合命題如何可能，又可分為四個問題：</p>\n<ol>\n<li>純粹數學如何可能？</li>\n<li>純粹自然科學如何可能？</li>\n<li>視為自然傾向的玄學（形而上學）如何可能？</li>\n<li>視為學問的玄學（形而上學）如何可能？</li>\n</ol>","more":"<p>什麼是先天綜合命題？</p>\n<p>「先天」是跟「後天」或者說「經驗」相對的。離開一切經驗而能獨存的知識，康德稱之為「先天知識」，進一步地，未雜有經驗事物的先天知識，稱之為「先天純粹知識」；反之，從經驗中得出的知識，則是經驗知識。康德認為我們的認知是從經驗開始的。對象刺激我們的感官，形成表象，再經由我們的悟性處理成為經驗知識。但是並不意味著一切知識都是從經驗中來的。</p>\n<p>「先天知識」或稱「先驗知識」是嚴格普遍的且在思維時認為是必然的；「後天知識」或稱「經驗知識」則是假定的，比較普遍的，偶然的。</p>\n<p>「綜合命題」也稱之為「綜合判斷」，是跟「分析命題」相對的。分析命題就是在一個包含主賓關係的命題中賓的概念是包含在主的概念中的，例如：紅花是紅的。明顯「紅的」是包含在「紅花」的概念中的，是對其的說明，沒有新的知識。綜合命題是則是賓的概念是不包含在主的概念中的命題，例如：一切事物皆有重量。「重量」的概念並不包含在「一切事物」的概念之中，是對「一切事物」內涵的擴大。當然這個綜合命題是錯誤的，學過物理的都知道「失重」是怎麼一回事。</p>\n<p>「一切發生之事都有其原因」這是一個「先天綜合命題」，「原因」是我們無法感受的，因而不可能從經驗中獲取，是「先天」的，且「原因」的概念並不包含在「一切發生之事」的概念當中，所以是「先天綜合命題」。</p>\n<p>「一切事物皆有重量」這是一個「後天綜合命題」，「重量」明顯是從經驗得來的知識，是「後天」的，且「重量」的概念並不包含在「一切事物」的概念當中，所以是「後天綜合命題」。</p>\n<p>康德認為「先天綜合命題」很重要，是科學的根基，是嚴格普遍、必然且擴大的（不是說明的）知識。</p>\n<p>純粹數學的所有命題都是先天綜合命題，例如代數學中的「7+5=12」，「12」的概念並不包含在「7+5」之和的概念中，因而是綜合的；而「7+5=12」能離開一切經驗獨存，是普遍且必然的，是先天的。又如幾何學中的「兩點間之直線為最短線」，「長短」的概念並不包含在「直線」的概念中，因為是綜合的；而「兩點間之直線為最短線」是普遍必然的，是先天的。</p>\n<p>純粹自然科學之原理包含先天綜合命題，例如：牛頓第三定律「兩個物體相互作用時，作用力與反作用力相等」。「反作用力」的概念並不包含在「作用力」的概念中，因而是綜合的；而此原理康德認為是必然而普遍的。</p>\n<p>玄學，或稱之為形而上學，研究三大主題：神、自由和靈魂不滅。康德認為玄學尚無成就，他想探討是否能將玄學發展成類似數學和自然科學那樣的學問。</p>\n<p>康德認為原初的綜合命題不是通過矛盾律得出的，而是從直觀中得到認知的。矛盾律是傳統邏輯的基本規律之一，指的是兩個相反或矛盾的命題，無法同時成立。像「7+5=12」，我們並不是排除了所有的其他可能而得出的，而是直觀上就知道如此。</p>\n<p>「純粹理性」也稱之為「悟性」，是我們絕對地先天地知道一切事物的原理；「批判」即審視、研究。說白了這本書就是審視人類認知，有沒有局限性，靠不靠譜。</p>\n<p>康德提出的「純粹理性批判」包含「先驗原理論」和「先驗方法論」，「先驗原理論」又可細分為「先驗感性論」和「先驗理性論」。</p>"},{"title":"關於我存在的一點思考","date":"2021-11-09T22:35:32.000Z","p":"essay/think-about-me","_content":"\n過去我時常在想一個問題，就是：人生有何意義？\n\n我問父母，父母告訴我三頓有得吃就好了；\n我問老師，老師告訴我這不用考；\n我問書本，書本說回首往事的時候不會後悔；\n我問佛陀，佛陀拈花微笑不語。\n\n<!--more-->\n\n後來又在逐漸地接觸社會、看書、看電影和思考中，我體悟到「人生並沒有什麼意義」，或者說並沒有什麼天生的使命和價值。\n\n有時候我們會錯認為別人對我有所求，我就有價值。不是的，那是你對他人來說有利用價值，不是你的終極價值。種在無何有之鄉的大樹看起來對任何人都沒有利用價值，既不能砍來做傢俱，也不能乘涼，但大樹可以長久而挺拔地過完自己的一生，享受日照和雨淋。\n\n剛開始的時候，這令我抓狂，人生無意義，那麼我豈不是可以為所欲為，一切道德和法律的束縛都可以無視？\n\n其實不是的，人生就像一趟單程的旅行，時間有限，精力有限。有些行為只會耗費你的時間和精力，讓你過早結束旅行，無法體驗到更深層次的生命體驗`(這是我在油管上從印度瑜伽大師薩古魯學習到的)`。\n\n要體驗到更深層次的生命體驗，有幾項要注意：\n\n1. 把握時間，每個人一天都只有 24 小時；關注重要而緊急的事情，先做。\n2. 保存精力，人一天的精力是很有限的，精力如果花費在一些瑣事上，那麼對重要的事時就會精力不足。飲食很重要，要注重。食物是人體的燃料，要注重營養搭配，多吃蔬菜水果，要細嚼慢嚥，減少身體負擔。要運動，強壯的身體，有活力的身體，才能支持你探索世界。\n3. 積極探索，跟隨自己內心的指引，探索更廣闊和深層的精神和物質世界。看書看電影是不錯的，用腳步丈量世界可以破除對世界的誤解，有機會的話一定要去地球之外看看。\n4. 關心家人、朋友和週遭的一切。人不是孤立存在的，留一片溫情於世，大概也是不錯的。\n\n如果不想到死的時候還是對世間和我的存在一臉迷惑，那麼現在就應該擦亮眼睛，積極生活了。人終將一死，有的人在臨死的時候掙扎著想要多活幾秒，有的人巴不得早點離開這悲慘世界，而我希望是跟世界說：「我來過，我活過」。\n\n![圖：木乃伊外面和裏面](think-about-me/IMG_4140.JPG)\n","source":"_posts/essay/think-about-me.md","raw":"---\ntitle: 關於我存在的一點思考\ndate: 2021-11-10 06:35:32\np: essay/think-about-me\ntags: \n- 隨筆\n- 我思\n---\n\n過去我時常在想一個問題，就是：人生有何意義？\n\n我問父母，父母告訴我三頓有得吃就好了；\n我問老師，老師告訴我這不用考；\n我問書本，書本說回首往事的時候不會後悔；\n我問佛陀，佛陀拈花微笑不語。\n\n<!--more-->\n\n後來又在逐漸地接觸社會、看書、看電影和思考中，我體悟到「人生並沒有什麼意義」，或者說並沒有什麼天生的使命和價值。\n\n有時候我們會錯認為別人對我有所求，我就有價值。不是的，那是你對他人來說有利用價值，不是你的終極價值。種在無何有之鄉的大樹看起來對任何人都沒有利用價值，既不能砍來做傢俱，也不能乘涼，但大樹可以長久而挺拔地過完自己的一生，享受日照和雨淋。\n\n剛開始的時候，這令我抓狂，人生無意義，那麼我豈不是可以為所欲為，一切道德和法律的束縛都可以無視？\n\n其實不是的，人生就像一趟單程的旅行，時間有限，精力有限。有些行為只會耗費你的時間和精力，讓你過早結束旅行，無法體驗到更深層次的生命體驗`(這是我在油管上從印度瑜伽大師薩古魯學習到的)`。\n\n要體驗到更深層次的生命體驗，有幾項要注意：\n\n1. 把握時間，每個人一天都只有 24 小時；關注重要而緊急的事情，先做。\n2. 保存精力，人一天的精力是很有限的，精力如果花費在一些瑣事上，那麼對重要的事時就會精力不足。飲食很重要，要注重。食物是人體的燃料，要注重營養搭配，多吃蔬菜水果，要細嚼慢嚥，減少身體負擔。要運動，強壯的身體，有活力的身體，才能支持你探索世界。\n3. 積極探索，跟隨自己內心的指引，探索更廣闊和深層的精神和物質世界。看書看電影是不錯的，用腳步丈量世界可以破除對世界的誤解，有機會的話一定要去地球之外看看。\n4. 關心家人、朋友和週遭的一切。人不是孤立存在的，留一片溫情於世，大概也是不錯的。\n\n如果不想到死的時候還是對世間和我的存在一臉迷惑，那麼現在就應該擦亮眼睛，積極生活了。人終將一死，有的人在臨死的時候掙扎著想要多活幾秒，有的人巴不得早點離開這悲慘世界，而我希望是跟世界說：「我來過，我活過」。\n\n![圖：木乃伊外面和裏面](think-about-me/IMG_4140.JPG)\n","slug":"essay/think-about-me","published":1,"updated":"2021-11-09T22:39:05.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlen00081n9k5qarexpw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>過去我時常在想一個問題，就是：人生有何意義？</p>\n<p>我問父母，父母告訴我三頓有得吃就好了；<br>我問老師，老師告訴我這不用考；<br>我問書本，書本說回首往事的時候不會後悔；<br>我問佛陀，佛陀拈花微笑不語。</p>\n<span id=\"more\"></span>\n\n<p>後來又在逐漸地接觸社會、看書、看電影和思考中，我體悟到「人生並沒有什麼意義」，或者說並沒有什麼天生的使命和價值。</p>\n<p>有時候我們會錯認為別人對我有所求，我就有價值。不是的，那是你對他人來說有利用價值，不是你的終極價值。種在無何有之鄉的大樹看起來對任何人都沒有利用價值，既不能砍來做傢俱，也不能乘涼，但大樹可以長久而挺拔地過完自己的一生，享受日照和雨淋。</p>\n<p>剛開始的時候，這令我抓狂，人生無意義，那麼我豈不是可以為所欲為，一切道德和法律的束縛都可以無視？</p>\n<p>其實不是的，人生就像一趟單程的旅行，時間有限，精力有限。有些行為只會耗費你的時間和精力，讓你過早結束旅行，無法體驗到更深層次的生命體驗<code>(這是我在油管上從印度瑜伽大師薩古魯學習到的)</code>。</p>\n<p>要體驗到更深層次的生命體驗，有幾項要注意：</p>\n<ol>\n<li>把握時間，每個人一天都只有 24 小時；關注重要而緊急的事情，先做。</li>\n<li>保存精力，人一天的精力是很有限的，精力如果花費在一些瑣事上，那麼對重要的事時就會精力不足。飲食很重要，要注重。食物是人體的燃料，要注重營養搭配，多吃蔬菜水果，要細嚼慢嚥，減少身體負擔。要運動，強壯的身體，有活力的身體，才能支持你探索世界。</li>\n<li>積極探索，跟隨自己內心的指引，探索更廣闊和深層的精神和物質世界。看書看電影是不錯的，用腳步丈量世界可以破除對世界的誤解，有機會的話一定要去地球之外看看。</li>\n<li>關心家人、朋友和週遭的一切。人不是孤立存在的，留一片溫情於世，大概也是不錯的。</li>\n</ol>\n<p>如果不想到死的時候還是對世間和我的存在一臉迷惑，那麼現在就應該擦亮眼睛，積極生活了。人終將一死，有的人在臨死的時候掙扎著想要多活幾秒，有的人巴不得早點離開這悲慘世界，而我希望是跟世界說：「我來過，我活過」。</p>\n<p><img src=\"/essay/think-about-me/IMG_4140.JPG\" alt=\"圖：木乃伊外面和裏面\"></p>\n","site":{"data":{}},"excerpt":"<p>過去我時常在想一個問題，就是：人生有何意義？</p>\n<p>我問父母，父母告訴我三頓有得吃就好了；<br>我問老師，老師告訴我這不用考；<br>我問書本，書本說回首往事的時候不會後悔；<br>我問佛陀，佛陀拈花微笑不語。</p>","more":"<p>後來又在逐漸地接觸社會、看書、看電影和思考中，我體悟到「人生並沒有什麼意義」，或者說並沒有什麼天生的使命和價值。</p>\n<p>有時候我們會錯認為別人對我有所求，我就有價值。不是的，那是你對他人來說有利用價值，不是你的終極價值。種在無何有之鄉的大樹看起來對任何人都沒有利用價值，既不能砍來做傢俱，也不能乘涼，但大樹可以長久而挺拔地過完自己的一生，享受日照和雨淋。</p>\n<p>剛開始的時候，這令我抓狂，人生無意義，那麼我豈不是可以為所欲為，一切道德和法律的束縛都可以無視？</p>\n<p>其實不是的，人生就像一趟單程的旅行，時間有限，精力有限。有些行為只會耗費你的時間和精力，讓你過早結束旅行，無法體驗到更深層次的生命體驗<code>(這是我在油管上從印度瑜伽大師薩古魯學習到的)</code>。</p>\n<p>要體驗到更深層次的生命體驗，有幾項要注意：</p>\n<ol>\n<li>把握時間，每個人一天都只有 24 小時；關注重要而緊急的事情，先做。</li>\n<li>保存精力，人一天的精力是很有限的，精力如果花費在一些瑣事上，那麼對重要的事時就會精力不足。飲食很重要，要注重。食物是人體的燃料，要注重營養搭配，多吃蔬菜水果，要細嚼慢嚥，減少身體負擔。要運動，強壯的身體，有活力的身體，才能支持你探索世界。</li>\n<li>積極探索，跟隨自己內心的指引，探索更廣闊和深層的精神和物質世界。看書看電影是不錯的，用腳步丈量世界可以破除對世界的誤解，有機會的話一定要去地球之外看看。</li>\n<li>關心家人、朋友和週遭的一切。人不是孤立存在的，留一片溫情於世，大概也是不錯的。</li>\n</ol>\n<p>如果不想到死的時候還是對世間和我的存在一臉迷惑，那麼現在就應該擦亮眼睛，積極生活了。人終將一死，有的人在臨死的時候掙扎著想要多活幾秒，有的人巴不得早點離開這悲慘世界，而我希望是跟世界說：「我來過，我活過」。</p>\n<p><img src=\"/essay/think-about-me/IMG_4140.JPG\" alt=\"圖：木乃伊外面和裏面\"></p>"},{"title":"觀電影《飛越瘋人院》後的一點思考","p":"essay/thinking-about-the-cuckoos-nest","date":"2022-07-13T15:21:00.000Z","_content":"\n電影《飛越瘋人院》（One Flew Over the Cuckoo's Nest）是基於 1962 年肯·克西（Ken Kesey）的同名小說改編，1975年上映，並獲得當年的第48屆奧斯卡五項大獎。男主角是藍道爾·麥克莫菲（Randle McMurphy），由傑克·尼克爾森（Jack Nicholson）扮演，女主角是護士拉契特（Ratched），由路易斯·弗萊徹（Louise Fletcher）扮演。\n\n麥克莫菲是一個罪犯，很好鬥，還曾經強姦了 15歲的少女，入獄後為了擺脫勞改，申請去了精神病院。在病院裏面，他發現只有少數人是跟他一樣是罪犯，而大多數居然是自願進來的。這令他很不解，明明他們都抱怨病院的不好，為什麼還不離開呢。\n\n<!--more-->\n\n漸漸地，他發現護士長拉契特是個很有問題的人。拉契特總是在逼著其他人談論他們不想觸及的話題，總是在活動時間大聲放音樂讓他們需要吼叫才能聽到彼此的話。她還不講理，在一次更改作息表觀看棒球比賽的投票中，即使麥克莫菲拉到 9個人投票還不行，她把那些精神失常的也算進來，認為不夠選票。在會議快結束時，麥克莫菲懇請再多 1分鐘，她卻宣佈會議結束。麥克莫菲最後拉到了酋長 1票，10:8 贏得多數選票，但她卻不承認結果。說到酋長，需要指出他並不是精神失常，也不是傻大個，他只是裝聾作啞，不想像他父親那樣被人利用。\n\n他還發現，那些所謂的精神病人，有的其實只是沒有勇氣去走出第一步。麥克莫菲鼓舞他們一起觀看「棒球比賽」，一起打籃球，還私自開巴士載著他們去碼頭，光明正大地駕駛了別人的遊艇，帶了一名妓女一起去海釣......\n\n麥克莫菲的結局很令人惋惜，他有很多次機會可以逃離瘋人院，但他沒有走。他太善良了，即使他曾經犯過罪。他總是在爲那些失去勇氣的人考慮，酋長、比利、查理等等。麥克莫菲死了，從他被執行了腦白質切除手術後就行屍走肉了。酋長終於尋回了他的勇氣，送走了麥克莫菲，搬起水療台砸向鐵窗，走了。\n\n酋長完成了麥克莫菲的遺願，電影最後只剩下他堅定遠去不回頭的背影，慢慢地、慢慢地越縮越小。導演在時間上的留白，不禁讓我開始了思考。\n\n第一點，社會治理不能把罪犯、網癮少年、同性戀、不同政見者等等野蠻地歸結爲精神問題，然後投到精神病院，接受藥物、電擊，甚至手術「治療」。這樣做無疑是對人權的踐踏。那些把他們送進去或者讓他們以爲自己病了的人或社會才是真的病了。大多數人都不是聖人，都可能有犯罪傾向，都會痴迷於某些事物，或者有不同的性取向，或者有對立的觀點。我們不能因爲他人（可能處在弱勢地位）與我不同就認為他人病了，因爲可能是自己（或者所處的強勢群體）病了，被某種情緒或觀念所綁架，沒有客觀理性地認知事物。\n\n第二點，現代社會讓人活得抑鬱，說是在「瘋人院」中也不爲過。首先是人的異化，被當成工具使，被不斷地壓榨，一旦不好用就被無情拋棄；還有就是暴戾、情緒化、不思考的社會氛圍讓人不斷遭遇平庸之惡。麥克莫菲們下場就像麥克莫菲一樣。小人物該如何鼓起勇氣飛越瘋人院呢？\n\n第三點，說到「飛越」，是麥克莫菲飛越了，還是酋長飛越了，剩下的「瘋人們」呢？ 酋長無疑是飛越了，他肉身翻出了瘋人院；而麥克莫菲，他從一開始精神上就不在瘋人院，他一直在鼓舞「瘋人們」走出來，特別是比利，一個 21歲的小年輕（比利的結局也很令人惋惜）。雖然最終麥克莫菲身體沒有飛越，但酋長替他完成了。剩下的「瘋人們」聽到砸窗的聲音後很激動，我覺得他們一定程度上也受到了鼓舞，相信他們以後會有點不同。\n\n第四點，麥克莫菲在幫助「瘋人們」走出來時使用的方法可能也適用於在「瘋人院」的我。簡單羅列如下：\n\n1. 保持清醒，不吃「不明藥物」。麥克莫菲從來不吃護士喂的作用不明的藥。在我看來，一切灌輸的、習以為常的、未經省察的東西都是「不明藥物」。\n2. 去外面走走，認識和經歷更多的事物。麥克莫菲帶他們去駕船、去海釣。\n3. 團隊活動，活動可以增進個人體力、團隊凝聚力，同時讓思考更活躍。麥克莫菲不厭其煩地訓練酋長和其他人一起打籃球。\n4. 飛越可能比想像中的要簡單，只要敢於踏出第一步。麥克莫菲最終使酋長鼓起了勇氣，暢通無阻地走了。\n\n以上，就是我看完這部電影後的一點點思考，可能在我看完原著後會有另外的思考，到時再談談了。\n","source":"_posts/essay/thinking-about-the-cuckoos-nest.md","raw":"---\ntitle: 觀電影《飛越瘋人院》後的一點思考\np: essay/thinking-about-the-cuckoos-nest\ndate: 2022-07-13 23:21:00\ntags:\n- 隨筆\n- 電影\n---\n\n電影《飛越瘋人院》（One Flew Over the Cuckoo's Nest）是基於 1962 年肯·克西（Ken Kesey）的同名小說改編，1975年上映，並獲得當年的第48屆奧斯卡五項大獎。男主角是藍道爾·麥克莫菲（Randle McMurphy），由傑克·尼克爾森（Jack Nicholson）扮演，女主角是護士拉契特（Ratched），由路易斯·弗萊徹（Louise Fletcher）扮演。\n\n麥克莫菲是一個罪犯，很好鬥，還曾經強姦了 15歲的少女，入獄後為了擺脫勞改，申請去了精神病院。在病院裏面，他發現只有少數人是跟他一樣是罪犯，而大多數居然是自願進來的。這令他很不解，明明他們都抱怨病院的不好，為什麼還不離開呢。\n\n<!--more-->\n\n漸漸地，他發現護士長拉契特是個很有問題的人。拉契特總是在逼著其他人談論他們不想觸及的話題，總是在活動時間大聲放音樂讓他們需要吼叫才能聽到彼此的話。她還不講理，在一次更改作息表觀看棒球比賽的投票中，即使麥克莫菲拉到 9個人投票還不行，她把那些精神失常的也算進來，認為不夠選票。在會議快結束時，麥克莫菲懇請再多 1分鐘，她卻宣佈會議結束。麥克莫菲最後拉到了酋長 1票，10:8 贏得多數選票，但她卻不承認結果。說到酋長，需要指出他並不是精神失常，也不是傻大個，他只是裝聾作啞，不想像他父親那樣被人利用。\n\n他還發現，那些所謂的精神病人，有的其實只是沒有勇氣去走出第一步。麥克莫菲鼓舞他們一起觀看「棒球比賽」，一起打籃球，還私自開巴士載著他們去碼頭，光明正大地駕駛了別人的遊艇，帶了一名妓女一起去海釣......\n\n麥克莫菲的結局很令人惋惜，他有很多次機會可以逃離瘋人院，但他沒有走。他太善良了，即使他曾經犯過罪。他總是在爲那些失去勇氣的人考慮，酋長、比利、查理等等。麥克莫菲死了，從他被執行了腦白質切除手術後就行屍走肉了。酋長終於尋回了他的勇氣，送走了麥克莫菲，搬起水療台砸向鐵窗，走了。\n\n酋長完成了麥克莫菲的遺願，電影最後只剩下他堅定遠去不回頭的背影，慢慢地、慢慢地越縮越小。導演在時間上的留白，不禁讓我開始了思考。\n\n第一點，社會治理不能把罪犯、網癮少年、同性戀、不同政見者等等野蠻地歸結爲精神問題，然後投到精神病院，接受藥物、電擊，甚至手術「治療」。這樣做無疑是對人權的踐踏。那些把他們送進去或者讓他們以爲自己病了的人或社會才是真的病了。大多數人都不是聖人，都可能有犯罪傾向，都會痴迷於某些事物，或者有不同的性取向，或者有對立的觀點。我們不能因爲他人（可能處在弱勢地位）與我不同就認為他人病了，因爲可能是自己（或者所處的強勢群體）病了，被某種情緒或觀念所綁架，沒有客觀理性地認知事物。\n\n第二點，現代社會讓人活得抑鬱，說是在「瘋人院」中也不爲過。首先是人的異化，被當成工具使，被不斷地壓榨，一旦不好用就被無情拋棄；還有就是暴戾、情緒化、不思考的社會氛圍讓人不斷遭遇平庸之惡。麥克莫菲們下場就像麥克莫菲一樣。小人物該如何鼓起勇氣飛越瘋人院呢？\n\n第三點，說到「飛越」，是麥克莫菲飛越了，還是酋長飛越了，剩下的「瘋人們」呢？ 酋長無疑是飛越了，他肉身翻出了瘋人院；而麥克莫菲，他從一開始精神上就不在瘋人院，他一直在鼓舞「瘋人們」走出來，特別是比利，一個 21歲的小年輕（比利的結局也很令人惋惜）。雖然最終麥克莫菲身體沒有飛越，但酋長替他完成了。剩下的「瘋人們」聽到砸窗的聲音後很激動，我覺得他們一定程度上也受到了鼓舞，相信他們以後會有點不同。\n\n第四點，麥克莫菲在幫助「瘋人們」走出來時使用的方法可能也適用於在「瘋人院」的我。簡單羅列如下：\n\n1. 保持清醒，不吃「不明藥物」。麥克莫菲從來不吃護士喂的作用不明的藥。在我看來，一切灌輸的、習以為常的、未經省察的東西都是「不明藥物」。\n2. 去外面走走，認識和經歷更多的事物。麥克莫菲帶他們去駕船、去海釣。\n3. 團隊活動，活動可以增進個人體力、團隊凝聚力，同時讓思考更活躍。麥克莫菲不厭其煩地訓練酋長和其他人一起打籃球。\n4. 飛越可能比想像中的要簡單，只要敢於踏出第一步。麥克莫菲最終使酋長鼓起了勇氣，暢通無阻地走了。\n\n以上，就是我看完這部電影後的一點點思考，可能在我看完原著後會有另外的思考，到時再談談了。\n","slug":"essay/thinking-about-the-cuckoos-nest","published":1,"updated":"2022-07-13T17:41:47.519Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxleo00091n9k4y03fo3a","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>電影《飛越瘋人院》（One Flew Over the Cuckoo’s Nest）是基於 1962 年肯·克西（Ken Kesey）的同名小說改編，1975年上映，並獲得當年的第48屆奧斯卡五項大獎。男主角是藍道爾·麥克莫菲（Randle McMurphy），由傑克·尼克爾森（Jack Nicholson）扮演，女主角是護士拉契特（Ratched），由路易斯·弗萊徹（Louise Fletcher）扮演。</p>\n<p>麥克莫菲是一個罪犯，很好鬥，還曾經強姦了 15歲的少女，入獄後為了擺脫勞改，申請去了精神病院。在病院裏面，他發現只有少數人是跟他一樣是罪犯，而大多數居然是自願進來的。這令他很不解，明明他們都抱怨病院的不好，為什麼還不離開呢。</p>\n<span id=\"more\"></span>\n\n<p>漸漸地，他發現護士長拉契特是個很有問題的人。拉契特總是在逼著其他人談論他們不想觸及的話題，總是在活動時間大聲放音樂讓他們需要吼叫才能聽到彼此的話。她還不講理，在一次更改作息表觀看棒球比賽的投票中，即使麥克莫菲拉到 9個人投票還不行，她把那些精神失常的也算進來，認為不夠選票。在會議快結束時，麥克莫菲懇請再多 1分鐘，她卻宣佈會議結束。麥克莫菲最後拉到了酋長 1票，10:8 贏得多數選票，但她卻不承認結果。說到酋長，需要指出他並不是精神失常，也不是傻大個，他只是裝聾作啞，不想像他父親那樣被人利用。</p>\n<p>他還發現，那些所謂的精神病人，有的其實只是沒有勇氣去走出第一步。麥克莫菲鼓舞他們一起觀看「棒球比賽」，一起打籃球，還私自開巴士載著他們去碼頭，光明正大地駕駛了別人的遊艇，帶了一名妓女一起去海釣……</p>\n<p>麥克莫菲的結局很令人惋惜，他有很多次機會可以逃離瘋人院，但他沒有走。他太善良了，即使他曾經犯過罪。他總是在爲那些失去勇氣的人考慮，酋長、比利、查理等等。麥克莫菲死了，從他被執行了腦白質切除手術後就行屍走肉了。酋長終於尋回了他的勇氣，送走了麥克莫菲，搬起水療台砸向鐵窗，走了。</p>\n<p>酋長完成了麥克莫菲的遺願，電影最後只剩下他堅定遠去不回頭的背影，慢慢地、慢慢地越縮越小。導演在時間上的留白，不禁讓我開始了思考。</p>\n<p>第一點，社會治理不能把罪犯、網癮少年、同性戀、不同政見者等等野蠻地歸結爲精神問題，然後投到精神病院，接受藥物、電擊，甚至手術「治療」。這樣做無疑是對人權的踐踏。那些把他們送進去或者讓他們以爲自己病了的人或社會才是真的病了。大多數人都不是聖人，都可能有犯罪傾向，都會痴迷於某些事物，或者有不同的性取向，或者有對立的觀點。我們不能因爲他人（可能處在弱勢地位）與我不同就認為他人病了，因爲可能是自己（或者所處的強勢群體）病了，被某種情緒或觀念所綁架，沒有客觀理性地認知事物。</p>\n<p>第二點，現代社會讓人活得抑鬱，說是在「瘋人院」中也不爲過。首先是人的異化，被當成工具使，被不斷地壓榨，一旦不好用就被無情拋棄；還有就是暴戾、情緒化、不思考的社會氛圍讓人不斷遭遇平庸之惡。麥克莫菲們下場就像麥克莫菲一樣。小人物該如何鼓起勇氣飛越瘋人院呢？</p>\n<p>第三點，說到「飛越」，是麥克莫菲飛越了，還是酋長飛越了，剩下的「瘋人們」呢？ 酋長無疑是飛越了，他肉身翻出了瘋人院；而麥克莫菲，他從一開始精神上就不在瘋人院，他一直在鼓舞「瘋人們」走出來，特別是比利，一個 21歲的小年輕（比利的結局也很令人惋惜）。雖然最終麥克莫菲身體沒有飛越，但酋長替他完成了。剩下的「瘋人們」聽到砸窗的聲音後很激動，我覺得他們一定程度上也受到了鼓舞，相信他們以後會有點不同。</p>\n<p>第四點，麥克莫菲在幫助「瘋人們」走出來時使用的方法可能也適用於在「瘋人院」的我。簡單羅列如下：</p>\n<ol>\n<li>保持清醒，不吃「不明藥物」。麥克莫菲從來不吃護士喂的作用不明的藥。在我看來，一切灌輸的、習以為常的、未經省察的東西都是「不明藥物」。</li>\n<li>去外面走走，認識和經歷更多的事物。麥克莫菲帶他們去駕船、去海釣。</li>\n<li>團隊活動，活動可以增進個人體力、團隊凝聚力，同時讓思考更活躍。麥克莫菲不厭其煩地訓練酋長和其他人一起打籃球。</li>\n<li>飛越可能比想像中的要簡單，只要敢於踏出第一步。麥克莫菲最終使酋長鼓起了勇氣，暢通無阻地走了。</li>\n</ol>\n<p>以上，就是我看完這部電影後的一點點思考，可能在我看完原著後會有另外的思考，到時再談談了。</p>\n","site":{"data":{}},"excerpt":"<p>電影《飛越瘋人院》（One Flew Over the Cuckoo’s Nest）是基於 1962 年肯·克西（Ken Kesey）的同名小說改編，1975年上映，並獲得當年的第48屆奧斯卡五項大獎。男主角是藍道爾·麥克莫菲（Randle McMurphy），由傑克·尼克爾森（Jack Nicholson）扮演，女主角是護士拉契特（Ratched），由路易斯·弗萊徹（Louise Fletcher）扮演。</p>\n<p>麥克莫菲是一個罪犯，很好鬥，還曾經強姦了 15歲的少女，入獄後為了擺脫勞改，申請去了精神病院。在病院裏面，他發現只有少數人是跟他一樣是罪犯，而大多數居然是自願進來的。這令他很不解，明明他們都抱怨病院的不好，為什麼還不離開呢。</p>","more":"<p>漸漸地，他發現護士長拉契特是個很有問題的人。拉契特總是在逼著其他人談論他們不想觸及的話題，總是在活動時間大聲放音樂讓他們需要吼叫才能聽到彼此的話。她還不講理，在一次更改作息表觀看棒球比賽的投票中，即使麥克莫菲拉到 9個人投票還不行，她把那些精神失常的也算進來，認為不夠選票。在會議快結束時，麥克莫菲懇請再多 1分鐘，她卻宣佈會議結束。麥克莫菲最後拉到了酋長 1票，10:8 贏得多數選票，但她卻不承認結果。說到酋長，需要指出他並不是精神失常，也不是傻大個，他只是裝聾作啞，不想像他父親那樣被人利用。</p>\n<p>他還發現，那些所謂的精神病人，有的其實只是沒有勇氣去走出第一步。麥克莫菲鼓舞他們一起觀看「棒球比賽」，一起打籃球，還私自開巴士載著他們去碼頭，光明正大地駕駛了別人的遊艇，帶了一名妓女一起去海釣……</p>\n<p>麥克莫菲的結局很令人惋惜，他有很多次機會可以逃離瘋人院，但他沒有走。他太善良了，即使他曾經犯過罪。他總是在爲那些失去勇氣的人考慮，酋長、比利、查理等等。麥克莫菲死了，從他被執行了腦白質切除手術後就行屍走肉了。酋長終於尋回了他的勇氣，送走了麥克莫菲，搬起水療台砸向鐵窗，走了。</p>\n<p>酋長完成了麥克莫菲的遺願，電影最後只剩下他堅定遠去不回頭的背影，慢慢地、慢慢地越縮越小。導演在時間上的留白，不禁讓我開始了思考。</p>\n<p>第一點，社會治理不能把罪犯、網癮少年、同性戀、不同政見者等等野蠻地歸結爲精神問題，然後投到精神病院，接受藥物、電擊，甚至手術「治療」。這樣做無疑是對人權的踐踏。那些把他們送進去或者讓他們以爲自己病了的人或社會才是真的病了。大多數人都不是聖人，都可能有犯罪傾向，都會痴迷於某些事物，或者有不同的性取向，或者有對立的觀點。我們不能因爲他人（可能處在弱勢地位）與我不同就認為他人病了，因爲可能是自己（或者所處的強勢群體）病了，被某種情緒或觀念所綁架，沒有客觀理性地認知事物。</p>\n<p>第二點，現代社會讓人活得抑鬱，說是在「瘋人院」中也不爲過。首先是人的異化，被當成工具使，被不斷地壓榨，一旦不好用就被無情拋棄；還有就是暴戾、情緒化、不思考的社會氛圍讓人不斷遭遇平庸之惡。麥克莫菲們下場就像麥克莫菲一樣。小人物該如何鼓起勇氣飛越瘋人院呢？</p>\n<p>第三點，說到「飛越」，是麥克莫菲飛越了，還是酋長飛越了，剩下的「瘋人們」呢？ 酋長無疑是飛越了，他肉身翻出了瘋人院；而麥克莫菲，他從一開始精神上就不在瘋人院，他一直在鼓舞「瘋人們」走出來，特別是比利，一個 21歲的小年輕（比利的結局也很令人惋惜）。雖然最終麥克莫菲身體沒有飛越，但酋長替他完成了。剩下的「瘋人們」聽到砸窗的聲音後很激動，我覺得他們一定程度上也受到了鼓舞，相信他們以後會有點不同。</p>\n<p>第四點，麥克莫菲在幫助「瘋人們」走出來時使用的方法可能也適用於在「瘋人院」的我。簡單羅列如下：</p>\n<ol>\n<li>保持清醒，不吃「不明藥物」。麥克莫菲從來不吃護士喂的作用不明的藥。在我看來，一切灌輸的、習以為常的、未經省察的東西都是「不明藥物」。</li>\n<li>去外面走走，認識和經歷更多的事物。麥克莫菲帶他們去駕船、去海釣。</li>\n<li>團隊活動，活動可以增進個人體力、團隊凝聚力，同時讓思考更活躍。麥克莫菲不厭其煩地訓練酋長和其他人一起打籃球。</li>\n<li>飛越可能比想像中的要簡單，只要敢於踏出第一步。麥克莫菲最終使酋長鼓起了勇氣，暢通無阻地走了。</li>\n</ol>\n<p>以上，就是我看完這部電影後的一點點思考，可能在我看完原著後會有另外的思考，到時再談談了。</p>"},{"title":"聆聽音樂：蕭邦之「雨滴」","p":"music/listen-chopin-raindrop","date":"2020-10-11T15:23:00.000Z","_content":"\n我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。\n\n今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。\n\n<!--more-->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n## 聽後感\n\n正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。\n\n翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。\n\n## 音樂筆記\n\n### Prélude\nPrélude：法語，英文爲Prelude， 意爲前奏曲。\n常見的音樂體裁還有：\n- Ballade 敘事曲\n- Concerto 協奏曲\n- Etude 練習曲\n- Fuga 賦格\n- Impromptu 即興曲\n- Menuet 小步舞曲\n- Overture 序曲\n- Prelude 前奏曲\n- Sonata 奏鳴曲\n- String Quartet 弦樂四重奏\n- Suite 組曲\n- Symphony 交響曲\n- Violin Concerto 小提請協奏曲\n- Waltz 圓舞曲\n\n### D Flat / Db\nD Flat / Db：降D\n相關符號有：\n-  ♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；\n- ♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；\n- ♮，還原號，英文natural，表示復歸原先的音高。\n\n### Major\n**major 大調**\n![](cdefgab.jpg)\n名詞解釋：\n- 簡譜：用數字表示音的簡單記譜方式\n- 音名：音的名字\n- 唱名：音的唱法\n- 距離：代表兩個音之間的距離\n- 半音：最靠近的兩個音之間的距離\n- 全音：1全音 = 1半音 + 1半音\n![](piano-keys.gif)\nE－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。\n\n記憶方法：\n1\tDo\tC\t這個不需要想，也很直覺，乾脆就直接背了\n2\tRe\tD\tDouble 跟 Repeat 都可以聯想到 2\n3\tMi\tE\t3 M E 都長的很像\n4\tFa\tF\t4 的英文單字是 Four\n5\tSol\tG\t你跟別人 Give me five 是用手 (Sol) 來的\n6\tLa\tA\t六的閩南語念成什麼? 尾音 A\n7\tSi\tB\t七夕(Si)。 SB\n\n音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：\n- C Major：C D E F G A B C\n- Db Major：Db Eb F Gb Ab Bb C Db\n\n**minor 小調**\n音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。\n\n### Op. 28 , No. 15\nOp. 28 , No. 15：作品 28 之 15\nOp.，拉丁文 Opus，著作，尤指編號的音樂作品。\nNo.，Number，編號。\n\n## 參考\n1. [ 音階與調性 ](http://www.dancepiano.com/scalechar.aspx \"音階與調性\")\n2. [ 必學基礎樂理：音階/簡譜/音名/唱名 ](https://www.guitar.com.tw/basic-music-theory/ \"必學基礎樂理：音階/簡譜/音名/唱名\")\n3. [ 音階基本概念 ](http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf \"音階基本概念\")\n\n\n","source":"_posts/music/listen-chopin-raindrop.md","raw":"---\ntitle: 聆聽音樂：蕭邦之「雨滴」\np: music/listen-chopin-raindrop\ndate: 2020-10-11 23:23:00\ntags:\n- 聆聽音樂\n---\n\n我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。\n\n今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。\n\n<!--more-->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n## 聽後感\n\n正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。\n\n翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。\n\n## 音樂筆記\n\n### Prélude\nPrélude：法語，英文爲Prelude， 意爲前奏曲。\n常見的音樂體裁還有：\n- Ballade 敘事曲\n- Concerto 協奏曲\n- Etude 練習曲\n- Fuga 賦格\n- Impromptu 即興曲\n- Menuet 小步舞曲\n- Overture 序曲\n- Prelude 前奏曲\n- Sonata 奏鳴曲\n- String Quartet 弦樂四重奏\n- Suite 組曲\n- Symphony 交響曲\n- Violin Concerto 小提請協奏曲\n- Waltz 圓舞曲\n\n### D Flat / Db\nD Flat / Db：降D\n相關符號有：\n-  ♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；\n- ♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；\n- ♮，還原號，英文natural，表示復歸原先的音高。\n\n### Major\n**major 大調**\n![](cdefgab.jpg)\n名詞解釋：\n- 簡譜：用數字表示音的簡單記譜方式\n- 音名：音的名字\n- 唱名：音的唱法\n- 距離：代表兩個音之間的距離\n- 半音：最靠近的兩個音之間的距離\n- 全音：1全音 = 1半音 + 1半音\n![](piano-keys.gif)\nE－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。\n\n記憶方法：\n1\tDo\tC\t這個不需要想，也很直覺，乾脆就直接背了\n2\tRe\tD\tDouble 跟 Repeat 都可以聯想到 2\n3\tMi\tE\t3 M E 都長的很像\n4\tFa\tF\t4 的英文單字是 Four\n5\tSol\tG\t你跟別人 Give me five 是用手 (Sol) 來的\n6\tLa\tA\t六的閩南語念成什麼? 尾音 A\n7\tSi\tB\t七夕(Si)。 SB\n\n音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：\n- C Major：C D E F G A B C\n- Db Major：Db Eb F Gb Ab Bb C Db\n\n**minor 小調**\n音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。\n\n### Op. 28 , No. 15\nOp. 28 , No. 15：作品 28 之 15\nOp.，拉丁文 Opus，著作，尤指編號的音樂作品。\nNo.，Number，編號。\n\n## 參考\n1. [ 音階與調性 ](http://www.dancepiano.com/scalechar.aspx \"音階與調性\")\n2. [ 必學基礎樂理：音階/簡譜/音名/唱名 ](https://www.guitar.com.tw/basic-music-theory/ \"必學基礎樂理：音階/簡譜/音名/唱名\")\n3. [ 音階基本概念 ](http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf \"音階基本概念\")\n\n\n","slug":"music/listen-chopin-raindrop","published":1,"updated":"2021-09-13T14:17:45.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxleq000b1n9kaucd99vp","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。</p>\n<p>今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。</p>\n<span id=\"more\"></span>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n<h2 id=\"聽後感\"><a href=\"#聽後感\" class=\"headerlink\" title=\"聽後感\"></a>聽後感</h2><p>正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。</p>\n<p>翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。</p>\n<h2 id=\"音樂筆記\"><a href=\"#音樂筆記\" class=\"headerlink\" title=\"音樂筆記\"></a>音樂筆記</h2><h3 id=\"Prelude\"><a href=\"#Prelude\" class=\"headerlink\" title=\"Prélude\"></a>Prélude</h3><p>Prélude：法語，英文爲Prelude， 意爲前奏曲。<br>常見的音樂體裁還有：</p>\n<ul>\n<li>Ballade 敘事曲</li>\n<li>Concerto 協奏曲</li>\n<li>Etude 練習曲</li>\n<li>Fuga 賦格</li>\n<li>Impromptu 即興曲</li>\n<li>Menuet 小步舞曲</li>\n<li>Overture 序曲</li>\n<li>Prelude 前奏曲</li>\n<li>Sonata 奏鳴曲</li>\n<li>String Quartet 弦樂四重奏</li>\n<li>Suite 組曲</li>\n<li>Symphony 交響曲</li>\n<li>Violin Concerto 小提請協奏曲</li>\n<li>Waltz 圓舞曲</li>\n</ul>\n<h3 id=\"D-Flat-Db\"><a href=\"#D-Flat-Db\" class=\"headerlink\" title=\"D Flat / Db\"></a>D Flat / Db</h3><p>D Flat / Db：降D<br>相關符號有：</p>\n<ul>\n<li>♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；</li>\n<li>♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；</li>\n<li>♮，還原號，英文natural，表示復歸原先的音高。</li>\n</ul>\n<h3 id=\"Major\"><a href=\"#Major\" class=\"headerlink\" title=\"Major\"></a>Major</h3><p><strong>major 大調</strong><br><img src=\"/music/listen-chopin-raindrop/cdefgab.jpg\" alt><br>名詞解釋：</p>\n<ul>\n<li>簡譜：用數字表示音的簡單記譜方式</li>\n<li>音名：音的名字</li>\n<li>唱名：音的唱法</li>\n<li>距離：代表兩個音之間的距離</li>\n<li>半音：最靠近的兩個音之間的距離</li>\n<li>全音：1全音 = 1半音 + 1半音<br><img src=\"/music/listen-chopin-raindrop/piano-keys.gif\" alt><br>E－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。</li>\n</ul>\n<p>記憶方法：<br>1    Do    C    這個不需要想，也很直覺，乾脆就直接背了<br>2    Re    D    Double 跟 Repeat 都可以聯想到 2<br>3    Mi    E    3 M E 都長的很像<br>4    Fa    F    4 的英文單字是 Four<br>5    Sol    G    你跟別人 Give me five 是用手 (Sol) 來的<br>6    La    A    六的閩南語念成什麼? 尾音 A<br>7    Si    B    七夕(Si)。 SB</p>\n<p>音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：</p>\n<ul>\n<li>C Major：C D E F G A B C</li>\n<li>Db Major：Db Eb F Gb Ab Bb C Db</li>\n</ul>\n<p><strong>minor 小調</strong><br>音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。</p>\n<h3 id=\"Op-28-No-15\"><a href=\"#Op-28-No-15\" class=\"headerlink\" title=\"Op. 28 , No. 15\"></a>Op. 28 , No. 15</h3><p>Op. 28 , No. 15：作品 28 之 15<br>Op.，拉丁文 Opus，著作，尤指編號的音樂作品。<br>No.，Number，編號。</p>\n<h2 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考\"></a>參考</h2><ol>\n<li><a href=\"http://www.dancepiano.com/scalechar.aspx\" title=\"音階與調性\"> 音階與調性 </a></li>\n<li><a href=\"https://www.guitar.com.tw/basic-music-theory/\" title=\"必學基礎樂理：音階/簡譜/音名/唱名\"> 必學基礎樂理：音階/簡譜/音名/唱名 </a></li>\n<li><a href=\"http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf\" title=\"音階基本概念\"> 音階基本概念 </a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。</p>\n<p>今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。</p>","more":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n<h2 id=\"聽後感\"><a href=\"#聽後感\" class=\"headerlink\" title=\"聽後感\"></a>聽後感</h2><p>正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。</p>\n<p>翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。</p>\n<h2 id=\"音樂筆記\"><a href=\"#音樂筆記\" class=\"headerlink\" title=\"音樂筆記\"></a>音樂筆記</h2><h3 id=\"Prelude\"><a href=\"#Prelude\" class=\"headerlink\" title=\"Prélude\"></a>Prélude</h3><p>Prélude：法語，英文爲Prelude， 意爲前奏曲。<br>常見的音樂體裁還有：</p>\n<ul>\n<li>Ballade 敘事曲</li>\n<li>Concerto 協奏曲</li>\n<li>Etude 練習曲</li>\n<li>Fuga 賦格</li>\n<li>Impromptu 即興曲</li>\n<li>Menuet 小步舞曲</li>\n<li>Overture 序曲</li>\n<li>Prelude 前奏曲</li>\n<li>Sonata 奏鳴曲</li>\n<li>String Quartet 弦樂四重奏</li>\n<li>Suite 組曲</li>\n<li>Symphony 交響曲</li>\n<li>Violin Concerto 小提請協奏曲</li>\n<li>Waltz 圓舞曲</li>\n</ul>\n<h3 id=\"D-Flat-Db\"><a href=\"#D-Flat-Db\" class=\"headerlink\" title=\"D Flat / Db\"></a>D Flat / Db</h3><p>D Flat / Db：降D<br>相關符號有：</p>\n<ul>\n<li>♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；</li>\n<li>♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；</li>\n<li>♮，還原號，英文natural，表示復歸原先的音高。</li>\n</ul>\n<h3 id=\"Major\"><a href=\"#Major\" class=\"headerlink\" title=\"Major\"></a>Major</h3><p><strong>major 大調</strong><br><img src=\"/music/listen-chopin-raindrop/cdefgab.jpg\" alt><br>名詞解釋：</p>\n<ul>\n<li>簡譜：用數字表示音的簡單記譜方式</li>\n<li>音名：音的名字</li>\n<li>唱名：音的唱法</li>\n<li>距離：代表兩個音之間的距離</li>\n<li>半音：最靠近的兩個音之間的距離</li>\n<li>全音：1全音 = 1半音 + 1半音<br><img src=\"/music/listen-chopin-raindrop/piano-keys.gif\" alt><br>E－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。</li>\n</ul>\n<p>記憶方法：<br>1    Do    C    這個不需要想，也很直覺，乾脆就直接背了<br>2    Re    D    Double 跟 Repeat 都可以聯想到 2<br>3    Mi    E    3 M E 都長的很像<br>4    Fa    F    4 的英文單字是 Four<br>5    Sol    G    你跟別人 Give me five 是用手 (Sol) 來的<br>6    La    A    六的閩南語念成什麼? 尾音 A<br>7    Si    B    七夕(Si)。 SB</p>\n<p>音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：</p>\n<ul>\n<li>C Major：C D E F G A B C</li>\n<li>Db Major：Db Eb F Gb Ab Bb C Db</li>\n</ul>\n<p><strong>minor 小調</strong><br>音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。</p>\n<h3 id=\"Op-28-No-15\"><a href=\"#Op-28-No-15\" class=\"headerlink\" title=\"Op. 28 , No. 15\"></a>Op. 28 , No. 15</h3><p>Op. 28 , No. 15：作品 28 之 15<br>Op.，拉丁文 Opus，著作，尤指編號的音樂作品。<br>No.，Number，編號。</p>\n<h2 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考\"></a>參考</h2><ol>\n<li><a href=\"http://www.dancepiano.com/scalechar.aspx\" title=\"音階與調性\"> 音階與調性 </a></li>\n<li><a href=\"https://www.guitar.com.tw/basic-music-theory/\" title=\"必學基礎樂理：音階/簡譜/音名/唱名\"> 必學基礎樂理：音階/簡譜/音名/唱名 </a></li>\n<li><a href=\"http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf\" title=\"音階基本概念\"> 音階基本概念 </a></li>\n</ol>"},{"title":"遊清暉園","p":"essay/visit-qinghui-garden","date":"2021-09-12T12:56:00.000Z","_content":"\n透早睇了一頃《哥倫比亞的倒影》，內底是呾木心先生著紐約哥倫比亞大學行走時亓所見所想。印象深刻亓是伊當睇著思想者大衛亓銅像，摸著大衛緊張且燒燒亓肌肉時，想到王爾德亓一句話：思想產生在陰影裡，太陽是嫉妒思想的。\n\n<!--more-->\n\n又睏了一頃，兩點外鐘，叫車前往清暉園`(粵語: cing¹ fai¹ jyun⁴, 甲子話: cêng¹ hui¹ hng⁵)`。準備乞日頭消滅我亓胡思亂想。\n\n行入清暉園前，需要預約（可即時預約）並且展示綠碼正好入去，然後到售票亭買票，大人票張15個銀，較便`(pin¹, 便宜)`。\n\n一入園就信步而行，行到底塊就底塊，事前無攻略。\n\n入園往左，睇著一bao⁵`(棵)`樹，名玉堂春，卡片上呾是木蘭，又叫功名樹，需要考上功名皇帝賜汝正好種。潮劇中的蘇三花名「玉堂春」原來是暗示王金龍考上功名。\n\n又見一亭，有對聯兩句：「白菡萏開含露重，紅蜻蜓去帶香飛」，後一句尤其喜歡。只可惜荷葉<u>gao³ oi⁵</u>`(大片)`枯乾，也無荷花也無沙螟。\n\n![紅蜻蜓去帶香飛](visit-qinghui-garden/IMG_3717.jpg)\n\n又入一兩房一廳，廳兩爿dah⁴`(貼)`兩張關公木版畫，廳倒手爿亓關公出倒骹、倒手擎刀，正手爿亓出正骹、正手擎刀，是鏡像；內有臥室，擺了一些嫁妝，有洗面盆、瓷枕頭、尿壺還有一個睇起來應該是屎盆。\n\n![關公木版畫](visit-qinghui-garden/IMG_3721.jpg)\n\n入一假山，有水有洞有魚。鯉魚酷㩼酷大隻，喙囁囁著，無歇。有一隻覕著石後，靜靜，是一隻孤單亓魚。\n\n![孤獨亓魚](visit-qinghui-garden/IMG_3726.jpg)\n\n見一龍爪槐，樹幹直立，又倒垂枝葉，奇特；一灌木葉扭曲成刺，原來是中國冬青、枸骨或名貓兒刺，奇醜。\n\n![龍爪槐](visit-qinghui-garden/IMG_3730.jpg)\n\n上一橋，橋兩爿種水葫蘆，細小可愛。\n\n![水葫蘆](visit-qinghui-garden/IMG_3734.jpg)\n\n入一堂，名狀元堂，有一塑像，是黃士俊，順德第一個狀元，明朝人，清暉園最早亓主人。\n\n![狀元黃士俊](visit-qinghui-garden/IMG_3736.jpg)\n\n黃狀元亓閣樓著清朝時沒落了，乞當時亓進士龍應時購買擴充。後來伊亓囝龍延槐，回園奉母，請同榜進士李兆洛題名「清暉」，取「誰言寸草心，報得三春暉」亓意味。龍家幾代人苦心經營，可惜民國戰亂人走樓空。新中國成立後，變做順德縣第一招待所，現在正成為清暉園博物館。\n\n又見茶室琴房、吊燈翠竹。\n\n![茶室](visit-qinghui-garden/IMG_3739.jpg)\n\n![吊燈花](visit-qinghui-garden/IMG_3742.jpg)\n\n進一齋，名真研齋，是書房，有書桌，有書冊，還有孔子像。\n\n![真研齋](visit-qinghui-garden/IMG_3744.jpg)\n\n有一泉眼，往外口不斷吐水。\n\n有一橢圓形亓窗，竹葉伸入，兩爿題「白雲無盡時，綠樹多生意」，應景。\n\n![白雲無盡時，綠樹多生意](visit-qinghui-garden/IMG_3751.jpg)\n\n又上一假山，有各式草類聚集成景，挲了幾下貓毛兒草，酷柔。\n\n![貓毛兒草](visit-qinghui-garden/IMG_3763.jpg)\n\n見池柏三兩叢，樹幹聳立，樹葉下垂，有柳意。\n\n![池柏](visit-qinghui-garden/IMG_3766.jpg)\n\n見一窗石林，大驚。大約高不過三十釐米，然用凸起亓樹根或樹幹做石景，頭逝見。\n\n![石林](visit-qinghui-garden/IMG_3768.jpg)\n\n見一老門，匾寫「清暉園」，聯寫「水色山光皆畫本，花香鳥語總詩情」。\n\n見一楊桃樹，危大青翠，桃葉難辨，坐伊骹頭，聽鳥音不斷。\n\n![楊桃樹](visit-qinghui-garden/IMG_3778.jpg)\n\n移步換景，景緻<u>相sua³相sua³</u>`(接連不斷)`，無感覺時間已過去兩三個鐘頭。\n\n出園，覓食。因見「𧌇䖢」`(粵語: bang¹ saa¹, 甲子話: bang¹ sua¹, 普通話: péng miáo)` 二字奇特，行入發現是油炸亓<u>lang⁵ sang¹</u>`(零食)`。又行了幾步，睇著民信老舖，點了一份凍双皮奶佮一份炸牛奶，凍双皮奶熱天時食合好，奶味足、入口即化；炸牛奶怪甜，毋喜歡。\n\n是爲記。\n\n\n二零二一年九月十三日\n","source":"_posts/essay/visit-qinghui-garden.md","raw":"---\ntitle: 遊清暉園\np: essay/visit-qinghui-garden\ndate: 2021-09-12 20:56:00\ntags: \n- 隨筆\n- 遊記\n- 閩南語\n- 甲子話\n---\n\n透早睇了一頃《哥倫比亞的倒影》，內底是呾木心先生著紐約哥倫比亞大學行走時亓所見所想。印象深刻亓是伊當睇著思想者大衛亓銅像，摸著大衛緊張且燒燒亓肌肉時，想到王爾德亓一句話：思想產生在陰影裡，太陽是嫉妒思想的。\n\n<!--more-->\n\n又睏了一頃，兩點外鐘，叫車前往清暉園`(粵語: cing¹ fai¹ jyun⁴, 甲子話: cêng¹ hui¹ hng⁵)`。準備乞日頭消滅我亓胡思亂想。\n\n行入清暉園前，需要預約（可即時預約）並且展示綠碼正好入去，然後到售票亭買票，大人票張15個銀，較便`(pin¹, 便宜)`。\n\n一入園就信步而行，行到底塊就底塊，事前無攻略。\n\n入園往左，睇著一bao⁵`(棵)`樹，名玉堂春，卡片上呾是木蘭，又叫功名樹，需要考上功名皇帝賜汝正好種。潮劇中的蘇三花名「玉堂春」原來是暗示王金龍考上功名。\n\n又見一亭，有對聯兩句：「白菡萏開含露重，紅蜻蜓去帶香飛」，後一句尤其喜歡。只可惜荷葉<u>gao³ oi⁵</u>`(大片)`枯乾，也無荷花也無沙螟。\n\n![紅蜻蜓去帶香飛](visit-qinghui-garden/IMG_3717.jpg)\n\n又入一兩房一廳，廳兩爿dah⁴`(貼)`兩張關公木版畫，廳倒手爿亓關公出倒骹、倒手擎刀，正手爿亓出正骹、正手擎刀，是鏡像；內有臥室，擺了一些嫁妝，有洗面盆、瓷枕頭、尿壺還有一個睇起來應該是屎盆。\n\n![關公木版畫](visit-qinghui-garden/IMG_3721.jpg)\n\n入一假山，有水有洞有魚。鯉魚酷㩼酷大隻，喙囁囁著，無歇。有一隻覕著石後，靜靜，是一隻孤單亓魚。\n\n![孤獨亓魚](visit-qinghui-garden/IMG_3726.jpg)\n\n見一龍爪槐，樹幹直立，又倒垂枝葉，奇特；一灌木葉扭曲成刺，原來是中國冬青、枸骨或名貓兒刺，奇醜。\n\n![龍爪槐](visit-qinghui-garden/IMG_3730.jpg)\n\n上一橋，橋兩爿種水葫蘆，細小可愛。\n\n![水葫蘆](visit-qinghui-garden/IMG_3734.jpg)\n\n入一堂，名狀元堂，有一塑像，是黃士俊，順德第一個狀元，明朝人，清暉園最早亓主人。\n\n![狀元黃士俊](visit-qinghui-garden/IMG_3736.jpg)\n\n黃狀元亓閣樓著清朝時沒落了，乞當時亓進士龍應時購買擴充。後來伊亓囝龍延槐，回園奉母，請同榜進士李兆洛題名「清暉」，取「誰言寸草心，報得三春暉」亓意味。龍家幾代人苦心經營，可惜民國戰亂人走樓空。新中國成立後，變做順德縣第一招待所，現在正成為清暉園博物館。\n\n又見茶室琴房、吊燈翠竹。\n\n![茶室](visit-qinghui-garden/IMG_3739.jpg)\n\n![吊燈花](visit-qinghui-garden/IMG_3742.jpg)\n\n進一齋，名真研齋，是書房，有書桌，有書冊，還有孔子像。\n\n![真研齋](visit-qinghui-garden/IMG_3744.jpg)\n\n有一泉眼，往外口不斷吐水。\n\n有一橢圓形亓窗，竹葉伸入，兩爿題「白雲無盡時，綠樹多生意」，應景。\n\n![白雲無盡時，綠樹多生意](visit-qinghui-garden/IMG_3751.jpg)\n\n又上一假山，有各式草類聚集成景，挲了幾下貓毛兒草，酷柔。\n\n![貓毛兒草](visit-qinghui-garden/IMG_3763.jpg)\n\n見池柏三兩叢，樹幹聳立，樹葉下垂，有柳意。\n\n![池柏](visit-qinghui-garden/IMG_3766.jpg)\n\n見一窗石林，大驚。大約高不過三十釐米，然用凸起亓樹根或樹幹做石景，頭逝見。\n\n![石林](visit-qinghui-garden/IMG_3768.jpg)\n\n見一老門，匾寫「清暉園」，聯寫「水色山光皆畫本，花香鳥語總詩情」。\n\n見一楊桃樹，危大青翠，桃葉難辨，坐伊骹頭，聽鳥音不斷。\n\n![楊桃樹](visit-qinghui-garden/IMG_3778.jpg)\n\n移步換景，景緻<u>相sua³相sua³</u>`(接連不斷)`，無感覺時間已過去兩三個鐘頭。\n\n出園，覓食。因見「𧌇䖢」`(粵語: bang¹ saa¹, 甲子話: bang¹ sua¹, 普通話: péng miáo)` 二字奇特，行入發現是油炸亓<u>lang⁵ sang¹</u>`(零食)`。又行了幾步，睇著民信老舖，點了一份凍双皮奶佮一份炸牛奶，凍双皮奶熱天時食合好，奶味足、入口即化；炸牛奶怪甜，毋喜歡。\n\n是爲記。\n\n\n二零二一年九月十三日\n","slug":"essay/visit-qinghui-garden","published":1,"updated":"2021-09-14T14:10:30.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxler000d1n9k479p1p3a","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>透早睇了一頃《哥倫比亞的倒影》，內底是呾木心先生著紐約哥倫比亞大學行走時亓所見所想。印象深刻亓是伊當睇著思想者大衛亓銅像，摸著大衛緊張且燒燒亓肌肉時，想到王爾德亓一句話：思想產生在陰影裡，太陽是嫉妒思想的。</p>\n<span id=\"more\"></span>\n\n<p>又睏了一頃，兩點外鐘，叫車前往清暉園<code>(粵語: cing¹ fai¹ jyun⁴, 甲子話: cêng¹ hui¹ hng⁵)</code>。準備乞日頭消滅我亓胡思亂想。</p>\n<p>行入清暉園前，需要預約（可即時預約）並且展示綠碼正好入去，然後到售票亭買票，大人票張15個銀，較便<code>(pin¹, 便宜)</code>。</p>\n<p>一入園就信步而行，行到底塊就底塊，事前無攻略。</p>\n<p>入園往左，睇著一bao⁵<code>(棵)</code>樹，名玉堂春，卡片上呾是木蘭，又叫功名樹，需要考上功名皇帝賜汝正好種。潮劇中的蘇三花名「玉堂春」原來是暗示王金龍考上功名。</p>\n<p>又見一亭，有對聯兩句：「白菡萏開含露重，紅蜻蜓去帶香飛」，後一句尤其喜歡。只可惜荷葉<u>gao³ oi⁵</u><code>(大片)</code>枯乾，也無荷花也無沙螟。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3717.jpg\" alt=\"紅蜻蜓去帶香飛\"></p>\n<p>又入一兩房一廳，廳兩爿dah⁴<code>(貼)</code>兩張關公木版畫，廳倒手爿亓關公出倒骹、倒手擎刀，正手爿亓出正骹、正手擎刀，是鏡像；內有臥室，擺了一些嫁妝，有洗面盆、瓷枕頭、尿壺還有一個睇起來應該是屎盆。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3721.jpg\" alt=\"關公木版畫\"></p>\n<p>入一假山，有水有洞有魚。鯉魚酷㩼酷大隻，喙囁囁著，無歇。有一隻覕著石後，靜靜，是一隻孤單亓魚。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3726.jpg\" alt=\"孤獨亓魚\"></p>\n<p>見一龍爪槐，樹幹直立，又倒垂枝葉，奇特；一灌木葉扭曲成刺，原來是中國冬青、枸骨或名貓兒刺，奇醜。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3730.jpg\" alt=\"龍爪槐\"></p>\n<p>上一橋，橋兩爿種水葫蘆，細小可愛。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3734.jpg\" alt=\"水葫蘆\"></p>\n<p>入一堂，名狀元堂，有一塑像，是黃士俊，順德第一個狀元，明朝人，清暉園最早亓主人。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3736.jpg\" alt=\"狀元黃士俊\"></p>\n<p>黃狀元亓閣樓著清朝時沒落了，乞當時亓進士龍應時購買擴充。後來伊亓囝龍延槐，回園奉母，請同榜進士李兆洛題名「清暉」，取「誰言寸草心，報得三春暉」亓意味。龍家幾代人苦心經營，可惜民國戰亂人走樓空。新中國成立後，變做順德縣第一招待所，現在正成為清暉園博物館。</p>\n<p>又見茶室琴房、吊燈翠竹。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3739.jpg\" alt=\"茶室\"></p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3742.jpg\" alt=\"吊燈花\"></p>\n<p>進一齋，名真研齋，是書房，有書桌，有書冊，還有孔子像。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3744.jpg\" alt=\"真研齋\"></p>\n<p>有一泉眼，往外口不斷吐水。</p>\n<p>有一橢圓形亓窗，竹葉伸入，兩爿題「白雲無盡時，綠樹多生意」，應景。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3751.jpg\" alt=\"白雲無盡時，綠樹多生意\"></p>\n<p>又上一假山，有各式草類聚集成景，挲了幾下貓毛兒草，酷柔。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3763.jpg\" alt=\"貓毛兒草\"></p>\n<p>見池柏三兩叢，樹幹聳立，樹葉下垂，有柳意。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3766.jpg\" alt=\"池柏\"></p>\n<p>見一窗石林，大驚。大約高不過三十釐米，然用凸起亓樹根或樹幹做石景，頭逝見。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3768.jpg\" alt=\"石林\"></p>\n<p>見一老門，匾寫「清暉園」，聯寫「水色山光皆畫本，花香鳥語總詩情」。</p>\n<p>見一楊桃樹，危大青翠，桃葉難辨，坐伊骹頭，聽鳥音不斷。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3778.jpg\" alt=\"楊桃樹\"></p>\n<p>移步換景，景緻<u>相sua³相sua³</u><code>(接連不斷)</code>，無感覺時間已過去兩三個鐘頭。</p>\n<p>出園，覓食。因見「𧌇䖢」<code>(粵語: bang¹ saa¹, 甲子話: bang¹ sua¹, 普通話: péng miáo)</code> 二字奇特，行入發現是油炸亓<u>lang⁵ sang¹</u><code>(零食)</code>。又行了幾步，睇著民信老舖，點了一份凍双皮奶佮一份炸牛奶，凍双皮奶熱天時食合好，奶味足、入口即化；炸牛奶怪甜，毋喜歡。</p>\n<p>是爲記。</p>\n<p>二零二一年九月十三日</p>\n","site":{"data":{}},"excerpt":"<p>透早睇了一頃《哥倫比亞的倒影》，內底是呾木心先生著紐約哥倫比亞大學行走時亓所見所想。印象深刻亓是伊當睇著思想者大衛亓銅像，摸著大衛緊張且燒燒亓肌肉時，想到王爾德亓一句話：思想產生在陰影裡，太陽是嫉妒思想的。</p>","more":"<p>又睏了一頃，兩點外鐘，叫車前往清暉園<code>(粵語: cing¹ fai¹ jyun⁴, 甲子話: cêng¹ hui¹ hng⁵)</code>。準備乞日頭消滅我亓胡思亂想。</p>\n<p>行入清暉園前，需要預約（可即時預約）並且展示綠碼正好入去，然後到售票亭買票，大人票張15個銀，較便<code>(pin¹, 便宜)</code>。</p>\n<p>一入園就信步而行，行到底塊就底塊，事前無攻略。</p>\n<p>入園往左，睇著一bao⁵<code>(棵)</code>樹，名玉堂春，卡片上呾是木蘭，又叫功名樹，需要考上功名皇帝賜汝正好種。潮劇中的蘇三花名「玉堂春」原來是暗示王金龍考上功名。</p>\n<p>又見一亭，有對聯兩句：「白菡萏開含露重，紅蜻蜓去帶香飛」，後一句尤其喜歡。只可惜荷葉<u>gao³ oi⁵</u><code>(大片)</code>枯乾，也無荷花也無沙螟。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3717.jpg\" alt=\"紅蜻蜓去帶香飛\"></p>\n<p>又入一兩房一廳，廳兩爿dah⁴<code>(貼)</code>兩張關公木版畫，廳倒手爿亓關公出倒骹、倒手擎刀，正手爿亓出正骹、正手擎刀，是鏡像；內有臥室，擺了一些嫁妝，有洗面盆、瓷枕頭、尿壺還有一個睇起來應該是屎盆。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3721.jpg\" alt=\"關公木版畫\"></p>\n<p>入一假山，有水有洞有魚。鯉魚酷㩼酷大隻，喙囁囁著，無歇。有一隻覕著石後，靜靜，是一隻孤單亓魚。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3726.jpg\" alt=\"孤獨亓魚\"></p>\n<p>見一龍爪槐，樹幹直立，又倒垂枝葉，奇特；一灌木葉扭曲成刺，原來是中國冬青、枸骨或名貓兒刺，奇醜。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3730.jpg\" alt=\"龍爪槐\"></p>\n<p>上一橋，橋兩爿種水葫蘆，細小可愛。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3734.jpg\" alt=\"水葫蘆\"></p>\n<p>入一堂，名狀元堂，有一塑像，是黃士俊，順德第一個狀元，明朝人，清暉園最早亓主人。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3736.jpg\" alt=\"狀元黃士俊\"></p>\n<p>黃狀元亓閣樓著清朝時沒落了，乞當時亓進士龍應時購買擴充。後來伊亓囝龍延槐，回園奉母，請同榜進士李兆洛題名「清暉」，取「誰言寸草心，報得三春暉」亓意味。龍家幾代人苦心經營，可惜民國戰亂人走樓空。新中國成立後，變做順德縣第一招待所，現在正成為清暉園博物館。</p>\n<p>又見茶室琴房、吊燈翠竹。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3739.jpg\" alt=\"茶室\"></p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3742.jpg\" alt=\"吊燈花\"></p>\n<p>進一齋，名真研齋，是書房，有書桌，有書冊，還有孔子像。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3744.jpg\" alt=\"真研齋\"></p>\n<p>有一泉眼，往外口不斷吐水。</p>\n<p>有一橢圓形亓窗，竹葉伸入，兩爿題「白雲無盡時，綠樹多生意」，應景。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3751.jpg\" alt=\"白雲無盡時，綠樹多生意\"></p>\n<p>又上一假山，有各式草類聚集成景，挲了幾下貓毛兒草，酷柔。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3763.jpg\" alt=\"貓毛兒草\"></p>\n<p>見池柏三兩叢，樹幹聳立，樹葉下垂，有柳意。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3766.jpg\" alt=\"池柏\"></p>\n<p>見一窗石林，大驚。大約高不過三十釐米，然用凸起亓樹根或樹幹做石景，頭逝見。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3768.jpg\" alt=\"石林\"></p>\n<p>見一老門，匾寫「清暉園」，聯寫「水色山光皆畫本，花香鳥語總詩情」。</p>\n<p>見一楊桃樹，危大青翠，桃葉難辨，坐伊骹頭，聽鳥音不斷。</p>\n<p><img src=\"/essay/visit-qinghui-garden/IMG_3778.jpg\" alt=\"楊桃樹\"></p>\n<p>移步換景，景緻<u>相sua³相sua³</u><code>(接連不斷)</code>，無感覺時間已過去兩三個鐘頭。</p>\n<p>出園，覓食。因見「𧌇䖢」<code>(粵語: bang¹ saa¹, 甲子話: bang¹ sua¹, 普通話: péng miáo)</code> 二字奇特，行入發現是油炸亓<u>lang⁵ sang¹</u><code>(零食)</code>。又行了幾步，睇著民信老舖，點了一份凍双皮奶佮一份炸牛奶，凍双皮奶熱天時食合好，奶味足、入口即化；炸牛奶怪甜，毋喜歡。</p>\n<p>是爲記。</p>\n<p>二零二一年九月十三日</p>"},{"title":"網絡I/O","p":"it/common/net-io","date":"2021-12-29T08:30:00.000Z","_content":"\n區分幾個概念：\n- 同步（synchronous）和異步（asynchronous）是消息通知的機制，是從消息發送方的角度看；\n- 阻塞（blocking）和非阻塞（non-blocking）是線程等待通知的過程，是從接收方的角度看。\n多路復用是指單一線程監聽多個文件描述符（file descriptor）。\n- 邊緣觸發（edge-trigger）和水平觸發（level-trigger）是當文件描述符關聯的內核緩衝區變化時通知應用程序的兩種方式。邊緣觸發是當狀態變化時通知，水平觸發是只要滿足條件就一直通知。\n  epoll 默認是使用水平觸發，但提供邊緣觸發模式。\n  所謂水平觸發，就是只要達到某個限定的水平就一直通知；而邊緣觸發是處在上升沿或下降沿的時候觸發。\n\n<!--more-->\n","source":"_posts/it/common/net-io.md","raw":"---\ntitle: 網絡I/O\np: it/common/net-io\ndate: 2021-12-29 16:30:00\ntags:\n- net\n---\n\n區分幾個概念：\n- 同步（synchronous）和異步（asynchronous）是消息通知的機制，是從消息發送方的角度看；\n- 阻塞（blocking）和非阻塞（non-blocking）是線程等待通知的過程，是從接收方的角度看。\n多路復用是指單一線程監聽多個文件描述符（file descriptor）。\n- 邊緣觸發（edge-trigger）和水平觸發（level-trigger）是當文件描述符關聯的內核緩衝區變化時通知應用程序的兩種方式。邊緣觸發是當狀態變化時通知，水平觸發是只要滿足條件就一直通知。\n  epoll 默認是使用水平觸發，但提供邊緣觸發模式。\n  所謂水平觸發，就是只要達到某個限定的水平就一直通知；而邊緣觸發是處在上升沿或下降沿的時候觸發。\n\n<!--more-->\n","slug":"it/common/net-io","published":1,"updated":"2022-01-04T14:29:39.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlet000f1n9k0ny19s3z","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>區分幾個概念：</p>\n<ul>\n<li>同步（synchronous）和異步（asynchronous）是消息通知的機制，是從消息發送方的角度看；</li>\n<li>阻塞（blocking）和非阻塞（non-blocking）是線程等待通知的過程，是從接收方的角度看。<br>多路復用是指單一線程監聽多個文件描述符（file descriptor）。</li>\n<li>邊緣觸發（edge-trigger）和水平觸發（level-trigger）是當文件描述符關聯的內核緩衝區變化時通知應用程序的兩種方式。邊緣觸發是當狀態變化時通知，水平觸發是只要滿足條件就一直通知。<br>epoll 默認是使用水平觸發，但提供邊緣觸發模式。<br>所謂水平觸發，就是只要達到某個限定的水平就一直通知；而邊緣觸發是處在上升沿或下降沿的時候觸發。</li>\n</ul>\n<span id=\"more\"></span>\n","site":{"data":{}},"excerpt":"<p>區分幾個概念：</p>\n<ul>\n<li>同步（synchronous）和異步（asynchronous）是消息通知的機制，是從消息發送方的角度看；</li>\n<li>阻塞（blocking）和非阻塞（non-blocking）是線程等待通知的過程，是從接收方的角度看。<br>多路復用是指單一線程監聽多個文件描述符（file descriptor）。</li>\n<li>邊緣觸發（edge-trigger）和水平觸發（level-trigger）是當文件描述符關聯的內核緩衝區變化時通知應用程序的兩種方式。邊緣觸發是當狀態變化時通知，水平觸發是只要滿足條件就一直通知。<br>epoll 默認是使用水平觸發，但提供邊緣觸發模式。<br>所謂水平觸發，就是只要達到某個限定的水平就一直通知；而邊緣觸發是處在上升沿或下降沿的時候觸發。</li>\n</ul>","more":""},{"title":"軟件架構與康德的哲學理論","p":"it/commmon/software-architecture-and-kants-philosophy","date":"2022-07-16T15:45:26.000Z","_content":"\n最近讀了一篇名爲 *Foundations for the Study of Software Architecture* 的論文。它是由 AT&T 公司的 Dewayne E. Perry 和卡羅拉大學的 Alexander L. Wolf 於 1992 聯合署名發表。\n\n這篇論文不得了，光看名字就覺得很重要，這可是研究軟件架構的基石啊。文中提出了一個重要的軟件架構模型，即：\n\n```\nSoftware Architecture = { Elements, Form, Rationale }\n```\n\n翻譯過來就是：\n\n```\n軟件架構 = { 元素, 形式, 理論依據 } \n```\n\nPerry 和 Wolf 如何得出該模型呢？\n\n<!--more-->\n\n## 康德的哲學理論\n\n讓我們先大略了解下康德的哲學理論吧。\n\n康德認爲對象通過我們的感性形成直觀，然後再經由我們的悟性所思維形成概念。感性的對象我們稱之爲現象，非物自身，物自身我們不知道。現象中之質料(Materie)經由感性，形成感覺，是爲經驗直觀；現象中之形式(Form)，是指先天存在我們心中用來整理感覺的東西，即時間和空間關係，是爲純粹直觀。\n\n簡單來說，就是：\n\n```\n物自身 --> 現象 --> 直觀 --> 概念\n```\n\n以杯子為例，我們怎麼得出杯子的概念的呢？首先我們用感性感覺到它的存在，但它自身我們並不知道，我們所知的只是它所展現給我們的現象。從現象之質料上，我們直觀知曉它形狀像個碗，但比較小；有的有把手，有的又沒有；有的表面比較粗糙，但更多的是表面光滑；有的木製的，但更多的是玻璃或陶瓷的。從現象之形式上，我們知道可以從上往下倒入液體到它中，隨著時間的流逝，它會盛滿至溢出。按照康德的邏輯，我們思維這些直觀，然後形成了杯子的概念。牛津詞典上如是解釋：\n\n```\nCup\n\n[C] a small container shaped like a bowl, usually with a handle, used for drinking tea, coffee, etc.\n```\n\n翻譯過來就是：\n\n```\n杯子\n\n【可數名詞】一種小的容器，狀似碗，通常有個把手，用來喝茶或咖啡等等。\n```\n\n同樣地，我們要形成軟件架構的概念，必須先建構軟件架構的直觀。\n\n## 軟件架構的直觀\n\nPerry 和 Wolf 審視了當前的軟件架構，並與已有的建築架構学科進行類比，建構了軟件架構的直觀（intuition）：\n\n1. 軟件架構是多視圖的（multiple views）。架構應該是多個面向的，正如建築架構會提供立面圖和平面圖一樣。\n2. 軟件架構是有不同架構風格的（architecture styles）。正如建築架構有哥特式、羅馬式等不同的風格，軟件架構也有不同風格，並且架構風格約束著架構元素以及它們之間的關係。\n3. 架構（風格）是跟工程原理（engineering principle）密切相关的。不同的架構風格需要不同的工程原理。\n4. 架构風格是跟質料（materials）密切相關的。正如摩天大樓不能用木頭構建。\n\n再者，從軟件製品的整個生產流程看，架構處在 `需求-架構-設計-實現` 流程中的一環，溝通著問題域（需求）和解域（實現）。\n\n* 需求：決定著系統中的用戶需要的信息和處理過程。\n* 架構：關心元素、交互和約束。\n* 設計：關心模塊化、詳細接口、算法和數據類型。\n* 實現：關心算法和數據結構的最終表示。\n\n可見，架構的上下文（context）即是需求、設計和實現。\n\n還有，架構會隨著新需求（通常是定制化的需求）不斷演進，稍有不慎可能導致架構腐化（architectural erosion）或架構偏移（architectural drift）。架構腐化是架構不斷被違反導致的，架構的違反增加了系統的脆性，從而導致災難；而架構偏移是由於對架構的頓感，這種頓感導致架構變得模糊不清，很容易演變成架構違反以至腐化。\n\n爲避免演進過程架構的腐化和偏移，我們期望有這樣的架構規範：\n\n1. 以最少約束原則規定需要的約束級別。\n2. 區分主幹和裝飾。\n3. 使用恰當的方式展現架構的不同視圖。\n4. 進行依賴和一致性分析。\n\n## 架構模型\n\n從上述的直觀中，Perry 和 Wolf 得出以下的架構模型：\n\n```\n軟件架構 = { 元素, 形式, 理論依據 } \n```\n\n該模型認爲軟件架構是由一組具有特定形式的架構元素構成。\n\n* 架構元素（elements），包含處理元素、數據元素和連接元素。處理元素是主動的，負責處理數據；數據元素是被動的，被處理元素處理；連接元素是在處理元素之間運載數據元素的機制，它限制著數據元素。例如：在「人在水池中打水球」場景中，人是處理元素，水池則連接元素，水球則是數據元素。換到「人在足球場上踢足球」的場景中，人依然是處理元素，而連接元素變為足球場，數據元素變為足球。顯然，我們無法在足球場中打水球，因此當連接元素變化時，數據元素也跟著變化了，即連接元素限制著數據元素。\n* 形式（form），指架構元素之間的關係，主次、先後等等。\n* 理論依據（rationale），指架構風格、元素和形式的選擇動機，以及其滿足功能性或非功能性的約束（或需求）的依據。\n\n在得出軟件架構的概念後，我們仍然不滿足，因爲架構基本都是定製化的，實在太多了。\n\n### 架構風格\n\n於是，我們基於眾多特定架構，抽象出了架構風格的概念。這個抽象過程其實就是減少約束和減少完成度的過程。\n\n我們知道架構是一系列決策（決定使用哪些架構元素以及何種形式）的集合，因此也可以說架構風格是一系列重要決策的集合，包含關鍵的架構元素和形式。\n\n常見的架構風格有：\n\n* 獨立構件（Independent Components）\n* 虛擬機（Virtual Machines）\n* 數據流（Data Flow）\n* 數據中心（Data-Centered）\n* 調用返回（Call-and-return）\n* MVC（Model-View-Controller）\n* 代理架構風格（Broker Architecture Style）\n* 面向服務架構（Service Oriented Architecture (SOA)）\n* 點對點架構（Peer-to-Peer Architecture）\n\n需要注意的是：架構與架構風格之間沒有明顯的分界線，一個架構可以成為另一個架構的架構風格。\n\n### 3 視圖\n\n架構模型的三種元素相互依賴，分別從三種元素的視角觀察，可以得出三種視圖，即：\n\n1. 處理視圖：從處理元素的視角看到的是系統的數據流（data flow）以及處理元素之間的連接。\n2. 數據視圖：從數據元素的視角看到的是系統的處理流（processing flow）。\n3. 連接視圖：從連接元素的視角看到的是處理元素之間的互動，一個處理元素的輸出是另一個處理元素的輸入，輸入輸出的數據元素在連接協議中定義。\n\nPerry 和 Wolf 說是有 3 種視圖，但是只給了 2 種，可能是連接視圖沒有畫的必要性。\n\n處理視圖展現了數據流，數據視圖展現了處理流，有趣。處理視圖強調了處理元素的主觀能動性，數據在其中被處理和流轉；而數據視圖強調了數據本身的變化，處理過程是數據產生變化的原因。\n\n![處理視圖](software-architecture-and-kants-philosophy/3-views-processing.png)\n\n![數據視圖](software-architecture-and-kants-philosophy/3-views-data.png)\n\n\n## 其他重要的視圖\n\n### 4+1 視圖\n\n三視圖是從架構元素的視角觀察得出的，我們能否從用戶角度觀察呢？\n\nRational 軟件公司的 Philippe Kruchten 就是這樣思考的，他於 1995 在 IEEE Software 上發表了題為 *Architectual Blueprints--The \"4+1\" View Model of Software Architecture* 的論文探討了 4+1 視圖。 \n\n4+1 視圖是從用戶視角觀察的，不同用戶的視角得出不同的視圖，4+1 時圖共整理了 5 種視圖，即：\n\n1. 邏輯視圖，從終端用戶的視角，關注的是功能。\n2. 處理視圖，從集成方的視角，關注的是性能和伸縮性。\n3. 開發視圖，從開發者的視角，關注的是軟件管理。\n4. 物理視圖，從系統工程師/運維人員的視角，關注的是拓撲、通信。\n5. 場景視圖，場景串聯以上 4 種視圖，講述某個場景如何被實現。\n\n![4+1視圖](software-architecture-and-kants-philosophy/4+1-views.png)\n\n### 5 視圖\n\nCSAI 的架構師們於2009年11月在第六屆中國軟件大會上提出了一種軟件架構設計方法 ADMEMS（Architecture Design Method has been Extended to Method System）。\n\n該方法上承需求、下接實現，包括 3 個階段和 1 個貫穿環節，即：\n\n1. 預備架構階段（PA, Pre-Architecture）：關注充分理解需求，把握需求特點。\n2. 概念架構階段（CA, Conceptual Architecture）：關注功能、質量、約束等等。\n3. 細化架構階段（RA, Refined Architecture）：使用 5 視圖。\n4. 貫穿環節：對非功能性目標的考量。\n\n所謂的 5 視圖包括：\n\n1. 邏輯視圖：面向對象或結構化，關注職責劃分和職責間協作。\n2. 運行視圖：面向控制流，關注控制流及其組織。\n3. 物理視圖：面向節點，關注物理節點及其拓撲。\n4. 數據視圖：面向Table或文件，關注持久化數據單元和數據存儲格式。\n5. 開發視圖：面向文件，關注程序單元及其組織。\n\n![5視圖](software-architecture-and-kants-philosophy/5-views.png)\n\n### C4 模型\n\n架構師 Simon Brown 在 2006 年到 2011 年間基於 UML 和 4+1 視圖構建了 C4 模型（C4 model），並隨後創辦了 c4model.com 宣傳該模型。2018 年，他在 InfoQ 上發表了題爲 *The C4 Model for Software Architecture* 的文章，受到廣泛關注。\n\nC4 是四個首字母爲 C 的單詞的統稱，即：上下文（Context）、容器（Container）、組件（Component）和代碼（Code）。\n\n![C4 模型](software-architecture-and-kants-philosophy/c4-model.jpg)\n\nC4 模型體現了一種頂層設計、逐步細化的思維方式。它就像使用地圖軟件一般，逐步放大，獲取所關注級別的信息。首先從系統的上下文開始，梳理此系統與別的系統之間的關係；然後再深入到系統內部，看內部各個容器（包括應用程序、微服務或數據存儲等等）之間的交互；然後繼續深入到某個容器內部，看容器中各個組件（或功能模塊）之間如何交互；最後如果有必要還可以深入到代碼級別，看看內部各個類之間如何交互。\n\n綜合上面提到的眾多視圖，顯見架構視圖是上承需求、下接實現的；架構視圖是頂層設計、逐步細化的；架構視圖可以從架構元素的角度觀察，也可以從用戶角度觀察。每種視圖模型都各自的優點，可以視團隊規模、面向的用戶以及系統的複雜度選擇。\n\n## 參考\n\n1. [Dewayne E. Perry & Alexander L. Wolf, *Foundations for the Study of Software Architecture*](https://www.ics.uci.edu/~andre/ics223w2006/perrywolf.pdf)\n2. [Philippe Kruchten, *Architectural Blueprints—The “4+1” View Model of Software Architecture*](https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf)\n3. 溫昱著《軟件架構設計(第2版)》, p176\n4. [Simon Brown 著, 无明譯 《用于软件架构的 C4 模型》](https://www.infoq.cn/article/c4-architecture-model)\n5. [Simon Brown, *The C4 Model for Software Architecture*](https://www.infoq.com/articles/C4-architecture-model/)\n","source":"_posts/it/common/software-architecture-and-kants-philosophy.md","raw":"---\ntitle: 軟件架構與康德的哲學理論\np: it/commmon/software-architecture-and-kants-philosophy\ntags:\n  - 軟件架構\n  - 哲學\ndate: 2022-07-16 23:45:26\n---\n\n最近讀了一篇名爲 *Foundations for the Study of Software Architecture* 的論文。它是由 AT&T 公司的 Dewayne E. Perry 和卡羅拉大學的 Alexander L. Wolf 於 1992 聯合署名發表。\n\n這篇論文不得了，光看名字就覺得很重要，這可是研究軟件架構的基石啊。文中提出了一個重要的軟件架構模型，即：\n\n```\nSoftware Architecture = { Elements, Form, Rationale }\n```\n\n翻譯過來就是：\n\n```\n軟件架構 = { 元素, 形式, 理論依據 } \n```\n\nPerry 和 Wolf 如何得出該模型呢？\n\n<!--more-->\n\n## 康德的哲學理論\n\n讓我們先大略了解下康德的哲學理論吧。\n\n康德認爲對象通過我們的感性形成直觀，然後再經由我們的悟性所思維形成概念。感性的對象我們稱之爲現象，非物自身，物自身我們不知道。現象中之質料(Materie)經由感性，形成感覺，是爲經驗直觀；現象中之形式(Form)，是指先天存在我們心中用來整理感覺的東西，即時間和空間關係，是爲純粹直觀。\n\n簡單來說，就是：\n\n```\n物自身 --> 現象 --> 直觀 --> 概念\n```\n\n以杯子為例，我們怎麼得出杯子的概念的呢？首先我們用感性感覺到它的存在，但它自身我們並不知道，我們所知的只是它所展現給我們的現象。從現象之質料上，我們直觀知曉它形狀像個碗，但比較小；有的有把手，有的又沒有；有的表面比較粗糙，但更多的是表面光滑；有的木製的，但更多的是玻璃或陶瓷的。從現象之形式上，我們知道可以從上往下倒入液體到它中，隨著時間的流逝，它會盛滿至溢出。按照康德的邏輯，我們思維這些直觀，然後形成了杯子的概念。牛津詞典上如是解釋：\n\n```\nCup\n\n[C] a small container shaped like a bowl, usually with a handle, used for drinking tea, coffee, etc.\n```\n\n翻譯過來就是：\n\n```\n杯子\n\n【可數名詞】一種小的容器，狀似碗，通常有個把手，用來喝茶或咖啡等等。\n```\n\n同樣地，我們要形成軟件架構的概念，必須先建構軟件架構的直觀。\n\n## 軟件架構的直觀\n\nPerry 和 Wolf 審視了當前的軟件架構，並與已有的建築架構学科進行類比，建構了軟件架構的直觀（intuition）：\n\n1. 軟件架構是多視圖的（multiple views）。架構應該是多個面向的，正如建築架構會提供立面圖和平面圖一樣。\n2. 軟件架構是有不同架構風格的（architecture styles）。正如建築架構有哥特式、羅馬式等不同的風格，軟件架構也有不同風格，並且架構風格約束著架構元素以及它們之間的關係。\n3. 架構（風格）是跟工程原理（engineering principle）密切相关的。不同的架構風格需要不同的工程原理。\n4. 架构風格是跟質料（materials）密切相關的。正如摩天大樓不能用木頭構建。\n\n再者，從軟件製品的整個生產流程看，架構處在 `需求-架構-設計-實現` 流程中的一環，溝通著問題域（需求）和解域（實現）。\n\n* 需求：決定著系統中的用戶需要的信息和處理過程。\n* 架構：關心元素、交互和約束。\n* 設計：關心模塊化、詳細接口、算法和數據類型。\n* 實現：關心算法和數據結構的最終表示。\n\n可見，架構的上下文（context）即是需求、設計和實現。\n\n還有，架構會隨著新需求（通常是定制化的需求）不斷演進，稍有不慎可能導致架構腐化（architectural erosion）或架構偏移（architectural drift）。架構腐化是架構不斷被違反導致的，架構的違反增加了系統的脆性，從而導致災難；而架構偏移是由於對架構的頓感，這種頓感導致架構變得模糊不清，很容易演變成架構違反以至腐化。\n\n爲避免演進過程架構的腐化和偏移，我們期望有這樣的架構規範：\n\n1. 以最少約束原則規定需要的約束級別。\n2. 區分主幹和裝飾。\n3. 使用恰當的方式展現架構的不同視圖。\n4. 進行依賴和一致性分析。\n\n## 架構模型\n\n從上述的直觀中，Perry 和 Wolf 得出以下的架構模型：\n\n```\n軟件架構 = { 元素, 形式, 理論依據 } \n```\n\n該模型認爲軟件架構是由一組具有特定形式的架構元素構成。\n\n* 架構元素（elements），包含處理元素、數據元素和連接元素。處理元素是主動的，負責處理數據；數據元素是被動的，被處理元素處理；連接元素是在處理元素之間運載數據元素的機制，它限制著數據元素。例如：在「人在水池中打水球」場景中，人是處理元素，水池則連接元素，水球則是數據元素。換到「人在足球場上踢足球」的場景中，人依然是處理元素，而連接元素變為足球場，數據元素變為足球。顯然，我們無法在足球場中打水球，因此當連接元素變化時，數據元素也跟著變化了，即連接元素限制著數據元素。\n* 形式（form），指架構元素之間的關係，主次、先後等等。\n* 理論依據（rationale），指架構風格、元素和形式的選擇動機，以及其滿足功能性或非功能性的約束（或需求）的依據。\n\n在得出軟件架構的概念後，我們仍然不滿足，因爲架構基本都是定製化的，實在太多了。\n\n### 架構風格\n\n於是，我們基於眾多特定架構，抽象出了架構風格的概念。這個抽象過程其實就是減少約束和減少完成度的過程。\n\n我們知道架構是一系列決策（決定使用哪些架構元素以及何種形式）的集合，因此也可以說架構風格是一系列重要決策的集合，包含關鍵的架構元素和形式。\n\n常見的架構風格有：\n\n* 獨立構件（Independent Components）\n* 虛擬機（Virtual Machines）\n* 數據流（Data Flow）\n* 數據中心（Data-Centered）\n* 調用返回（Call-and-return）\n* MVC（Model-View-Controller）\n* 代理架構風格（Broker Architecture Style）\n* 面向服務架構（Service Oriented Architecture (SOA)）\n* 點對點架構（Peer-to-Peer Architecture）\n\n需要注意的是：架構與架構風格之間沒有明顯的分界線，一個架構可以成為另一個架構的架構風格。\n\n### 3 視圖\n\n架構模型的三種元素相互依賴，分別從三種元素的視角觀察，可以得出三種視圖，即：\n\n1. 處理視圖：從處理元素的視角看到的是系統的數據流（data flow）以及處理元素之間的連接。\n2. 數據視圖：從數據元素的視角看到的是系統的處理流（processing flow）。\n3. 連接視圖：從連接元素的視角看到的是處理元素之間的互動，一個處理元素的輸出是另一個處理元素的輸入，輸入輸出的數據元素在連接協議中定義。\n\nPerry 和 Wolf 說是有 3 種視圖，但是只給了 2 種，可能是連接視圖沒有畫的必要性。\n\n處理視圖展現了數據流，數據視圖展現了處理流，有趣。處理視圖強調了處理元素的主觀能動性，數據在其中被處理和流轉；而數據視圖強調了數據本身的變化，處理過程是數據產生變化的原因。\n\n![處理視圖](software-architecture-and-kants-philosophy/3-views-processing.png)\n\n![數據視圖](software-architecture-and-kants-philosophy/3-views-data.png)\n\n\n## 其他重要的視圖\n\n### 4+1 視圖\n\n三視圖是從架構元素的視角觀察得出的，我們能否從用戶角度觀察呢？\n\nRational 軟件公司的 Philippe Kruchten 就是這樣思考的，他於 1995 在 IEEE Software 上發表了題為 *Architectual Blueprints--The \"4+1\" View Model of Software Architecture* 的論文探討了 4+1 視圖。 \n\n4+1 視圖是從用戶視角觀察的，不同用戶的視角得出不同的視圖，4+1 時圖共整理了 5 種視圖，即：\n\n1. 邏輯視圖，從終端用戶的視角，關注的是功能。\n2. 處理視圖，從集成方的視角，關注的是性能和伸縮性。\n3. 開發視圖，從開發者的視角，關注的是軟件管理。\n4. 物理視圖，從系統工程師/運維人員的視角，關注的是拓撲、通信。\n5. 場景視圖，場景串聯以上 4 種視圖，講述某個場景如何被實現。\n\n![4+1視圖](software-architecture-and-kants-philosophy/4+1-views.png)\n\n### 5 視圖\n\nCSAI 的架構師們於2009年11月在第六屆中國軟件大會上提出了一種軟件架構設計方法 ADMEMS（Architecture Design Method has been Extended to Method System）。\n\n該方法上承需求、下接實現，包括 3 個階段和 1 個貫穿環節，即：\n\n1. 預備架構階段（PA, Pre-Architecture）：關注充分理解需求，把握需求特點。\n2. 概念架構階段（CA, Conceptual Architecture）：關注功能、質量、約束等等。\n3. 細化架構階段（RA, Refined Architecture）：使用 5 視圖。\n4. 貫穿環節：對非功能性目標的考量。\n\n所謂的 5 視圖包括：\n\n1. 邏輯視圖：面向對象或結構化，關注職責劃分和職責間協作。\n2. 運行視圖：面向控制流，關注控制流及其組織。\n3. 物理視圖：面向節點，關注物理節點及其拓撲。\n4. 數據視圖：面向Table或文件，關注持久化數據單元和數據存儲格式。\n5. 開發視圖：面向文件，關注程序單元及其組織。\n\n![5視圖](software-architecture-and-kants-philosophy/5-views.png)\n\n### C4 模型\n\n架構師 Simon Brown 在 2006 年到 2011 年間基於 UML 和 4+1 視圖構建了 C4 模型（C4 model），並隨後創辦了 c4model.com 宣傳該模型。2018 年，他在 InfoQ 上發表了題爲 *The C4 Model for Software Architecture* 的文章，受到廣泛關注。\n\nC4 是四個首字母爲 C 的單詞的統稱，即：上下文（Context）、容器（Container）、組件（Component）和代碼（Code）。\n\n![C4 模型](software-architecture-and-kants-philosophy/c4-model.jpg)\n\nC4 模型體現了一種頂層設計、逐步細化的思維方式。它就像使用地圖軟件一般，逐步放大，獲取所關注級別的信息。首先從系統的上下文開始，梳理此系統與別的系統之間的關係；然後再深入到系統內部，看內部各個容器（包括應用程序、微服務或數據存儲等等）之間的交互；然後繼續深入到某個容器內部，看容器中各個組件（或功能模塊）之間如何交互；最後如果有必要還可以深入到代碼級別，看看內部各個類之間如何交互。\n\n綜合上面提到的眾多視圖，顯見架構視圖是上承需求、下接實現的；架構視圖是頂層設計、逐步細化的；架構視圖可以從架構元素的角度觀察，也可以從用戶角度觀察。每種視圖模型都各自的優點，可以視團隊規模、面向的用戶以及系統的複雜度選擇。\n\n## 參考\n\n1. [Dewayne E. Perry & Alexander L. Wolf, *Foundations for the Study of Software Architecture*](https://www.ics.uci.edu/~andre/ics223w2006/perrywolf.pdf)\n2. [Philippe Kruchten, *Architectural Blueprints—The “4+1” View Model of Software Architecture*](https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf)\n3. 溫昱著《軟件架構設計(第2版)》, p176\n4. [Simon Brown 著, 无明譯 《用于软件架构的 C4 模型》](https://www.infoq.cn/article/c4-architecture-model)\n5. [Simon Brown, *The C4 Model for Software Architecture*](https://www.infoq.com/articles/C4-architecture-model/)\n","slug":"it/common/software-architecture-and-kants-philosophy","published":1,"updated":"2022-07-19T14:27:06.213Z","_id":"cl5qxxleu000h1n9keyz3f3ar","comments":1,"layout":"post","photos":[],"link":"","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>最近讀了一篇名爲 <em>Foundations for the Study of Software Architecture</em> 的論文。它是由 AT&amp;T 公司的 Dewayne E. Perry 和卡羅拉大學的 Alexander L. Wolf 於 1992 聯合署名發表。</p>\n<p>這篇論文不得了，光看名字就覺得很重要，這可是研究軟件架構的基石啊。文中提出了一個重要的軟件架構模型，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Software Architecture = &#123; Elements, Form, Rationale &#125;</span><br></pre></td></tr></table></figure>\n\n<p>翻譯過來就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">軟件架構 = &#123; 元素, 形式, 理論依據 &#125; </span><br></pre></td></tr></table></figure>\n\n<p>Perry 和 Wolf 如何得出該模型呢？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"康德的哲學理論\"><a href=\"#康德的哲學理論\" class=\"headerlink\" title=\"康德的哲學理論\"></a>康德的哲學理論</h2><p>讓我們先大略了解下康德的哲學理論吧。</p>\n<p>康德認爲對象通過我們的感性形成直觀，然後再經由我們的悟性所思維形成概念。感性的對象我們稱之爲現象，非物自身，物自身我們不知道。現象中之質料(Materie)經由感性，形成感覺，是爲經驗直觀；現象中之形式(Form)，是指先天存在我們心中用來整理感覺的東西，即時間和空間關係，是爲純粹直觀。</p>\n<p>簡單來說，就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">物自身 --&gt; 現象 --&gt; 直觀 --&gt; 概念</span><br></pre></td></tr></table></figure>\n\n<p>以杯子為例，我們怎麼得出杯子的概念的呢？首先我們用感性感覺到它的存在，但它自身我們並不知道，我們所知的只是它所展現給我們的現象。從現象之質料上，我們直觀知曉它形狀像個碗，但比較小；有的有把手，有的又沒有；有的表面比較粗糙，但更多的是表面光滑；有的木製的，但更多的是玻璃或陶瓷的。從現象之形式上，我們知道可以從上往下倒入液體到它中，隨著時間的流逝，它會盛滿至溢出。按照康德的邏輯，我們思維這些直觀，然後形成了杯子的概念。牛津詞典上如是解釋：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Cup</span><br><span class=\"line\"></span><br><span class=\"line\">[C] a small container shaped like a bowl, usually with a handle, used for drinking tea, coffee, etc.</span><br></pre></td></tr></table></figure>\n\n<p>翻譯過來就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">杯子</span><br><span class=\"line\"></span><br><span class=\"line\">【可數名詞】一種小的容器，狀似碗，通常有個把手，用來喝茶或咖啡等等。</span><br></pre></td></tr></table></figure>\n\n<p>同樣地，我們要形成軟件架構的概念，必須先建構軟件架構的直觀。</p>\n<h2 id=\"軟件架構的直觀\"><a href=\"#軟件架構的直觀\" class=\"headerlink\" title=\"軟件架構的直觀\"></a>軟件架構的直觀</h2><p>Perry 和 Wolf 審視了當前的軟件架構，並與已有的建築架構学科進行類比，建構了軟件架構的直觀（intuition）：</p>\n<ol>\n<li>軟件架構是多視圖的（multiple views）。架構應該是多個面向的，正如建築架構會提供立面圖和平面圖一樣。</li>\n<li>軟件架構是有不同架構風格的（architecture styles）。正如建築架構有哥特式、羅馬式等不同的風格，軟件架構也有不同風格，並且架構風格約束著架構元素以及它們之間的關係。</li>\n<li>架構（風格）是跟工程原理（engineering principle）密切相关的。不同的架構風格需要不同的工程原理。</li>\n<li>架构風格是跟質料（materials）密切相關的。正如摩天大樓不能用木頭構建。</li>\n</ol>\n<p>再者，從軟件製品的整個生產流程看，架構處在 <code>需求-架構-設計-實現</code> 流程中的一環，溝通著問題域（需求）和解域（實現）。</p>\n<ul>\n<li>需求：決定著系統中的用戶需要的信息和處理過程。</li>\n<li>架構：關心元素、交互和約束。</li>\n<li>設計：關心模塊化、詳細接口、算法和數據類型。</li>\n<li>實現：關心算法和數據結構的最終表示。</li>\n</ul>\n<p>可見，架構的上下文（context）即是需求、設計和實現。</p>\n<p>還有，架構會隨著新需求（通常是定制化的需求）不斷演進，稍有不慎可能導致架構腐化（architectural erosion）或架構偏移（architectural drift）。架構腐化是架構不斷被違反導致的，架構的違反增加了系統的脆性，從而導致災難；而架構偏移是由於對架構的頓感，這種頓感導致架構變得模糊不清，很容易演變成架構違反以至腐化。</p>\n<p>爲避免演進過程架構的腐化和偏移，我們期望有這樣的架構規範：</p>\n<ol>\n<li>以最少約束原則規定需要的約束級別。</li>\n<li>區分主幹和裝飾。</li>\n<li>使用恰當的方式展現架構的不同視圖。</li>\n<li>進行依賴和一致性分析。</li>\n</ol>\n<h2 id=\"架構模型\"><a href=\"#架構模型\" class=\"headerlink\" title=\"架構模型\"></a>架構模型</h2><p>從上述的直觀中，Perry 和 Wolf 得出以下的架構模型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">軟件架構 = &#123; 元素, 形式, 理論依據 &#125; </span><br></pre></td></tr></table></figure>\n\n<p>該模型認爲軟件架構是由一組具有特定形式的架構元素構成。</p>\n<ul>\n<li>架構元素（elements），包含處理元素、數據元素和連接元素。處理元素是主動的，負責處理數據；數據元素是被動的，被處理元素處理；連接元素是在處理元素之間運載數據元素的機制，它限制著數據元素。例如：在「人在水池中打水球」場景中，人是處理元素，水池則連接元素，水球則是數據元素。換到「人在足球場上踢足球」的場景中，人依然是處理元素，而連接元素變為足球場，數據元素變為足球。顯然，我們無法在足球場中打水球，因此當連接元素變化時，數據元素也跟著變化了，即連接元素限制著數據元素。</li>\n<li>形式（form），指架構元素之間的關係，主次、先後等等。</li>\n<li>理論依據（rationale），指架構風格、元素和形式的選擇動機，以及其滿足功能性或非功能性的約束（或需求）的依據。</li>\n</ul>\n<p>在得出軟件架構的概念後，我們仍然不滿足，因爲架構基本都是定製化的，實在太多了。</p>\n<h3 id=\"架構風格\"><a href=\"#架構風格\" class=\"headerlink\" title=\"架構風格\"></a>架構風格</h3><p>於是，我們基於眾多特定架構，抽象出了架構風格的概念。這個抽象過程其實就是減少約束和減少完成度的過程。</p>\n<p>我們知道架構是一系列決策（決定使用哪些架構元素以及何種形式）的集合，因此也可以說架構風格是一系列重要決策的集合，包含關鍵的架構元素和形式。</p>\n<p>常見的架構風格有：</p>\n<ul>\n<li>獨立構件（Independent Components）</li>\n<li>虛擬機（Virtual Machines）</li>\n<li>數據流（Data Flow）</li>\n<li>數據中心（Data-Centered）</li>\n<li>調用返回（Call-and-return）</li>\n<li>MVC（Model-View-Controller）</li>\n<li>代理架構風格（Broker Architecture Style）</li>\n<li>面向服務架構（Service Oriented Architecture (SOA)）</li>\n<li>點對點架構（Peer-to-Peer Architecture）</li>\n</ul>\n<p>需要注意的是：架構與架構風格之間沒有明顯的分界線，一個架構可以成為另一個架構的架構風格。</p>\n<h3 id=\"3-視圖\"><a href=\"#3-視圖\" class=\"headerlink\" title=\"3 視圖\"></a>3 視圖</h3><p>架構模型的三種元素相互依賴，分別從三種元素的視角觀察，可以得出三種視圖，即：</p>\n<ol>\n<li>處理視圖：從處理元素的視角看到的是系統的數據流（data flow）以及處理元素之間的連接。</li>\n<li>數據視圖：從數據元素的視角看到的是系統的處理流（processing flow）。</li>\n<li>連接視圖：從連接元素的視角看到的是處理元素之間的互動，一個處理元素的輸出是另一個處理元素的輸入，輸入輸出的數據元素在連接協議中定義。</li>\n</ol>\n<p>Perry 和 Wolf 說是有 3 種視圖，但是只給了 2 種，可能是連接視圖沒有畫的必要性。</p>\n<p>處理視圖展現了數據流，數據視圖展現了處理流，有趣。處理視圖強調了處理元素的主觀能動性，數據在其中被處理和流轉；而數據視圖強調了數據本身的變化，處理過程是數據產生變化的原因。</p>\n<p><img src=\"/it/common/software-architecture-and-kants-philosophy/3-views-processing.png\" alt=\"處理視圖\"></p>\n<p><img src=\"/it/common/software-architecture-and-kants-philosophy/3-views-data.png\" alt=\"數據視圖\"></p>\n<h2 id=\"其他重要的視圖\"><a href=\"#其他重要的視圖\" class=\"headerlink\" title=\"其他重要的視圖\"></a>其他重要的視圖</h2><h3 id=\"4-1-視圖\"><a href=\"#4-1-視圖\" class=\"headerlink\" title=\"4+1 視圖\"></a>4+1 視圖</h3><p>三視圖是從架構元素的視角觀察得出的，我們能否從用戶角度觀察呢？</p>\n<p>Rational 軟件公司的 Philippe Kruchten 就是這樣思考的，他於 1995 在 IEEE Software 上發表了題為 <em>Architectual Blueprints–The “4+1” View Model of Software Architecture</em> 的論文探討了 4+1 視圖。 </p>\n<p>4+1 視圖是從用戶視角觀察的，不同用戶的視角得出不同的視圖，4+1 時圖共整理了 5 種視圖，即：</p>\n<ol>\n<li>邏輯視圖，從終端用戶的視角，關注的是功能。</li>\n<li>處理視圖，從集成方的視角，關注的是性能和伸縮性。</li>\n<li>開發視圖，從開發者的視角，關注的是軟件管理。</li>\n<li>物理視圖，從系統工程師/運維人員的視角，關注的是拓撲、通信。</li>\n<li>場景視圖，場景串聯以上 4 種視圖，講述某個場景如何被實現。</li>\n</ol>\n<p><img src=\"/it/common/software-architecture-and-kants-philosophy/4+1-views.png\" alt=\"4+1視圖\"></p>\n<h3 id=\"5-視圖\"><a href=\"#5-視圖\" class=\"headerlink\" title=\"5 視圖\"></a>5 視圖</h3><p>CSAI 的架構師們於2009年11月在第六屆中國軟件大會上提出了一種軟件架構設計方法 ADMEMS（Architecture Design Method has been Extended to Method System）。</p>\n<p>該方法上承需求、下接實現，包括 3 個階段和 1 個貫穿環節，即：</p>\n<ol>\n<li>預備架構階段（PA, Pre-Architecture）：關注充分理解需求，把握需求特點。</li>\n<li>概念架構階段（CA, Conceptual Architecture）：關注功能、質量、約束等等。</li>\n<li>細化架構階段（RA, Refined Architecture）：使用 5 視圖。</li>\n<li>貫穿環節：對非功能性目標的考量。</li>\n</ol>\n<p>所謂的 5 視圖包括：</p>\n<ol>\n<li>邏輯視圖：面向對象或結構化，關注職責劃分和職責間協作。</li>\n<li>運行視圖：面向控制流，關注控制流及其組織。</li>\n<li>物理視圖：面向節點，關注物理節點及其拓撲。</li>\n<li>數據視圖：面向Table或文件，關注持久化數據單元和數據存儲格式。</li>\n<li>開發視圖：面向文件，關注程序單元及其組織。</li>\n</ol>\n<p><img src=\"/it/common/software-architecture-and-kants-philosophy/5-views.png\" alt=\"5視圖\"></p>\n<h3 id=\"C4-模型\"><a href=\"#C4-模型\" class=\"headerlink\" title=\"C4 模型\"></a>C4 模型</h3><p>架構師 Simon Brown 在 2006 年到 2011 年間基於 UML 和 4+1 視圖構建了 C4 模型（C4 model），並隨後創辦了 c4model.com 宣傳該模型。2018 年，他在 InfoQ 上發表了題爲 <em>The C4 Model for Software Architecture</em> 的文章，受到廣泛關注。</p>\n<p>C4 是四個首字母爲 C 的單詞的統稱，即：上下文（Context）、容器（Container）、組件（Component）和代碼（Code）。</p>\n<p><img src=\"/it/common/software-architecture-and-kants-philosophy/c4-model.jpg\" alt=\"C4 模型\"></p>\n<p>C4 模型體現了一種頂層設計、逐步細化的思維方式。它就像使用地圖軟件一般，逐步放大，獲取所關注級別的信息。首先從系統的上下文開始，梳理此系統與別的系統之間的關係；然後再深入到系統內部，看內部各個容器（包括應用程序、微服務或數據存儲等等）之間的交互；然後繼續深入到某個容器內部，看容器中各個組件（或功能模塊）之間如何交互；最後如果有必要還可以深入到代碼級別，看看內部各個類之間如何交互。</p>\n<p>綜合上面提到的眾多視圖，顯見架構視圖是上承需求、下接實現的；架構視圖是頂層設計、逐步細化的；架構視圖可以從架構元素的角度觀察，也可以從用戶角度觀察。每種視圖模型都各自的優點，可以視團隊規模、面向的用戶以及系統的複雜度選擇。</p>\n<h2 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考\"></a>參考</h2><ol>\n<li><a href=\"https://www.ics.uci.edu/~andre/ics223w2006/perrywolf.pdf\">Dewayne E. Perry &amp; Alexander L. Wolf, <em>Foundations for the Study of Software Architecture</em></a></li>\n<li><a href=\"https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf\">Philippe Kruchten, <em>Architectural Blueprints—The “4+1” View Model of Software Architecture</em></a></li>\n<li>溫昱著《軟件架構設計(第2版)》, p176</li>\n<li><a href=\"https://www.infoq.cn/article/c4-architecture-model\">Simon Brown 著, 无明譯 《用于软件架构的 C4 模型》</a></li>\n<li><a href=\"https://www.infoq.com/articles/C4-architecture-model/\">Simon Brown, <em>The C4 Model for Software Architecture</em></a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>最近讀了一篇名爲 <em>Foundations for the Study of Software Architecture</em> 的論文。它是由 AT&amp;T 公司的 Dewayne E. Perry 和卡羅拉大學的 Alexander L. Wolf 於 1992 聯合署名發表。</p>\n<p>這篇論文不得了，光看名字就覺得很重要，這可是研究軟件架構的基石啊。文中提出了一個重要的軟件架構模型，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Software Architecture = &#123; Elements, Form, Rationale &#125;</span><br></pre></td></tr></table></figure>\n\n<p>翻譯過來就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">軟件架構 = &#123; 元素, 形式, 理論依據 &#125; </span><br></pre></td></tr></table></figure>\n\n<p>Perry 和 Wolf 如何得出該模型呢？</p>","more":"<h2 id=\"康德的哲學理論\"><a href=\"#康德的哲學理論\" class=\"headerlink\" title=\"康德的哲學理論\"></a>康德的哲學理論</h2><p>讓我們先大略了解下康德的哲學理論吧。</p>\n<p>康德認爲對象通過我們的感性形成直觀，然後再經由我們的悟性所思維形成概念。感性的對象我們稱之爲現象，非物自身，物自身我們不知道。現象中之質料(Materie)經由感性，形成感覺，是爲經驗直觀；現象中之形式(Form)，是指先天存在我們心中用來整理感覺的東西，即時間和空間關係，是爲純粹直觀。</p>\n<p>簡單來說，就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">物自身 --&gt; 現象 --&gt; 直觀 --&gt; 概念</span><br></pre></td></tr></table></figure>\n\n<p>以杯子為例，我們怎麼得出杯子的概念的呢？首先我們用感性感覺到它的存在，但它自身我們並不知道，我們所知的只是它所展現給我們的現象。從現象之質料上，我們直觀知曉它形狀像個碗，但比較小；有的有把手，有的又沒有；有的表面比較粗糙，但更多的是表面光滑；有的木製的，但更多的是玻璃或陶瓷的。從現象之形式上，我們知道可以從上往下倒入液體到它中，隨著時間的流逝，它會盛滿至溢出。按照康德的邏輯，我們思維這些直觀，然後形成了杯子的概念。牛津詞典上如是解釋：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Cup</span><br><span class=\"line\"></span><br><span class=\"line\">[C] a small container shaped like a bowl, usually with a handle, used for drinking tea, coffee, etc.</span><br></pre></td></tr></table></figure>\n\n<p>翻譯過來就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">杯子</span><br><span class=\"line\"></span><br><span class=\"line\">【可數名詞】一種小的容器，狀似碗，通常有個把手，用來喝茶或咖啡等等。</span><br></pre></td></tr></table></figure>\n\n<p>同樣地，我們要形成軟件架構的概念，必須先建構軟件架構的直觀。</p>\n<h2 id=\"軟件架構的直觀\"><a href=\"#軟件架構的直觀\" class=\"headerlink\" title=\"軟件架構的直觀\"></a>軟件架構的直觀</h2><p>Perry 和 Wolf 審視了當前的軟件架構，並與已有的建築架構学科進行類比，建構了軟件架構的直觀（intuition）：</p>\n<ol>\n<li>軟件架構是多視圖的（multiple views）。架構應該是多個面向的，正如建築架構會提供立面圖和平面圖一樣。</li>\n<li>軟件架構是有不同架構風格的（architecture styles）。正如建築架構有哥特式、羅馬式等不同的風格，軟件架構也有不同風格，並且架構風格約束著架構元素以及它們之間的關係。</li>\n<li>架構（風格）是跟工程原理（engineering principle）密切相关的。不同的架構風格需要不同的工程原理。</li>\n<li>架构風格是跟質料（materials）密切相關的。正如摩天大樓不能用木頭構建。</li>\n</ol>\n<p>再者，從軟件製品的整個生產流程看，架構處在 <code>需求-架構-設計-實現</code> 流程中的一環，溝通著問題域（需求）和解域（實現）。</p>\n<ul>\n<li>需求：決定著系統中的用戶需要的信息和處理過程。</li>\n<li>架構：關心元素、交互和約束。</li>\n<li>設計：關心模塊化、詳細接口、算法和數據類型。</li>\n<li>實現：關心算法和數據結構的最終表示。</li>\n</ul>\n<p>可見，架構的上下文（context）即是需求、設計和實現。</p>\n<p>還有，架構會隨著新需求（通常是定制化的需求）不斷演進，稍有不慎可能導致架構腐化（architectural erosion）或架構偏移（architectural drift）。架構腐化是架構不斷被違反導致的，架構的違反增加了系統的脆性，從而導致災難；而架構偏移是由於對架構的頓感，這種頓感導致架構變得模糊不清，很容易演變成架構違反以至腐化。</p>\n<p>爲避免演進過程架構的腐化和偏移，我們期望有這樣的架構規範：</p>\n<ol>\n<li>以最少約束原則規定需要的約束級別。</li>\n<li>區分主幹和裝飾。</li>\n<li>使用恰當的方式展現架構的不同視圖。</li>\n<li>進行依賴和一致性分析。</li>\n</ol>\n<h2 id=\"架構模型\"><a href=\"#架構模型\" class=\"headerlink\" title=\"架構模型\"></a>架構模型</h2><p>從上述的直觀中，Perry 和 Wolf 得出以下的架構模型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">軟件架構 = &#123; 元素, 形式, 理論依據 &#125; </span><br></pre></td></tr></table></figure>\n\n<p>該模型認爲軟件架構是由一組具有特定形式的架構元素構成。</p>\n<ul>\n<li>架構元素（elements），包含處理元素、數據元素和連接元素。處理元素是主動的，負責處理數據；數據元素是被動的，被處理元素處理；連接元素是在處理元素之間運載數據元素的機制，它限制著數據元素。例如：在「人在水池中打水球」場景中，人是處理元素，水池則連接元素，水球則是數據元素。換到「人在足球場上踢足球」的場景中，人依然是處理元素，而連接元素變為足球場，數據元素變為足球。顯然，我們無法在足球場中打水球，因此當連接元素變化時，數據元素也跟著變化了，即連接元素限制著數據元素。</li>\n<li>形式（form），指架構元素之間的關係，主次、先後等等。</li>\n<li>理論依據（rationale），指架構風格、元素和形式的選擇動機，以及其滿足功能性或非功能性的約束（或需求）的依據。</li>\n</ul>\n<p>在得出軟件架構的概念後，我們仍然不滿足，因爲架構基本都是定製化的，實在太多了。</p>\n<h3 id=\"架構風格\"><a href=\"#架構風格\" class=\"headerlink\" title=\"架構風格\"></a>架構風格</h3><p>於是，我們基於眾多特定架構，抽象出了架構風格的概念。這個抽象過程其實就是減少約束和減少完成度的過程。</p>\n<p>我們知道架構是一系列決策（決定使用哪些架構元素以及何種形式）的集合，因此也可以說架構風格是一系列重要決策的集合，包含關鍵的架構元素和形式。</p>\n<p>常見的架構風格有：</p>\n<ul>\n<li>獨立構件（Independent Components）</li>\n<li>虛擬機（Virtual Machines）</li>\n<li>數據流（Data Flow）</li>\n<li>數據中心（Data-Centered）</li>\n<li>調用返回（Call-and-return）</li>\n<li>MVC（Model-View-Controller）</li>\n<li>代理架構風格（Broker Architecture Style）</li>\n<li>面向服務架構（Service Oriented Architecture (SOA)）</li>\n<li>點對點架構（Peer-to-Peer Architecture）</li>\n</ul>\n<p>需要注意的是：架構與架構風格之間沒有明顯的分界線，一個架構可以成為另一個架構的架構風格。</p>\n<h3 id=\"3-視圖\"><a href=\"#3-視圖\" class=\"headerlink\" title=\"3 視圖\"></a>3 視圖</h3><p>架構模型的三種元素相互依賴，分別從三種元素的視角觀察，可以得出三種視圖，即：</p>\n<ol>\n<li>處理視圖：從處理元素的視角看到的是系統的數據流（data flow）以及處理元素之間的連接。</li>\n<li>數據視圖：從數據元素的視角看到的是系統的處理流（processing flow）。</li>\n<li>連接視圖：從連接元素的視角看到的是處理元素之間的互動，一個處理元素的輸出是另一個處理元素的輸入，輸入輸出的數據元素在連接協議中定義。</li>\n</ol>\n<p>Perry 和 Wolf 說是有 3 種視圖，但是只給了 2 種，可能是連接視圖沒有畫的必要性。</p>\n<p>處理視圖展現了數據流，數據視圖展現了處理流，有趣。處理視圖強調了處理元素的主觀能動性，數據在其中被處理和流轉；而數據視圖強調了數據本身的變化，處理過程是數據產生變化的原因。</p>\n<p><img src=\"/it/common/software-architecture-and-kants-philosophy/3-views-processing.png\" alt=\"處理視圖\"></p>\n<p><img src=\"/it/common/software-architecture-and-kants-philosophy/3-views-data.png\" alt=\"數據視圖\"></p>\n<h2 id=\"其他重要的視圖\"><a href=\"#其他重要的視圖\" class=\"headerlink\" title=\"其他重要的視圖\"></a>其他重要的視圖</h2><h3 id=\"4-1-視圖\"><a href=\"#4-1-視圖\" class=\"headerlink\" title=\"4+1 視圖\"></a>4+1 視圖</h3><p>三視圖是從架構元素的視角觀察得出的，我們能否從用戶角度觀察呢？</p>\n<p>Rational 軟件公司的 Philippe Kruchten 就是這樣思考的，他於 1995 在 IEEE Software 上發表了題為 <em>Architectual Blueprints–The “4+1” View Model of Software Architecture</em> 的論文探討了 4+1 視圖。 </p>\n<p>4+1 視圖是從用戶視角觀察的，不同用戶的視角得出不同的視圖，4+1 時圖共整理了 5 種視圖，即：</p>\n<ol>\n<li>邏輯視圖，從終端用戶的視角，關注的是功能。</li>\n<li>處理視圖，從集成方的視角，關注的是性能和伸縮性。</li>\n<li>開發視圖，從開發者的視角，關注的是軟件管理。</li>\n<li>物理視圖，從系統工程師/運維人員的視角，關注的是拓撲、通信。</li>\n<li>場景視圖，場景串聯以上 4 種視圖，講述某個場景如何被實現。</li>\n</ol>\n<p><img src=\"/it/common/software-architecture-and-kants-philosophy/4+1-views.png\" alt=\"4+1視圖\"></p>\n<h3 id=\"5-視圖\"><a href=\"#5-視圖\" class=\"headerlink\" title=\"5 視圖\"></a>5 視圖</h3><p>CSAI 的架構師們於2009年11月在第六屆中國軟件大會上提出了一種軟件架構設計方法 ADMEMS（Architecture Design Method has been Extended to Method System）。</p>\n<p>該方法上承需求、下接實現，包括 3 個階段和 1 個貫穿環節，即：</p>\n<ol>\n<li>預備架構階段（PA, Pre-Architecture）：關注充分理解需求，把握需求特點。</li>\n<li>概念架構階段（CA, Conceptual Architecture）：關注功能、質量、約束等等。</li>\n<li>細化架構階段（RA, Refined Architecture）：使用 5 視圖。</li>\n<li>貫穿環節：對非功能性目標的考量。</li>\n</ol>\n<p>所謂的 5 視圖包括：</p>\n<ol>\n<li>邏輯視圖：面向對象或結構化，關注職責劃分和職責間協作。</li>\n<li>運行視圖：面向控制流，關注控制流及其組織。</li>\n<li>物理視圖：面向節點，關注物理節點及其拓撲。</li>\n<li>數據視圖：面向Table或文件，關注持久化數據單元和數據存儲格式。</li>\n<li>開發視圖：面向文件，關注程序單元及其組織。</li>\n</ol>\n<p><img src=\"/it/common/software-architecture-and-kants-philosophy/5-views.png\" alt=\"5視圖\"></p>\n<h3 id=\"C4-模型\"><a href=\"#C4-模型\" class=\"headerlink\" title=\"C4 模型\"></a>C4 模型</h3><p>架構師 Simon Brown 在 2006 年到 2011 年間基於 UML 和 4+1 視圖構建了 C4 模型（C4 model），並隨後創辦了 c4model.com 宣傳該模型。2018 年，他在 InfoQ 上發表了題爲 <em>The C4 Model for Software Architecture</em> 的文章，受到廣泛關注。</p>\n<p>C4 是四個首字母爲 C 的單詞的統稱，即：上下文（Context）、容器（Container）、組件（Component）和代碼（Code）。</p>\n<p><img src=\"/it/common/software-architecture-and-kants-philosophy/c4-model.jpg\" alt=\"C4 模型\"></p>\n<p>C4 模型體現了一種頂層設計、逐步細化的思維方式。它就像使用地圖軟件一般，逐步放大，獲取所關注級別的信息。首先從系統的上下文開始，梳理此系統與別的系統之間的關係；然後再深入到系統內部，看內部各個容器（包括應用程序、微服務或數據存儲等等）之間的交互；然後繼續深入到某個容器內部，看容器中各個組件（或功能模塊）之間如何交互；最後如果有必要還可以深入到代碼級別，看看內部各個類之間如何交互。</p>\n<p>綜合上面提到的眾多視圖，顯見架構視圖是上承需求、下接實現的；架構視圖是頂層設計、逐步細化的；架構視圖可以從架構元素的角度觀察，也可以從用戶角度觀察。每種視圖模型都各自的優點，可以視團隊規模、面向的用戶以及系統的複雜度選擇。</p>\n<h2 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考\"></a>參考</h2><ol>\n<li><a href=\"https://www.ics.uci.edu/~andre/ics223w2006/perrywolf.pdf\">Dewayne E. Perry &amp; Alexander L. Wolf, <em>Foundations for the Study of Software Architecture</em></a></li>\n<li><a href=\"https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf\">Philippe Kruchten, <em>Architectural Blueprints—The “4+1” View Model of Software Architecture</em></a></li>\n<li>溫昱著《軟件架構設計(第2版)》, p176</li>\n<li><a href=\"https://www.infoq.cn/article/c4-architecture-model\">Simon Brown 著, 无明譯 《用于软件架构的 C4 模型》</a></li>\n<li><a href=\"https://www.infoq.com/articles/C4-architecture-model/\">Simon Brown, <em>The C4 Model for Software Architecture</em></a></li>\n</ol>"},{"title":"Unicode 字符集及UTF編碼入門","p":"it/common/unicode","date":"2021-12-20T13:06:00.000Z","mathjax":true,"_content":"\n開始介紹 Unicode 之前，我們先來做一道不定項選擇題。\n\n```css\n問題1：請問以下說法正確的是（）\n\nA. 所有中文字符都可用 UTF-8 編碼，並佔用 3 個字節。\nB. 字符串可以直接轉成字節數組，字節數組可以直接轉成字符串。\nC. 文本的編碼順序跟其書寫順序一致，不一定是按從左到右從上到下順序。\nD. 帶 BOM 的文本一定是 UTF-8 編碼，不帶 BOM 的文本不一定是 UTF-8 編碼。\nE. Unicode、GBK 和 UTF-8 都是不同的編碼方式。\nF. UTF-16 不兼容 ASCII 碼\nG. 十進制的數字可以轉成二進制，因此不需要編碼。\n```\n\n答案文章末尾揭曉，如果著急想對答案可以先翻到末尾核對；如果想知道為什麼，那就帶著問題繼續往下看吧。\n\n## 字符集\n\nUnicode 是一種國際通用的字符集。\n\n什麼是字符？計算機中的字符分為兩種：打印字符和非打印字符。打印字符包括數字、字母、漢字、假名、標點符號等等，非打印字符又稱之為控制字符，常見的有：回車（'\\r'，U+000D）、換行（'\\n'，U+000A）等等。\n\n```css\n問題2：數字 123 由（）個字符組成？\n```\n\n什麼是字符集？字符集就是字符的集合，不同的字符集包含的字符類型和數量可能不一樣。Unicode 是字符集的一種。\n\n字符之所以能被計算機處理，其中最為關鍵的是字符能夠被正確地編碼和解碼。字符的編碼是字符在對應字符集中的序號。此序號是一個整數，稱之為字符碼點 （code point）。不同的字符集可能會對同樣的字符有不同的碼點表示，甚至沒有表示（並不是所有字符在字符集中都有定義）。\n\n<!--more-->\n\n```css\n問題3：有一種語言只有五種字符，暫記錄為「金木水火土」，請自定義碼表並說明需要多少個比特位進行編碼。\n```\n\n有人說：直接用一個整型來表示一個字符不就可以了嗎？可以是可以，不過整型大小固定 4 個字節，浪費空間。比如數字 123 使用 ASCII 字符集需要 $1\\*3=3$ 個字節，而使用整型的方式將是 $4\\*3=12$ 個字節。\n\n常見的字符集有：\n\n1. US-ASCII（ISO646-US）：美國信息交換標準代碼，1967年首次發表，1986年最後更新，7位，共 128 個字符。\n2. ISO-8859-1（ISO-LATIN-1）：1980年發表，8位，共 256 個字符，兼容 US-ASCII。\n3. GB2312：國標2312，1980年發表，共 7,445 個字符，兼容 US-ASCII；\n4. GBK：國標擴展碼，1995年發表，共 21,886 個字符，兼容 GB2312。\n5. GB18030：國標18030，採用可變長編碼，每個字由 1、2 或 4 個字節組成，2000年發表，2005年更新，共 70,244 個字符，兼容 GBK，並實現了 Unicode 2.0 定義的碼位。\n6. Unicode：統一碼，1994年發表1.0，2021年發佈14.0版本。\n\n## Unicode\n\nUnicode 碼點，取值範圍為 [U+0000, U+10FFFF]。\n\n```css\n問題4：已知 Unicode碼點取值範圍為 [U+0000, U+10FFFF]，請問最多可以表示（）種字符？\n```\n\nUnicode 碼點使用平面（Plane）進行歸類，有：\n\n| 平面               | 始末字符值              | 用途                                                         |\n| ------------------ | ----------------------- | ------------------------------------------------------------ |\n| 0號平面（Plane 0） | `U+0000` - `U+FFFF`     | 基本多文種平面（Basic Multilingual Plane，簡稱 BMP），保留 `U+D800` - `U+DFFF`。 |\n| 1號平面            | `U+10000` - `U+1FFFF`   | 多文種補充平面（Supplementary Multilingual Plane，簡稱 SMP） |\n| 2號平面            | `U+20000` - `U+2FFFF`   | 表意文字補充平面（Supplementary Ideographic Plane，簡稱 SIP） |\n| 3號平面            | `U+30000` - `U+3FFFF`   | 表意文字第三平面（Tertiary Ideographic Plane，簡稱 TIP）     |\n| 4號平面~13號平面   | `U+40000` - `U+DFFFF`   | （尚未使用）                                                 |\n| 14號平面           | `U+E0000` - `U+EFFFF`   | 特別用途補充平面（Supplementary Special-purpose Plane，簡稱 SSP） |\n| 15號平面           | `U+F0000` - `U+FFFFF`   | 私人使用區（A區）（Private Use Area-A，簡稱 PUA-A）          |\n| 16號平面           | `U+100000` - `U+10FFFF` | 私人使用區（B區）（Private Use Area-B，簡稱 PUA-B）          |\n\n值得注意的是：**Unicode 只定義了碼點，而字符到具體的字節序列的映射由 UTF（Unicode/UCS Transformation Format 統一碼轉化格式） 實現**。\n\nUTF 目前有UTF-8、UTF-16 和 UTF-32。\n\n```css\n問題5：Unicode的每個平面最多可以表示（）種字符？BMP除去保留的區域外，共可以表示（）種字符？\n```\n\n## UTF-8\n\nUTF-8 是面向字節（8位）的 Unicode 編碼形式，使用一個、兩個、三個字節表示BMP上的字符，使用四個字節表示 BMP 外的字符。兼容 US-ASCII 字符集。\n\n| 碼點位數 | 範圍                   | 字節序列 | Byte 1     | Byte 2     | Byte 3     | Byte 4     |\n| -------- | ---------------------- | -------- | ---------- | ---------- | ---------- | ---------- |\n| 7        | `U+0000` - `U+007F`    | 1        | `0xxxxxxx` |            |            |            |\n| 11       | `U+0080` - `U+07FF`    | 2        | `110xxxxx` | `10xxxxxx` |            |            |\n| 16       | `U+0800` - `U+FFFF`    | 3        | `1110xxxx` | `10xxxxxx` | `10xxxxxx` |            |\n| 21       | `U+10000` - `U+10FFFF` | 4        | `11110xxx` | `10xxxxxx` | `10xxxxxx` | `10xxxxxx` |\n\n## UTF-16\n\nUTF-16 使用兩個字節來表示基本多語言平面，四個字節來表示輔助平面。\n\n對於英文來說使用 UTF-8 省空間，對於中文來說UTF-16省空間，因為英文用 UTF-8 佔用 1 個字節，用 UTF-16 佔用 2 個字節；中文用 UTF-8 佔用 3 個字節，用 UTF-16 佔用 2 個字節。\n\n| 碼點位數 | 範圍                    | UTF-16 編碼形式（二進制）                        |\n| -------- | ----------------------- | ------------------------------------------------ |\n| 16       | `U+000000` - `U+00FFFF` | `xxxx xxxx` `xxxx xxxx`                          |\n| 20       | `U+010000` - `U+10FFFF` | `1101 10yy` `yyyy yyyy`  `1101 11xx` `xxxx xxxx` |\n\n對於基本多語言平面，其編碼等同於其碼位。\n\n對於輔助平面上的碼，編碼方式為：\n\n1. 減去 0x10000，成二進制形式：yyyy yyyy yyxx xxxx xxxx，共 20 位。\n2. 前 10 位為高位，加上 0xD800 作為前導代理(lead surrogates)，值範圍：[0xD800, 0xDBFF]\n3. 後 10 位為低位，加上 0xDC00 作為後尾代理(trail surrogates)，值範圍：[0xDC00, 0xDFFF]\n4. 可見前導和後尾的值不在同一個區間，最終形成：110110yyyyyyyyyy 110111xxxxxxxxxx\n\n```css\n問題6：已知字符A的Unicode碼點為 U+0041，其UTF-8編碼和UTF-16編碼分別是？\n```\n\n## UTFs\n\nUTF-16 編碼包含 BE （big endian）和 LE（little endian）版本，大端者，高位字節（MSB，most significant byte）在低地址；小端者，低位字節在低地址。\n\n| Name                       | UTF-8  | UTF-16  | UTF-16BE   | UTF-16LE      | UTF-32  | UTF-32BE   | UTF-32LE      |\n| -------------------------- | ------ | ------- | ---------- | ------------- | ------- | ---------- | ------------- |\n| Smallest code point        | 0000   | 0000    | 0000       | 0000          | 0000    | 0000       | 0000          |\n| Largest code point         | 10FFFF | 10FFFF  | 10FFFF     | 10FFFF        | 10FFFF  | 10FFFF     | 10FFFF        |\n| Code unit size             | 8 bits | 16 bits | 16 bits    | 16 bits       | 32 bits | 32 bits    | 32 bits       |\n| Byte order                 | N/A    | \\<BOM\\>   | big-endian | little-endian | \\<BOM\\>   | big-endian | little-endian |\n| Fewest bytes per character | 1      | 2       | 2          | 2             | 4       | 4          | 4             |\n| Most bytes per character   | 4      | 4       | 4          | 4             | 4       | 4          | 4             |\n\n## BOM\n\nBOM，即 Byte Order Mark，字節序標記，用在文本文件的開頭。該標記為字符 U+FEFF，又稱為 ZWNBSP（ZERO WIDTH NO-BREAK SPACE，零寬非換行空格），表示大端字節序；相反的，U+FFFE（Noncharacters，非字符）表示小端字節序。\n\nBOM字符的 UTF-8 編碼為 EF BB BF。UTF-8有 BOM編碼的文件會以 BOM 字符開頭。\n\nUTF-8 不需要 BOM 來指定是小端還是大端字節序，但是可以通過 BOM 來區分是 UTF-8 編碼還是其他編碼。\n\n```css\n問題7：請完成下列實操，並說說你對UTF-8編碼、BOM和CRLF的理解\n\n1. 在 Windows 中打開記事本，輸入「好」，然後另存為 UTF-8 編碼的文本文件 a.txt；\n2. 使用 vim 打開 a.txt，執行命令 「%!xxd」 可以將文本轉為 16 進制形式；\n3. 閱讀並嘗試解讀該 16 進制串；\n4. 使用 notepad++ 或 vim 創建一個 b.txt，輸入「好」，按同樣方式獲取並解讀 16 進制串；\n5. 在 a.txt 和 b.txt 中增加一個換行，再次獲取並解讀 16 進制串。\n```\n\n## 問題答案\n\n**（問題1）**CF。Unicode 採用邏輯序（logical order）編碼文本，比如會對英文從左到右編碼，而對希伯來文從右到左編碼，見：http://www.unicode.org/versions/Unicode3.0.0/ch02.pdf。UTF-16 編碼至少需要 2 個字節，ASCII 碼只需要 1 個字節，不兼容。\n\n**（問題2）**3。很明顯1、2、3分別是3個字符。\n\n**（問題3）**3。計算過程：$2^2<5<2^3$, 可編碼爲：000 金、001 木、010 水、011 火、100 土，剩餘 101、110 和 111 三個碼點。\n\n**（問題4）**1,114,112。計算過程：$16^5+16^4$\n\n**（問題5）**65536，63488。計算過程：$16^4-(16^3-8*16^2)$\n\n**（問題6）**0x41，0x0041。UTF-8表示A佔用1個字節，UTF-16則是佔用2個字節。\n\n**（問題7）**\n\n（1）「好」\nWindows記事本：efbb bfe5 a5bb 0a\nVim：e5a5 bb0a\n- efbb bf 是 BOM\n- e5 a5bb 是「好」的UTF-8 編碼，1110 0101 1010 0101 1011 1101\n- 0a 是 LF '\\n'，換行符\n\n（2）「好」+換行\nWindows記事本：efbb bfe5 a5bb 0d0a\nVim：e5a5 bb0a\n\n- 0d 是 CR '\\r' ，回車\n\n結論：\n1. Windows記事本中的UTF-8編碼默認是帶BOM的，而Notepad++或Vim編輯器中的UTF-8編碼是無BOM的；\n2. Windows記事本中的換行符默認是 CRLF，而Notepad++或Vim編輯器中是Unix風格的 LF。\n\n## 延伸閱讀\n\n- [Unicode碼表](https://unicode-table.com/en/#basic-latin)\n- [Unicode 標準14.0.0 -- unicode.org](https://www.unicode.org/versions/Unicode14.0.0/)\n- [FAQ：UTF-8, UTF-16, UTF-32 & BOM -- unicode.org](https://www.unicode.org/faq/utf_bom.html)\n- [Java的char類型和Unicode](https://kkua.github.io/post/java-char-type-and-unicode/)\n- [utf16編碼格式](https://www.cnblogs.com/dragon2012/p/5020259.html)\n- [2.5 unicode — Unicode码点、UTF-8/16编码](https://docs.kilvn.com/The-Golang-Standard-Library-by-Example/chapter02/02.5.html)\n","source":"_posts/it/common/unicode.md","raw":"---\ntitle: Unicode 字符集及UTF編碼入門\np: it/common/unicode\ndate: 2021-12-20 21:06:00\ntags:\n- Unicode\n- UTF-8\n- UTF-16\n- BOM\nmathjax: true\n---\n\n開始介紹 Unicode 之前，我們先來做一道不定項選擇題。\n\n```css\n問題1：請問以下說法正確的是（）\n\nA. 所有中文字符都可用 UTF-8 編碼，並佔用 3 個字節。\nB. 字符串可以直接轉成字節數組，字節數組可以直接轉成字符串。\nC. 文本的編碼順序跟其書寫順序一致，不一定是按從左到右從上到下順序。\nD. 帶 BOM 的文本一定是 UTF-8 編碼，不帶 BOM 的文本不一定是 UTF-8 編碼。\nE. Unicode、GBK 和 UTF-8 都是不同的編碼方式。\nF. UTF-16 不兼容 ASCII 碼\nG. 十進制的數字可以轉成二進制，因此不需要編碼。\n```\n\n答案文章末尾揭曉，如果著急想對答案可以先翻到末尾核對；如果想知道為什麼，那就帶著問題繼續往下看吧。\n\n## 字符集\n\nUnicode 是一種國際通用的字符集。\n\n什麼是字符？計算機中的字符分為兩種：打印字符和非打印字符。打印字符包括數字、字母、漢字、假名、標點符號等等，非打印字符又稱之為控制字符，常見的有：回車（'\\r'，U+000D）、換行（'\\n'，U+000A）等等。\n\n```css\n問題2：數字 123 由（）個字符組成？\n```\n\n什麼是字符集？字符集就是字符的集合，不同的字符集包含的字符類型和數量可能不一樣。Unicode 是字符集的一種。\n\n字符之所以能被計算機處理，其中最為關鍵的是字符能夠被正確地編碼和解碼。字符的編碼是字符在對應字符集中的序號。此序號是一個整數，稱之為字符碼點 （code point）。不同的字符集可能會對同樣的字符有不同的碼點表示，甚至沒有表示（並不是所有字符在字符集中都有定義）。\n\n<!--more-->\n\n```css\n問題3：有一種語言只有五種字符，暫記錄為「金木水火土」，請自定義碼表並說明需要多少個比特位進行編碼。\n```\n\n有人說：直接用一個整型來表示一個字符不就可以了嗎？可以是可以，不過整型大小固定 4 個字節，浪費空間。比如數字 123 使用 ASCII 字符集需要 $1\\*3=3$ 個字節，而使用整型的方式將是 $4\\*3=12$ 個字節。\n\n常見的字符集有：\n\n1. US-ASCII（ISO646-US）：美國信息交換標準代碼，1967年首次發表，1986年最後更新，7位，共 128 個字符。\n2. ISO-8859-1（ISO-LATIN-1）：1980年發表，8位，共 256 個字符，兼容 US-ASCII。\n3. GB2312：國標2312，1980年發表，共 7,445 個字符，兼容 US-ASCII；\n4. GBK：國標擴展碼，1995年發表，共 21,886 個字符，兼容 GB2312。\n5. GB18030：國標18030，採用可變長編碼，每個字由 1、2 或 4 個字節組成，2000年發表，2005年更新，共 70,244 個字符，兼容 GBK，並實現了 Unicode 2.0 定義的碼位。\n6. Unicode：統一碼，1994年發表1.0，2021年發佈14.0版本。\n\n## Unicode\n\nUnicode 碼點，取值範圍為 [U+0000, U+10FFFF]。\n\n```css\n問題4：已知 Unicode碼點取值範圍為 [U+0000, U+10FFFF]，請問最多可以表示（）種字符？\n```\n\nUnicode 碼點使用平面（Plane）進行歸類，有：\n\n| 平面               | 始末字符值              | 用途                                                         |\n| ------------------ | ----------------------- | ------------------------------------------------------------ |\n| 0號平面（Plane 0） | `U+0000` - `U+FFFF`     | 基本多文種平面（Basic Multilingual Plane，簡稱 BMP），保留 `U+D800` - `U+DFFF`。 |\n| 1號平面            | `U+10000` - `U+1FFFF`   | 多文種補充平面（Supplementary Multilingual Plane，簡稱 SMP） |\n| 2號平面            | `U+20000` - `U+2FFFF`   | 表意文字補充平面（Supplementary Ideographic Plane，簡稱 SIP） |\n| 3號平面            | `U+30000` - `U+3FFFF`   | 表意文字第三平面（Tertiary Ideographic Plane，簡稱 TIP）     |\n| 4號平面~13號平面   | `U+40000` - `U+DFFFF`   | （尚未使用）                                                 |\n| 14號平面           | `U+E0000` - `U+EFFFF`   | 特別用途補充平面（Supplementary Special-purpose Plane，簡稱 SSP） |\n| 15號平面           | `U+F0000` - `U+FFFFF`   | 私人使用區（A區）（Private Use Area-A，簡稱 PUA-A）          |\n| 16號平面           | `U+100000` - `U+10FFFF` | 私人使用區（B區）（Private Use Area-B，簡稱 PUA-B）          |\n\n值得注意的是：**Unicode 只定義了碼點，而字符到具體的字節序列的映射由 UTF（Unicode/UCS Transformation Format 統一碼轉化格式） 實現**。\n\nUTF 目前有UTF-8、UTF-16 和 UTF-32。\n\n```css\n問題5：Unicode的每個平面最多可以表示（）種字符？BMP除去保留的區域外，共可以表示（）種字符？\n```\n\n## UTF-8\n\nUTF-8 是面向字節（8位）的 Unicode 編碼形式，使用一個、兩個、三個字節表示BMP上的字符，使用四個字節表示 BMP 外的字符。兼容 US-ASCII 字符集。\n\n| 碼點位數 | 範圍                   | 字節序列 | Byte 1     | Byte 2     | Byte 3     | Byte 4     |\n| -------- | ---------------------- | -------- | ---------- | ---------- | ---------- | ---------- |\n| 7        | `U+0000` - `U+007F`    | 1        | `0xxxxxxx` |            |            |            |\n| 11       | `U+0080` - `U+07FF`    | 2        | `110xxxxx` | `10xxxxxx` |            |            |\n| 16       | `U+0800` - `U+FFFF`    | 3        | `1110xxxx` | `10xxxxxx` | `10xxxxxx` |            |\n| 21       | `U+10000` - `U+10FFFF` | 4        | `11110xxx` | `10xxxxxx` | `10xxxxxx` | `10xxxxxx` |\n\n## UTF-16\n\nUTF-16 使用兩個字節來表示基本多語言平面，四個字節來表示輔助平面。\n\n對於英文來說使用 UTF-8 省空間，對於中文來說UTF-16省空間，因為英文用 UTF-8 佔用 1 個字節，用 UTF-16 佔用 2 個字節；中文用 UTF-8 佔用 3 個字節，用 UTF-16 佔用 2 個字節。\n\n| 碼點位數 | 範圍                    | UTF-16 編碼形式（二進制）                        |\n| -------- | ----------------------- | ------------------------------------------------ |\n| 16       | `U+000000` - `U+00FFFF` | `xxxx xxxx` `xxxx xxxx`                          |\n| 20       | `U+010000` - `U+10FFFF` | `1101 10yy` `yyyy yyyy`  `1101 11xx` `xxxx xxxx` |\n\n對於基本多語言平面，其編碼等同於其碼位。\n\n對於輔助平面上的碼，編碼方式為：\n\n1. 減去 0x10000，成二進制形式：yyyy yyyy yyxx xxxx xxxx，共 20 位。\n2. 前 10 位為高位，加上 0xD800 作為前導代理(lead surrogates)，值範圍：[0xD800, 0xDBFF]\n3. 後 10 位為低位，加上 0xDC00 作為後尾代理(trail surrogates)，值範圍：[0xDC00, 0xDFFF]\n4. 可見前導和後尾的值不在同一個區間，最終形成：110110yyyyyyyyyy 110111xxxxxxxxxx\n\n```css\n問題6：已知字符A的Unicode碼點為 U+0041，其UTF-8編碼和UTF-16編碼分別是？\n```\n\n## UTFs\n\nUTF-16 編碼包含 BE （big endian）和 LE（little endian）版本，大端者，高位字節（MSB，most significant byte）在低地址；小端者，低位字節在低地址。\n\n| Name                       | UTF-8  | UTF-16  | UTF-16BE   | UTF-16LE      | UTF-32  | UTF-32BE   | UTF-32LE      |\n| -------------------------- | ------ | ------- | ---------- | ------------- | ------- | ---------- | ------------- |\n| Smallest code point        | 0000   | 0000    | 0000       | 0000          | 0000    | 0000       | 0000          |\n| Largest code point         | 10FFFF | 10FFFF  | 10FFFF     | 10FFFF        | 10FFFF  | 10FFFF     | 10FFFF        |\n| Code unit size             | 8 bits | 16 bits | 16 bits    | 16 bits       | 32 bits | 32 bits    | 32 bits       |\n| Byte order                 | N/A    | \\<BOM\\>   | big-endian | little-endian | \\<BOM\\>   | big-endian | little-endian |\n| Fewest bytes per character | 1      | 2       | 2          | 2             | 4       | 4          | 4             |\n| Most bytes per character   | 4      | 4       | 4          | 4             | 4       | 4          | 4             |\n\n## BOM\n\nBOM，即 Byte Order Mark，字節序標記，用在文本文件的開頭。該標記為字符 U+FEFF，又稱為 ZWNBSP（ZERO WIDTH NO-BREAK SPACE，零寬非換行空格），表示大端字節序；相反的，U+FFFE（Noncharacters，非字符）表示小端字節序。\n\nBOM字符的 UTF-8 編碼為 EF BB BF。UTF-8有 BOM編碼的文件會以 BOM 字符開頭。\n\nUTF-8 不需要 BOM 來指定是小端還是大端字節序，但是可以通過 BOM 來區分是 UTF-8 編碼還是其他編碼。\n\n```css\n問題7：請完成下列實操，並說說你對UTF-8編碼、BOM和CRLF的理解\n\n1. 在 Windows 中打開記事本，輸入「好」，然後另存為 UTF-8 編碼的文本文件 a.txt；\n2. 使用 vim 打開 a.txt，執行命令 「%!xxd」 可以將文本轉為 16 進制形式；\n3. 閱讀並嘗試解讀該 16 進制串；\n4. 使用 notepad++ 或 vim 創建一個 b.txt，輸入「好」，按同樣方式獲取並解讀 16 進制串；\n5. 在 a.txt 和 b.txt 中增加一個換行，再次獲取並解讀 16 進制串。\n```\n\n## 問題答案\n\n**（問題1）**CF。Unicode 採用邏輯序（logical order）編碼文本，比如會對英文從左到右編碼，而對希伯來文從右到左編碼，見：http://www.unicode.org/versions/Unicode3.0.0/ch02.pdf。UTF-16 編碼至少需要 2 個字節，ASCII 碼只需要 1 個字節，不兼容。\n\n**（問題2）**3。很明顯1、2、3分別是3個字符。\n\n**（問題3）**3。計算過程：$2^2<5<2^3$, 可編碼爲：000 金、001 木、010 水、011 火、100 土，剩餘 101、110 和 111 三個碼點。\n\n**（問題4）**1,114,112。計算過程：$16^5+16^4$\n\n**（問題5）**65536，63488。計算過程：$16^4-(16^3-8*16^2)$\n\n**（問題6）**0x41，0x0041。UTF-8表示A佔用1個字節，UTF-16則是佔用2個字節。\n\n**（問題7）**\n\n（1）「好」\nWindows記事本：efbb bfe5 a5bb 0a\nVim：e5a5 bb0a\n- efbb bf 是 BOM\n- e5 a5bb 是「好」的UTF-8 編碼，1110 0101 1010 0101 1011 1101\n- 0a 是 LF '\\n'，換行符\n\n（2）「好」+換行\nWindows記事本：efbb bfe5 a5bb 0d0a\nVim：e5a5 bb0a\n\n- 0d 是 CR '\\r' ，回車\n\n結論：\n1. Windows記事本中的UTF-8編碼默認是帶BOM的，而Notepad++或Vim編輯器中的UTF-8編碼是無BOM的；\n2. Windows記事本中的換行符默認是 CRLF，而Notepad++或Vim編輯器中是Unix風格的 LF。\n\n## 延伸閱讀\n\n- [Unicode碼表](https://unicode-table.com/en/#basic-latin)\n- [Unicode 標準14.0.0 -- unicode.org](https://www.unicode.org/versions/Unicode14.0.0/)\n- [FAQ：UTF-8, UTF-16, UTF-32 & BOM -- unicode.org](https://www.unicode.org/faq/utf_bom.html)\n- [Java的char類型和Unicode](https://kkua.github.io/post/java-char-type-and-unicode/)\n- [utf16編碼格式](https://www.cnblogs.com/dragon2012/p/5020259.html)\n- [2.5 unicode — Unicode码点、UTF-8/16编码](https://docs.kilvn.com/The-Golang-Standard-Library-by-Example/chapter02/02.5.html)\n","slug":"it/common/unicode","published":1,"updated":"2021-12-20T14:35:45.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlev000j1n9kcajidxol","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>開始介紹 Unicode 之前，我們先來做一道不定項選擇題。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">1</span>：請問以下說法正確的是（）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">A</span>. 所有中文字符都可用 UTF-<span class=\"number\">8</span> 編碼，並佔用 <span class=\"number\">3</span> 個字節。</span><br><span class=\"line\"><span class=\"selector-tag\">B</span>. 字符串可以直接轉成字節數組，字節數組可以直接轉成字符串。</span><br><span class=\"line\">C. 文本的編碼順序跟其書寫順序一致，不一定是按從左到右從上到下順序。</span><br><span class=\"line\">D. 帶 BOM 的文本一定是 UTF-<span class=\"number\">8</span> 編碼，不帶 BOM 的文本不一定是 UTF-<span class=\"number\">8</span> 編碼。</span><br><span class=\"line\">E. Unicode、GBK 和 UTF-<span class=\"number\">8</span> 都是不同的編碼方式。</span><br><span class=\"line\">F. UTF-<span class=\"number\">16</span> 不兼容 ASCII 碼</span><br><span class=\"line\">G. 十進制的數字可以轉成二進制，因此不需要編碼。</span><br></pre></td></tr></table></figure>\n\n<p>答案文章末尾揭曉，如果著急想對答案可以先翻到末尾核對；如果想知道為什麼，那就帶著問題繼續往下看吧。</p>\n<h2 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a>字符集</h2><p>Unicode 是一種國際通用的字符集。</p>\n<p>什麼是字符？計算機中的字符分為兩種：打印字符和非打印字符。打印字符包括數字、字母、漢字、假名、標點符號等等，非打印字符又稱之為控制字符，常見的有：回車（’\\r’，U+000D）、換行（’\\n’，U+000A）等等。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">2</span>：數字 <span class=\"number\">123</span> 由（）個字符組成？</span><br></pre></td></tr></table></figure>\n\n<p>什麼是字符集？字符集就是字符的集合，不同的字符集包含的字符類型和數量可能不一樣。Unicode 是字符集的一種。</p>\n<p>字符之所以能被計算機處理，其中最為關鍵的是字符能夠被正確地編碼和解碼。字符的編碼是字符在對應字符集中的序號。此序號是一個整數，稱之為字符碼點 （code point）。不同的字符集可能會對同樣的字符有不同的碼點表示，甚至沒有表示（並不是所有字符在字符集中都有定義）。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">3</span>：有一種語言只有五種字符，暫記錄為「金木水火土」，請自定義碼表並說明需要多少個比特位進行編碼。</span><br></pre></td></tr></table></figure>\n\n<p>有人說：直接用一個整型來表示一個字符不就可以了嗎？可以是可以，不過整型大小固定 4 個字節，浪費空間。比如數字 123 使用 ASCII 字符集需要 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"8.548ex\" height=\"1.692ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -666 3778 748\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(722.2,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(1444.4,0)\"><path data-c=\"33\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(2222.2,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(3278,0)\"><path data-c=\"33\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"/></g></g></g></svg></mjx-container> 個字節，而使用整型的方式將是 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.679ex\" height=\"1.717ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -677 4278 759\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(722.2,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(1444.4,0)\"><path data-c=\"33\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(2222.2,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(3278,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\" transform=\"translate(500,0)\"/></g></g></g></svg></mjx-container> 個字節。</p>\n<p>常見的字符集有：</p>\n<ol>\n<li>US-ASCII（ISO646-US）：美國信息交換標準代碼，1967年首次發表，1986年最後更新，7位，共 128 個字符。</li>\n<li>ISO-8859-1（ISO-LATIN-1）：1980年發表，8位，共 256 個字符，兼容 US-ASCII。</li>\n<li>GB2312：國標2312，1980年發表，共 7,445 個字符，兼容 US-ASCII；</li>\n<li>GBK：國標擴展碼，1995年發表，共 21,886 個字符，兼容 GB2312。</li>\n<li>GB18030：國標18030，採用可變長編碼，每個字由 1、2 或 4 個字節組成，2000年發表，2005年更新，共 70,244 個字符，兼容 GBK，並實現了 Unicode 2.0 定義的碼位。</li>\n<li>Unicode：統一碼，1994年發表1.0，2021年發佈14.0版本。</li>\n</ol>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><p>Unicode 碼點，取值範圍為 [U+0000, U+10FFFF]。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">4</span>：已知 Unicode碼點取值範圍為 <span class=\"selector-attr\">[U+0000, U+10FFFF]</span>，請問最多可以表示（）種字符？</span><br></pre></td></tr></table></figure>\n\n<p>Unicode 碼點使用平面（Plane）進行歸類，有：</p>\n<table>\n<thead>\n<tr>\n<th>平面</th>\n<th>始末字符值</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0號平面（Plane 0）</td>\n<td><code>U+0000</code> - <code>U+FFFF</code></td>\n<td>基本多文種平面（Basic Multilingual Plane，簡稱 BMP），保留 <code>U+D800</code> - <code>U+DFFF</code>。</td>\n</tr>\n<tr>\n<td>1號平面</td>\n<td><code>U+10000</code> - <code>U+1FFFF</code></td>\n<td>多文種補充平面（Supplementary Multilingual Plane，簡稱 SMP）</td>\n</tr>\n<tr>\n<td>2號平面</td>\n<td><code>U+20000</code> - <code>U+2FFFF</code></td>\n<td>表意文字補充平面（Supplementary Ideographic Plane，簡稱 SIP）</td>\n</tr>\n<tr>\n<td>3號平面</td>\n<td><code>U+30000</code> - <code>U+3FFFF</code></td>\n<td>表意文字第三平面（Tertiary Ideographic Plane，簡稱 TIP）</td>\n</tr>\n<tr>\n<td>4號平面~13號平面</td>\n<td><code>U+40000</code> - <code>U+DFFFF</code></td>\n<td>（尚未使用）</td>\n</tr>\n<tr>\n<td>14號平面</td>\n<td><code>U+E0000</code> - <code>U+EFFFF</code></td>\n<td>特別用途補充平面（Supplementary Special-purpose Plane，簡稱 SSP）</td>\n</tr>\n<tr>\n<td>15號平面</td>\n<td><code>U+F0000</code> - <code>U+FFFFF</code></td>\n<td>私人使用區（A區）（Private Use Area-A，簡稱 PUA-A）</td>\n</tr>\n<tr>\n<td>16號平面</td>\n<td><code>U+100000</code> - <code>U+10FFFF</code></td>\n<td>私人使用區（B區）（Private Use Area-B，簡稱 PUA-B）</td>\n</tr>\n</tbody></table>\n<p>值得注意的是：<strong>Unicode 只定義了碼點，而字符到具體的字節序列的映射由 UTF（Unicode/UCS Transformation Format 統一碼轉化格式） 實現</strong>。</p>\n<p>UTF 目前有UTF-8、UTF-16 和 UTF-32。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">5</span>：Unicode的每個平面最多可以表示（）種字符？BMP除去保留的區域外，共可以表示（）種字符？</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h2><p>UTF-8 是面向字節（8位）的 Unicode 編碼形式，使用一個、兩個、三個字節表示BMP上的字符，使用四個字節表示 BMP 外的字符。兼容 US-ASCII 字符集。</p>\n<table>\n<thead>\n<tr>\n<th>碼點位數</th>\n<th>範圍</th>\n<th>字節序列</th>\n<th>Byte 1</th>\n<th>Byte 2</th>\n<th>Byte 3</th>\n<th>Byte 4</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>7</td>\n<td><code>U+0000</code> - <code>U+007F</code></td>\n<td>1</td>\n<td><code>0xxxxxxx</code></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td><code>U+0080</code> - <code>U+07FF</code></td>\n<td>2</td>\n<td><code>110xxxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td><code>U+0800</code> - <code>U+FFFF</code></td>\n<td>3</td>\n<td><code>1110xxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td><code>U+10000</code> - <code>U+10FFFF</code></td>\n<td>4</td>\n<td><code>11110xxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>10xxxxxx</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h2><p>UTF-16 使用兩個字節來表示基本多語言平面，四個字節來表示輔助平面。</p>\n<p>對於英文來說使用 UTF-8 省空間，對於中文來說UTF-16省空間，因為英文用 UTF-8 佔用 1 個字節，用 UTF-16 佔用 2 個字節；中文用 UTF-8 佔用 3 個字節，用 UTF-16 佔用 2 個字節。</p>\n<table>\n<thead>\n<tr>\n<th>碼點位數</th>\n<th>範圍</th>\n<th>UTF-16 編碼形式（二進制）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>16</td>\n<td><code>U+000000</code> - <code>U+00FFFF</code></td>\n<td><code>xxxx xxxx</code> <code>xxxx xxxx</code></td>\n</tr>\n<tr>\n<td>20</td>\n<td><code>U+010000</code> - <code>U+10FFFF</code></td>\n<td><code>1101 10yy</code> <code>yyyy yyyy</code>  <code>1101 11xx</code> <code>xxxx xxxx</code></td>\n</tr>\n</tbody></table>\n<p>對於基本多語言平面，其編碼等同於其碼位。</p>\n<p>對於輔助平面上的碼，編碼方式為：</p>\n<ol>\n<li>減去 0x10000，成二進制形式：yyyy yyyy yyxx xxxx xxxx，共 20 位。</li>\n<li>前 10 位為高位，加上 0xD800 作為前導代理(lead surrogates)，值範圍：[0xD800, 0xDBFF]</li>\n<li>後 10 位為低位，加上 0xDC00 作為後尾代理(trail surrogates)，值範圍：[0xDC00, 0xDFFF]</li>\n<li>可見前導和後尾的值不在同一個區間，最終形成：110110yyyyyyyyyy 110111xxxxxxxxxx</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">6</span>：已知字符<span class=\"selector-tag\">A</span>的Unicode碼點為 U+<span class=\"number\">0041</span>，其UTF-<span class=\"number\">8</span>編碼和UTF-<span class=\"number\">16</span>編碼分別是？</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"UTFs\"><a href=\"#UTFs\" class=\"headerlink\" title=\"UTFs\"></a>UTFs</h2><p>UTF-16 編碼包含 BE （big endian）和 LE（little endian）版本，大端者，高位字節（MSB，most significant byte）在低地址；小端者，低位字節在低地址。</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>UTF-8</th>\n<th>UTF-16</th>\n<th>UTF-16BE</th>\n<th>UTF-16LE</th>\n<th>UTF-32</th>\n<th>UTF-32BE</th>\n<th>UTF-32LE</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Smallest code point</td>\n<td>0000</td>\n<td>0000</td>\n<td>0000</td>\n<td>0000</td>\n<td>0000</td>\n<td>0000</td>\n<td>0000</td>\n</tr>\n<tr>\n<td>Largest code point</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n</tr>\n<tr>\n<td>Code unit size</td>\n<td>8 bits</td>\n<td>16 bits</td>\n<td>16 bits</td>\n<td>16 bits</td>\n<td>32 bits</td>\n<td>32 bits</td>\n<td>32 bits</td>\n</tr>\n<tr>\n<td>Byte order</td>\n<td>N/A</td>\n<td>&lt;BOM&gt;</td>\n<td>big-endian</td>\n<td>little-endian</td>\n<td>&lt;BOM&gt;</td>\n<td>big-endian</td>\n<td>little-endian</td>\n</tr>\n<tr>\n<td>Fewest bytes per character</td>\n<td>1</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Most bytes per character</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<h2 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h2><p>BOM，即 Byte Order Mark，字節序標記，用在文本文件的開頭。該標記為字符 U+FEFF，又稱為 ZWNBSP（ZERO WIDTH NO-BREAK SPACE，零寬非換行空格），表示大端字節序；相反的，U+FFFE（Noncharacters，非字符）表示小端字節序。</p>\n<p>BOM字符的 UTF-8 編碼為 EF BB BF。UTF-8有 BOM編碼的文件會以 BOM 字符開頭。</p>\n<p>UTF-8 不需要 BOM 來指定是小端還是大端字節序，但是可以通過 BOM 來區分是 UTF-8 編碼還是其他編碼。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">7</span>：請完成下列實操，並說說你對UTF-<span class=\"number\">8</span>編碼、BOM和CRLF的理解</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>. 在 Windows 中打開記事本，輸入「好」，然後另存為 UTF-<span class=\"number\">8</span> 編碼的文本文件 <span class=\"selector-tag\">a</span><span class=\"selector-class\">.txt</span>；</span><br><span class=\"line\"><span class=\"number\">2</span>. 使用 vim 打開 <span class=\"selector-tag\">a</span><span class=\"selector-class\">.txt</span>，執行命令 「%!xxd」 可以將文本轉為 <span class=\"number\">16</span> 進制形式；</span><br><span class=\"line\"><span class=\"number\">3</span>. 閱讀並嘗試解讀該 <span class=\"number\">16</span> 進制串；</span><br><span class=\"line\"><span class=\"number\">4</span>. 使用 notepad++ 或 vim 創建一個 <span class=\"selector-tag\">b</span><span class=\"selector-class\">.txt</span>，輸入「好」，按同樣方式獲取並解讀 <span class=\"number\">16</span> 進制串；</span><br><span class=\"line\"><span class=\"number\">5</span>. 在 <span class=\"selector-tag\">a</span><span class=\"selector-class\">.txt</span> 和 <span class=\"selector-tag\">b</span><span class=\"selector-class\">.txt</span> 中增加一個換行，再次獲取並解讀 <span class=\"number\">16</span> 進制串。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"問題答案\"><a href=\"#問題答案\" class=\"headerlink\" title=\"問題答案\"></a>問題答案</h2><p><strong>（問題1）</strong>CF。Unicode 採用邏輯序（logical order）編碼文本，比如會對英文從左到右編碼，而對希伯來文從右到左編碼，見：<a href=\"http://www.unicode.org/versions/Unicode3.0.0/ch02.pdf。UTF-16\">http://www.unicode.org/versions/Unicode3.0.0/ch02.pdf。UTF-16</a> 編碼至少需要 2 個字節，ASCII 碼只需要 1 個字節，不兼容。</p>\n<p><strong>（問題2）</strong>3。很明顯1、2、3分別是3個字符。</p>\n<p><strong>（問題3）</strong>3。計算過程：<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.09ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.403ex\" height=\"1.977ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -833.9 5040.2 873.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msup\"><g data-mml-node=\"mn\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(533,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"/></g></g><g data-mml-node=\"mo\" transform=\"translate(1214.3,0)\"><path data-c=\"3C\" d=\"M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(2270.1,0)\"><path data-c=\"35\" d=\"M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(3047.9,0)\"><path data-c=\"3C\" d=\"M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z\"/></g><g data-mml-node=\"msup\" transform=\"translate(4103.7,0)\"><g data-mml-node=\"mn\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(533,363) scale(0.707)\"><path data-c=\"33\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"/></g></g></g></g></svg></mjx-container>, 可編碼爲：000 金、001 木、010 水、011 火、100 土，剩餘 101、110 和 111 三個碼點。</p>\n<p><strong>（問題4）</strong>1,114,112。計算過程：<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.266ex\" height=\"2.158ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -871.8 4095.6 953.8\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msup\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\" transform=\"translate(500,0)\"/></g><g data-mml-node=\"mn\" transform=\"translate(1033,393.1) scale(0.707)\"><path data-c=\"35\" d=\"M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z\"/></g></g><g data-mml-node=\"mo\" transform=\"translate(1658.8,0)\"><path data-c=\"2B\" d=\"M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z\"/></g><g data-mml-node=\"msup\" transform=\"translate(2659,0)\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\" transform=\"translate(500,0)\"/></g><g data-mml-node=\"mn\" transform=\"translate(1033,393.1) scale(0.707)\"><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\"/></g></g></g></g></svg></mjx-container></p>\n<p><strong>（問題5）</strong>65536，63488。計算過程：<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"20.31ex\" height=\"2.538ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -871.8 8977 1121.8\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msup\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\" transform=\"translate(500,0)\"/></g><g data-mml-node=\"mn\" transform=\"translate(1033,393.1) scale(0.707)\"><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\"/></g></g><g data-mml-node=\"mo\" transform=\"translate(1658.8,0)\"><path data-c=\"2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(2659,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"/></g><g data-mml-node=\"msup\" transform=\"translate(3048,0)\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\" transform=\"translate(500,0)\"/></g><g data-mml-node=\"mn\" transform=\"translate(1033,393.1) scale(0.707)\"><path data-c=\"33\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"/></g></g><g data-mml-node=\"mo\" transform=\"translate(4706.8,0)\"><path data-c=\"2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(5707,0)\"><path data-c=\"38\" d=\"M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(6429.2,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"/></g><g data-mml-node=\"msup\" transform=\"translate(7151.4,0)\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\" transform=\"translate(500,0)\"/></g><g data-mml-node=\"mn\" transform=\"translate(1033,393.1) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"/></g></g><g data-mml-node=\"mo\" transform=\"translate(8588,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"/></g></g></g></svg></mjx-container></p>\n<p><strong>（問題6）</strong>0x41，0x0041。UTF-8表示A佔用1個字節，UTF-16則是佔用2個字節。</p>\n<p><strong>（問題7）</strong></p>\n<p>（1）「好」<br>Windows記事本：efbb bfe5 a5bb 0a<br>Vim：e5a5 bb0a</p>\n<ul>\n<li>efbb bf 是 BOM</li>\n<li>e5 a5bb 是「好」的UTF-8 編碼，1110 0101 1010 0101 1011 1101</li>\n<li>0a 是 LF ‘\\n’，換行符</li>\n</ul>\n<p>（2）「好」+換行<br>Windows記事本：efbb bfe5 a5bb 0d0a<br>Vim：e5a5 bb0a</p>\n<ul>\n<li>0d 是 CR ‘\\r’ ，回車</li>\n</ul>\n<p>結論：</p>\n<ol>\n<li>Windows記事本中的UTF-8編碼默認是帶BOM的，而Notepad++或Vim編輯器中的UTF-8編碼是無BOM的；</li>\n<li>Windows記事本中的換行符默認是 CRLF，而Notepad++或Vim編輯器中是Unix風格的 LF。</li>\n</ol>\n<h2 id=\"延伸閱讀\"><a href=\"#延伸閱讀\" class=\"headerlink\" title=\"延伸閱讀\"></a>延伸閱讀</h2><ul>\n<li><a href=\"https://unicode-table.com/en/#basic-latin\">Unicode碼表</a></li>\n<li><a href=\"https://www.unicode.org/versions/Unicode14.0.0/\">Unicode 標準14.0.0 – unicode.org</a></li>\n<li><a href=\"https://www.unicode.org/faq/utf_bom.html\">FAQ：UTF-8, UTF-16, UTF-32 &amp; BOM – unicode.org</a></li>\n<li><a href=\"https://kkua.github.io/post/java-char-type-and-unicode/\">Java的char類型和Unicode</a></li>\n<li><a href=\"https://www.cnblogs.com/dragon2012/p/5020259.html\">utf16編碼格式</a></li>\n<li><a href=\"https://docs.kilvn.com/The-Golang-Standard-Library-by-Example/chapter02/02.5.html\">2.5 unicode — Unicode码点、UTF-8/16编码</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>開始介紹 Unicode 之前，我們先來做一道不定項選擇題。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">1</span>：請問以下說法正確的是（）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">A</span>. 所有中文字符都可用 UTF-<span class=\"number\">8</span> 編碼，並佔用 <span class=\"number\">3</span> 個字節。</span><br><span class=\"line\"><span class=\"selector-tag\">B</span>. 字符串可以直接轉成字節數組，字節數組可以直接轉成字符串。</span><br><span class=\"line\">C. 文本的編碼順序跟其書寫順序一致，不一定是按從左到右從上到下順序。</span><br><span class=\"line\">D. 帶 BOM 的文本一定是 UTF-<span class=\"number\">8</span> 編碼，不帶 BOM 的文本不一定是 UTF-<span class=\"number\">8</span> 編碼。</span><br><span class=\"line\">E. Unicode、GBK 和 UTF-<span class=\"number\">8</span> 都是不同的編碼方式。</span><br><span class=\"line\">F. UTF-<span class=\"number\">16</span> 不兼容 ASCII 碼</span><br><span class=\"line\">G. 十進制的數字可以轉成二進制，因此不需要編碼。</span><br></pre></td></tr></table></figure>\n\n<p>答案文章末尾揭曉，如果著急想對答案可以先翻到末尾核對；如果想知道為什麼，那就帶著問題繼續往下看吧。</p>\n<h2 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a>字符集</h2><p>Unicode 是一種國際通用的字符集。</p>\n<p>什麼是字符？計算機中的字符分為兩種：打印字符和非打印字符。打印字符包括數字、字母、漢字、假名、標點符號等等，非打印字符又稱之為控制字符，常見的有：回車（’\\r’，U+000D）、換行（’\\n’，U+000A）等等。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">2</span>：數字 <span class=\"number\">123</span> 由（）個字符組成？</span><br></pre></td></tr></table></figure>\n\n<p>什麼是字符集？字符集就是字符的集合，不同的字符集包含的字符類型和數量可能不一樣。Unicode 是字符集的一種。</p>\n<p>字符之所以能被計算機處理，其中最為關鍵的是字符能夠被正確地編碼和解碼。字符的編碼是字符在對應字符集中的序號。此序號是一個整數，稱之為字符碼點 （code point）。不同的字符集可能會對同樣的字符有不同的碼點表示，甚至沒有表示（並不是所有字符在字符集中都有定義）。</p>","more":"<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">3</span>：有一種語言只有五種字符，暫記錄為「金木水火土」，請自定義碼表並說明需要多少個比特位進行編碼。</span><br></pre></td></tr></table></figure>\n\n<p>有人說：直接用一個整型來表示一個字符不就可以了嗎？可以是可以，不過整型大小固定 4 個字節，浪費空間。比如數字 123 使用 ASCII 字符集需要 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"8.548ex\" height=\"1.692ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -666 3778 748\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(722.2,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(1444.4,0)\"><path data-c=\"33\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(2222.2,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(3278,0)\"><path data-c=\"33\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"/></g></g></g></svg></mjx-container> 個字節，而使用整型的方式將是 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.679ex\" height=\"1.717ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -677 4278 759\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(722.2,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(1444.4,0)\"><path data-c=\"33\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(2222.2,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(3278,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\" transform=\"translate(500,0)\"/></g></g></g></svg></mjx-container> 個字節。</p>\n<p>常見的字符集有：</p>\n<ol>\n<li>US-ASCII（ISO646-US）：美國信息交換標準代碼，1967年首次發表，1986年最後更新，7位，共 128 個字符。</li>\n<li>ISO-8859-1（ISO-LATIN-1）：1980年發表，8位，共 256 個字符，兼容 US-ASCII。</li>\n<li>GB2312：國標2312，1980年發表，共 7,445 個字符，兼容 US-ASCII；</li>\n<li>GBK：國標擴展碼，1995年發表，共 21,886 個字符，兼容 GB2312。</li>\n<li>GB18030：國標18030，採用可變長編碼，每個字由 1、2 或 4 個字節組成，2000年發表，2005年更新，共 70,244 個字符，兼容 GBK，並實現了 Unicode 2.0 定義的碼位。</li>\n<li>Unicode：統一碼，1994年發表1.0，2021年發佈14.0版本。</li>\n</ol>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><p>Unicode 碼點，取值範圍為 [U+0000, U+10FFFF]。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">4</span>：已知 Unicode碼點取值範圍為 <span class=\"selector-attr\">[U+0000, U+10FFFF]</span>，請問最多可以表示（）種字符？</span><br></pre></td></tr></table></figure>\n\n<p>Unicode 碼點使用平面（Plane）進行歸類，有：</p>\n<table>\n<thead>\n<tr>\n<th>平面</th>\n<th>始末字符值</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0號平面（Plane 0）</td>\n<td><code>U+0000</code> - <code>U+FFFF</code></td>\n<td>基本多文種平面（Basic Multilingual Plane，簡稱 BMP），保留 <code>U+D800</code> - <code>U+DFFF</code>。</td>\n</tr>\n<tr>\n<td>1號平面</td>\n<td><code>U+10000</code> - <code>U+1FFFF</code></td>\n<td>多文種補充平面（Supplementary Multilingual Plane，簡稱 SMP）</td>\n</tr>\n<tr>\n<td>2號平面</td>\n<td><code>U+20000</code> - <code>U+2FFFF</code></td>\n<td>表意文字補充平面（Supplementary Ideographic Plane，簡稱 SIP）</td>\n</tr>\n<tr>\n<td>3號平面</td>\n<td><code>U+30000</code> - <code>U+3FFFF</code></td>\n<td>表意文字第三平面（Tertiary Ideographic Plane，簡稱 TIP）</td>\n</tr>\n<tr>\n<td>4號平面~13號平面</td>\n<td><code>U+40000</code> - <code>U+DFFFF</code></td>\n<td>（尚未使用）</td>\n</tr>\n<tr>\n<td>14號平面</td>\n<td><code>U+E0000</code> - <code>U+EFFFF</code></td>\n<td>特別用途補充平面（Supplementary Special-purpose Plane，簡稱 SSP）</td>\n</tr>\n<tr>\n<td>15號平面</td>\n<td><code>U+F0000</code> - <code>U+FFFFF</code></td>\n<td>私人使用區（A區）（Private Use Area-A，簡稱 PUA-A）</td>\n</tr>\n<tr>\n<td>16號平面</td>\n<td><code>U+100000</code> - <code>U+10FFFF</code></td>\n<td>私人使用區（B區）（Private Use Area-B，簡稱 PUA-B）</td>\n</tr>\n</tbody></table>\n<p>值得注意的是：<strong>Unicode 只定義了碼點，而字符到具體的字節序列的映射由 UTF（Unicode/UCS Transformation Format 統一碼轉化格式） 實現</strong>。</p>\n<p>UTF 目前有UTF-8、UTF-16 和 UTF-32。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">5</span>：Unicode的每個平面最多可以表示（）種字符？BMP除去保留的區域外，共可以表示（）種字符？</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"UTF-8\"><a href=\"#UTF-8\" class=\"headerlink\" title=\"UTF-8\"></a>UTF-8</h2><p>UTF-8 是面向字節（8位）的 Unicode 編碼形式，使用一個、兩個、三個字節表示BMP上的字符，使用四個字節表示 BMP 外的字符。兼容 US-ASCII 字符集。</p>\n<table>\n<thead>\n<tr>\n<th>碼點位數</th>\n<th>範圍</th>\n<th>字節序列</th>\n<th>Byte 1</th>\n<th>Byte 2</th>\n<th>Byte 3</th>\n<th>Byte 4</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>7</td>\n<td><code>U+0000</code> - <code>U+007F</code></td>\n<td>1</td>\n<td><code>0xxxxxxx</code></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td><code>U+0080</code> - <code>U+07FF</code></td>\n<td>2</td>\n<td><code>110xxxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td><code>U+0800</code> - <code>U+FFFF</code></td>\n<td>3</td>\n<td><code>1110xxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td><code>U+10000</code> - <code>U+10FFFF</code></td>\n<td>4</td>\n<td><code>11110xxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>10xxxxxx</code></td>\n<td><code>10xxxxxx</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"UTF-16\"><a href=\"#UTF-16\" class=\"headerlink\" title=\"UTF-16\"></a>UTF-16</h2><p>UTF-16 使用兩個字節來表示基本多語言平面，四個字節來表示輔助平面。</p>\n<p>對於英文來說使用 UTF-8 省空間，對於中文來說UTF-16省空間，因為英文用 UTF-8 佔用 1 個字節，用 UTF-16 佔用 2 個字節；中文用 UTF-8 佔用 3 個字節，用 UTF-16 佔用 2 個字節。</p>\n<table>\n<thead>\n<tr>\n<th>碼點位數</th>\n<th>範圍</th>\n<th>UTF-16 編碼形式（二進制）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>16</td>\n<td><code>U+000000</code> - <code>U+00FFFF</code></td>\n<td><code>xxxx xxxx</code> <code>xxxx xxxx</code></td>\n</tr>\n<tr>\n<td>20</td>\n<td><code>U+010000</code> - <code>U+10FFFF</code></td>\n<td><code>1101 10yy</code> <code>yyyy yyyy</code>  <code>1101 11xx</code> <code>xxxx xxxx</code></td>\n</tr>\n</tbody></table>\n<p>對於基本多語言平面，其編碼等同於其碼位。</p>\n<p>對於輔助平面上的碼，編碼方式為：</p>\n<ol>\n<li>減去 0x10000，成二進制形式：yyyy yyyy yyxx xxxx xxxx，共 20 位。</li>\n<li>前 10 位為高位，加上 0xD800 作為前導代理(lead surrogates)，值範圍：[0xD800, 0xDBFF]</li>\n<li>後 10 位為低位，加上 0xDC00 作為後尾代理(trail surrogates)，值範圍：[0xDC00, 0xDFFF]</li>\n<li>可見前導和後尾的值不在同一個區間，最終形成：110110yyyyyyyyyy 110111xxxxxxxxxx</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">6</span>：已知字符<span class=\"selector-tag\">A</span>的Unicode碼點為 U+<span class=\"number\">0041</span>，其UTF-<span class=\"number\">8</span>編碼和UTF-<span class=\"number\">16</span>編碼分別是？</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"UTFs\"><a href=\"#UTFs\" class=\"headerlink\" title=\"UTFs\"></a>UTFs</h2><p>UTF-16 編碼包含 BE （big endian）和 LE（little endian）版本，大端者，高位字節（MSB，most significant byte）在低地址；小端者，低位字節在低地址。</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>UTF-8</th>\n<th>UTF-16</th>\n<th>UTF-16BE</th>\n<th>UTF-16LE</th>\n<th>UTF-32</th>\n<th>UTF-32BE</th>\n<th>UTF-32LE</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Smallest code point</td>\n<td>0000</td>\n<td>0000</td>\n<td>0000</td>\n<td>0000</td>\n<td>0000</td>\n<td>0000</td>\n<td>0000</td>\n</tr>\n<tr>\n<td>Largest code point</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n<td>10FFFF</td>\n</tr>\n<tr>\n<td>Code unit size</td>\n<td>8 bits</td>\n<td>16 bits</td>\n<td>16 bits</td>\n<td>16 bits</td>\n<td>32 bits</td>\n<td>32 bits</td>\n<td>32 bits</td>\n</tr>\n<tr>\n<td>Byte order</td>\n<td>N/A</td>\n<td>&lt;BOM&gt;</td>\n<td>big-endian</td>\n<td>little-endian</td>\n<td>&lt;BOM&gt;</td>\n<td>big-endian</td>\n<td>little-endian</td>\n</tr>\n<tr>\n<td>Fewest bytes per character</td>\n<td>1</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Most bytes per character</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<h2 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h2><p>BOM，即 Byte Order Mark，字節序標記，用在文本文件的開頭。該標記為字符 U+FEFF，又稱為 ZWNBSP（ZERO WIDTH NO-BREAK SPACE，零寬非換行空格），表示大端字節序；相反的，U+FFFE（Noncharacters，非字符）表示小端字節序。</p>\n<p>BOM字符的 UTF-8 編碼為 EF BB BF。UTF-8有 BOM編碼的文件會以 BOM 字符開頭。</p>\n<p>UTF-8 不需要 BOM 來指定是小端還是大端字節序，但是可以通過 BOM 來區分是 UTF-8 編碼還是其他編碼。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">問題<span class=\"number\">7</span>：請完成下列實操，並說說你對UTF-<span class=\"number\">8</span>編碼、BOM和CRLF的理解</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>. 在 Windows 中打開記事本，輸入「好」，然後另存為 UTF-<span class=\"number\">8</span> 編碼的文本文件 <span class=\"selector-tag\">a</span><span class=\"selector-class\">.txt</span>；</span><br><span class=\"line\"><span class=\"number\">2</span>. 使用 vim 打開 <span class=\"selector-tag\">a</span><span class=\"selector-class\">.txt</span>，執行命令 「%!xxd」 可以將文本轉為 <span class=\"number\">16</span> 進制形式；</span><br><span class=\"line\"><span class=\"number\">3</span>. 閱讀並嘗試解讀該 <span class=\"number\">16</span> 進制串；</span><br><span class=\"line\"><span class=\"number\">4</span>. 使用 notepad++ 或 vim 創建一個 <span class=\"selector-tag\">b</span><span class=\"selector-class\">.txt</span>，輸入「好」，按同樣方式獲取並解讀 <span class=\"number\">16</span> 進制串；</span><br><span class=\"line\"><span class=\"number\">5</span>. 在 <span class=\"selector-tag\">a</span><span class=\"selector-class\">.txt</span> 和 <span class=\"selector-tag\">b</span><span class=\"selector-class\">.txt</span> 中增加一個換行，再次獲取並解讀 <span class=\"number\">16</span> 進制串。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"問題答案\"><a href=\"#問題答案\" class=\"headerlink\" title=\"問題答案\"></a>問題答案</h2><p><strong>（問題1）</strong>CF。Unicode 採用邏輯序（logical order）編碼文本，比如會對英文從左到右編碼，而對希伯來文從右到左編碼，見：<a href=\"http://www.unicode.org/versions/Unicode3.0.0/ch02.pdf。UTF-16\">http://www.unicode.org/versions/Unicode3.0.0/ch02.pdf。UTF-16</a> 編碼至少需要 2 個字節，ASCII 碼只需要 1 個字節，不兼容。</p>\n<p><strong>（問題2）</strong>3。很明顯1、2、3分別是3個字符。</p>\n<p><strong>（問題3）</strong>3。計算過程：<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.09ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.403ex\" height=\"1.977ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -833.9 5040.2 873.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msup\"><g data-mml-node=\"mn\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(533,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"/></g></g><g data-mml-node=\"mo\" transform=\"translate(1214.3,0)\"><path data-c=\"3C\" d=\"M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(2270.1,0)\"><path data-c=\"35\" d=\"M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(3047.9,0)\"><path data-c=\"3C\" d=\"M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z\"/></g><g data-mml-node=\"msup\" transform=\"translate(4103.7,0)\"><g data-mml-node=\"mn\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(533,363) scale(0.707)\"><path data-c=\"33\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"/></g></g></g></g></svg></mjx-container>, 可編碼爲：000 金、001 木、010 水、011 火、100 土，剩餘 101、110 和 111 三個碼點。</p>\n<p><strong>（問題4）</strong>1,114,112。計算過程：<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.266ex\" height=\"2.158ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -871.8 4095.6 953.8\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msup\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\" transform=\"translate(500,0)\"/></g><g data-mml-node=\"mn\" transform=\"translate(1033,393.1) scale(0.707)\"><path data-c=\"35\" d=\"M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z\"/></g></g><g data-mml-node=\"mo\" transform=\"translate(1658.8,0)\"><path data-c=\"2B\" d=\"M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z\"/></g><g data-mml-node=\"msup\" transform=\"translate(2659,0)\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\" transform=\"translate(500,0)\"/></g><g data-mml-node=\"mn\" transform=\"translate(1033,393.1) scale(0.707)\"><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\"/></g></g></g></g></svg></mjx-container></p>\n<p><strong>（問題5）</strong>65536，63488。計算過程：<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"20.31ex\" height=\"2.538ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -871.8 8977 1121.8\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msup\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\" transform=\"translate(500,0)\"/></g><g data-mml-node=\"mn\" transform=\"translate(1033,393.1) scale(0.707)\"><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\"/></g></g><g data-mml-node=\"mo\" transform=\"translate(1658.8,0)\"><path data-c=\"2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(2659,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"/></g><g data-mml-node=\"msup\" transform=\"translate(3048,0)\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\" transform=\"translate(500,0)\"/></g><g data-mml-node=\"mn\" transform=\"translate(1033,393.1) scale(0.707)\"><path data-c=\"33\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"/></g></g><g data-mml-node=\"mo\" transform=\"translate(4706.8,0)\"><path data-c=\"2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(5707,0)\"><path data-c=\"38\" d=\"M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(6429.2,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"/></g><g data-mml-node=\"msup\" transform=\"translate(7151.4,0)\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\" transform=\"translate(500,0)\"/></g><g data-mml-node=\"mn\" transform=\"translate(1033,393.1) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"/></g></g><g data-mml-node=\"mo\" transform=\"translate(8588,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"/></g></g></g></svg></mjx-container></p>\n<p><strong>（問題6）</strong>0x41，0x0041。UTF-8表示A佔用1個字節，UTF-16則是佔用2個字節。</p>\n<p><strong>（問題7）</strong></p>\n<p>（1）「好」<br>Windows記事本：efbb bfe5 a5bb 0a<br>Vim：e5a5 bb0a</p>\n<ul>\n<li>efbb bf 是 BOM</li>\n<li>e5 a5bb 是「好」的UTF-8 編碼，1110 0101 1010 0101 1011 1101</li>\n<li>0a 是 LF ‘\\n’，換行符</li>\n</ul>\n<p>（2）「好」+換行<br>Windows記事本：efbb bfe5 a5bb 0d0a<br>Vim：e5a5 bb0a</p>\n<ul>\n<li>0d 是 CR ‘\\r’ ，回車</li>\n</ul>\n<p>結論：</p>\n<ol>\n<li>Windows記事本中的UTF-8編碼默認是帶BOM的，而Notepad++或Vim編輯器中的UTF-8編碼是無BOM的；</li>\n<li>Windows記事本中的換行符默認是 CRLF，而Notepad++或Vim編輯器中是Unix風格的 LF。</li>\n</ol>\n<h2 id=\"延伸閱讀\"><a href=\"#延伸閱讀\" class=\"headerlink\" title=\"延伸閱讀\"></a>延伸閱讀</h2><ul>\n<li><a href=\"https://unicode-table.com/en/#basic-latin\">Unicode碼表</a></li>\n<li><a href=\"https://www.unicode.org/versions/Unicode14.0.0/\">Unicode 標準14.0.0 – unicode.org</a></li>\n<li><a href=\"https://www.unicode.org/faq/utf_bom.html\">FAQ：UTF-8, UTF-16, UTF-32 &amp; BOM – unicode.org</a></li>\n<li><a href=\"https://kkua.github.io/post/java-char-type-and-unicode/\">Java的char類型和Unicode</a></li>\n<li><a href=\"https://www.cnblogs.com/dragon2012/p/5020259.html\">utf16編碼格式</a></li>\n<li><a href=\"https://docs.kilvn.com/The-Golang-Standard-Library-by-Example/chapter02/02.5.html\">2.5 unicode — Unicode码点、UTF-8/16编码</a></li>\n</ul>"},{"title":"Concurrency in Go","date":"2021-09-08T13:41:30.000Z","p":"it/go/concurrency-in-go.md","_content":"\n*Concurrency in Go* is an excellent book written by Katherine Cox-Buday. And It is impressive and drive me to learn deeply about Go.\n\n《Go並發編程》是凱瑟琳·考克斯布迪執筆的一本絕好的書籍。此書令我印象深刻，並驅使我深入學習Go。\n\n<!--more-->\n\nLet's get a bird's eye view of this book at first. There are six topics we should care about, including:\n\n1. Troubles we face when using concurrency\n2. Go's philosophy on concurrency\n3. Go's tools on concurrency\n4. Concurrency patterns in Go\n5. Concurrency at scale\n6. How goroutine works\n\n我們先來總覽此書，有六項我們需要關注的主題，包含：\n\n1. 並發面臨的問題\n2. Go的並發哲學\n3. Go的並發工具\n4. 基於Go的並發模式\n5. 大規模並發\n6. goroutine如何工作\n\n##Troubles we face when using concurrency (並發面臨的問題)\n\nConcurrency is hard but significant. It is the multicore processors' time, and Moore's Law had come to end. We should improve our program's performance by taking full advantage of multicore. According to Amdahl's Law, the program's potential performance gains from implementing solution to a problem in parallel manner. \n\n並發難而重要。這是一個多核處理器的時代，摩爾定律已經過時了。我們應該通過充分利用多核心來提升程序的性能。據阿姆達爾定律，程序潛在性能從用並行的方式實現問題的解決方案獲得。\n\n\nWhat concurrency troubles us is that it force us to take attention to what we don't need to care before:\n\n1. Race condition\n2. Atomicity\n3. Memory access synchronization\n4. Deadlock, livelock, and starvation\n\n並發困擾我們之處在於其迫使我們關注我們之前無需關心的東西：\n\n1. 競態\n2. 原子性\n3. 內存訪問同步\n4. 死鎖、活鎖及餓死\n\n\nThe so-called race condition is the problem occurred  when two or more operations must be executed in order, but the program doesn't guarantee it. For Example:\n\n所謂競態就是當兩項或多項操作是有序的而程序未能保證其有序執行而引發的錯誤情況。例如：\n\n```go\nvar data = 0\ngo func(){\n  data++\n}()\n// maybe sleep a while, so that you can find the problem\n// time.Sleep(1*time.Second)\nprintln(data)\n```\n\nWe cannot guarantee that the write operation to data or the read operation is the first, because they're run in concurrency, so it causes the race condition and the undetermined result.\n\n因對 data 的寫操作和讀操作是並發的，我們無法保證誰先誰後，因而產生競態和結果的不確定性。\n\nAtomicity means that the operation is indivisible and uninterruptible in particular context. \n\n原子性意味著操作在特定的上下文中是不可分割和不可中斷的。這裏要強調下上下文，因為在進程中爲具備原子性的操作，在操作系統中可能不是；在操作系統中是的，在機器中可能不是；在機器中是的，在整個應用中可能不是。\n\n大部分語句都不具備原子性，比如函數、方法等，又比如 i++（可以分爲取值、增值和賦值三個操作）。\n\nCritical section, the section of program that needs to exclusive access to a shared resource.\n\n臨界區段：需要獨佔訪問共享資源的代碼段。\n\n可以通過內存訪問同步可以解決數據爭用（data race），但無法解決競態（race condition）。如下：\n\n```go\nvar memoryAccess sync.Mutex\nvar value int\ngo func(){\n  memoryAccess.Lock()\n  value++\n  memoryAccess.Unlock()\n}()\n\nmemoryAccess.Lock()\nif value == 0{\n  fmt.Printf(\"the value is %d.\\n\", value)\n}else{\n  fmt.Printf(\"the value is %d.\\n\", value)\n}\nmemoryAccess.Unlock()\n```\n\n\n\n死鎖是並發的進程相互等待的情況。\n\n死鎖的四個條件：\n\n1. 互斥：資源是互斥訪問的\n2. 等待條件：進程持有一項資源的同時又等待另一項資源\n3. 不可搶佔：資源一旦被一個進程持有，其他進程不可搶佔，只能等待持有者釋放\n4. 循環等待：進程間相互持有對方所需的資源。\n\n條件1和3是描述資源的屬性，互斥訪問且不可搶佔；條件2和4描述進程的狀況，持有對方需要的資源的同時又在等待對方持有的資源。\n\n\n\n活鎖是並發的進程仍在運行，但沒能改變程序的狀態。\n\n餓死是一個並發的進程無法獲取需要的所有資源以進行工作。死鎖及活鎖情況下，所有進程都是同等餓死，沒有工作是可以完成的。\n\n## Go的並發哲學\n\n","source":"_posts/it/go/concurrency-in-go.md","raw":"---\ntitle: Concurrency in Go\ndate: 2021-09-08 21:41:30\np: it/go/concurrency-in-go.md\ntags:\n- Go\n- TODO\n---\n\n*Concurrency in Go* is an excellent book written by Katherine Cox-Buday. And It is impressive and drive me to learn deeply about Go.\n\n《Go並發編程》是凱瑟琳·考克斯布迪執筆的一本絕好的書籍。此書令我印象深刻，並驅使我深入學習Go。\n\n<!--more-->\n\nLet's get a bird's eye view of this book at first. There are six topics we should care about, including:\n\n1. Troubles we face when using concurrency\n2. Go's philosophy on concurrency\n3. Go's tools on concurrency\n4. Concurrency patterns in Go\n5. Concurrency at scale\n6. How goroutine works\n\n我們先來總覽此書，有六項我們需要關注的主題，包含：\n\n1. 並發面臨的問題\n2. Go的並發哲學\n3. Go的並發工具\n4. 基於Go的並發模式\n5. 大規模並發\n6. goroutine如何工作\n\n##Troubles we face when using concurrency (並發面臨的問題)\n\nConcurrency is hard but significant. It is the multicore processors' time, and Moore's Law had come to end. We should improve our program's performance by taking full advantage of multicore. According to Amdahl's Law, the program's potential performance gains from implementing solution to a problem in parallel manner. \n\n並發難而重要。這是一個多核處理器的時代，摩爾定律已經過時了。我們應該通過充分利用多核心來提升程序的性能。據阿姆達爾定律，程序潛在性能從用並行的方式實現問題的解決方案獲得。\n\n\nWhat concurrency troubles us is that it force us to take attention to what we don't need to care before:\n\n1. Race condition\n2. Atomicity\n3. Memory access synchronization\n4. Deadlock, livelock, and starvation\n\n並發困擾我們之處在於其迫使我們關注我們之前無需關心的東西：\n\n1. 競態\n2. 原子性\n3. 內存訪問同步\n4. 死鎖、活鎖及餓死\n\n\nThe so-called race condition is the problem occurred  when two or more operations must be executed in order, but the program doesn't guarantee it. For Example:\n\n所謂競態就是當兩項或多項操作是有序的而程序未能保證其有序執行而引發的錯誤情況。例如：\n\n```go\nvar data = 0\ngo func(){\n  data++\n}()\n// maybe sleep a while, so that you can find the problem\n// time.Sleep(1*time.Second)\nprintln(data)\n```\n\nWe cannot guarantee that the write operation to data or the read operation is the first, because they're run in concurrency, so it causes the race condition and the undetermined result.\n\n因對 data 的寫操作和讀操作是並發的，我們無法保證誰先誰後，因而產生競態和結果的不確定性。\n\nAtomicity means that the operation is indivisible and uninterruptible in particular context. \n\n原子性意味著操作在特定的上下文中是不可分割和不可中斷的。這裏要強調下上下文，因為在進程中爲具備原子性的操作，在操作系統中可能不是；在操作系統中是的，在機器中可能不是；在機器中是的，在整個應用中可能不是。\n\n大部分語句都不具備原子性，比如函數、方法等，又比如 i++（可以分爲取值、增值和賦值三個操作）。\n\nCritical section, the section of program that needs to exclusive access to a shared resource.\n\n臨界區段：需要獨佔訪問共享資源的代碼段。\n\n可以通過內存訪問同步可以解決數據爭用（data race），但無法解決競態（race condition）。如下：\n\n```go\nvar memoryAccess sync.Mutex\nvar value int\ngo func(){\n  memoryAccess.Lock()\n  value++\n  memoryAccess.Unlock()\n}()\n\nmemoryAccess.Lock()\nif value == 0{\n  fmt.Printf(\"the value is %d.\\n\", value)\n}else{\n  fmt.Printf(\"the value is %d.\\n\", value)\n}\nmemoryAccess.Unlock()\n```\n\n\n\n死鎖是並發的進程相互等待的情況。\n\n死鎖的四個條件：\n\n1. 互斥：資源是互斥訪問的\n2. 等待條件：進程持有一項資源的同時又等待另一項資源\n3. 不可搶佔：資源一旦被一個進程持有，其他進程不可搶佔，只能等待持有者釋放\n4. 循環等待：進程間相互持有對方所需的資源。\n\n條件1和3是描述資源的屬性，互斥訪問且不可搶佔；條件2和4描述進程的狀況，持有對方需要的資源的同時又在等待對方持有的資源。\n\n\n\n活鎖是並發的進程仍在運行，但沒能改變程序的狀態。\n\n餓死是一個並發的進程無法獲取需要的所有資源以進行工作。死鎖及活鎖情況下，所有進程都是同等餓死，沒有工作是可以完成的。\n\n## Go的並發哲學\n\n","slug":"it/go/concurrency-in-go","published":1,"updated":"2021-09-27T14:06:06.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlew000k1n9kfqbbf5ie","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><em>Concurrency in Go</em> is an excellent book written by Katherine Cox-Buday. And It is impressive and drive me to learn deeply about Go.</p>\n<p>《Go並發編程》是凱瑟琳·考克斯布迪執筆的一本絕好的書籍。此書令我印象深刻，並驅使我深入學習Go。</p>\n<span id=\"more\"></span>\n\n<p>Let’s get a bird’s eye view of this book at first. There are six topics we should care about, including:</p>\n<ol>\n<li>Troubles we face when using concurrency</li>\n<li>Go’s philosophy on concurrency</li>\n<li>Go’s tools on concurrency</li>\n<li>Concurrency patterns in Go</li>\n<li>Concurrency at scale</li>\n<li>How goroutine works</li>\n</ol>\n<p>我們先來總覽此書，有六項我們需要關注的主題，包含：</p>\n<ol>\n<li>並發面臨的問題</li>\n<li>Go的並發哲學</li>\n<li>Go的並發工具</li>\n<li>基於Go的並發模式</li>\n<li>大規模並發</li>\n<li>goroutine如何工作</li>\n</ol>\n<p>##Troubles we face when using concurrency (並發面臨的問題)</p>\n<p>Concurrency is hard but significant. It is the multicore processors’ time, and Moore’s Law had come to end. We should improve our program’s performance by taking full advantage of multicore. According to Amdahl’s Law, the program’s potential performance gains from implementing solution to a problem in parallel manner. </p>\n<p>並發難而重要。這是一個多核處理器的時代，摩爾定律已經過時了。我們應該通過充分利用多核心來提升程序的性能。據阿姆達爾定律，程序潛在性能從用並行的方式實現問題的解決方案獲得。</p>\n<p>What concurrency troubles us is that it force us to take attention to what we don’t need to care before:</p>\n<ol>\n<li>Race condition</li>\n<li>Atomicity</li>\n<li>Memory access synchronization</li>\n<li>Deadlock, livelock, and starvation</li>\n</ol>\n<p>並發困擾我們之處在於其迫使我們關注我們之前無需關心的東西：</p>\n<ol>\n<li>競態</li>\n<li>原子性</li>\n<li>內存訪問同步</li>\n<li>死鎖、活鎖及餓死</li>\n</ol>\n<p>The so-called race condition is the problem occurred  when two or more operations must be executed in order, but the program doesn’t guarantee it. For Example:</p>\n<p>所謂競態就是當兩項或多項操作是有序的而程序未能保證其有序執行而引發的錯誤情況。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  data++</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"comment\">// maybe sleep a while, so that you can find the problem</span></span><br><span class=\"line\"><span class=\"comment\">// time.Sleep(1*time.Second)</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(data)</span><br></pre></td></tr></table></figure>\n\n<p>We cannot guarantee that the write operation to data or the read operation is the first, because they’re run in concurrency, so it causes the race condition and the undetermined result.</p>\n<p>因對 data 的寫操作和讀操作是並發的，我們無法保證誰先誰後，因而產生競態和結果的不確定性。</p>\n<p>Atomicity means that the operation is indivisible and uninterruptible in particular context. </p>\n<p>原子性意味著操作在特定的上下文中是不可分割和不可中斷的。這裏要強調下上下文，因為在進程中爲具備原子性的操作，在操作系統中可能不是；在操作系統中是的，在機器中可能不是；在機器中是的，在整個應用中可能不是。</p>\n<p>大部分語句都不具備原子性，比如函數、方法等，又比如 i++（可以分爲取值、增值和賦值三個操作）。</p>\n<p>Critical section, the section of program that needs to exclusive access to a shared resource.</p>\n<p>臨界區段：需要獨佔訪問共享資源的代碼段。</p>\n<p>可以通過內存訪問同步可以解決數據爭用（data race），但無法解決競態（race condition）。如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> memoryAccess sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> value <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  memoryAccess.Lock()</span><br><span class=\"line\">  value++</span><br><span class=\"line\">  memoryAccess.Unlock()</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">memoryAccess.Lock()</span><br><span class=\"line\"><span class=\"keyword\">if</span> value == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;the value is %d.\\n&quot;</span>, value)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;the value is %d.\\n&quot;</span>, value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">memoryAccess.Unlock()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>死鎖是並發的進程相互等待的情況。</p>\n<p>死鎖的四個條件：</p>\n<ol>\n<li>互斥：資源是互斥訪問的</li>\n<li>等待條件：進程持有一項資源的同時又等待另一項資源</li>\n<li>不可搶佔：資源一旦被一個進程持有，其他進程不可搶佔，只能等待持有者釋放</li>\n<li>循環等待：進程間相互持有對方所需的資源。</li>\n</ol>\n<p>條件1和3是描述資源的屬性，互斥訪問且不可搶佔；條件2和4描述進程的狀況，持有對方需要的資源的同時又在等待對方持有的資源。</p>\n<p>活鎖是並發的進程仍在運行，但沒能改變程序的狀態。</p>\n<p>餓死是一個並發的進程無法獲取需要的所有資源以進行工作。死鎖及活鎖情況下，所有進程都是同等餓死，沒有工作是可以完成的。</p>\n<h2 id=\"Go的並發哲學\"><a href=\"#Go的並發哲學\" class=\"headerlink\" title=\"Go的並發哲學\"></a>Go的並發哲學</h2>","site":{"data":{}},"excerpt":"<p><em>Concurrency in Go</em> is an excellent book written by Katherine Cox-Buday. And It is impressive and drive me to learn deeply about Go.</p>\n<p>《Go並發編程》是凱瑟琳·考克斯布迪執筆的一本絕好的書籍。此書令我印象深刻，並驅使我深入學習Go。</p>","more":"<p>Let’s get a bird’s eye view of this book at first. There are six topics we should care about, including:</p>\n<ol>\n<li>Troubles we face when using concurrency</li>\n<li>Go’s philosophy on concurrency</li>\n<li>Go’s tools on concurrency</li>\n<li>Concurrency patterns in Go</li>\n<li>Concurrency at scale</li>\n<li>How goroutine works</li>\n</ol>\n<p>我們先來總覽此書，有六項我們需要關注的主題，包含：</p>\n<ol>\n<li>並發面臨的問題</li>\n<li>Go的並發哲學</li>\n<li>Go的並發工具</li>\n<li>基於Go的並發模式</li>\n<li>大規模並發</li>\n<li>goroutine如何工作</li>\n</ol>\n<p>##Troubles we face when using concurrency (並發面臨的問題)</p>\n<p>Concurrency is hard but significant. It is the multicore processors’ time, and Moore’s Law had come to end. We should improve our program’s performance by taking full advantage of multicore. According to Amdahl’s Law, the program’s potential performance gains from implementing solution to a problem in parallel manner. </p>\n<p>並發難而重要。這是一個多核處理器的時代，摩爾定律已經過時了。我們應該通過充分利用多核心來提升程序的性能。據阿姆達爾定律，程序潛在性能從用並行的方式實現問題的解決方案獲得。</p>\n<p>What concurrency troubles us is that it force us to take attention to what we don’t need to care before:</p>\n<ol>\n<li>Race condition</li>\n<li>Atomicity</li>\n<li>Memory access synchronization</li>\n<li>Deadlock, livelock, and starvation</li>\n</ol>\n<p>並發困擾我們之處在於其迫使我們關注我們之前無需關心的東西：</p>\n<ol>\n<li>競態</li>\n<li>原子性</li>\n<li>內存訪問同步</li>\n<li>死鎖、活鎖及餓死</li>\n</ol>\n<p>The so-called race condition is the problem occurred  when two or more operations must be executed in order, but the program doesn’t guarantee it. For Example:</p>\n<p>所謂競態就是當兩項或多項操作是有序的而程序未能保證其有序執行而引發的錯誤情況。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  data++</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"comment\">// maybe sleep a while, so that you can find the problem</span></span><br><span class=\"line\"><span class=\"comment\">// time.Sleep(1*time.Second)</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>(data)</span><br></pre></td></tr></table></figure>\n\n<p>We cannot guarantee that the write operation to data or the read operation is the first, because they’re run in concurrency, so it causes the race condition and the undetermined result.</p>\n<p>因對 data 的寫操作和讀操作是並發的，我們無法保證誰先誰後，因而產生競態和結果的不確定性。</p>\n<p>Atomicity means that the operation is indivisible and uninterruptible in particular context. </p>\n<p>原子性意味著操作在特定的上下文中是不可分割和不可中斷的。這裏要強調下上下文，因為在進程中爲具備原子性的操作，在操作系統中可能不是；在操作系統中是的，在機器中可能不是；在機器中是的，在整個應用中可能不是。</p>\n<p>大部分語句都不具備原子性，比如函數、方法等，又比如 i++（可以分爲取值、增值和賦值三個操作）。</p>\n<p>Critical section, the section of program that needs to exclusive access to a shared resource.</p>\n<p>臨界區段：需要獨佔訪問共享資源的代碼段。</p>\n<p>可以通過內存訪問同步可以解決數據爭用（data race），但無法解決競態（race condition）。如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> memoryAccess sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> value <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  memoryAccess.Lock()</span><br><span class=\"line\">  value++</span><br><span class=\"line\">  memoryAccess.Unlock()</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">memoryAccess.Lock()</span><br><span class=\"line\"><span class=\"keyword\">if</span> value == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;the value is %d.\\n&quot;</span>, value)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;the value is %d.\\n&quot;</span>, value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">memoryAccess.Unlock()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>死鎖是並發的進程相互等待的情況。</p>\n<p>死鎖的四個條件：</p>\n<ol>\n<li>互斥：資源是互斥訪問的</li>\n<li>等待條件：進程持有一項資源的同時又等待另一項資源</li>\n<li>不可搶佔：資源一旦被一個進程持有，其他進程不可搶佔，只能等待持有者釋放</li>\n<li>循環等待：進程間相互持有對方所需的資源。</li>\n</ol>\n<p>條件1和3是描述資源的屬性，互斥訪問且不可搶佔；條件2和4描述進程的狀況，持有對方需要的資源的同時又在等待對方持有的資源。</p>\n<p>活鎖是並發的進程仍在運行，但沒能改變程序的狀態。</p>\n<p>餓死是一個並發的進程無法獲取需要的所有資源以進行工作。死鎖及活鎖情況下，所有進程都是同等餓死，沒有工作是可以完成的。</p>\n<h2 id=\"Go的並發哲學\"><a href=\"#Go的並發哲學\" class=\"headerlink\" title=\"Go的並發哲學\"></a>Go的並發哲學</h2>"},{"title":"《Go 設計與實現》筆記之第一章 準備工作","p":"it/go/go-design-and-implementation-01.md","date":"2021-01-02T04:15:00.000Z","_content":"\n深入學習 Go 語言的設計與實現之前要準備以下工作：\n\n1. 克隆 Go 倉庫源代碼並編譯它。\n2. 了解 Plan 9 彙編，知道 Go 的棧結構並能分析代碼的執行過程。\n\n彙編者，二進制代碼的文本形式也，其最大的特點就是不可移植。Plan 9 彙編是貝爾實驗室的九號計劃的產物，目前被用於 Go 程序編譯的中間代碼，因爲 Go 的作者 Rob Pike，同時也是 Plan 9 彙編的作者。\n\nPlan 9 彙編指令與 Intel 等彙編等的不同在於：\n\n1. 一般情況下，命令的源操作數在先，目的操作數在後。 如同樣是將十六進制的 10 傳送到 AX寄存器，在 Plan 9 中是 `MOVQ $0x10, AX` ，而在 Intel 彙編中是 `mov rax, 0x10` 。\n2.  棧的調整通過硬件 SP 寄存器進行加減運算實現。而 Intel 彙編中通過 push 和 pop 命令實現。\n3. 操作的數據長度取決於命令的後綴。而 Intel 彙編取決於寄存器。\n\n    ```go\n    // plan 9 彙編\n    MOVB $1, DI      // 1 byte\n    MOVW $0x10, BX   // 2 bytes\n    MOVD $1, DX      // 4 bytes\n    MOVQ $-10, AX     // 8 bytes\n\n    // intel 彙編\n    mov rax, 0x1   // 8 bytes\n    mov eax, 0x100 // 4 bytes\n    mov ax, 0x22   // 2 bytes\n    mov ah, 0x33   // 1 byte\n    mov al, 0x44   // 1 byte\n    ```\n\n通過分析 Plan 9 彙編代碼我們可以繪製出如下的棧結構：\n\n![](go-design-and-implementation-01/Untitled.png)\n\n<!-- more -->\n\n## 1.1 調試 Go 語言\n\n### **1.1.1 克隆 go 倉庫並查看代碼行數**\n\ncloc (Count Lines of Code) 工具可以計算源代碼行數。執行後可知 Go 源代碼超過 140 萬行。\n\n```bash\n$ git clone https://github.com/golang/go.git\n$ cloc go/src\n6277 text files.\n6156 unique files.\n1298 files ignored.\n# 省略部分內容\n-----------------------------------------------------------------------------------\nLanguage                         files          blank        comment           code\n-----------------------------------------------------------------------------------\nGo                                4340         143352         253857        1412372\nAssembly                           497          12862          18550         108301\nC                                   68            763            599           4745\n# 省略部分內容\n```\n\n### 1.1.2 編譯源碼\n\n在源代碼中找到 fmt 包，修改 Println 函數如下：\n\n```bash\nfunc Println(a ...interface{}) (n int, err error) {\n\tprintln(\"draven\")\n\treturn Fprintln(os.Stdout, a...)\n}\n```\n\n隨後執行  `./src/make.bash` 編譯源代碼，成功之後用編譯出來的 Go 二進制文件來執行你的代碼：\n\n```bash\n$ cat main.go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello World\")\n}\n$ src/github.com/golang/go/bin/go run main.go\ndraven\nHello World\n```\n\n## 1.2 Plan 9 彙編\n\n### **1.2.1 彙編**\n\n在正式學習 Plan 9 彙編之前，建議先看下阮一峰老師的[《汇编语言入门教程》](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)以理解以下結論：\n\n1. 匯編語言是二進制指令的文本形式。\n2. 較之CPU 緩存，CPU 訪問寄存器速度更快且不需要尋址。\n3. 寄存器依靠名稱而不是地址來區分數據。\n4. 內存中的堆自下而上分配，棧自上而下分配。\n\n    ![](go-design-and-implementation-01/Untitled%201.png)\n\n### **1.2.2 Plan 9**\n\nPlan 9，貝爾實驗室九號計劃，是一個基於 Unix 的分布式操作系統，該系統開源但並未商業化使用。Go 語言的作者 Rob Pike 是其帶領者之一。\n\nGo 使用了 Plan 9 彙編作爲中間代碼，最後再編譯成二進制代碼。了解 Plan 9 彙編有助於分析 Go 語言的底層實現和排查問題。\n\n彙編語言具有不可移植性，各個平台上的平台指令集和寄存器都不一樣。學習時我們以 Linux amd64 爲例。\n\n### **1.2.3 寄存器**\n\namd64 上的寄存器有：\n\n1. **AX**：累加寄存器(AccumulatorRegister)，用於存放數據，包括算術、操作數、結果和臨時存放地址。\n2. **BX**：基址寄存器(BaseRegister)，用於存放訪問存儲器時的地址。\n3. **CX**：計數寄存器(CountRegister)，用於保存計算值，用作計數器。\n4. **DX**：數據寄存器(DataRegister)，用於數據傳遞，在寄存器間接尋址中的I/O指令中存放I/O端口的地址。\n5. DI：目的寄存器(DestinationIndex)，用於存放目的操作數的偏移地址。\n6. SI：源變址寄存器(SourceIndex)，用於存放源操作數的偏移地址。\n7. **BP：**棧基指針(BasePointer)，保存在進入函數前的棧頂基址。\n8. **SP：**棧指針(StackPointer)，指向當前棧幀的局部變量的開始位置。如果是symbol+offset(SP)的形式表示**偽寄存器**，offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间；如果是offset(SP)的形式表示**硬件寄存器**。（注意：對於編譯輸出(`go tool compile -S / go tool objdump`)的代碼來講，目前所有的 SP 都是硬件寄存器 SP，無論是否帶 symbol）\n9. **FP**：棧幀指針(FramePointer)，偽寄存器。指向引用函數的輸入參數，形式是symbol+offset(FP)，例如 arg0+0(FP)。\n10. SB：靜態基指針(StaticBasePointer)，偽寄存器。一般用來聲明函數或全局變量。\n11. PC：程序計數器(ProgramCounter)，偽寄存器。存放下一條指令的地址。\n12. R8\n13. R9\n14. R10\n\n**偽寄存器**(pseudo register)：僞寄存器與平台無關，只在生成目標代碼時才與平台上的硬件寄存器對應起來。Plan 9 彙編有四個偽寄存器，FP、SP、SB、PC。FP 存放引用函數的輸入參數，SP 存放當前棧幀的局部變量的開始位置，SB 聲明函數和全局變量，PC 存放下一條指令的地址。\n\n### **1.2.4 基本指令**\n\n1. **棧調整**\n\n    通過對 SP 寄存器進行操作實現，這與 intle 或 AT&T 匯編不同，他們是使用 push、pop 指令實現。\n\n    ```go\n    SUBQ $0x18, SP // 對 SP 做減法，為函數分配函數棧幀\n    ...               // 省略無用代碼\n    ADDQ $0x18, SP // 對 SP 做加法，清除函數棧幀\n    ```\n\n    注意：SP 一開始處於棧頂且棧是自上而下分配的，所以要通過減法分配棧幀，通過加法清除棧幀。示意圖如下：\n\n    ![](go-design-and-implementation-01/Untitled%202.png)\n\n2. **數據搬運**\n\n    將源操作數複製到目的操作數。Plan 9 中用 `$num` 形式表示常數，默認爲十進制，也可用 `$0x123` 形式表示十六進制。搬運的長度由 `MOV` 的後綴決定。\n\n    格式：`MOVB source destination`\n\n    ```go\n    // move byte\n    // 搬運一個字節長\n    MOVB $1, DI\n    // move word = 2 bytes\n    // 搬運一個字長\n    MOVW $0x10, BX\n    // move double word = 4 bytes\n    // 搬運兩倍字長\n    MOVD $1, DX\n    // move quad word = 8 bytes\n    // 搬運四倍字長\n    MOVQ $-10, AX\n    ```\n\n3. **地址傳送**\n\n    將源操作數的地址複製到目的操作數。\n\n    > lea is an abbreviation of \"load effective address\"。— [Stack Overflow](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwif6oDs8PbtAhWNzIsBHb-kDG0QFjADegQICBAC&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F1658294%2Fwhats-the-purpose-of-the-lea-instruction&usg=AOvVaw1XNxphxiOi5AcnWxGpYRbV)\n\n    ```go\n    // 把AX內容的地址傳送到BX中\n    LEAQ AX, BX\n    ```\n\n4. **計算**\n\n    ```go\n    // add quad word from AX to BX\n    // BX += AX\n    ADDQ  AX, BX\n    // subtract quad word from AX to BX\n    // BX -= AX\n    SUBQ  AX, BX\n    // 無符號乘法 IMUL\n    // BX *= AX\n    IMULQ AX, BX\n    // 無符號除法 IDIV\n    // 除數是CX，被除數是AX，結果存儲到AX中\n    IDIVQ CX\n    // 比較SI和CX的大小。與SUBQ類似，只是不賦值\n    // 其結果會存放到寄存器中\n    CMPQ SI CX\n    ```\n\n5. **跳轉**\n\n    ```go\n    // -- 無條件跳轉 -- \n    // 跳轉到地址，地址可為代碼中的地址，不過實際上手寫不會出現這種東西\n    JMP addr\n    // 跳轉到標籤，可以跳轉到同一函數內的標籤位置\n    JMP label\n    // 以當前指令為基礎，向前跳轉 x 行\n    JMP 2(PC)\n    // 以當前指令為基礎，向後跳轉 x 行\n    JMP -2(PC)\n\n    // -- 有條件跳轉 --\n    // jump target if zero\n    // 如果 zero flag 被 set 過，則跳轉\n    JZ target\n    // jump target if less\n    // 上一行的比較CMP結果，左邊小於右邊則執行跳到0x0185地址處(十進制389轉換成十六進制0x0185)\n    JLS 389\n    ```\n\n6. **指令集**\n\n    見源代碼的 [arch 部分](https://github.com/golang/arch/blob/master/x86/x86.csv)。\n\n### 1.2.5 **案例分析：函數調用**\n\n編寫以下代碼於 call.go 文件：\n\n```go\npackage main\n\nfunc Callee(x, y int) int {\n\tr := x + y\n\treturn r\n}\n\nfunc Caller() {\n\tCallee(1, 2)\n}\n```\n\n執行以下命令可查看彙編代碼：\n\n```go\n// -S 輸出彙編代碼到控制台 Print assembly listing to standard output (code only).\n// -l 禁止內聯 Disable inlining.\n// -N 禁止優化 Disable optimizations.\n// 更多參數：https://pkg.go.dev/cmd/compile@go1.15.6\ngo build -gcflags=\"-S -l -N\" call.go\n```\n\n輸出結果爲（有刪減）：\n\n```go\n\"\".Callee STEXT nosplit size=52 args=0x18 locals=0x10\n0x0000 00000 (call.go:3)    TEXT    \"\".Callee(SB), NOSPLIT|ABIInternal, $16-24\n0x0000 00000 (call.go:3)    SUBQ    $16, SP\n0x0004 00004 (call.go:3)    MOVQ    BP, 8(SP)\n0x0009 00009 (call.go:3)    LEAQ    8(SP), BP\n// 將40(SP)處的變量~r2的值爲0，即返回值初始化爲0\n0x000e 00014 (call.go:3)    MOVQ    $0, \"\".~r2+40(SP)\n// 將24(SP)處的變量x的值傳送到AX中\n0x0017 00023 (call.go:4)    MOVQ    \"\".x+24(SP), AX\n// 將32(SP)處的變量y加到AX中\n0x001c 00028 (call.go:4)    ADDQ    \"\".y+32(SP), AX\n// 將AX的值傳送到(SP)處的變量r中\n0x0021 00033 (call.go:4)    MOVQ    AX, \"\".r(SP)\n// 將AX中的值傳送到40(SP)處的變量~r2，即返回值賦值爲AX中的值\n0x0025 00037 (call.go:5)    MOVQ    AX, \"\".~r2+40(SP)\n0x002a 00042 (call.go:5)    MOVQ    8(SP), BP\n0x002f 00047 (call.go:5)    ADDQ    $16, SP\n0x0033 00051 (call.go:5)    RET\n\n// Go 彙編的固定開頭，Caller爲函數名，\n// args 爲入參和返回值佔用的字節大小 0x0=0，\n// locals 爲局部變量佔用的字節大小 0x20=32\n\"\".Caller STEXT size=71 args=0x0 locals=0x20\n// 聲明函數Caller\n0x0000 00000 (call.go:8)    TEXT    \"\".Caller(SB), ABIInternal, $32-0\n// 將(TLS)複製到CX寄存器，(TLS)是指向當前G(goroutine的一種數據結構)的指針\n0x0000 00000 (call.go:8)    MOVQ    (TLS), CX\n// 比較當前棧指針和CX正偏移16個字節的地址\n0x0009 00009 (call.go:8)    CMPQ    SP, 16(CX)\n// 如果比較值左邊小於右邊，則跳轉到地址 64 處，即 CALL    runtime.morestack_noctxt(SB)\n0x000d 00013 (call.go:8)    JLS     64\n// SP減去32，函數開始入棧\n0x000f 00015 (call.go:8)    SUBQ    $32, SP\n// 把BP中的值傳送到24(SP)處開始的內存空間，保存調用者棧幀地址到本棧。\n0x0013 00019 (call.go:8)    MOVQ    BP, 24(SP)\n// 將24(SP)處的地址傳送到BP，保存當前棧幀地址到BP。\n0x0018 00024 (call.go:8)    LEAQ    24(SP), BP\n// 將數字1傳送到(SP)處開始的內存空間\n0x001d 00029 (call.go:9)    MOVQ    $1, (SP)\n// 將數字2傳送到8(SP)處開始的內存空間\n0x0025 00037 (call.go:9)    MOVQ    $2, 8(SP)\n// 調用Callee函數\n0x002e 00046 (call.go:9)    CALL    \"\".Callee(SB)\n// 調用Callee函數時BP寄存器的值會指向Callee的棧幀地址，因此結束後需要復位。\n0x0033 00051 (call.go:10)   MOVQ    24(SP), BP\n// 出棧\n0x0038 00056 (call.go:10)   ADDQ    $32, SP\n// 返回\n0x003c 00060 (call.go:10)   RET\n// 無操作\n0x003d 00061 (call.go:10)   NOP\n0x003d 00061 (call.go:8)    NOP\n// 調用runtime.morestack_noctxt函數\n0x0040 00064 (call.go:8)    CALL    runtime.morestack_noctxt(SB)\n// 跳轉到函數聲明處\n0x0045 00069 (call.go:8)    JMP     0\n```\n\n分析可得棧結構如下：\n\n![](go-design-and-implementation-01/Untitled%203.png)\n\n## 1.3 參考\n\n1. [Go 语言设计与实现：第一章 准备工作 — draveness](https://draveness.me/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/)\n2. [汇编语言入门教程 — 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)\n3. [Go 系列文章3 ：plan9 汇编入门 — 曹春晖@No Headback](https://xargin.com/plan9-assembly/)\n4. [深入Go的底层，带你走近一群有追求的人 — Stefno@博客园](https://www.cnblogs.com/qcrao-2018/p/10562216.html)\n5. [go plan9汇编入门 — yuchanns@Go 语言中文网](https://studygolang.com/articles/26380)\n6. [go编译工具的使用之汇编 — yuchanns@github.com](https://github.com/yuchanns/Atelier/blob/theme/hermit/src/_posts/golang-assembly.md)\n7. [Go Assembly by Example](https://davidwong.fr/goasm/)\n8. [A Quick Guide to Go's Assembler — golang.org](https://golang.org/doc/asm)\n9. [A Manual for the Plan 9 assembler — Rob Pike](http://doc.cat-v.org/plan_9/4th_edition/papers/asm)","source":"_posts/it/go/go-design-and-implementation-01.md","raw":"---\ntitle: 《Go 設計與實現》筆記之第一章 準備工作\np: it/go/go-design-and-implementation-01.md\ndate: 2021-01-02 12:15:00\ntags:\n- Go\n---\n\n深入學習 Go 語言的設計與實現之前要準備以下工作：\n\n1. 克隆 Go 倉庫源代碼並編譯它。\n2. 了解 Plan 9 彙編，知道 Go 的棧結構並能分析代碼的執行過程。\n\n彙編者，二進制代碼的文本形式也，其最大的特點就是不可移植。Plan 9 彙編是貝爾實驗室的九號計劃的產物，目前被用於 Go 程序編譯的中間代碼，因爲 Go 的作者 Rob Pike，同時也是 Plan 9 彙編的作者。\n\nPlan 9 彙編指令與 Intel 等彙編等的不同在於：\n\n1. 一般情況下，命令的源操作數在先，目的操作數在後。 如同樣是將十六進制的 10 傳送到 AX寄存器，在 Plan 9 中是 `MOVQ $0x10, AX` ，而在 Intel 彙編中是 `mov rax, 0x10` 。\n2.  棧的調整通過硬件 SP 寄存器進行加減運算實現。而 Intel 彙編中通過 push 和 pop 命令實現。\n3. 操作的數據長度取決於命令的後綴。而 Intel 彙編取決於寄存器。\n\n    ```go\n    // plan 9 彙編\n    MOVB $1, DI      // 1 byte\n    MOVW $0x10, BX   // 2 bytes\n    MOVD $1, DX      // 4 bytes\n    MOVQ $-10, AX     // 8 bytes\n\n    // intel 彙編\n    mov rax, 0x1   // 8 bytes\n    mov eax, 0x100 // 4 bytes\n    mov ax, 0x22   // 2 bytes\n    mov ah, 0x33   // 1 byte\n    mov al, 0x44   // 1 byte\n    ```\n\n通過分析 Plan 9 彙編代碼我們可以繪製出如下的棧結構：\n\n![](go-design-and-implementation-01/Untitled.png)\n\n<!-- more -->\n\n## 1.1 調試 Go 語言\n\n### **1.1.1 克隆 go 倉庫並查看代碼行數**\n\ncloc (Count Lines of Code) 工具可以計算源代碼行數。執行後可知 Go 源代碼超過 140 萬行。\n\n```bash\n$ git clone https://github.com/golang/go.git\n$ cloc go/src\n6277 text files.\n6156 unique files.\n1298 files ignored.\n# 省略部分內容\n-----------------------------------------------------------------------------------\nLanguage                         files          blank        comment           code\n-----------------------------------------------------------------------------------\nGo                                4340         143352         253857        1412372\nAssembly                           497          12862          18550         108301\nC                                   68            763            599           4745\n# 省略部分內容\n```\n\n### 1.1.2 編譯源碼\n\n在源代碼中找到 fmt 包，修改 Println 函數如下：\n\n```bash\nfunc Println(a ...interface{}) (n int, err error) {\n\tprintln(\"draven\")\n\treturn Fprintln(os.Stdout, a...)\n}\n```\n\n隨後執行  `./src/make.bash` 編譯源代碼，成功之後用編譯出來的 Go 二進制文件來執行你的代碼：\n\n```bash\n$ cat main.go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello World\")\n}\n$ src/github.com/golang/go/bin/go run main.go\ndraven\nHello World\n```\n\n## 1.2 Plan 9 彙編\n\n### **1.2.1 彙編**\n\n在正式學習 Plan 9 彙編之前，建議先看下阮一峰老師的[《汇编语言入门教程》](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)以理解以下結論：\n\n1. 匯編語言是二進制指令的文本形式。\n2. 較之CPU 緩存，CPU 訪問寄存器速度更快且不需要尋址。\n3. 寄存器依靠名稱而不是地址來區分數據。\n4. 內存中的堆自下而上分配，棧自上而下分配。\n\n    ![](go-design-and-implementation-01/Untitled%201.png)\n\n### **1.2.2 Plan 9**\n\nPlan 9，貝爾實驗室九號計劃，是一個基於 Unix 的分布式操作系統，該系統開源但並未商業化使用。Go 語言的作者 Rob Pike 是其帶領者之一。\n\nGo 使用了 Plan 9 彙編作爲中間代碼，最後再編譯成二進制代碼。了解 Plan 9 彙編有助於分析 Go 語言的底層實現和排查問題。\n\n彙編語言具有不可移植性，各個平台上的平台指令集和寄存器都不一樣。學習時我們以 Linux amd64 爲例。\n\n### **1.2.3 寄存器**\n\namd64 上的寄存器有：\n\n1. **AX**：累加寄存器(AccumulatorRegister)，用於存放數據，包括算術、操作數、結果和臨時存放地址。\n2. **BX**：基址寄存器(BaseRegister)，用於存放訪問存儲器時的地址。\n3. **CX**：計數寄存器(CountRegister)，用於保存計算值，用作計數器。\n4. **DX**：數據寄存器(DataRegister)，用於數據傳遞，在寄存器間接尋址中的I/O指令中存放I/O端口的地址。\n5. DI：目的寄存器(DestinationIndex)，用於存放目的操作數的偏移地址。\n6. SI：源變址寄存器(SourceIndex)，用於存放源操作數的偏移地址。\n7. **BP：**棧基指針(BasePointer)，保存在進入函數前的棧頂基址。\n8. **SP：**棧指針(StackPointer)，指向當前棧幀的局部變量的開始位置。如果是symbol+offset(SP)的形式表示**偽寄存器**，offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间；如果是offset(SP)的形式表示**硬件寄存器**。（注意：對於編譯輸出(`go tool compile -S / go tool objdump`)的代碼來講，目前所有的 SP 都是硬件寄存器 SP，無論是否帶 symbol）\n9. **FP**：棧幀指針(FramePointer)，偽寄存器。指向引用函數的輸入參數，形式是symbol+offset(FP)，例如 arg0+0(FP)。\n10. SB：靜態基指針(StaticBasePointer)，偽寄存器。一般用來聲明函數或全局變量。\n11. PC：程序計數器(ProgramCounter)，偽寄存器。存放下一條指令的地址。\n12. R8\n13. R9\n14. R10\n\n**偽寄存器**(pseudo register)：僞寄存器與平台無關，只在生成目標代碼時才與平台上的硬件寄存器對應起來。Plan 9 彙編有四個偽寄存器，FP、SP、SB、PC。FP 存放引用函數的輸入參數，SP 存放當前棧幀的局部變量的開始位置，SB 聲明函數和全局變量，PC 存放下一條指令的地址。\n\n### **1.2.4 基本指令**\n\n1. **棧調整**\n\n    通過對 SP 寄存器進行操作實現，這與 intle 或 AT&T 匯編不同，他們是使用 push、pop 指令實現。\n\n    ```go\n    SUBQ $0x18, SP // 對 SP 做減法，為函數分配函數棧幀\n    ...               // 省略無用代碼\n    ADDQ $0x18, SP // 對 SP 做加法，清除函數棧幀\n    ```\n\n    注意：SP 一開始處於棧頂且棧是自上而下分配的，所以要通過減法分配棧幀，通過加法清除棧幀。示意圖如下：\n\n    ![](go-design-and-implementation-01/Untitled%202.png)\n\n2. **數據搬運**\n\n    將源操作數複製到目的操作數。Plan 9 中用 `$num` 形式表示常數，默認爲十進制，也可用 `$0x123` 形式表示十六進制。搬運的長度由 `MOV` 的後綴決定。\n\n    格式：`MOVB source destination`\n\n    ```go\n    // move byte\n    // 搬運一個字節長\n    MOVB $1, DI\n    // move word = 2 bytes\n    // 搬運一個字長\n    MOVW $0x10, BX\n    // move double word = 4 bytes\n    // 搬運兩倍字長\n    MOVD $1, DX\n    // move quad word = 8 bytes\n    // 搬運四倍字長\n    MOVQ $-10, AX\n    ```\n\n3. **地址傳送**\n\n    將源操作數的地址複製到目的操作數。\n\n    > lea is an abbreviation of \"load effective address\"。— [Stack Overflow](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwif6oDs8PbtAhWNzIsBHb-kDG0QFjADegQICBAC&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F1658294%2Fwhats-the-purpose-of-the-lea-instruction&usg=AOvVaw1XNxphxiOi5AcnWxGpYRbV)\n\n    ```go\n    // 把AX內容的地址傳送到BX中\n    LEAQ AX, BX\n    ```\n\n4. **計算**\n\n    ```go\n    // add quad word from AX to BX\n    // BX += AX\n    ADDQ  AX, BX\n    // subtract quad word from AX to BX\n    // BX -= AX\n    SUBQ  AX, BX\n    // 無符號乘法 IMUL\n    // BX *= AX\n    IMULQ AX, BX\n    // 無符號除法 IDIV\n    // 除數是CX，被除數是AX，結果存儲到AX中\n    IDIVQ CX\n    // 比較SI和CX的大小。與SUBQ類似，只是不賦值\n    // 其結果會存放到寄存器中\n    CMPQ SI CX\n    ```\n\n5. **跳轉**\n\n    ```go\n    // -- 無條件跳轉 -- \n    // 跳轉到地址，地址可為代碼中的地址，不過實際上手寫不會出現這種東西\n    JMP addr\n    // 跳轉到標籤，可以跳轉到同一函數內的標籤位置\n    JMP label\n    // 以當前指令為基礎，向前跳轉 x 行\n    JMP 2(PC)\n    // 以當前指令為基礎，向後跳轉 x 行\n    JMP -2(PC)\n\n    // -- 有條件跳轉 --\n    // jump target if zero\n    // 如果 zero flag 被 set 過，則跳轉\n    JZ target\n    // jump target if less\n    // 上一行的比較CMP結果，左邊小於右邊則執行跳到0x0185地址處(十進制389轉換成十六進制0x0185)\n    JLS 389\n    ```\n\n6. **指令集**\n\n    見源代碼的 [arch 部分](https://github.com/golang/arch/blob/master/x86/x86.csv)。\n\n### 1.2.5 **案例分析：函數調用**\n\n編寫以下代碼於 call.go 文件：\n\n```go\npackage main\n\nfunc Callee(x, y int) int {\n\tr := x + y\n\treturn r\n}\n\nfunc Caller() {\n\tCallee(1, 2)\n}\n```\n\n執行以下命令可查看彙編代碼：\n\n```go\n// -S 輸出彙編代碼到控制台 Print assembly listing to standard output (code only).\n// -l 禁止內聯 Disable inlining.\n// -N 禁止優化 Disable optimizations.\n// 更多參數：https://pkg.go.dev/cmd/compile@go1.15.6\ngo build -gcflags=\"-S -l -N\" call.go\n```\n\n輸出結果爲（有刪減）：\n\n```go\n\"\".Callee STEXT nosplit size=52 args=0x18 locals=0x10\n0x0000 00000 (call.go:3)    TEXT    \"\".Callee(SB), NOSPLIT|ABIInternal, $16-24\n0x0000 00000 (call.go:3)    SUBQ    $16, SP\n0x0004 00004 (call.go:3)    MOVQ    BP, 8(SP)\n0x0009 00009 (call.go:3)    LEAQ    8(SP), BP\n// 將40(SP)處的變量~r2的值爲0，即返回值初始化爲0\n0x000e 00014 (call.go:3)    MOVQ    $0, \"\".~r2+40(SP)\n// 將24(SP)處的變量x的值傳送到AX中\n0x0017 00023 (call.go:4)    MOVQ    \"\".x+24(SP), AX\n// 將32(SP)處的變量y加到AX中\n0x001c 00028 (call.go:4)    ADDQ    \"\".y+32(SP), AX\n// 將AX的值傳送到(SP)處的變量r中\n0x0021 00033 (call.go:4)    MOVQ    AX, \"\".r(SP)\n// 將AX中的值傳送到40(SP)處的變量~r2，即返回值賦值爲AX中的值\n0x0025 00037 (call.go:5)    MOVQ    AX, \"\".~r2+40(SP)\n0x002a 00042 (call.go:5)    MOVQ    8(SP), BP\n0x002f 00047 (call.go:5)    ADDQ    $16, SP\n0x0033 00051 (call.go:5)    RET\n\n// Go 彙編的固定開頭，Caller爲函數名，\n// args 爲入參和返回值佔用的字節大小 0x0=0，\n// locals 爲局部變量佔用的字節大小 0x20=32\n\"\".Caller STEXT size=71 args=0x0 locals=0x20\n// 聲明函數Caller\n0x0000 00000 (call.go:8)    TEXT    \"\".Caller(SB), ABIInternal, $32-0\n// 將(TLS)複製到CX寄存器，(TLS)是指向當前G(goroutine的一種數據結構)的指針\n0x0000 00000 (call.go:8)    MOVQ    (TLS), CX\n// 比較當前棧指針和CX正偏移16個字節的地址\n0x0009 00009 (call.go:8)    CMPQ    SP, 16(CX)\n// 如果比較值左邊小於右邊，則跳轉到地址 64 處，即 CALL    runtime.morestack_noctxt(SB)\n0x000d 00013 (call.go:8)    JLS     64\n// SP減去32，函數開始入棧\n0x000f 00015 (call.go:8)    SUBQ    $32, SP\n// 把BP中的值傳送到24(SP)處開始的內存空間，保存調用者棧幀地址到本棧。\n0x0013 00019 (call.go:8)    MOVQ    BP, 24(SP)\n// 將24(SP)處的地址傳送到BP，保存當前棧幀地址到BP。\n0x0018 00024 (call.go:8)    LEAQ    24(SP), BP\n// 將數字1傳送到(SP)處開始的內存空間\n0x001d 00029 (call.go:9)    MOVQ    $1, (SP)\n// 將數字2傳送到8(SP)處開始的內存空間\n0x0025 00037 (call.go:9)    MOVQ    $2, 8(SP)\n// 調用Callee函數\n0x002e 00046 (call.go:9)    CALL    \"\".Callee(SB)\n// 調用Callee函數時BP寄存器的值會指向Callee的棧幀地址，因此結束後需要復位。\n0x0033 00051 (call.go:10)   MOVQ    24(SP), BP\n// 出棧\n0x0038 00056 (call.go:10)   ADDQ    $32, SP\n// 返回\n0x003c 00060 (call.go:10)   RET\n// 無操作\n0x003d 00061 (call.go:10)   NOP\n0x003d 00061 (call.go:8)    NOP\n// 調用runtime.morestack_noctxt函數\n0x0040 00064 (call.go:8)    CALL    runtime.morestack_noctxt(SB)\n// 跳轉到函數聲明處\n0x0045 00069 (call.go:8)    JMP     0\n```\n\n分析可得棧結構如下：\n\n![](go-design-and-implementation-01/Untitled%203.png)\n\n## 1.3 參考\n\n1. [Go 语言设计与实现：第一章 准备工作 — draveness](https://draveness.me/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/)\n2. [汇编语言入门教程 — 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)\n3. [Go 系列文章3 ：plan9 汇编入门 — 曹春晖@No Headback](https://xargin.com/plan9-assembly/)\n4. [深入Go的底层，带你走近一群有追求的人 — Stefno@博客园](https://www.cnblogs.com/qcrao-2018/p/10562216.html)\n5. [go plan9汇编入门 — yuchanns@Go 语言中文网](https://studygolang.com/articles/26380)\n6. [go编译工具的使用之汇编 — yuchanns@github.com](https://github.com/yuchanns/Atelier/blob/theme/hermit/src/_posts/golang-assembly.md)\n7. [Go Assembly by Example](https://davidwong.fr/goasm/)\n8. [A Quick Guide to Go's Assembler — golang.org](https://golang.org/doc/asm)\n9. [A Manual for the Plan 9 assembler — Rob Pike](http://doc.cat-v.org/plan_9/4th_edition/papers/asm)","slug":"it/go/go-design-and-implementation-01","published":1,"updated":"2021-09-13T14:13:19.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlex000m1n9kechf3lf9","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>深入學習 Go 語言的設計與實現之前要準備以下工作：</p>\n<ol>\n<li>克隆 Go 倉庫源代碼並編譯它。</li>\n<li>了解 Plan 9 彙編，知道 Go 的棧結構並能分析代碼的執行過程。</li>\n</ol>\n<p>彙編者，二進制代碼的文本形式也，其最大的特點就是不可移植。Plan 9 彙編是貝爾實驗室的九號計劃的產物，目前被用於 Go 程序編譯的中間代碼，因爲 Go 的作者 Rob Pike，同時也是 Plan 9 彙編的作者。</p>\n<p>Plan 9 彙編指令與 Intel 等彙編等的不同在於：</p>\n<ol>\n<li><p>一般情況下，命令的源操作數在先，目的操作數在後。 如同樣是將十六進制的 10 傳送到 AX寄存器，在 Plan 9 中是 <code>MOVQ $0x10, AX</code> ，而在 Intel 彙編中是 <code>mov rax, 0x10</code> 。</p>\n</li>\n<li><p>棧的調整通過硬件 SP 寄存器進行加減運算實現。而 Intel 彙編中通過 push 和 pop 命令實現。</p>\n</li>\n<li><p>操作的數據長度取決於命令的後綴。而 Intel 彙編取決於寄存器。</p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plan 9 彙編</span></span><br><span class=\"line\">MOVB $<span class=\"number\">1</span>, DI      <span class=\"comment\">// 1 byte</span></span><br><span class=\"line\">MOVW $<span class=\"number\">0x10</span>, BX   <span class=\"comment\">// 2 bytes</span></span><br><span class=\"line\">MOVD $<span class=\"number\">1</span>, DX      <span class=\"comment\">// 4 bytes</span></span><br><span class=\"line\">MOVQ $<span class=\"number\">-10</span>, AX     <span class=\"comment\">// 8 bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// intel 彙編</span></span><br><span class=\"line\">mov rax, <span class=\"number\">0x1</span>   <span class=\"comment\">// 8 bytes</span></span><br><span class=\"line\">mov eax, <span class=\"number\">0x100</span> <span class=\"comment\">// 4 bytes</span></span><br><span class=\"line\">mov ax, <span class=\"number\">0x22</span>   <span class=\"comment\">// 2 bytes</span></span><br><span class=\"line\">mov ah, <span class=\"number\">0x33</span>   <span class=\"comment\">// 1 byte</span></span><br><span class=\"line\">mov al, <span class=\"number\">0x44</span>   <span class=\"comment\">// 1 byte</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>通過分析 Plan 9 彙編代碼我們可以繪製出如下的棧結構：</p>\n<p><img src=\"/it/go/go-design-and-implementation-01/Untitled.png\" alt></p>\n<span id=\"more\"></span>\n\n<h2 id=\"1-1-調試-Go-語言\"><a href=\"#1-1-調試-Go-語言\" class=\"headerlink\" title=\"1.1 調試 Go 語言\"></a>1.1 調試 Go 語言</h2><h3 id=\"1-1-1-克隆-go-倉庫並查看代碼行數\"><a href=\"#1-1-1-克隆-go-倉庫並查看代碼行數\" class=\"headerlink\" title=\"1.1.1 克隆 go 倉庫並查看代碼行數\"></a><strong>1.1.1 克隆 go 倉庫並查看代碼行數</strong></h3><p>cloc (Count Lines of Code) 工具可以計算源代碼行數。執行後可知 Go 源代碼超過 140 萬行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/golang/go.git</span><br><span class=\"line\">$ cloc go/src</span><br><span class=\"line\">6277 text files.</span><br><span class=\"line\">6156 unique files.</span><br><span class=\"line\">1298 files ignored.</span><br><span class=\"line\"><span class=\"comment\"># 省略部分內容</span></span><br><span class=\"line\">-----------------------------------------------------------------------------------</span><br><span class=\"line\">Language                         files          blank        comment           code</span><br><span class=\"line\">-----------------------------------------------------------------------------------</span><br><span class=\"line\">Go                                4340         143352         253857        1412372</span><br><span class=\"line\">Assembly                           497          12862          18550         108301</span><br><span class=\"line\">C                                   68            763            599           4745</span><br><span class=\"line\"><span class=\"comment\"># 省略部分內容</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-2-編譯源碼\"><a href=\"#1-1-2-編譯源碼\" class=\"headerlink\" title=\"1.1.2 編譯源碼\"></a>1.1.2 編譯源碼</h3><p>在源代碼中找到 fmt 包，修改 Println 函數如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">func Println(a ...interface&#123;&#125;) (n int, err error) &#123;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;draven&quot;</span>)</span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fprintln(os.Stdout, a...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>隨後執行  <code>./src/make.bash</code> 編譯源代碼，成功之後用編譯出來的 Go 二進制文件來執行你的代碼：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat main.go</span><br><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$ src/github.com/golang/go/bin/go run main.go</span><br><span class=\"line\">draven</span><br><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-Plan-9-彙編\"><a href=\"#1-2-Plan-9-彙編\" class=\"headerlink\" title=\"1.2 Plan 9 彙編\"></a>1.2 Plan 9 彙編</h2><h3 id=\"1-2-1-彙編\"><a href=\"#1-2-1-彙編\" class=\"headerlink\" title=\"1.2.1 彙編\"></a><strong>1.2.1 彙編</strong></h3><p>在正式學習 Plan 9 彙編之前，建議先看下阮一峰老師的<a href=\"http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html\">《汇编语言入门教程》</a>以理解以下結論：</p>\n<ol>\n<li><p>匯編語言是二進制指令的文本形式。</p>\n</li>\n<li><p>較之CPU 緩存，CPU 訪問寄存器速度更快且不需要尋址。</p>\n</li>\n<li><p>寄存器依靠名稱而不是地址來區分數據。</p>\n</li>\n<li><p>內存中的堆自下而上分配，棧自上而下分配。</p>\n<p> <img src=\"/it/go/go-design-and-implementation-01/Untitled%201.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"1-2-2-Plan-9\"><a href=\"#1-2-2-Plan-9\" class=\"headerlink\" title=\"1.2.2 Plan 9\"></a><strong>1.2.2 Plan 9</strong></h3><p>Plan 9，貝爾實驗室九號計劃，是一個基於 Unix 的分布式操作系統，該系統開源但並未商業化使用。Go 語言的作者 Rob Pike 是其帶領者之一。</p>\n<p>Go 使用了 Plan 9 彙編作爲中間代碼，最後再編譯成二進制代碼。了解 Plan 9 彙編有助於分析 Go 語言的底層實現和排查問題。</p>\n<p>彙編語言具有不可移植性，各個平台上的平台指令集和寄存器都不一樣。學習時我們以 Linux amd64 爲例。</p>\n<h3 id=\"1-2-3-寄存器\"><a href=\"#1-2-3-寄存器\" class=\"headerlink\" title=\"1.2.3 寄存器\"></a><strong>1.2.3 寄存器</strong></h3><p>amd64 上的寄存器有：</p>\n<ol>\n<li><strong>AX</strong>：累加寄存器(AccumulatorRegister)，用於存放數據，包括算術、操作數、結果和臨時存放地址。</li>\n<li><strong>BX</strong>：基址寄存器(BaseRegister)，用於存放訪問存儲器時的地址。</li>\n<li><strong>CX</strong>：計數寄存器(CountRegister)，用於保存計算值，用作計數器。</li>\n<li><strong>DX</strong>：數據寄存器(DataRegister)，用於數據傳遞，在寄存器間接尋址中的I/O指令中存放I/O端口的地址。</li>\n<li>DI：目的寄存器(DestinationIndex)，用於存放目的操作數的偏移地址。</li>\n<li>SI：源變址寄存器(SourceIndex)，用於存放源操作數的偏移地址。</li>\n<li><strong>BP：</strong>棧基指針(BasePointer)，保存在進入函數前的棧頂基址。</li>\n<li><strong>SP：</strong>棧指針(StackPointer)，指向當前棧幀的局部變量的開始位置。如果是symbol+offset(SP)的形式表示<strong>偽寄存器</strong>，offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间；如果是offset(SP)的形式表示<strong>硬件寄存器</strong>。（注意：對於編譯輸出(<code>go tool compile -S / go tool objdump</code>)的代碼來講，目前所有的 SP 都是硬件寄存器 SP，無論是否帶 symbol）</li>\n<li><strong>FP</strong>：棧幀指針(FramePointer)，偽寄存器。指向引用函數的輸入參數，形式是symbol+offset(FP)，例如 arg0+0(FP)。</li>\n<li>SB：靜態基指針(StaticBasePointer)，偽寄存器。一般用來聲明函數或全局變量。</li>\n<li>PC：程序計數器(ProgramCounter)，偽寄存器。存放下一條指令的地址。</li>\n<li>R8</li>\n<li>R9</li>\n<li>R10</li>\n</ol>\n<p><strong>偽寄存器</strong>(pseudo register)：僞寄存器與平台無關，只在生成目標代碼時才與平台上的硬件寄存器對應起來。Plan 9 彙編有四個偽寄存器，FP、SP、SB、PC。FP 存放引用函數的輸入參數，SP 存放當前棧幀的局部變量的開始位置，SB 聲明函數和全局變量，PC 存放下一條指令的地址。</p>\n<h3 id=\"1-2-4-基本指令\"><a href=\"#1-2-4-基本指令\" class=\"headerlink\" title=\"1.2.4 基本指令\"></a><strong>1.2.4 基本指令</strong></h3><ol>\n<li><p><strong>棧調整</strong></p>\n<p> 通過對 SP 寄存器進行操作實現，這與 intle 或 AT&amp;T 匯編不同，他們是使用 push、pop 指令實現。</p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">SUBQ $<span class=\"number\">0x18</span>, SP <span class=\"comment\">// 對 SP 做減法，為函數分配函數棧幀</span></span><br><span class=\"line\">...               <span class=\"comment\">// 省略無用代碼</span></span><br><span class=\"line\">ADDQ $<span class=\"number\">0x18</span>, SP <span class=\"comment\">// 對 SP 做加法，清除函數棧幀</span></span><br></pre></td></tr></table></figure>\n\n<p> 注意：SP 一開始處於棧頂且棧是自上而下分配的，所以要通過減法分配棧幀，通過加法清除棧幀。示意圖如下：</p>\n<p> <img src=\"/it/go/go-design-and-implementation-01/Untitled%202.png\" alt></p>\n</li>\n<li><p><strong>數據搬運</strong></p>\n<p> 將源操作數複製到目的操作數。Plan 9 中用 <code>$num</code> 形式表示常數，默認爲十進制，也可用 <code>$0x123</code> 形式表示十六進制。搬運的長度由 <code>MOV</code> 的後綴決定。</p>\n<p> 格式：<code>MOVB source destination</code></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// move byte</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運一個字節長</span></span><br><span class=\"line\">MOVB $<span class=\"number\">1</span>, DI</span><br><span class=\"line\"><span class=\"comment\">// move word = 2 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運一個字長</span></span><br><span class=\"line\">MOVW $<span class=\"number\">0x10</span>, BX</span><br><span class=\"line\"><span class=\"comment\">// move double word = 4 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運兩倍字長</span></span><br><span class=\"line\">MOVD $<span class=\"number\">1</span>, DX</span><br><span class=\"line\"><span class=\"comment\">// move quad word = 8 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運四倍字長</span></span><br><span class=\"line\">MOVQ $<span class=\"number\">-10</span>, AX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>地址傳送</strong></p>\n<p> 將源操作數的地址複製到目的操作數。</p>\n<blockquote>\n<p>lea is an abbreviation of “load effective address”。— <a href=\"https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwif6oDs8PbtAhWNzIsBHb-kDG0QFjADegQICBAC&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F1658294%2Fwhats-the-purpose-of-the-lea-instruction&usg=AOvVaw1XNxphxiOi5AcnWxGpYRbV\">Stack Overflow</a></p>\n</blockquote>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把AX內容的地址傳送到BX中</span></span><br><span class=\"line\">LEAQ AX, BX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>計算</strong></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add quad word from AX to BX</span></span><br><span class=\"line\"><span class=\"comment\">// BX += AX</span></span><br><span class=\"line\">ADDQ  AX, BX</span><br><span class=\"line\"><span class=\"comment\">// subtract quad word from AX to BX</span></span><br><span class=\"line\"><span class=\"comment\">// BX -= AX</span></span><br><span class=\"line\">SUBQ  AX, BX</span><br><span class=\"line\"><span class=\"comment\">// 無符號乘法 IMUL</span></span><br><span class=\"line\"><span class=\"comment\">// BX *= AX</span></span><br><span class=\"line\">IMULQ AX, BX</span><br><span class=\"line\"><span class=\"comment\">// 無符號除法 IDIV</span></span><br><span class=\"line\"><span class=\"comment\">// 除數是CX，被除數是AX，結果存儲到AX中</span></span><br><span class=\"line\">IDIVQ CX</span><br><span class=\"line\"><span class=\"comment\">// 比較SI和CX的大小。與SUBQ類似，只是不賦值</span></span><br><span class=\"line\"><span class=\"comment\">// 其結果會存放到寄存器中</span></span><br><span class=\"line\">CMPQ SI CX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>跳轉</strong></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- 無條件跳轉 -- </span></span><br><span class=\"line\"><span class=\"comment\">// 跳轉到地址，地址可為代碼中的地址，不過實際上手寫不會出現這種東西</span></span><br><span class=\"line\">JMP addr</span><br><span class=\"line\"><span class=\"comment\">// 跳轉到標籤，可以跳轉到同一函數內的標籤位置</span></span><br><span class=\"line\">JMP label</span><br><span class=\"line\"><span class=\"comment\">// 以當前指令為基礎，向前跳轉 x 行</span></span><br><span class=\"line\">JMP <span class=\"number\">2</span>(PC)</span><br><span class=\"line\"><span class=\"comment\">// 以當前指令為基礎，向後跳轉 x 行</span></span><br><span class=\"line\">JMP <span class=\"number\">-2</span>(PC)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- 有條件跳轉 --</span></span><br><span class=\"line\"><span class=\"comment\">// jump target if zero</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 zero flag 被 set 過，則跳轉</span></span><br><span class=\"line\">JZ target</span><br><span class=\"line\"><span class=\"comment\">// jump target if less</span></span><br><span class=\"line\"><span class=\"comment\">// 上一行的比較CMP結果，左邊小於右邊則執行跳到0x0185地址處(十進制389轉換成十六進制0x0185)</span></span><br><span class=\"line\">JLS <span class=\"number\">389</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>指令集</strong></p>\n<p> 見源代碼的 <a href=\"https://github.com/golang/arch/blob/master/x86/x86.csv\">arch 部分</a>。</p>\n</li>\n</ol>\n<h3 id=\"1-2-5-案例分析：函數調用\"><a href=\"#1-2-5-案例分析：函數調用\" class=\"headerlink\" title=\"1.2.5 案例分析：函數調用\"></a>1.2.5 <strong>案例分析：函數調用</strong></h3><p>編寫以下代碼於 call.go 文件：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Callee</span><span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  r := x + y</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Caller</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  Callee(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行以下命令可查看彙編代碼：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -S 輸出彙編代碼到控制台 Print assembly listing to standard output (code only).</span></span><br><span class=\"line\"><span class=\"comment\">// -l 禁止內聯 Disable inlining.</span></span><br><span class=\"line\"><span class=\"comment\">// -N 禁止優化 Disable optimizations.</span></span><br><span class=\"line\"><span class=\"comment\">// 更多參數：https://pkg.go.dev/cmd/compile@go1.15.6</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> build -gcflags=<span class=\"string\">&quot;-S -l -N&quot;</span> call.<span class=\"keyword\">go</span></span><br></pre></td></tr></table></figure>\n\n<p>輸出結果爲（有刪減）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span>.Callee STEXT nosplit size=<span class=\"number\">52</span> args=<span class=\"number\">0x18</span> locals=<span class=\"number\">0x10</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    TEXT    <span class=\"string\">&quot;&quot;</span>.Callee(SB), NOSPLIT|ABIInternal, $<span class=\"number\">16</span><span class=\"number\">-24</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    SUBQ    $<span class=\"number\">16</span>, SP</span><br><span class=\"line\"><span class=\"number\">0x0004</span> <span class=\"number\">00004</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    MOVQ    BP, <span class=\"number\">8</span>(SP)</span><br><span class=\"line\"><span class=\"number\">0x0009</span> <span class=\"number\">00009</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    LEAQ    <span class=\"number\">8</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 將40(SP)處的變量~r2的值爲0，即返回值初始化爲0</span></span><br><span class=\"line\"><span class=\"number\">0x000e</span> <span class=\"number\">00014</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    MOVQ    $<span class=\"number\">0</span>, <span class=\"string\">&quot;&quot;</span>.~r2+<span class=\"number\">40</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將24(SP)處的變量x的值傳送到AX中</span></span><br><span class=\"line\"><span class=\"number\">0x0017</span> <span class=\"number\">00023</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    MOVQ    <span class=\"string\">&quot;&quot;</span>.x+<span class=\"number\">24</span>(SP), AX</span><br><span class=\"line\"><span class=\"comment\">// 將32(SP)處的變量y加到AX中</span></span><br><span class=\"line\"><span class=\"number\">0x001c</span> <span class=\"number\">00028</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    ADDQ    <span class=\"string\">&quot;&quot;</span>.y+<span class=\"number\">32</span>(SP), AX</span><br><span class=\"line\"><span class=\"comment\">// 將AX的值傳送到(SP)處的變量r中</span></span><br><span class=\"line\"><span class=\"number\">0x0021</span> <span class=\"number\">00033</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    MOVQ    AX, <span class=\"string\">&quot;&quot;</span>.r(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將AX中的值傳送到40(SP)處的變量~r2，即返回值賦值爲AX中的值</span></span><br><span class=\"line\"><span class=\"number\">0x0025</span> <span class=\"number\">00037</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    MOVQ    AX, <span class=\"string\">&quot;&quot;</span>.~r2+<span class=\"number\">40</span>(SP)</span><br><span class=\"line\"><span class=\"number\">0x002a</span> <span class=\"number\">00042</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    MOVQ    <span class=\"number\">8</span>(SP), BP</span><br><span class=\"line\"><span class=\"number\">0x002f</span> <span class=\"number\">00047</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    ADDQ    $<span class=\"number\">16</span>, SP</span><br><span class=\"line\"><span class=\"number\">0x0033</span> <span class=\"number\">00051</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    RET</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Go 彙編的固定開頭，Caller爲函數名，</span></span><br><span class=\"line\"><span class=\"comment\">// args 爲入參和返回值佔用的字節大小 0x0=0，</span></span><br><span class=\"line\"><span class=\"comment\">// locals 爲局部變量佔用的字節大小 0x20=32</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span>.Caller STEXT size=<span class=\"number\">71</span> args=<span class=\"number\">0x0</span> locals=<span class=\"number\">0x20</span></span><br><span class=\"line\"><span class=\"comment\">// 聲明函數Caller</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    TEXT    <span class=\"string\">&quot;&quot;</span>.Caller(SB), ABIInternal, $<span class=\"number\">32</span><span class=\"number\">-0</span></span><br><span class=\"line\"><span class=\"comment\">// 將(TLS)複製到CX寄存器，(TLS)是指向當前G(goroutine的一種數據結構)的指針</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    MOVQ    (TLS), CX</span><br><span class=\"line\"><span class=\"comment\">// 比較當前棧指針和CX正偏移16個字節的地址</span></span><br><span class=\"line\"><span class=\"number\">0x0009</span> <span class=\"number\">00009</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    CMPQ    SP, <span class=\"number\">16</span>(CX)</span><br><span class=\"line\"><span class=\"comment\">// 如果比較值左邊小於右邊，則跳轉到地址 64 處，即 CALL    runtime.morestack_noctxt(SB)</span></span><br><span class=\"line\"><span class=\"number\">0x000d</span> <span class=\"number\">00013</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    JLS     <span class=\"number\">64</span></span><br><span class=\"line\"><span class=\"comment\">// SP減去32，函數開始入棧</span></span><br><span class=\"line\"><span class=\"number\">0x000f</span> <span class=\"number\">00015</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    SUBQ    $<span class=\"number\">32</span>, SP</span><br><span class=\"line\"><span class=\"comment\">// 把BP中的值傳送到24(SP)處開始的內存空間，保存調用者棧幀地址到本棧。</span></span><br><span class=\"line\"><span class=\"number\">0x0013</span> <span class=\"number\">00019</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    MOVQ    BP, <span class=\"number\">24</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將24(SP)處的地址傳送到BP，保存當前棧幀地址到BP。</span></span><br><span class=\"line\"><span class=\"number\">0x0018</span> <span class=\"number\">00024</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    LEAQ    <span class=\"number\">24</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 將數字1傳送到(SP)處開始的內存空間</span></span><br><span class=\"line\"><span class=\"number\">0x001d</span> <span class=\"number\">00029</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    MOVQ    $<span class=\"number\">1</span>, (SP)</span><br><span class=\"line\"><span class=\"comment\">// 將數字2傳送到8(SP)處開始的內存空間</span></span><br><span class=\"line\"><span class=\"number\">0x0025</span> <span class=\"number\">00037</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    MOVQ    $<span class=\"number\">2</span>, <span class=\"number\">8</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 調用Callee函數</span></span><br><span class=\"line\"><span class=\"number\">0x002e</span> <span class=\"number\">00046</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    CALL    <span class=\"string\">&quot;&quot;</span>.Callee(SB)</span><br><span class=\"line\"><span class=\"comment\">// 調用Callee函數時BP寄存器的值會指向Callee的棧幀地址，因此結束後需要復位。</span></span><br><span class=\"line\"><span class=\"number\">0x0033</span> <span class=\"number\">00051</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   MOVQ    <span class=\"number\">24</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 出棧</span></span><br><span class=\"line\"><span class=\"number\">0x0038</span> <span class=\"number\">00056</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   ADDQ    $<span class=\"number\">32</span>, SP</span><br><span class=\"line\"><span class=\"comment\">// 返回</span></span><br><span class=\"line\"><span class=\"number\">0x003c</span> <span class=\"number\">00060</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   RET</span><br><span class=\"line\"><span class=\"comment\">// 無操作</span></span><br><span class=\"line\"><span class=\"number\">0x003d</span> <span class=\"number\">00061</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   NOP</span><br><span class=\"line\"><span class=\"number\">0x003d</span> <span class=\"number\">00061</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    NOP</span><br><span class=\"line\"><span class=\"comment\">// 調用runtime.morestack_noctxt函數</span></span><br><span class=\"line\"><span class=\"number\">0x0040</span> <span class=\"number\">00064</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    CALL    runtime.morestack_noctxt(SB)</span><br><span class=\"line\"><span class=\"comment\">// 跳轉到函數聲明處</span></span><br><span class=\"line\"><span class=\"number\">0x0045</span> <span class=\"number\">00069</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    JMP     <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>分析可得棧結構如下：</p>\n<p><img src=\"/it/go/go-design-and-implementation-01/Untitled%203.png\" alt></p>\n<h2 id=\"1-3-參考\"><a href=\"#1-3-參考\" class=\"headerlink\" title=\"1.3 參考\"></a>1.3 參考</h2><ol>\n<li><a href=\"https://draveness.me/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/\">Go 语言设计与实现：第一章 准备工作 — draveness</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html\">汇编语言入门教程 — 阮一峰的网络日志</a></li>\n<li><a href=\"https://xargin.com/plan9-assembly/\">Go 系列文章3 ：plan9 汇编入门 — 曹春晖@No Headback</a></li>\n<li><a href=\"https://www.cnblogs.com/qcrao-2018/p/10562216.html\">深入Go的底层，带你走近一群有追求的人 — Stefno@博客园</a></li>\n<li><a href=\"https://studygolang.com/articles/26380\">go plan9汇编入门 — yuchanns@Go 语言中文网</a></li>\n<li><a href=\"https://github.com/yuchanns/Atelier/blob/theme/hermit/src/_posts/golang-assembly.md\">go编译工具的使用之汇编 — yuchanns@github.com</a></li>\n<li><a href=\"https://davidwong.fr/goasm/\">Go Assembly by Example</a></li>\n<li><a href=\"https://golang.org/doc/asm\">A Quick Guide to Go’s Assembler — golang.org</a></li>\n<li><a href=\"http://doc.cat-v.org/plan_9/4th_edition/papers/asm\">A Manual for the Plan 9 assembler — Rob Pike</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>深入學習 Go 語言的設計與實現之前要準備以下工作：</p>\n<ol>\n<li>克隆 Go 倉庫源代碼並編譯它。</li>\n<li>了解 Plan 9 彙編，知道 Go 的棧結構並能分析代碼的執行過程。</li>\n</ol>\n<p>彙編者，二進制代碼的文本形式也，其最大的特點就是不可移植。Plan 9 彙編是貝爾實驗室的九號計劃的產物，目前被用於 Go 程序編譯的中間代碼，因爲 Go 的作者 Rob Pike，同時也是 Plan 9 彙編的作者。</p>\n<p>Plan 9 彙編指令與 Intel 等彙編等的不同在於：</p>\n<ol>\n<li><p>一般情況下，命令的源操作數在先，目的操作數在後。 如同樣是將十六進制的 10 傳送到 AX寄存器，在 Plan 9 中是 <code>MOVQ $0x10, AX</code> ，而在 Intel 彙編中是 <code>mov rax, 0x10</code> 。</p>\n</li>\n<li><p>棧的調整通過硬件 SP 寄存器進行加減運算實現。而 Intel 彙編中通過 push 和 pop 命令實現。</p>\n</li>\n<li><p>操作的數據長度取決於命令的後綴。而 Intel 彙編取決於寄存器。</p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plan 9 彙編</span></span><br><span class=\"line\">MOVB $<span class=\"number\">1</span>, DI      <span class=\"comment\">// 1 byte</span></span><br><span class=\"line\">MOVW $<span class=\"number\">0x10</span>, BX   <span class=\"comment\">// 2 bytes</span></span><br><span class=\"line\">MOVD $<span class=\"number\">1</span>, DX      <span class=\"comment\">// 4 bytes</span></span><br><span class=\"line\">MOVQ $<span class=\"number\">-10</span>, AX     <span class=\"comment\">// 8 bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// intel 彙編</span></span><br><span class=\"line\">mov rax, <span class=\"number\">0x1</span>   <span class=\"comment\">// 8 bytes</span></span><br><span class=\"line\">mov eax, <span class=\"number\">0x100</span> <span class=\"comment\">// 4 bytes</span></span><br><span class=\"line\">mov ax, <span class=\"number\">0x22</span>   <span class=\"comment\">// 2 bytes</span></span><br><span class=\"line\">mov ah, <span class=\"number\">0x33</span>   <span class=\"comment\">// 1 byte</span></span><br><span class=\"line\">mov al, <span class=\"number\">0x44</span>   <span class=\"comment\">// 1 byte</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>通過分析 Plan 9 彙編代碼我們可以繪製出如下的棧結構：</p>\n<p><img src=\"/it/go/go-design-and-implementation-01/Untitled.png\" alt></p>","more":"<h2 id=\"1-1-調試-Go-語言\"><a href=\"#1-1-調試-Go-語言\" class=\"headerlink\" title=\"1.1 調試 Go 語言\"></a>1.1 調試 Go 語言</h2><h3 id=\"1-1-1-克隆-go-倉庫並查看代碼行數\"><a href=\"#1-1-1-克隆-go-倉庫並查看代碼行數\" class=\"headerlink\" title=\"1.1.1 克隆 go 倉庫並查看代碼行數\"></a><strong>1.1.1 克隆 go 倉庫並查看代碼行數</strong></h3><p>cloc (Count Lines of Code) 工具可以計算源代碼行數。執行後可知 Go 源代碼超過 140 萬行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/golang/go.git</span><br><span class=\"line\">$ cloc go/src</span><br><span class=\"line\">6277 text files.</span><br><span class=\"line\">6156 unique files.</span><br><span class=\"line\">1298 files ignored.</span><br><span class=\"line\"><span class=\"comment\"># 省略部分內容</span></span><br><span class=\"line\">-----------------------------------------------------------------------------------</span><br><span class=\"line\">Language                         files          blank        comment           code</span><br><span class=\"line\">-----------------------------------------------------------------------------------</span><br><span class=\"line\">Go                                4340         143352         253857        1412372</span><br><span class=\"line\">Assembly                           497          12862          18550         108301</span><br><span class=\"line\">C                                   68            763            599           4745</span><br><span class=\"line\"><span class=\"comment\"># 省略部分內容</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-2-編譯源碼\"><a href=\"#1-1-2-編譯源碼\" class=\"headerlink\" title=\"1.1.2 編譯源碼\"></a>1.1.2 編譯源碼</h3><p>在源代碼中找到 fmt 包，修改 Println 函數如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">func Println(a ...interface&#123;&#125;) (n int, err error) &#123;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;draven&quot;</span>)</span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fprintln(os.Stdout, a...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>隨後執行  <code>./src/make.bash</code> 編譯源代碼，成功之後用編譯出來的 Go 二進制文件來執行你的代碼：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat main.go</span><br><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$ src/github.com/golang/go/bin/go run main.go</span><br><span class=\"line\">draven</span><br><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-Plan-9-彙編\"><a href=\"#1-2-Plan-9-彙編\" class=\"headerlink\" title=\"1.2 Plan 9 彙編\"></a>1.2 Plan 9 彙編</h2><h3 id=\"1-2-1-彙編\"><a href=\"#1-2-1-彙編\" class=\"headerlink\" title=\"1.2.1 彙編\"></a><strong>1.2.1 彙編</strong></h3><p>在正式學習 Plan 9 彙編之前，建議先看下阮一峰老師的<a href=\"http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html\">《汇编语言入门教程》</a>以理解以下結論：</p>\n<ol>\n<li><p>匯編語言是二進制指令的文本形式。</p>\n</li>\n<li><p>較之CPU 緩存，CPU 訪問寄存器速度更快且不需要尋址。</p>\n</li>\n<li><p>寄存器依靠名稱而不是地址來區分數據。</p>\n</li>\n<li><p>內存中的堆自下而上分配，棧自上而下分配。</p>\n<p> <img src=\"/it/go/go-design-and-implementation-01/Untitled%201.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"1-2-2-Plan-9\"><a href=\"#1-2-2-Plan-9\" class=\"headerlink\" title=\"1.2.2 Plan 9\"></a><strong>1.2.2 Plan 9</strong></h3><p>Plan 9，貝爾實驗室九號計劃，是一個基於 Unix 的分布式操作系統，該系統開源但並未商業化使用。Go 語言的作者 Rob Pike 是其帶領者之一。</p>\n<p>Go 使用了 Plan 9 彙編作爲中間代碼，最後再編譯成二進制代碼。了解 Plan 9 彙編有助於分析 Go 語言的底層實現和排查問題。</p>\n<p>彙編語言具有不可移植性，各個平台上的平台指令集和寄存器都不一樣。學習時我們以 Linux amd64 爲例。</p>\n<h3 id=\"1-2-3-寄存器\"><a href=\"#1-2-3-寄存器\" class=\"headerlink\" title=\"1.2.3 寄存器\"></a><strong>1.2.3 寄存器</strong></h3><p>amd64 上的寄存器有：</p>\n<ol>\n<li><strong>AX</strong>：累加寄存器(AccumulatorRegister)，用於存放數據，包括算術、操作數、結果和臨時存放地址。</li>\n<li><strong>BX</strong>：基址寄存器(BaseRegister)，用於存放訪問存儲器時的地址。</li>\n<li><strong>CX</strong>：計數寄存器(CountRegister)，用於保存計算值，用作計數器。</li>\n<li><strong>DX</strong>：數據寄存器(DataRegister)，用於數據傳遞，在寄存器間接尋址中的I/O指令中存放I/O端口的地址。</li>\n<li>DI：目的寄存器(DestinationIndex)，用於存放目的操作數的偏移地址。</li>\n<li>SI：源變址寄存器(SourceIndex)，用於存放源操作數的偏移地址。</li>\n<li><strong>BP：</strong>棧基指針(BasePointer)，保存在進入函數前的棧頂基址。</li>\n<li><strong>SP：</strong>棧指針(StackPointer)，指向當前棧幀的局部變量的開始位置。如果是symbol+offset(SP)的形式表示<strong>偽寄存器</strong>，offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间；如果是offset(SP)的形式表示<strong>硬件寄存器</strong>。（注意：對於編譯輸出(<code>go tool compile -S / go tool objdump</code>)的代碼來講，目前所有的 SP 都是硬件寄存器 SP，無論是否帶 symbol）</li>\n<li><strong>FP</strong>：棧幀指針(FramePointer)，偽寄存器。指向引用函數的輸入參數，形式是symbol+offset(FP)，例如 arg0+0(FP)。</li>\n<li>SB：靜態基指針(StaticBasePointer)，偽寄存器。一般用來聲明函數或全局變量。</li>\n<li>PC：程序計數器(ProgramCounter)，偽寄存器。存放下一條指令的地址。</li>\n<li>R8</li>\n<li>R9</li>\n<li>R10</li>\n</ol>\n<p><strong>偽寄存器</strong>(pseudo register)：僞寄存器與平台無關，只在生成目標代碼時才與平台上的硬件寄存器對應起來。Plan 9 彙編有四個偽寄存器，FP、SP、SB、PC。FP 存放引用函數的輸入參數，SP 存放當前棧幀的局部變量的開始位置，SB 聲明函數和全局變量，PC 存放下一條指令的地址。</p>\n<h3 id=\"1-2-4-基本指令\"><a href=\"#1-2-4-基本指令\" class=\"headerlink\" title=\"1.2.4 基本指令\"></a><strong>1.2.4 基本指令</strong></h3><ol>\n<li><p><strong>棧調整</strong></p>\n<p> 通過對 SP 寄存器進行操作實現，這與 intle 或 AT&amp;T 匯編不同，他們是使用 push、pop 指令實現。</p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">SUBQ $<span class=\"number\">0x18</span>, SP <span class=\"comment\">// 對 SP 做減法，為函數分配函數棧幀</span></span><br><span class=\"line\">...               <span class=\"comment\">// 省略無用代碼</span></span><br><span class=\"line\">ADDQ $<span class=\"number\">0x18</span>, SP <span class=\"comment\">// 對 SP 做加法，清除函數棧幀</span></span><br></pre></td></tr></table></figure>\n\n<p> 注意：SP 一開始處於棧頂且棧是自上而下分配的，所以要通過減法分配棧幀，通過加法清除棧幀。示意圖如下：</p>\n<p> <img src=\"/it/go/go-design-and-implementation-01/Untitled%202.png\" alt></p>\n</li>\n<li><p><strong>數據搬運</strong></p>\n<p> 將源操作數複製到目的操作數。Plan 9 中用 <code>$num</code> 形式表示常數，默認爲十進制，也可用 <code>$0x123</code> 形式表示十六進制。搬運的長度由 <code>MOV</code> 的後綴決定。</p>\n<p> 格式：<code>MOVB source destination</code></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// move byte</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運一個字節長</span></span><br><span class=\"line\">MOVB $<span class=\"number\">1</span>, DI</span><br><span class=\"line\"><span class=\"comment\">// move word = 2 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運一個字長</span></span><br><span class=\"line\">MOVW $<span class=\"number\">0x10</span>, BX</span><br><span class=\"line\"><span class=\"comment\">// move double word = 4 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運兩倍字長</span></span><br><span class=\"line\">MOVD $<span class=\"number\">1</span>, DX</span><br><span class=\"line\"><span class=\"comment\">// move quad word = 8 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運四倍字長</span></span><br><span class=\"line\">MOVQ $<span class=\"number\">-10</span>, AX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>地址傳送</strong></p>\n<p> 將源操作數的地址複製到目的操作數。</p>\n<blockquote>\n<p>lea is an abbreviation of “load effective address”。— <a href=\"https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwif6oDs8PbtAhWNzIsBHb-kDG0QFjADegQICBAC&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F1658294%2Fwhats-the-purpose-of-the-lea-instruction&usg=AOvVaw1XNxphxiOi5AcnWxGpYRbV\">Stack Overflow</a></p>\n</blockquote>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把AX內容的地址傳送到BX中</span></span><br><span class=\"line\">LEAQ AX, BX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>計算</strong></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add quad word from AX to BX</span></span><br><span class=\"line\"><span class=\"comment\">// BX += AX</span></span><br><span class=\"line\">ADDQ  AX, BX</span><br><span class=\"line\"><span class=\"comment\">// subtract quad word from AX to BX</span></span><br><span class=\"line\"><span class=\"comment\">// BX -= AX</span></span><br><span class=\"line\">SUBQ  AX, BX</span><br><span class=\"line\"><span class=\"comment\">// 無符號乘法 IMUL</span></span><br><span class=\"line\"><span class=\"comment\">// BX *= AX</span></span><br><span class=\"line\">IMULQ AX, BX</span><br><span class=\"line\"><span class=\"comment\">// 無符號除法 IDIV</span></span><br><span class=\"line\"><span class=\"comment\">// 除數是CX，被除數是AX，結果存儲到AX中</span></span><br><span class=\"line\">IDIVQ CX</span><br><span class=\"line\"><span class=\"comment\">// 比較SI和CX的大小。與SUBQ類似，只是不賦值</span></span><br><span class=\"line\"><span class=\"comment\">// 其結果會存放到寄存器中</span></span><br><span class=\"line\">CMPQ SI CX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>跳轉</strong></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- 無條件跳轉 -- </span></span><br><span class=\"line\"><span class=\"comment\">// 跳轉到地址，地址可為代碼中的地址，不過實際上手寫不會出現這種東西</span></span><br><span class=\"line\">JMP addr</span><br><span class=\"line\"><span class=\"comment\">// 跳轉到標籤，可以跳轉到同一函數內的標籤位置</span></span><br><span class=\"line\">JMP label</span><br><span class=\"line\"><span class=\"comment\">// 以當前指令為基礎，向前跳轉 x 行</span></span><br><span class=\"line\">JMP <span class=\"number\">2</span>(PC)</span><br><span class=\"line\"><span class=\"comment\">// 以當前指令為基礎，向後跳轉 x 行</span></span><br><span class=\"line\">JMP <span class=\"number\">-2</span>(PC)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- 有條件跳轉 --</span></span><br><span class=\"line\"><span class=\"comment\">// jump target if zero</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 zero flag 被 set 過，則跳轉</span></span><br><span class=\"line\">JZ target</span><br><span class=\"line\"><span class=\"comment\">// jump target if less</span></span><br><span class=\"line\"><span class=\"comment\">// 上一行的比較CMP結果，左邊小於右邊則執行跳到0x0185地址處(十進制389轉換成十六進制0x0185)</span></span><br><span class=\"line\">JLS <span class=\"number\">389</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>指令集</strong></p>\n<p> 見源代碼的 <a href=\"https://github.com/golang/arch/blob/master/x86/x86.csv\">arch 部分</a>。</p>\n</li>\n</ol>\n<h3 id=\"1-2-5-案例分析：函數調用\"><a href=\"#1-2-5-案例分析：函數調用\" class=\"headerlink\" title=\"1.2.5 案例分析：函數調用\"></a>1.2.5 <strong>案例分析：函數調用</strong></h3><p>編寫以下代碼於 call.go 文件：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Callee</span><span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  r := x + y</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Caller</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  Callee(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行以下命令可查看彙編代碼：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -S 輸出彙編代碼到控制台 Print assembly listing to standard output (code only).</span></span><br><span class=\"line\"><span class=\"comment\">// -l 禁止內聯 Disable inlining.</span></span><br><span class=\"line\"><span class=\"comment\">// -N 禁止優化 Disable optimizations.</span></span><br><span class=\"line\"><span class=\"comment\">// 更多參數：https://pkg.go.dev/cmd/compile@go1.15.6</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> build -gcflags=<span class=\"string\">&quot;-S -l -N&quot;</span> call.<span class=\"keyword\">go</span></span><br></pre></td></tr></table></figure>\n\n<p>輸出結果爲（有刪減）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span>.Callee STEXT nosplit size=<span class=\"number\">52</span> args=<span class=\"number\">0x18</span> locals=<span class=\"number\">0x10</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    TEXT    <span class=\"string\">&quot;&quot;</span>.Callee(SB), NOSPLIT|ABIInternal, $<span class=\"number\">16</span><span class=\"number\">-24</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    SUBQ    $<span class=\"number\">16</span>, SP</span><br><span class=\"line\"><span class=\"number\">0x0004</span> <span class=\"number\">00004</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    MOVQ    BP, <span class=\"number\">8</span>(SP)</span><br><span class=\"line\"><span class=\"number\">0x0009</span> <span class=\"number\">00009</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    LEAQ    <span class=\"number\">8</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 將40(SP)處的變量~r2的值爲0，即返回值初始化爲0</span></span><br><span class=\"line\"><span class=\"number\">0x000e</span> <span class=\"number\">00014</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    MOVQ    $<span class=\"number\">0</span>, <span class=\"string\">&quot;&quot;</span>.~r2+<span class=\"number\">40</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將24(SP)處的變量x的值傳送到AX中</span></span><br><span class=\"line\"><span class=\"number\">0x0017</span> <span class=\"number\">00023</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    MOVQ    <span class=\"string\">&quot;&quot;</span>.x+<span class=\"number\">24</span>(SP), AX</span><br><span class=\"line\"><span class=\"comment\">// 將32(SP)處的變量y加到AX中</span></span><br><span class=\"line\"><span class=\"number\">0x001c</span> <span class=\"number\">00028</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    ADDQ    <span class=\"string\">&quot;&quot;</span>.y+<span class=\"number\">32</span>(SP), AX</span><br><span class=\"line\"><span class=\"comment\">// 將AX的值傳送到(SP)處的變量r中</span></span><br><span class=\"line\"><span class=\"number\">0x0021</span> <span class=\"number\">00033</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    MOVQ    AX, <span class=\"string\">&quot;&quot;</span>.r(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將AX中的值傳送到40(SP)處的變量~r2，即返回值賦值爲AX中的值</span></span><br><span class=\"line\"><span class=\"number\">0x0025</span> <span class=\"number\">00037</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    MOVQ    AX, <span class=\"string\">&quot;&quot;</span>.~r2+<span class=\"number\">40</span>(SP)</span><br><span class=\"line\"><span class=\"number\">0x002a</span> <span class=\"number\">00042</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    MOVQ    <span class=\"number\">8</span>(SP), BP</span><br><span class=\"line\"><span class=\"number\">0x002f</span> <span class=\"number\">00047</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    ADDQ    $<span class=\"number\">16</span>, SP</span><br><span class=\"line\"><span class=\"number\">0x0033</span> <span class=\"number\">00051</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    RET</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Go 彙編的固定開頭，Caller爲函數名，</span></span><br><span class=\"line\"><span class=\"comment\">// args 爲入參和返回值佔用的字節大小 0x0=0，</span></span><br><span class=\"line\"><span class=\"comment\">// locals 爲局部變量佔用的字節大小 0x20=32</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span>.Caller STEXT size=<span class=\"number\">71</span> args=<span class=\"number\">0x0</span> locals=<span class=\"number\">0x20</span></span><br><span class=\"line\"><span class=\"comment\">// 聲明函數Caller</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    TEXT    <span class=\"string\">&quot;&quot;</span>.Caller(SB), ABIInternal, $<span class=\"number\">32</span><span class=\"number\">-0</span></span><br><span class=\"line\"><span class=\"comment\">// 將(TLS)複製到CX寄存器，(TLS)是指向當前G(goroutine的一種數據結構)的指針</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    MOVQ    (TLS), CX</span><br><span class=\"line\"><span class=\"comment\">// 比較當前棧指針和CX正偏移16個字節的地址</span></span><br><span class=\"line\"><span class=\"number\">0x0009</span> <span class=\"number\">00009</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    CMPQ    SP, <span class=\"number\">16</span>(CX)</span><br><span class=\"line\"><span class=\"comment\">// 如果比較值左邊小於右邊，則跳轉到地址 64 處，即 CALL    runtime.morestack_noctxt(SB)</span></span><br><span class=\"line\"><span class=\"number\">0x000d</span> <span class=\"number\">00013</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    JLS     <span class=\"number\">64</span></span><br><span class=\"line\"><span class=\"comment\">// SP減去32，函數開始入棧</span></span><br><span class=\"line\"><span class=\"number\">0x000f</span> <span class=\"number\">00015</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    SUBQ    $<span class=\"number\">32</span>, SP</span><br><span class=\"line\"><span class=\"comment\">// 把BP中的值傳送到24(SP)處開始的內存空間，保存調用者棧幀地址到本棧。</span></span><br><span class=\"line\"><span class=\"number\">0x0013</span> <span class=\"number\">00019</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    MOVQ    BP, <span class=\"number\">24</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將24(SP)處的地址傳送到BP，保存當前棧幀地址到BP。</span></span><br><span class=\"line\"><span class=\"number\">0x0018</span> <span class=\"number\">00024</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    LEAQ    <span class=\"number\">24</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 將數字1傳送到(SP)處開始的內存空間</span></span><br><span class=\"line\"><span class=\"number\">0x001d</span> <span class=\"number\">00029</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    MOVQ    $<span class=\"number\">1</span>, (SP)</span><br><span class=\"line\"><span class=\"comment\">// 將數字2傳送到8(SP)處開始的內存空間</span></span><br><span class=\"line\"><span class=\"number\">0x0025</span> <span class=\"number\">00037</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    MOVQ    $<span class=\"number\">2</span>, <span class=\"number\">8</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 調用Callee函數</span></span><br><span class=\"line\"><span class=\"number\">0x002e</span> <span class=\"number\">00046</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    CALL    <span class=\"string\">&quot;&quot;</span>.Callee(SB)</span><br><span class=\"line\"><span class=\"comment\">// 調用Callee函數時BP寄存器的值會指向Callee的棧幀地址，因此結束後需要復位。</span></span><br><span class=\"line\"><span class=\"number\">0x0033</span> <span class=\"number\">00051</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   MOVQ    <span class=\"number\">24</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 出棧</span></span><br><span class=\"line\"><span class=\"number\">0x0038</span> <span class=\"number\">00056</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   ADDQ    $<span class=\"number\">32</span>, SP</span><br><span class=\"line\"><span class=\"comment\">// 返回</span></span><br><span class=\"line\"><span class=\"number\">0x003c</span> <span class=\"number\">00060</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   RET</span><br><span class=\"line\"><span class=\"comment\">// 無操作</span></span><br><span class=\"line\"><span class=\"number\">0x003d</span> <span class=\"number\">00061</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   NOP</span><br><span class=\"line\"><span class=\"number\">0x003d</span> <span class=\"number\">00061</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    NOP</span><br><span class=\"line\"><span class=\"comment\">// 調用runtime.morestack_noctxt函數</span></span><br><span class=\"line\"><span class=\"number\">0x0040</span> <span class=\"number\">00064</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    CALL    runtime.morestack_noctxt(SB)</span><br><span class=\"line\"><span class=\"comment\">// 跳轉到函數聲明處</span></span><br><span class=\"line\"><span class=\"number\">0x0045</span> <span class=\"number\">00069</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    JMP     <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>分析可得棧結構如下：</p>\n<p><img src=\"/it/go/go-design-and-implementation-01/Untitled%203.png\" alt></p>\n<h2 id=\"1-3-參考\"><a href=\"#1-3-參考\" class=\"headerlink\" title=\"1.3 參考\"></a>1.3 參考</h2><ol>\n<li><a href=\"https://draveness.me/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/\">Go 语言设计与实现：第一章 准备工作 — draveness</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html\">汇编语言入门教程 — 阮一峰的网络日志</a></li>\n<li><a href=\"https://xargin.com/plan9-assembly/\">Go 系列文章3 ：plan9 汇编入门 — 曹春晖@No Headback</a></li>\n<li><a href=\"https://www.cnblogs.com/qcrao-2018/p/10562216.html\">深入Go的底层，带你走近一群有追求的人 — Stefno@博客园</a></li>\n<li><a href=\"https://studygolang.com/articles/26380\">go plan9汇编入门 — yuchanns@Go 语言中文网</a></li>\n<li><a href=\"https://github.com/yuchanns/Atelier/blob/theme/hermit/src/_posts/golang-assembly.md\">go编译工具的使用之汇编 — yuchanns@github.com</a></li>\n<li><a href=\"https://davidwong.fr/goasm/\">Go Assembly by Example</a></li>\n<li><a href=\"https://golang.org/doc/asm\">A Quick Guide to Go’s Assembler — golang.org</a></li>\n<li><a href=\"http://doc.cat-v.org/plan_9/4th_edition/papers/asm\">A Manual for the Plan 9 assembler — Rob Pike</a></li>\n</ol>"},{"title":"《Go 設計與實現》筆記之第二章 編譯原理","p":"it/go/go-design-and-implementation-02.md","date":"2021-01-10T15:27:00.000Z","_content":"\n編譯原理這一章講 Go 的源代碼是如何變成二進制碼的，可分爲四個過程：\n\n1. 詞法和語法分析 lexical and grammar analysis\n2. 類型檢查 type check\n3. 中間代碼生成 IR(intermediate representation) generation\n4. 機器碼生成 machine code generation\n\n詞法分析是將源代碼視爲字符串序列，對各個字符串進行標記，生成 Token 序列。\n\n語法分析是將 Token 序列按照 LALR(1)（向前查看和自底向上解析）的解析文法進行解析，生成一棵AST (抽象語法樹 )。\n\n類型檢查分靜態類型檢查和動態類型檢查，靜態類型檢查會在編譯期對變量賦值、返回值和函數參數進行類型檢查；動態類型檢查在代碼運行時進行，可以實現向下類型轉換、延遲綁定和反射等功能。\n\n中間代碼生成階段首先會進行 ssaconfig 的初始化，緩存可能需要用到的類型和指針；然後進行遍歷和替換，將內建函數 make、map、channel、new、select、panic、recover 等等替換成 runtime 包的函數。最後不斷地進行中間代碼生成，優化代碼，生成類似彙編代碼的代碼。\n\n機器碼生成階段分兩個部分：一是 SSA 中間代碼降級、針對特定CPU架構的中間代碼優化和重寫，最後生成相當接近特定架構彙編代碼的指令；二是將特定架構的指令轉成二進制代碼。\n\n<!--more-->\n\n## 2.1 概述\n\n編譯原理就是講編譯器如何將代碼編譯成二進制碼。\n\n### 2.1.1 預備知識\n\n**（1）抽象語法樹**\n\n抽象語法樹（Abstract Syntax Tree、AST），是源代碼語法的結構的樹狀表示。以表達式 2 * 3 + 7 為例，編譯器的語法分析階段會生成如下圖所示的抽象語法樹：\n\n![](go-design-and-implementation-02/Untitled.png)\n\n**（2）靜態單賦值**\n\n靜態單賦值（Static Single Assignment、SSA），是指中間代碼每個變量只會被賦值一次。例如以下代碼：\n\n```go\nx := 1\nx := 2\ny := x\n```\n\n其中間的代碼爲：\n\n```go\nx_1 := 1\nx_2 := 2\ny_1 := x_2\n```\n\n由於 x_1 := 1 沒有什麼用，因此會在生成機器碼時省去。\n\n**（3）指令集**\n\n指令集或者說指令集架構 (Instruction set architecture, ISA)，就是計算機的抽象模型。指令集可分爲兩大類：\n\n- 複雜指令集計算機 (complex instruction set computer, CISC)：包含了很多特定的指令，但是其中的一些指令很少會被程序使用（據說有 80% 不經常使用）。例如：Intel 8080、x86-family。\n- 精簡指令集計算機 (reduced instruction set computer, RISC)：只實現了經常被使用的指令，不常用的操作都會通過組合簡單指令來實現。例如：ARM、Power ISA。\n\n### 2.1.2 編譯原理\n\n![](go-design-and-implementation-02/Untitled%201.png)\n\n編譯器的前端：\n\n- 詞法分析 lexical analysis\n- 語法分析 syntax analysis\n- 語義分析 semantic analysis\n\n編譯器的後端：\n\n- 中間代碼生成 IR(Intermediate Representation)  generation\n- 代碼優化 code optimization\n- 機器碼生成 machinecode generation\n\nGo 的編譯器邏輯上可以分爲四個階段：\n\n1. 詞法和語法分析，將源代碼字符串序列轉成 Token 序列，再轉成抽象語法樹。\n2. 類型檢查，檢查類型，並展開內建的函數。\n3. 中間代碼生成，使用 goroutine 並發生成中間代碼，並進行 SSA 優化。\n4. 機器碼生成，根據不同類型的 CPU 生成不同的機器碼\n\nGo 的編譯器入口在 [src/cmd/compile/internal/gc/main.go](https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go) 文件中，其中的 Main 函數就是編譯器的主要程序，其工作過程是：\n\n1. 獲取命令行傳入的參數並更新編譯選項和配置。\n2. 調用 parseFiles 方法解析輸入的文件，得到 AST，隨後進行以下 9 個步驟：\n    1. const, type, and names and types of funcs（檢查常量、類型以及函數的名稱和類型）\n    2. Variable assignments（處理變量賦值）\n    3. Type check function bodies（對函數體進行類型檢查）\n    4. Decide how to capture closed variables（決定如何捕獲封閉的變量）\n    5. Inlining（處理內聯函數）\n    6. Escape analysis（進行逃逸分析）\n    7. Transform closure bodies to properly reference captured variables（將閉包的主體轉成實際引用的捕獲變量）\n    8. Compile top level functions（編譯頂層函數）\n    9. Check external declarations（檢查外部聲明）\n\n## 2.2 詞法和語法分析\n\n### 2.2.1 詞法分析\n\n詞法分析就是將源代碼的字符串序列轉成標記(Token)序列的過程。如 `make(chan int)` 經過詞法分析後是一個由 `make` 、`(`、`chan`、`int` 和 `)` 組成的 Token序列。\n\n可以使用 lex 工具進行詞法分析，Go 早期也是使用該工具，[該案例](https://github.com/LinLshare/case/blob/main/doc/compile/compile_001_flex)展示了使用 lex 工具進行詞法分析。後期更換成了自身，[該案例](https://github.com/LinLshare/case/blob/main/doc/compile/compile_002_golang_lexer)展示了使用 Go 自帶的詞法分析器進行詞法分析。\n\n### 2.2.2 語法分析\n\n語法分析是根據某種特定的形式文法（Grammar）對 Token 序列構成的輸入文本進行分析並確定其語法結構的過程。\n\n**文法**\n\n上下文無關文法([context-free grammar](https://en.wikipedia.org/wiki/Context-free_grammar)) 是用來形式化、精確描述某種編程語言的工具，由以下四個部分組成：\n\n1. N, 有限個非終結符的集合\n2. Σ, 有限個終結符的集合\n3. P, 有限個生成規則(production rule)的集合\n4. S, 開始變量或符號，用來代表整個語句或程序，是集合N的成員。\n\n非終結符可以使用一組終結符根據生成規則展開，而終結符是語言定義的基本元素，不可展開。\n\nP = N x (NvΣ)* 即生成規則是集合 N與集合N、Σ的併集的 Kleene 操作之間的二元關係。\n\n假定有以下生成規則：\n\n1. S —> aSb // S 可以展開爲 aSb\n2. S —> ab // S 可以展開爲 ab\n\n那麼，aabb（運用一次規則1，一次規則2）、aaabbb（運用兩次規則1，一次規則2）等就是符合語法規則的表示。\n\n**解析方法**\n\n解析文法的方法有兩種：\n\n1. **自頂向下解析**(Top-down parsing)：從最高級別開始解析，不斷地用生成規則右側的符號展開非終結符，直到最低級別的終結符號。\n2. **自底向上解析**(Bottom-up parsing)：從最低級別開始解析，不斷地用生成規則左側非終結符歸約，直到最高級別的開始符號。\n\n**LL文法**是一種使用自頂向下解析的文法。假定有 LL文法如下：\n\n1. 𝑆→𝑎𝑆1\n2. 𝑆1→𝑏𝑆1\n3. 𝑆1→𝜖\n\n輸入流 abb 採用上面的文法進行解析，其過程爲：\n\n1. S （開始符號）\n2. aS1（規則 1）\n3. abS1 （規則 2）\n4. abbS1 （規則2）\n5. abb（規則 3）\n\n**LR(0) 文法**是一种使用自底向上解析的文法。假定有 LR(0) 文法如下：\n\n1. 𝑆→𝑆1\n2. 𝑆1→𝑆1𝑏\n3. 𝑆1→𝑎\n\n輸入流 abb 採用上面的文法進行解析，其過程爲：\n\n1. a（入棧）\n2. S1（規則3）\n3. S1b（入棧）\n4. S1（規則2）\n5. S1b（入棧）\n6. S1（規則2）\n7. S（規則1）\n\n當有多個生成規則符合時，會出現衝突。解析時可以採用 **Lookahead** 向前查看技術解決，即預讀一個 Token 確保出現衝突的生成規則可以被正確處理。\n\nGo 語言的解析器採用 LALR(1) 的文法進行解析，是一種自底向上且帶有 **Lookahead**(縮寫爲LA) 功能的解析文法。LALR(1)  也是大多數編程語言的選擇。\n\n**Go 文法**\n\n閱讀 src/cmd/compile/internal/syntax/parser.go，可知：\n\n每個 Go 源代碼文件最終都會被解析成一個獨立的抽象語法樹，所以語法樹最頂層的結構或者開始符號都是 SourceFile：\n\n```go\nSourceFile = PackageClause \";\" { ImportDecl \";\" } { TopLevelDecl \";\" } .\n```\n\nPackageClause 的生成規則爲：\n\n```go\nPackageClause  = \"package\" PackageName .\nPackageName    = identifier .\nidentifier = letter { letter | unicode_digit } .\n```\n\nImportDecl 的生成規則爲：\n\n```go\nImportDecl       = \"import\" ( ImportSpec | \"(\" { ImportSpec \";\" } \")\" ) .\nImportSpec       = [ \".\" | PackageName ] ImportPath .\nImportPath       = string_lit .\n```\n\nTopLevelDecl 的生成規則爲：\n\n```go\nTopLevelDecl  = Declaration | FunctionDecl | MethodDecl .\nDeclaration   = ConstDecl | TypeDecl | VarDecl .\n```\n\n可知頂層的聲明共有五種，分別是常量、類型、變量、函數和方法聲明，其生成规则如下：\n\n```go\nConstDecl = \"const\" ( ConstSpec | \"(\" { ConstSpec \";\" } \")\" ) .\nConstSpec = IdentifierList [ [ Type ] \"=\" ExpressionList ] .\n\nTypeDecl  = \"type\" ( TypeSpec | \"(\" { TypeSpec \";\" } \")\" ) .\nTypeSpec  = AliasDecl | TypeDef .\nAliasDecl = identifier \"=\" Type .\nTypeDef   = identifier Type .\n\nVarDecl = \"var\" ( VarSpec | \"(\" { VarSpec \";\" } \")\" ) .\nVarSpec = IdentifierList ( Type [ \"=\" ExpressionList ] | \"=\" ExpressionList ) .\n\nFunctionDecl = \"func\" FunctionName Signature [ FunctionBody ] .\nFunctionName = identifier .\nFunctionBody = Block .\n\nMethodDecl = \"func\" Receiver MethodName Signature [ FunctionBody ] .\nReceiver   = Parameters .\n\nBlock = \"{\" StatementList \"}\" .\nStatementList = { Statement \";\" } .\n\nStatement =\n\tDeclaration | LabeledStmt | SimpleStmt |\n\tGoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |\n\tFallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |\n\tDeferStmt .\n\nSimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .\n```\n\n更詳細的文法見：[Language Specification](https://golang.org/ref/spec#Declarations_and_scope)。\n\n## 2.3 類型檢查\n\n類型檢查的目的在於確保代碼正確執行。\n\n類型分兩種：強類型和弱類型。一般來說，強類型是在編譯期間有嚴格的類型限制，會在編譯期間發現變量賦值、返回值和函數調用是的類型錯誤。弱類型則是在運行時出現類型錯誤時進行隱式類型轉換。\n\n檢查也分兩種：靜態類型檢查和動態類型檢查。靜態類型檢查是在編譯期進行，動態類型檢查是在運行期間進行。實現動態類型檢查通常是爲每個運行時對象關聯一個類型標籤，包含了它的類型信息（RTTI, the Runtime type information），用來實現動態派發、延遲綁定、向下轉型和反射等等。\n\n另外，只使用動態類型檢查的編程語言叫做動態類型編程語言，比如 JavaScript、Ruby 和 PHP。\n\nGo 進行靜態類型檢查的代碼主要邏輯在 [cmd/compile/internal/gc.typecheck](https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck) 和 [cmd/compile/internal/gc.typecheck1](https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1) 中。\n\n```go\nfunc typecheck1(n *Node, top int) (res *Node) {\n\tswitch n.Op {\n\tcase OTARRAY:\n\t\t...\n\n\tcase OTMAP:\n\t\t...\n\n\tcase OTCHAN:\n\t\t...\n\t}\n\n\t...\n\n\treturn n\n}\n```\n\n介紹幾種常見類型的檢查過程：\n\n- OTARRAY 數組或切片類型：\n    1. 對右節點也就是元素進行類型檢查\n    2. 對左節點，按三種情況：\n        1. []int，直接調用 [cmd/compile/internal/types.NewSlice](https://draveness.me/golang/tree/cmd/compile/internal/types.NewSlice)，返回一個 `TSLICE` 類型的結構體。\n        2. [...]int，ODDD(即...) 先調用 [cmd/compile/internal/gc.typecheckcomplit]() ，後調用 [cmd/compile/internal/types.NewArray](https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray) 初始化一個存儲著數組中元素類型和數組大小的結構體。\n        3. [3]int，調用 [cmd/compile/internal/types.NewArray](https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray) 初始化一個存儲著數組中元素類型和數組大小的結構體。\n- OTMAP 哈希類型：\n    1. 分別檢查鍵值類型\n    2. 通過 [cmd/compile/internal/types.NewMap]() 创建一个新的 TMAP 结构并将哈希的键值类型都存储到该结构体\n    3. 代表當前哈希的節點最終也會被加入 mapqueue 隊列，編譯器會在後面的階段對哈希鍵的類型進行再次檢查。\n- OMAKE 內置函數make\n    1. 檢查第一個類型參數，然後據此進入不同的分支：TSLICE 切片分支、TMAP 哈希分支和 TCHAN 信道分支。\n    2. 如是 TSLICE 分支，將檢查 len 和 cap 的合法性，然後將當前節點的 Op 改爲 OMAKESLICE。\n    3. 如是 TMAP 分支，將在檢查 size 之後將當前節點的 Op 改爲 OMAKEMAP。\n    4. 如是 TCHAN 分支，將在檢查 buffer 之後將當前節點的 Op 改爲 OMAKECHAN。\n\n## 2.4 中間代碼生成\n\n中間代碼生成是爲了解決直接編譯成二進制碼的複雜。通過將複雜問題拆分成一個個簡單的步驟，再逐個擊破，這就是中間代碼的作用。\n\nAST 和二進制碼之間隔了幾十次中間代碼的生成。生成之初會將緩存可能需要用到的類型和指針，並將內建函數映射到 runtime包中的函數。之後每次中間代碼的生成都是對代碼的優化，最後生成具備 SSA 特性的中間代碼。\n\n![](go-design-and-implementation-02/Untitled%202.png)\n\n關鍵字和操作符和運行時函數的映射\n\n中間代碼不是彙編代碼，但是很接近彙編代碼，也用到一些寄存器，可說是彙編代碼的偽代碼（pseudo code），中間代碼形如：\n\n```go\npass trim begin\n  pass trim end [738 ns]\nhello func(int) int\n  b1:\n    v1 = InitMem <mem>\n    v10 = VarDef <mem> {~r1} v1\n    v2 = SP <uintptr> : SP\n    v6 = Arg <int> {a} : a[int]\n    v8 = LoadReg <int> v6 : AX\n    v9 = ADDQconst <int> [2] v8 : AX (c[int])\n    v11 = MOVQstore <mem> {~r1} v2 v9 v10\n    Ret v11\n```\n\n## 2.5 機器碼生成\n\n機器碼的生成包含兩個部分：\n\n1. [cmd/compile/internal/ssa](https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa) 進行 SSA 中間代碼的降級過程，執行架構特定的優化和重寫，最後生成架構特定的指令 [cmd/compile/internal/obj.Prog](https://draveness.me/golang/tree/cmd/compile/internal/obj.Prog)。\n2. [cmd/internal/obj](https://github.com/golang/go/tree/master/src/cmd/internal/obj) 作爲彙編器將架構特定的指令轉成二進制代碼。","source":"_posts/it/go/go-design-and-implementation-02.md","raw":"---\ntitle: 《Go 設計與實現》筆記之第二章 編譯原理\np: it/go/go-design-and-implementation-02.md\ndate: 2021-01-10 23:27:00\ntags:\n- Go\n---\n\n編譯原理這一章講 Go 的源代碼是如何變成二進制碼的，可分爲四個過程：\n\n1. 詞法和語法分析 lexical and grammar analysis\n2. 類型檢查 type check\n3. 中間代碼生成 IR(intermediate representation) generation\n4. 機器碼生成 machine code generation\n\n詞法分析是將源代碼視爲字符串序列，對各個字符串進行標記，生成 Token 序列。\n\n語法分析是將 Token 序列按照 LALR(1)（向前查看和自底向上解析）的解析文法進行解析，生成一棵AST (抽象語法樹 )。\n\n類型檢查分靜態類型檢查和動態類型檢查，靜態類型檢查會在編譯期對變量賦值、返回值和函數參數進行類型檢查；動態類型檢查在代碼運行時進行，可以實現向下類型轉換、延遲綁定和反射等功能。\n\n中間代碼生成階段首先會進行 ssaconfig 的初始化，緩存可能需要用到的類型和指針；然後進行遍歷和替換，將內建函數 make、map、channel、new、select、panic、recover 等等替換成 runtime 包的函數。最後不斷地進行中間代碼生成，優化代碼，生成類似彙編代碼的代碼。\n\n機器碼生成階段分兩個部分：一是 SSA 中間代碼降級、針對特定CPU架構的中間代碼優化和重寫，最後生成相當接近特定架構彙編代碼的指令；二是將特定架構的指令轉成二進制代碼。\n\n<!--more-->\n\n## 2.1 概述\n\n編譯原理就是講編譯器如何將代碼編譯成二進制碼。\n\n### 2.1.1 預備知識\n\n**（1）抽象語法樹**\n\n抽象語法樹（Abstract Syntax Tree、AST），是源代碼語法的結構的樹狀表示。以表達式 2 * 3 + 7 為例，編譯器的語法分析階段會生成如下圖所示的抽象語法樹：\n\n![](go-design-and-implementation-02/Untitled.png)\n\n**（2）靜態單賦值**\n\n靜態單賦值（Static Single Assignment、SSA），是指中間代碼每個變量只會被賦值一次。例如以下代碼：\n\n```go\nx := 1\nx := 2\ny := x\n```\n\n其中間的代碼爲：\n\n```go\nx_1 := 1\nx_2 := 2\ny_1 := x_2\n```\n\n由於 x_1 := 1 沒有什麼用，因此會在生成機器碼時省去。\n\n**（3）指令集**\n\n指令集或者說指令集架構 (Instruction set architecture, ISA)，就是計算機的抽象模型。指令集可分爲兩大類：\n\n- 複雜指令集計算機 (complex instruction set computer, CISC)：包含了很多特定的指令，但是其中的一些指令很少會被程序使用（據說有 80% 不經常使用）。例如：Intel 8080、x86-family。\n- 精簡指令集計算機 (reduced instruction set computer, RISC)：只實現了經常被使用的指令，不常用的操作都會通過組合簡單指令來實現。例如：ARM、Power ISA。\n\n### 2.1.2 編譯原理\n\n![](go-design-and-implementation-02/Untitled%201.png)\n\n編譯器的前端：\n\n- 詞法分析 lexical analysis\n- 語法分析 syntax analysis\n- 語義分析 semantic analysis\n\n編譯器的後端：\n\n- 中間代碼生成 IR(Intermediate Representation)  generation\n- 代碼優化 code optimization\n- 機器碼生成 machinecode generation\n\nGo 的編譯器邏輯上可以分爲四個階段：\n\n1. 詞法和語法分析，將源代碼字符串序列轉成 Token 序列，再轉成抽象語法樹。\n2. 類型檢查，檢查類型，並展開內建的函數。\n3. 中間代碼生成，使用 goroutine 並發生成中間代碼，並進行 SSA 優化。\n4. 機器碼生成，根據不同類型的 CPU 生成不同的機器碼\n\nGo 的編譯器入口在 [src/cmd/compile/internal/gc/main.go](https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go) 文件中，其中的 Main 函數就是編譯器的主要程序，其工作過程是：\n\n1. 獲取命令行傳入的參數並更新編譯選項和配置。\n2. 調用 parseFiles 方法解析輸入的文件，得到 AST，隨後進行以下 9 個步驟：\n    1. const, type, and names and types of funcs（檢查常量、類型以及函數的名稱和類型）\n    2. Variable assignments（處理變量賦值）\n    3. Type check function bodies（對函數體進行類型檢查）\n    4. Decide how to capture closed variables（決定如何捕獲封閉的變量）\n    5. Inlining（處理內聯函數）\n    6. Escape analysis（進行逃逸分析）\n    7. Transform closure bodies to properly reference captured variables（將閉包的主體轉成實際引用的捕獲變量）\n    8. Compile top level functions（編譯頂層函數）\n    9. Check external declarations（檢查外部聲明）\n\n## 2.2 詞法和語法分析\n\n### 2.2.1 詞法分析\n\n詞法分析就是將源代碼的字符串序列轉成標記(Token)序列的過程。如 `make(chan int)` 經過詞法分析後是一個由 `make` 、`(`、`chan`、`int` 和 `)` 組成的 Token序列。\n\n可以使用 lex 工具進行詞法分析，Go 早期也是使用該工具，[該案例](https://github.com/LinLshare/case/blob/main/doc/compile/compile_001_flex)展示了使用 lex 工具進行詞法分析。後期更換成了自身，[該案例](https://github.com/LinLshare/case/blob/main/doc/compile/compile_002_golang_lexer)展示了使用 Go 自帶的詞法分析器進行詞法分析。\n\n### 2.2.2 語法分析\n\n語法分析是根據某種特定的形式文法（Grammar）對 Token 序列構成的輸入文本進行分析並確定其語法結構的過程。\n\n**文法**\n\n上下文無關文法([context-free grammar](https://en.wikipedia.org/wiki/Context-free_grammar)) 是用來形式化、精確描述某種編程語言的工具，由以下四個部分組成：\n\n1. N, 有限個非終結符的集合\n2. Σ, 有限個終結符的集合\n3. P, 有限個生成規則(production rule)的集合\n4. S, 開始變量或符號，用來代表整個語句或程序，是集合N的成員。\n\n非終結符可以使用一組終結符根據生成規則展開，而終結符是語言定義的基本元素，不可展開。\n\nP = N x (NvΣ)* 即生成規則是集合 N與集合N、Σ的併集的 Kleene 操作之間的二元關係。\n\n假定有以下生成規則：\n\n1. S —> aSb // S 可以展開爲 aSb\n2. S —> ab // S 可以展開爲 ab\n\n那麼，aabb（運用一次規則1，一次規則2）、aaabbb（運用兩次規則1，一次規則2）等就是符合語法規則的表示。\n\n**解析方法**\n\n解析文法的方法有兩種：\n\n1. **自頂向下解析**(Top-down parsing)：從最高級別開始解析，不斷地用生成規則右側的符號展開非終結符，直到最低級別的終結符號。\n2. **自底向上解析**(Bottom-up parsing)：從最低級別開始解析，不斷地用生成規則左側非終結符歸約，直到最高級別的開始符號。\n\n**LL文法**是一種使用自頂向下解析的文法。假定有 LL文法如下：\n\n1. 𝑆→𝑎𝑆1\n2. 𝑆1→𝑏𝑆1\n3. 𝑆1→𝜖\n\n輸入流 abb 採用上面的文法進行解析，其過程爲：\n\n1. S （開始符號）\n2. aS1（規則 1）\n3. abS1 （規則 2）\n4. abbS1 （規則2）\n5. abb（規則 3）\n\n**LR(0) 文法**是一种使用自底向上解析的文法。假定有 LR(0) 文法如下：\n\n1. 𝑆→𝑆1\n2. 𝑆1→𝑆1𝑏\n3. 𝑆1→𝑎\n\n輸入流 abb 採用上面的文法進行解析，其過程爲：\n\n1. a（入棧）\n2. S1（規則3）\n3. S1b（入棧）\n4. S1（規則2）\n5. S1b（入棧）\n6. S1（規則2）\n7. S（規則1）\n\n當有多個生成規則符合時，會出現衝突。解析時可以採用 **Lookahead** 向前查看技術解決，即預讀一個 Token 確保出現衝突的生成規則可以被正確處理。\n\nGo 語言的解析器採用 LALR(1) 的文法進行解析，是一種自底向上且帶有 **Lookahead**(縮寫爲LA) 功能的解析文法。LALR(1)  也是大多數編程語言的選擇。\n\n**Go 文法**\n\n閱讀 src/cmd/compile/internal/syntax/parser.go，可知：\n\n每個 Go 源代碼文件最終都會被解析成一個獨立的抽象語法樹，所以語法樹最頂層的結構或者開始符號都是 SourceFile：\n\n```go\nSourceFile = PackageClause \";\" { ImportDecl \";\" } { TopLevelDecl \";\" } .\n```\n\nPackageClause 的生成規則爲：\n\n```go\nPackageClause  = \"package\" PackageName .\nPackageName    = identifier .\nidentifier = letter { letter | unicode_digit } .\n```\n\nImportDecl 的生成規則爲：\n\n```go\nImportDecl       = \"import\" ( ImportSpec | \"(\" { ImportSpec \";\" } \")\" ) .\nImportSpec       = [ \".\" | PackageName ] ImportPath .\nImportPath       = string_lit .\n```\n\nTopLevelDecl 的生成規則爲：\n\n```go\nTopLevelDecl  = Declaration | FunctionDecl | MethodDecl .\nDeclaration   = ConstDecl | TypeDecl | VarDecl .\n```\n\n可知頂層的聲明共有五種，分別是常量、類型、變量、函數和方法聲明，其生成规则如下：\n\n```go\nConstDecl = \"const\" ( ConstSpec | \"(\" { ConstSpec \";\" } \")\" ) .\nConstSpec = IdentifierList [ [ Type ] \"=\" ExpressionList ] .\n\nTypeDecl  = \"type\" ( TypeSpec | \"(\" { TypeSpec \";\" } \")\" ) .\nTypeSpec  = AliasDecl | TypeDef .\nAliasDecl = identifier \"=\" Type .\nTypeDef   = identifier Type .\n\nVarDecl = \"var\" ( VarSpec | \"(\" { VarSpec \";\" } \")\" ) .\nVarSpec = IdentifierList ( Type [ \"=\" ExpressionList ] | \"=\" ExpressionList ) .\n\nFunctionDecl = \"func\" FunctionName Signature [ FunctionBody ] .\nFunctionName = identifier .\nFunctionBody = Block .\n\nMethodDecl = \"func\" Receiver MethodName Signature [ FunctionBody ] .\nReceiver   = Parameters .\n\nBlock = \"{\" StatementList \"}\" .\nStatementList = { Statement \";\" } .\n\nStatement =\n\tDeclaration | LabeledStmt | SimpleStmt |\n\tGoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |\n\tFallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |\n\tDeferStmt .\n\nSimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .\n```\n\n更詳細的文法見：[Language Specification](https://golang.org/ref/spec#Declarations_and_scope)。\n\n## 2.3 類型檢查\n\n類型檢查的目的在於確保代碼正確執行。\n\n類型分兩種：強類型和弱類型。一般來說，強類型是在編譯期間有嚴格的類型限制，會在編譯期間發現變量賦值、返回值和函數調用是的類型錯誤。弱類型則是在運行時出現類型錯誤時進行隱式類型轉換。\n\n檢查也分兩種：靜態類型檢查和動態類型檢查。靜態類型檢查是在編譯期進行，動態類型檢查是在運行期間進行。實現動態類型檢查通常是爲每個運行時對象關聯一個類型標籤，包含了它的類型信息（RTTI, the Runtime type information），用來實現動態派發、延遲綁定、向下轉型和反射等等。\n\n另外，只使用動態類型檢查的編程語言叫做動態類型編程語言，比如 JavaScript、Ruby 和 PHP。\n\nGo 進行靜態類型檢查的代碼主要邏輯在 [cmd/compile/internal/gc.typecheck](https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck) 和 [cmd/compile/internal/gc.typecheck1](https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1) 中。\n\n```go\nfunc typecheck1(n *Node, top int) (res *Node) {\n\tswitch n.Op {\n\tcase OTARRAY:\n\t\t...\n\n\tcase OTMAP:\n\t\t...\n\n\tcase OTCHAN:\n\t\t...\n\t}\n\n\t...\n\n\treturn n\n}\n```\n\n介紹幾種常見類型的檢查過程：\n\n- OTARRAY 數組或切片類型：\n    1. 對右節點也就是元素進行類型檢查\n    2. 對左節點，按三種情況：\n        1. []int，直接調用 [cmd/compile/internal/types.NewSlice](https://draveness.me/golang/tree/cmd/compile/internal/types.NewSlice)，返回一個 `TSLICE` 類型的結構體。\n        2. [...]int，ODDD(即...) 先調用 [cmd/compile/internal/gc.typecheckcomplit]() ，後調用 [cmd/compile/internal/types.NewArray](https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray) 初始化一個存儲著數組中元素類型和數組大小的結構體。\n        3. [3]int，調用 [cmd/compile/internal/types.NewArray](https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray) 初始化一個存儲著數組中元素類型和數組大小的結構體。\n- OTMAP 哈希類型：\n    1. 分別檢查鍵值類型\n    2. 通過 [cmd/compile/internal/types.NewMap]() 创建一个新的 TMAP 结构并将哈希的键值类型都存储到该结构体\n    3. 代表當前哈希的節點最終也會被加入 mapqueue 隊列，編譯器會在後面的階段對哈希鍵的類型進行再次檢查。\n- OMAKE 內置函數make\n    1. 檢查第一個類型參數，然後據此進入不同的分支：TSLICE 切片分支、TMAP 哈希分支和 TCHAN 信道分支。\n    2. 如是 TSLICE 分支，將檢查 len 和 cap 的合法性，然後將當前節點的 Op 改爲 OMAKESLICE。\n    3. 如是 TMAP 分支，將在檢查 size 之後將當前節點的 Op 改爲 OMAKEMAP。\n    4. 如是 TCHAN 分支，將在檢查 buffer 之後將當前節點的 Op 改爲 OMAKECHAN。\n\n## 2.4 中間代碼生成\n\n中間代碼生成是爲了解決直接編譯成二進制碼的複雜。通過將複雜問題拆分成一個個簡單的步驟，再逐個擊破，這就是中間代碼的作用。\n\nAST 和二進制碼之間隔了幾十次中間代碼的生成。生成之初會將緩存可能需要用到的類型和指針，並將內建函數映射到 runtime包中的函數。之後每次中間代碼的生成都是對代碼的優化，最後生成具備 SSA 特性的中間代碼。\n\n![](go-design-and-implementation-02/Untitled%202.png)\n\n關鍵字和操作符和運行時函數的映射\n\n中間代碼不是彙編代碼，但是很接近彙編代碼，也用到一些寄存器，可說是彙編代碼的偽代碼（pseudo code），中間代碼形如：\n\n```go\npass trim begin\n  pass trim end [738 ns]\nhello func(int) int\n  b1:\n    v1 = InitMem <mem>\n    v10 = VarDef <mem> {~r1} v1\n    v2 = SP <uintptr> : SP\n    v6 = Arg <int> {a} : a[int]\n    v8 = LoadReg <int> v6 : AX\n    v9 = ADDQconst <int> [2] v8 : AX (c[int])\n    v11 = MOVQstore <mem> {~r1} v2 v9 v10\n    Ret v11\n```\n\n## 2.5 機器碼生成\n\n機器碼的生成包含兩個部分：\n\n1. [cmd/compile/internal/ssa](https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa) 進行 SSA 中間代碼的降級過程，執行架構特定的優化和重寫，最後生成架構特定的指令 [cmd/compile/internal/obj.Prog](https://draveness.me/golang/tree/cmd/compile/internal/obj.Prog)。\n2. [cmd/internal/obj](https://github.com/golang/go/tree/master/src/cmd/internal/obj) 作爲彙編器將架構特定的指令轉成二進制代碼。","slug":"it/go/go-design-and-implementation-02","published":1,"updated":"2021-09-13T14:13:44.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlex000n1n9kejwo7ble","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>編譯原理這一章講 Go 的源代碼是如何變成二進制碼的，可分爲四個過程：</p>\n<ol>\n<li>詞法和語法分析 lexical and grammar analysis</li>\n<li>類型檢查 type check</li>\n<li>中間代碼生成 IR(intermediate representation) generation</li>\n<li>機器碼生成 machine code generation</li>\n</ol>\n<p>詞法分析是將源代碼視爲字符串序列，對各個字符串進行標記，生成 Token 序列。</p>\n<p>語法分析是將 Token 序列按照 LALR(1)（向前查看和自底向上解析）的解析文法進行解析，生成一棵AST (抽象語法樹 )。</p>\n<p>類型檢查分靜態類型檢查和動態類型檢查，靜態類型檢查會在編譯期對變量賦值、返回值和函數參數進行類型檢查；動態類型檢查在代碼運行時進行，可以實現向下類型轉換、延遲綁定和反射等功能。</p>\n<p>中間代碼生成階段首先會進行 ssaconfig 的初始化，緩存可能需要用到的類型和指針；然後進行遍歷和替換，將內建函數 make、map、channel、new、select、panic、recover 等等替換成 runtime 包的函數。最後不斷地進行中間代碼生成，優化代碼，生成類似彙編代碼的代碼。</p>\n<p>機器碼生成階段分兩個部分：一是 SSA 中間代碼降級、針對特定CPU架構的中間代碼優化和重寫，最後生成相當接近特定架構彙編代碼的指令；二是將特定架構的指令轉成二進制代碼。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h2><p>編譯原理就是講編譯器如何將代碼編譯成二進制碼。</p>\n<h3 id=\"2-1-1-預備知識\"><a href=\"#2-1-1-預備知識\" class=\"headerlink\" title=\"2.1.1 預備知識\"></a>2.1.1 預備知識</h3><p><strong>（1）抽象語法樹</strong></p>\n<p>抽象語法樹（Abstract Syntax Tree、AST），是源代碼語法的結構的樹狀表示。以表達式 2 * 3 + 7 為例，編譯器的語法分析階段會生成如下圖所示的抽象語法樹：</p>\n<p><img src=\"/it/go/go-design-and-implementation-02/Untitled.png\" alt></p>\n<p><strong>（2）靜態單賦值</strong></p>\n<p>靜態單賦值（Static Single Assignment、SSA），是指中間代碼每個變量只會被賦值一次。例如以下代碼：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">1</span></span><br><span class=\"line\">x := <span class=\"number\">2</span></span><br><span class=\"line\">y := x</span><br></pre></td></tr></table></figure>\n\n<p>其中間的代碼爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x_1 := <span class=\"number\">1</span></span><br><span class=\"line\">x_2 := <span class=\"number\">2</span></span><br><span class=\"line\">y_1 := x_2</span><br></pre></td></tr></table></figure>\n\n<p>由於 x_1 := 1 沒有什麼用，因此會在生成機器碼時省去。</p>\n<p><strong>（3）指令集</strong></p>\n<p>指令集或者說指令集架構 (Instruction set architecture, ISA)，就是計算機的抽象模型。指令集可分爲兩大類：</p>\n<ul>\n<li>複雜指令集計算機 (complex instruction set computer, CISC)：包含了很多特定的指令，但是其中的一些指令很少會被程序使用（據說有 80% 不經常使用）。例如：Intel 8080、x86-family。</li>\n<li>精簡指令集計算機 (reduced instruction set computer, RISC)：只實現了經常被使用的指令，不常用的操作都會通過組合簡單指令來實現。例如：ARM、Power ISA。</li>\n</ul>\n<h3 id=\"2-1-2-編譯原理\"><a href=\"#2-1-2-編譯原理\" class=\"headerlink\" title=\"2.1.2 編譯原理\"></a>2.1.2 編譯原理</h3><p><img src=\"/it/go/go-design-and-implementation-02/Untitled%201.png\" alt></p>\n<p>編譯器的前端：</p>\n<ul>\n<li>詞法分析 lexical analysis</li>\n<li>語法分析 syntax analysis</li>\n<li>語義分析 semantic analysis</li>\n</ul>\n<p>編譯器的後端：</p>\n<ul>\n<li>中間代碼生成 IR(Intermediate Representation)  generation</li>\n<li>代碼優化 code optimization</li>\n<li>機器碼生成 machinecode generation</li>\n</ul>\n<p>Go 的編譯器邏輯上可以分爲四個階段：</p>\n<ol>\n<li>詞法和語法分析，將源代碼字符串序列轉成 Token 序列，再轉成抽象語法樹。</li>\n<li>類型檢查，檢查類型，並展開內建的函數。</li>\n<li>中間代碼生成，使用 goroutine 並發生成中間代碼，並進行 SSA 優化。</li>\n<li>機器碼生成，根據不同類型的 CPU 生成不同的機器碼</li>\n</ol>\n<p>Go 的編譯器入口在 <a href=\"https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go\">src/cmd/compile/internal/gc/main.go</a> 文件中，其中的 Main 函數就是編譯器的主要程序，其工作過程是：</p>\n<ol>\n<li>獲取命令行傳入的參數並更新編譯選項和配置。</li>\n<li>調用 parseFiles 方法解析輸入的文件，得到 AST，隨後進行以下 9 個步驟：<ol>\n<li>const, type, and names and types of funcs（檢查常量、類型以及函數的名稱和類型）</li>\n<li>Variable assignments（處理變量賦值）</li>\n<li>Type check function bodies（對函數體進行類型檢查）</li>\n<li>Decide how to capture closed variables（決定如何捕獲封閉的變量）</li>\n<li>Inlining（處理內聯函數）</li>\n<li>Escape analysis（進行逃逸分析）</li>\n<li>Transform closure bodies to properly reference captured variables（將閉包的主體轉成實際引用的捕獲變量）</li>\n<li>Compile top level functions（編譯頂層函數）</li>\n<li>Check external declarations（檢查外部聲明）</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-2-詞法和語法分析\"><a href=\"#2-2-詞法和語法分析\" class=\"headerlink\" title=\"2.2 詞法和語法分析\"></a>2.2 詞法和語法分析</h2><h3 id=\"2-2-1-詞法分析\"><a href=\"#2-2-1-詞法分析\" class=\"headerlink\" title=\"2.2.1 詞法分析\"></a>2.2.1 詞法分析</h3><p>詞法分析就是將源代碼的字符串序列轉成標記(Token)序列的過程。如 <code>make(chan int)</code> 經過詞法分析後是一個由 <code>make</code> 、<code>(</code>、<code>chan</code>、<code>int</code> 和 <code>)</code> 組成的 Token序列。</p>\n<p>可以使用 lex 工具進行詞法分析，Go 早期也是使用該工具，<a href=\"https://github.com/LinLshare/case/blob/main/doc/compile/compile_001_flex\">該案例</a>展示了使用 lex 工具進行詞法分析。後期更換成了自身，<a href=\"https://github.com/LinLshare/case/blob/main/doc/compile/compile_002_golang_lexer\">該案例</a>展示了使用 Go 自帶的詞法分析器進行詞法分析。</p>\n<h3 id=\"2-2-2-語法分析\"><a href=\"#2-2-2-語法分析\" class=\"headerlink\" title=\"2.2.2 語法分析\"></a>2.2.2 語法分析</h3><p>語法分析是根據某種特定的形式文法（Grammar）對 Token 序列構成的輸入文本進行分析並確定其語法結構的過程。</p>\n<p><strong>文法</strong></p>\n<p>上下文無關文法(<a href=\"https://en.wikipedia.org/wiki/Context-free_grammar\">context-free grammar</a>) 是用來形式化、精確描述某種編程語言的工具，由以下四個部分組成：</p>\n<ol>\n<li>N, 有限個非終結符的集合</li>\n<li>Σ, 有限個終結符的集合</li>\n<li>P, 有限個生成規則(production rule)的集合</li>\n<li>S, 開始變量或符號，用來代表整個語句或程序，是集合N的成員。</li>\n</ol>\n<p>非終結符可以使用一組終結符根據生成規則展開，而終結符是語言定義的基本元素，不可展開。</p>\n<p>P = N x (NvΣ)* 即生成規則是集合 N與集合N、Σ的併集的 Kleene 操作之間的二元關係。</p>\n<p>假定有以下生成規則：</p>\n<ol>\n<li>S —&gt; aSb // S 可以展開爲 aSb</li>\n<li>S —&gt; ab // S 可以展開爲 ab</li>\n</ol>\n<p>那麼，aabb（運用一次規則1，一次規則2）、aaabbb（運用兩次規則1，一次規則2）等就是符合語法規則的表示。</p>\n<p><strong>解析方法</strong></p>\n<p>解析文法的方法有兩種：</p>\n<ol>\n<li><strong>自頂向下解析</strong>(Top-down parsing)：從最高級別開始解析，不斷地用生成規則右側的符號展開非終結符，直到最低級別的終結符號。</li>\n<li><strong>自底向上解析</strong>(Bottom-up parsing)：從最低級別開始解析，不斷地用生成規則左側非終結符歸約，直到最高級別的開始符號。</li>\n</ol>\n<p><strong>LL文法</strong>是一種使用自頂向下解析的文法。假定有 LL文法如下：</p>\n<ol>\n<li>𝑆→𝑎𝑆1</li>\n<li>𝑆1→𝑏𝑆1</li>\n<li>𝑆1→𝜖</li>\n</ol>\n<p>輸入流 abb 採用上面的文法進行解析，其過程爲：</p>\n<ol>\n<li>S （開始符號）</li>\n<li>aS1（規則 1）</li>\n<li>abS1 （規則 2）</li>\n<li>abbS1 （規則2）</li>\n<li>abb（規則 3）</li>\n</ol>\n<p><strong>LR(0) 文法</strong>是一种使用自底向上解析的文法。假定有 LR(0) 文法如下：</p>\n<ol>\n<li>𝑆→𝑆1</li>\n<li>𝑆1→𝑆1𝑏</li>\n<li>𝑆1→𝑎</li>\n</ol>\n<p>輸入流 abb 採用上面的文法進行解析，其過程爲：</p>\n<ol>\n<li>a（入棧）</li>\n<li>S1（規則3）</li>\n<li>S1b（入棧）</li>\n<li>S1（規則2）</li>\n<li>S1b（入棧）</li>\n<li>S1（規則2）</li>\n<li>S（規則1）</li>\n</ol>\n<p>當有多個生成規則符合時，會出現衝突。解析時可以採用 <strong>Lookahead</strong> 向前查看技術解決，即預讀一個 Token 確保出現衝突的生成規則可以被正確處理。</p>\n<p>Go 語言的解析器採用 LALR(1) 的文法進行解析，是一種自底向上且帶有 <strong>Lookahead</strong>(縮寫爲LA) 功能的解析文法。LALR(1)  也是大多數編程語言的選擇。</p>\n<p><strong>Go 文法</strong></p>\n<p>閱讀 src/cmd/compile/internal/syntax/parser.go，可知：</p>\n<p>每個 Go 源代碼文件最終都會被解析成一個獨立的抽象語法樹，所以語法樹最頂層的結構或者開始符號都是 SourceFile：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">SourceFile = PackageClause <span class=\"string\">&quot;;&quot;</span> &#123; ImportDecl <span class=\"string\">&quot;;&quot;</span> &#125; &#123; TopLevelDecl <span class=\"string\">&quot;;&quot;</span> &#125; .</span><br></pre></td></tr></table></figure>\n\n<p>PackageClause 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">PackageClause  = <span class=\"string\">&quot;package&quot;</span> PackageName .</span><br><span class=\"line\">PackageName    = identifier .</span><br><span class=\"line\">identifier = letter &#123; letter | unicode_digit &#125; .</span><br></pre></td></tr></table></figure>\n\n<p>ImportDecl 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ImportDecl       = <span class=\"string\">&quot;import&quot;</span> ( ImportSpec | <span class=\"string\">&quot;(&quot;</span> &#123; ImportSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">ImportSpec       = [ <span class=\"string\">&quot;.&quot;</span> | PackageName ] ImportPath .</span><br><span class=\"line\">ImportPath       = string_lit .</span><br></pre></td></tr></table></figure>\n\n<p>TopLevelDecl 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .</span><br><span class=\"line\">Declaration   = ConstDecl | TypeDecl | VarDecl .</span><br></pre></td></tr></table></figure>\n\n<p>可知頂層的聲明共有五種，分別是常量、類型、變量、函數和方法聲明，其生成规则如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ConstDecl = <span class=\"string\">&quot;const&quot;</span> ( ConstSpec | <span class=\"string\">&quot;(&quot;</span> &#123; ConstSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">ConstSpec = IdentifierList [ [ Type ] <span class=\"string\">&quot;=&quot;</span> ExpressionList ] .</span><br><span class=\"line\"></span><br><span class=\"line\">TypeDecl  = <span class=\"string\">&quot;type&quot;</span> ( TypeSpec | <span class=\"string\">&quot;(&quot;</span> &#123; TypeSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">TypeSpec  = AliasDecl | TypeDef .</span><br><span class=\"line\">AliasDecl = identifier <span class=\"string\">&quot;=&quot;</span> Type .</span><br><span class=\"line\">TypeDef   = identifier Type .</span><br><span class=\"line\"></span><br><span class=\"line\">VarDecl = <span class=\"string\">&quot;var&quot;</span> ( VarSpec | <span class=\"string\">&quot;(&quot;</span> &#123; VarSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">VarSpec = IdentifierList ( Type [ <span class=\"string\">&quot;=&quot;</span> ExpressionList ] | <span class=\"string\">&quot;=&quot;</span> ExpressionList ) .</span><br><span class=\"line\"></span><br><span class=\"line\">FunctionDecl = <span class=\"string\">&quot;func&quot;</span> FunctionName Signature [ FunctionBody ] .</span><br><span class=\"line\">FunctionName = identifier .</span><br><span class=\"line\">FunctionBody = Block .</span><br><span class=\"line\"></span><br><span class=\"line\">MethodDecl = <span class=\"string\">&quot;func&quot;</span> Receiver MethodName Signature [ FunctionBody ] .</span><br><span class=\"line\">Receiver   = Parameters .</span><br><span class=\"line\"></span><br><span class=\"line\">Block = <span class=\"string\">&quot;&#123;&quot;</span> StatementList <span class=\"string\">&quot;&#125;&quot;</span> .</span><br><span class=\"line\">StatementList = &#123; Statement <span class=\"string\">&quot;;&quot;</span> &#125; .</span><br><span class=\"line\"></span><br><span class=\"line\">Statement =</span><br><span class=\"line\">  Declaration | LabeledStmt | SimpleStmt |</span><br><span class=\"line\">  GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |</span><br><span class=\"line\">  FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |</span><br><span class=\"line\">  DeferStmt .</span><br><span class=\"line\"></span><br><span class=\"line\">SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .</span><br></pre></td></tr></table></figure>\n\n<p>更詳細的文法見：<a href=\"https://golang.org/ref/spec#Declarations_and_scope\">Language Specification</a>。</p>\n<h2 id=\"2-3-類型檢查\"><a href=\"#2-3-類型檢查\" class=\"headerlink\" title=\"2.3 類型檢查\"></a>2.3 類型檢查</h2><p>類型檢查的目的在於確保代碼正確執行。</p>\n<p>類型分兩種：強類型和弱類型。一般來說，強類型是在編譯期間有嚴格的類型限制，會在編譯期間發現變量賦值、返回值和函數調用是的類型錯誤。弱類型則是在運行時出現類型錯誤時進行隱式類型轉換。</p>\n<p>檢查也分兩種：靜態類型檢查和動態類型檢查。靜態類型檢查是在編譯期進行，動態類型檢查是在運行期間進行。實現動態類型檢查通常是爲每個運行時對象關聯一個類型標籤，包含了它的類型信息（RTTI, the Runtime type information），用來實現動態派發、延遲綁定、向下轉型和反射等等。</p>\n<p>另外，只使用動態類型檢查的編程語言叫做動態類型編程語言，比如 JavaScript、Ruby 和 PHP。</p>\n<p>Go 進行靜態類型檢查的代碼主要邏輯在 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck\">cmd/compile/internal/gc.typecheck</a> 和 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1\">cmd/compile/internal/gc.typecheck1</a> 中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">typecheck1</span><span class=\"params\">(n *Node, top <span class=\"keyword\">int</span>)</span> <span class=\"params\">(res *Node)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> n.Op &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTARRAY:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTMAP:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTCHAN:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>介紹幾種常見類型的檢查過程：</p>\n<ul>\n<li>OTARRAY 數組或切片類型：<ol>\n<li>對右節點也就是元素進行類型檢查</li>\n<li>對左節點，按三種情況：<ol>\n<li>[]int，直接調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewSlice\">cmd/compile/internal/types.NewSlice</a>，返回一個 <code>TSLICE</code> 類型的結構體。</li>\n<li>[…]int，ODDD(即…) 先調用 <a href>cmd/compile/internal/gc.typecheckcomplit</a> ，後調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray\">cmd/compile/internal/types.NewArray</a> 初始化一個存儲著數組中元素類型和數組大小的結構體。</li>\n<li>[3]int，調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray\">cmd/compile/internal/types.NewArray</a> 初始化一個存儲著數組中元素類型和數組大小的結構體。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>OTMAP 哈希類型：<ol>\n<li>分別檢查鍵值類型</li>\n<li>通過 <a href>cmd/compile/internal/types.NewMap</a> 创建一个新的 TMAP 结构并将哈希的键值类型都存储到该结构体</li>\n<li>代表當前哈希的節點最終也會被加入 mapqueue 隊列，編譯器會在後面的階段對哈希鍵的類型進行再次檢查。</li>\n</ol>\n</li>\n<li>OMAKE 內置函數make<ol>\n<li>檢查第一個類型參數，然後據此進入不同的分支：TSLICE 切片分支、TMAP 哈希分支和 TCHAN 信道分支。</li>\n<li>如是 TSLICE 分支，將檢查 len 和 cap 的合法性，然後將當前節點的 Op 改爲 OMAKESLICE。</li>\n<li>如是 TMAP 分支，將在檢查 size 之後將當前節點的 Op 改爲 OMAKEMAP。</li>\n<li>如是 TCHAN 分支，將在檢查 buffer 之後將當前節點的 Op 改爲 OMAKECHAN。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-4-中間代碼生成\"><a href=\"#2-4-中間代碼生成\" class=\"headerlink\" title=\"2.4 中間代碼生成\"></a>2.4 中間代碼生成</h2><p>中間代碼生成是爲了解決直接編譯成二進制碼的複雜。通過將複雜問題拆分成一個個簡單的步驟，再逐個擊破，這就是中間代碼的作用。</p>\n<p>AST 和二進制碼之間隔了幾十次中間代碼的生成。生成之初會將緩存可能需要用到的類型和指針，並將內建函數映射到 runtime包中的函數。之後每次中間代碼的生成都是對代碼的優化，最後生成具備 SSA 特性的中間代碼。</p>\n<p><img src=\"/it/go/go-design-and-implementation-02/Untitled%202.png\" alt></p>\n<p>關鍵字和操作符和運行時函數的映射</p>\n<p>中間代碼不是彙編代碼，但是很接近彙編代碼，也用到一些寄存器，可說是彙編代碼的偽代碼（pseudo code），中間代碼形如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">pass trim begin</span><br><span class=\"line\">  pass trim end [<span class=\"number\">738</span> ns]</span><br><span class=\"line\">hello <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span></span><br><span class=\"line\">  b1:</span><br><span class=\"line\">    v1 = InitMem &lt;mem&gt;</span><br><span class=\"line\">    v10 = VarDef &lt;mem&gt; &#123;~r1&#125; v1</span><br><span class=\"line\">    v2 = SP &lt;<span class=\"keyword\">uintptr</span>&gt; : SP</span><br><span class=\"line\">    v6 = Arg &lt;<span class=\"keyword\">int</span>&gt; &#123;a&#125; : a[<span class=\"keyword\">int</span>]</span><br><span class=\"line\">    v8 = LoadReg &lt;<span class=\"keyword\">int</span>&gt; v6 : AX</span><br><span class=\"line\">    v9 = ADDQconst &lt;<span class=\"keyword\">int</span>&gt; [<span class=\"number\">2</span>] v8 : AX (c[<span class=\"keyword\">int</span>])</span><br><span class=\"line\">    v11 = MOVQstore &lt;mem&gt; &#123;~r1&#125; v2 v9 v10</span><br><span class=\"line\">    Ret v11</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5-機器碼生成\"><a href=\"#2-5-機器碼生成\" class=\"headerlink\" title=\"2.5 機器碼生成\"></a>2.5 機器碼生成</h2><p>機器碼的生成包含兩個部分：</p>\n<ol>\n<li><a href=\"https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa\">cmd/compile/internal/ssa</a> 進行 SSA 中間代碼的降級過程，執行架構特定的優化和重寫，最後生成架構特定的指令 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/obj.Prog\">cmd/compile/internal/obj.Prog</a>。</li>\n<li><a href=\"https://github.com/golang/go/tree/master/src/cmd/internal/obj\">cmd/internal/obj</a> 作爲彙編器將架構特定的指令轉成二進制代碼。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>編譯原理這一章講 Go 的源代碼是如何變成二進制碼的，可分爲四個過程：</p>\n<ol>\n<li>詞法和語法分析 lexical and grammar analysis</li>\n<li>類型檢查 type check</li>\n<li>中間代碼生成 IR(intermediate representation) generation</li>\n<li>機器碼生成 machine code generation</li>\n</ol>\n<p>詞法分析是將源代碼視爲字符串序列，對各個字符串進行標記，生成 Token 序列。</p>\n<p>語法分析是將 Token 序列按照 LALR(1)（向前查看和自底向上解析）的解析文法進行解析，生成一棵AST (抽象語法樹 )。</p>\n<p>類型檢查分靜態類型檢查和動態類型檢查，靜態類型檢查會在編譯期對變量賦值、返回值和函數參數進行類型檢查；動態類型檢查在代碼運行時進行，可以實現向下類型轉換、延遲綁定和反射等功能。</p>\n<p>中間代碼生成階段首先會進行 ssaconfig 的初始化，緩存可能需要用到的類型和指針；然後進行遍歷和替換，將內建函數 make、map、channel、new、select、panic、recover 等等替換成 runtime 包的函數。最後不斷地進行中間代碼生成，優化代碼，生成類似彙編代碼的代碼。</p>\n<p>機器碼生成階段分兩個部分：一是 SSA 中間代碼降級、針對特定CPU架構的中間代碼優化和重寫，最後生成相當接近特定架構彙編代碼的指令；二是將特定架構的指令轉成二進制代碼。</p>","more":"<h2 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h2><p>編譯原理就是講編譯器如何將代碼編譯成二進制碼。</p>\n<h3 id=\"2-1-1-預備知識\"><a href=\"#2-1-1-預備知識\" class=\"headerlink\" title=\"2.1.1 預備知識\"></a>2.1.1 預備知識</h3><p><strong>（1）抽象語法樹</strong></p>\n<p>抽象語法樹（Abstract Syntax Tree、AST），是源代碼語法的結構的樹狀表示。以表達式 2 * 3 + 7 為例，編譯器的語法分析階段會生成如下圖所示的抽象語法樹：</p>\n<p><img src=\"/it/go/go-design-and-implementation-02/Untitled.png\" alt></p>\n<p><strong>（2）靜態單賦值</strong></p>\n<p>靜態單賦值（Static Single Assignment、SSA），是指中間代碼每個變量只會被賦值一次。例如以下代碼：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">1</span></span><br><span class=\"line\">x := <span class=\"number\">2</span></span><br><span class=\"line\">y := x</span><br></pre></td></tr></table></figure>\n\n<p>其中間的代碼爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x_1 := <span class=\"number\">1</span></span><br><span class=\"line\">x_2 := <span class=\"number\">2</span></span><br><span class=\"line\">y_1 := x_2</span><br></pre></td></tr></table></figure>\n\n<p>由於 x_1 := 1 沒有什麼用，因此會在生成機器碼時省去。</p>\n<p><strong>（3）指令集</strong></p>\n<p>指令集或者說指令集架構 (Instruction set architecture, ISA)，就是計算機的抽象模型。指令集可分爲兩大類：</p>\n<ul>\n<li>複雜指令集計算機 (complex instruction set computer, CISC)：包含了很多特定的指令，但是其中的一些指令很少會被程序使用（據說有 80% 不經常使用）。例如：Intel 8080、x86-family。</li>\n<li>精簡指令集計算機 (reduced instruction set computer, RISC)：只實現了經常被使用的指令，不常用的操作都會通過組合簡單指令來實現。例如：ARM、Power ISA。</li>\n</ul>\n<h3 id=\"2-1-2-編譯原理\"><a href=\"#2-1-2-編譯原理\" class=\"headerlink\" title=\"2.1.2 編譯原理\"></a>2.1.2 編譯原理</h3><p><img src=\"/it/go/go-design-and-implementation-02/Untitled%201.png\" alt></p>\n<p>編譯器的前端：</p>\n<ul>\n<li>詞法分析 lexical analysis</li>\n<li>語法分析 syntax analysis</li>\n<li>語義分析 semantic analysis</li>\n</ul>\n<p>編譯器的後端：</p>\n<ul>\n<li>中間代碼生成 IR(Intermediate Representation)  generation</li>\n<li>代碼優化 code optimization</li>\n<li>機器碼生成 machinecode generation</li>\n</ul>\n<p>Go 的編譯器邏輯上可以分爲四個階段：</p>\n<ol>\n<li>詞法和語法分析，將源代碼字符串序列轉成 Token 序列，再轉成抽象語法樹。</li>\n<li>類型檢查，檢查類型，並展開內建的函數。</li>\n<li>中間代碼生成，使用 goroutine 並發生成中間代碼，並進行 SSA 優化。</li>\n<li>機器碼生成，根據不同類型的 CPU 生成不同的機器碼</li>\n</ol>\n<p>Go 的編譯器入口在 <a href=\"https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go\">src/cmd/compile/internal/gc/main.go</a> 文件中，其中的 Main 函數就是編譯器的主要程序，其工作過程是：</p>\n<ol>\n<li>獲取命令行傳入的參數並更新編譯選項和配置。</li>\n<li>調用 parseFiles 方法解析輸入的文件，得到 AST，隨後進行以下 9 個步驟：<ol>\n<li>const, type, and names and types of funcs（檢查常量、類型以及函數的名稱和類型）</li>\n<li>Variable assignments（處理變量賦值）</li>\n<li>Type check function bodies（對函數體進行類型檢查）</li>\n<li>Decide how to capture closed variables（決定如何捕獲封閉的變量）</li>\n<li>Inlining（處理內聯函數）</li>\n<li>Escape analysis（進行逃逸分析）</li>\n<li>Transform closure bodies to properly reference captured variables（將閉包的主體轉成實際引用的捕獲變量）</li>\n<li>Compile top level functions（編譯頂層函數）</li>\n<li>Check external declarations（檢查外部聲明）</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-2-詞法和語法分析\"><a href=\"#2-2-詞法和語法分析\" class=\"headerlink\" title=\"2.2 詞法和語法分析\"></a>2.2 詞法和語法分析</h2><h3 id=\"2-2-1-詞法分析\"><a href=\"#2-2-1-詞法分析\" class=\"headerlink\" title=\"2.2.1 詞法分析\"></a>2.2.1 詞法分析</h3><p>詞法分析就是將源代碼的字符串序列轉成標記(Token)序列的過程。如 <code>make(chan int)</code> 經過詞法分析後是一個由 <code>make</code> 、<code>(</code>、<code>chan</code>、<code>int</code> 和 <code>)</code> 組成的 Token序列。</p>\n<p>可以使用 lex 工具進行詞法分析，Go 早期也是使用該工具，<a href=\"https://github.com/LinLshare/case/blob/main/doc/compile/compile_001_flex\">該案例</a>展示了使用 lex 工具進行詞法分析。後期更換成了自身，<a href=\"https://github.com/LinLshare/case/blob/main/doc/compile/compile_002_golang_lexer\">該案例</a>展示了使用 Go 自帶的詞法分析器進行詞法分析。</p>\n<h3 id=\"2-2-2-語法分析\"><a href=\"#2-2-2-語法分析\" class=\"headerlink\" title=\"2.2.2 語法分析\"></a>2.2.2 語法分析</h3><p>語法分析是根據某種特定的形式文法（Grammar）對 Token 序列構成的輸入文本進行分析並確定其語法結構的過程。</p>\n<p><strong>文法</strong></p>\n<p>上下文無關文法(<a href=\"https://en.wikipedia.org/wiki/Context-free_grammar\">context-free grammar</a>) 是用來形式化、精確描述某種編程語言的工具，由以下四個部分組成：</p>\n<ol>\n<li>N, 有限個非終結符的集合</li>\n<li>Σ, 有限個終結符的集合</li>\n<li>P, 有限個生成規則(production rule)的集合</li>\n<li>S, 開始變量或符號，用來代表整個語句或程序，是集合N的成員。</li>\n</ol>\n<p>非終結符可以使用一組終結符根據生成規則展開，而終結符是語言定義的基本元素，不可展開。</p>\n<p>P = N x (NvΣ)* 即生成規則是集合 N與集合N、Σ的併集的 Kleene 操作之間的二元關係。</p>\n<p>假定有以下生成規則：</p>\n<ol>\n<li>S —&gt; aSb // S 可以展開爲 aSb</li>\n<li>S —&gt; ab // S 可以展開爲 ab</li>\n</ol>\n<p>那麼，aabb（運用一次規則1，一次規則2）、aaabbb（運用兩次規則1，一次規則2）等就是符合語法規則的表示。</p>\n<p><strong>解析方法</strong></p>\n<p>解析文法的方法有兩種：</p>\n<ol>\n<li><strong>自頂向下解析</strong>(Top-down parsing)：從最高級別開始解析，不斷地用生成規則右側的符號展開非終結符，直到最低級別的終結符號。</li>\n<li><strong>自底向上解析</strong>(Bottom-up parsing)：從最低級別開始解析，不斷地用生成規則左側非終結符歸約，直到最高級別的開始符號。</li>\n</ol>\n<p><strong>LL文法</strong>是一種使用自頂向下解析的文法。假定有 LL文法如下：</p>\n<ol>\n<li>𝑆→𝑎𝑆1</li>\n<li>𝑆1→𝑏𝑆1</li>\n<li>𝑆1→𝜖</li>\n</ol>\n<p>輸入流 abb 採用上面的文法進行解析，其過程爲：</p>\n<ol>\n<li>S （開始符號）</li>\n<li>aS1（規則 1）</li>\n<li>abS1 （規則 2）</li>\n<li>abbS1 （規則2）</li>\n<li>abb（規則 3）</li>\n</ol>\n<p><strong>LR(0) 文法</strong>是一种使用自底向上解析的文法。假定有 LR(0) 文法如下：</p>\n<ol>\n<li>𝑆→𝑆1</li>\n<li>𝑆1→𝑆1𝑏</li>\n<li>𝑆1→𝑎</li>\n</ol>\n<p>輸入流 abb 採用上面的文法進行解析，其過程爲：</p>\n<ol>\n<li>a（入棧）</li>\n<li>S1（規則3）</li>\n<li>S1b（入棧）</li>\n<li>S1（規則2）</li>\n<li>S1b（入棧）</li>\n<li>S1（規則2）</li>\n<li>S（規則1）</li>\n</ol>\n<p>當有多個生成規則符合時，會出現衝突。解析時可以採用 <strong>Lookahead</strong> 向前查看技術解決，即預讀一個 Token 確保出現衝突的生成規則可以被正確處理。</p>\n<p>Go 語言的解析器採用 LALR(1) 的文法進行解析，是一種自底向上且帶有 <strong>Lookahead</strong>(縮寫爲LA) 功能的解析文法。LALR(1)  也是大多數編程語言的選擇。</p>\n<p><strong>Go 文法</strong></p>\n<p>閱讀 src/cmd/compile/internal/syntax/parser.go，可知：</p>\n<p>每個 Go 源代碼文件最終都會被解析成一個獨立的抽象語法樹，所以語法樹最頂層的結構或者開始符號都是 SourceFile：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">SourceFile = PackageClause <span class=\"string\">&quot;;&quot;</span> &#123; ImportDecl <span class=\"string\">&quot;;&quot;</span> &#125; &#123; TopLevelDecl <span class=\"string\">&quot;;&quot;</span> &#125; .</span><br></pre></td></tr></table></figure>\n\n<p>PackageClause 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">PackageClause  = <span class=\"string\">&quot;package&quot;</span> PackageName .</span><br><span class=\"line\">PackageName    = identifier .</span><br><span class=\"line\">identifier = letter &#123; letter | unicode_digit &#125; .</span><br></pre></td></tr></table></figure>\n\n<p>ImportDecl 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ImportDecl       = <span class=\"string\">&quot;import&quot;</span> ( ImportSpec | <span class=\"string\">&quot;(&quot;</span> &#123; ImportSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">ImportSpec       = [ <span class=\"string\">&quot;.&quot;</span> | PackageName ] ImportPath .</span><br><span class=\"line\">ImportPath       = string_lit .</span><br></pre></td></tr></table></figure>\n\n<p>TopLevelDecl 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .</span><br><span class=\"line\">Declaration   = ConstDecl | TypeDecl | VarDecl .</span><br></pre></td></tr></table></figure>\n\n<p>可知頂層的聲明共有五種，分別是常量、類型、變量、函數和方法聲明，其生成规则如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ConstDecl = <span class=\"string\">&quot;const&quot;</span> ( ConstSpec | <span class=\"string\">&quot;(&quot;</span> &#123; ConstSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">ConstSpec = IdentifierList [ [ Type ] <span class=\"string\">&quot;=&quot;</span> ExpressionList ] .</span><br><span class=\"line\"></span><br><span class=\"line\">TypeDecl  = <span class=\"string\">&quot;type&quot;</span> ( TypeSpec | <span class=\"string\">&quot;(&quot;</span> &#123; TypeSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">TypeSpec  = AliasDecl | TypeDef .</span><br><span class=\"line\">AliasDecl = identifier <span class=\"string\">&quot;=&quot;</span> Type .</span><br><span class=\"line\">TypeDef   = identifier Type .</span><br><span class=\"line\"></span><br><span class=\"line\">VarDecl = <span class=\"string\">&quot;var&quot;</span> ( VarSpec | <span class=\"string\">&quot;(&quot;</span> &#123; VarSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">VarSpec = IdentifierList ( Type [ <span class=\"string\">&quot;=&quot;</span> ExpressionList ] | <span class=\"string\">&quot;=&quot;</span> ExpressionList ) .</span><br><span class=\"line\"></span><br><span class=\"line\">FunctionDecl = <span class=\"string\">&quot;func&quot;</span> FunctionName Signature [ FunctionBody ] .</span><br><span class=\"line\">FunctionName = identifier .</span><br><span class=\"line\">FunctionBody = Block .</span><br><span class=\"line\"></span><br><span class=\"line\">MethodDecl = <span class=\"string\">&quot;func&quot;</span> Receiver MethodName Signature [ FunctionBody ] .</span><br><span class=\"line\">Receiver   = Parameters .</span><br><span class=\"line\"></span><br><span class=\"line\">Block = <span class=\"string\">&quot;&#123;&quot;</span> StatementList <span class=\"string\">&quot;&#125;&quot;</span> .</span><br><span class=\"line\">StatementList = &#123; Statement <span class=\"string\">&quot;;&quot;</span> &#125; .</span><br><span class=\"line\"></span><br><span class=\"line\">Statement =</span><br><span class=\"line\">  Declaration | LabeledStmt | SimpleStmt |</span><br><span class=\"line\">  GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |</span><br><span class=\"line\">  FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |</span><br><span class=\"line\">  DeferStmt .</span><br><span class=\"line\"></span><br><span class=\"line\">SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .</span><br></pre></td></tr></table></figure>\n\n<p>更詳細的文法見：<a href=\"https://golang.org/ref/spec#Declarations_and_scope\">Language Specification</a>。</p>\n<h2 id=\"2-3-類型檢查\"><a href=\"#2-3-類型檢查\" class=\"headerlink\" title=\"2.3 類型檢查\"></a>2.3 類型檢查</h2><p>類型檢查的目的在於確保代碼正確執行。</p>\n<p>類型分兩種：強類型和弱類型。一般來說，強類型是在編譯期間有嚴格的類型限制，會在編譯期間發現變量賦值、返回值和函數調用是的類型錯誤。弱類型則是在運行時出現類型錯誤時進行隱式類型轉換。</p>\n<p>檢查也分兩種：靜態類型檢查和動態類型檢查。靜態類型檢查是在編譯期進行，動態類型檢查是在運行期間進行。實現動態類型檢查通常是爲每個運行時對象關聯一個類型標籤，包含了它的類型信息（RTTI, the Runtime type information），用來實現動態派發、延遲綁定、向下轉型和反射等等。</p>\n<p>另外，只使用動態類型檢查的編程語言叫做動態類型編程語言，比如 JavaScript、Ruby 和 PHP。</p>\n<p>Go 進行靜態類型檢查的代碼主要邏輯在 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck\">cmd/compile/internal/gc.typecheck</a> 和 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1\">cmd/compile/internal/gc.typecheck1</a> 中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">typecheck1</span><span class=\"params\">(n *Node, top <span class=\"keyword\">int</span>)</span> <span class=\"params\">(res *Node)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> n.Op &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTARRAY:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTMAP:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTCHAN:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>介紹幾種常見類型的檢查過程：</p>\n<ul>\n<li>OTARRAY 數組或切片類型：<ol>\n<li>對右節點也就是元素進行類型檢查</li>\n<li>對左節點，按三種情況：<ol>\n<li>[]int，直接調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewSlice\">cmd/compile/internal/types.NewSlice</a>，返回一個 <code>TSLICE</code> 類型的結構體。</li>\n<li>[…]int，ODDD(即…) 先調用 <a href>cmd/compile/internal/gc.typecheckcomplit</a> ，後調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray\">cmd/compile/internal/types.NewArray</a> 初始化一個存儲著數組中元素類型和數組大小的結構體。</li>\n<li>[3]int，調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray\">cmd/compile/internal/types.NewArray</a> 初始化一個存儲著數組中元素類型和數組大小的結構體。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>OTMAP 哈希類型：<ol>\n<li>分別檢查鍵值類型</li>\n<li>通過 <a href>cmd/compile/internal/types.NewMap</a> 创建一个新的 TMAP 结构并将哈希的键值类型都存储到该结构体</li>\n<li>代表當前哈希的節點最終也會被加入 mapqueue 隊列，編譯器會在後面的階段對哈希鍵的類型進行再次檢查。</li>\n</ol>\n</li>\n<li>OMAKE 內置函數make<ol>\n<li>檢查第一個類型參數，然後據此進入不同的分支：TSLICE 切片分支、TMAP 哈希分支和 TCHAN 信道分支。</li>\n<li>如是 TSLICE 分支，將檢查 len 和 cap 的合法性，然後將當前節點的 Op 改爲 OMAKESLICE。</li>\n<li>如是 TMAP 分支，將在檢查 size 之後將當前節點的 Op 改爲 OMAKEMAP。</li>\n<li>如是 TCHAN 分支，將在檢查 buffer 之後將當前節點的 Op 改爲 OMAKECHAN。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-4-中間代碼生成\"><a href=\"#2-4-中間代碼生成\" class=\"headerlink\" title=\"2.4 中間代碼生成\"></a>2.4 中間代碼生成</h2><p>中間代碼生成是爲了解決直接編譯成二進制碼的複雜。通過將複雜問題拆分成一個個簡單的步驟，再逐個擊破，這就是中間代碼的作用。</p>\n<p>AST 和二進制碼之間隔了幾十次中間代碼的生成。生成之初會將緩存可能需要用到的類型和指針，並將內建函數映射到 runtime包中的函數。之後每次中間代碼的生成都是對代碼的優化，最後生成具備 SSA 特性的中間代碼。</p>\n<p><img src=\"/it/go/go-design-and-implementation-02/Untitled%202.png\" alt></p>\n<p>關鍵字和操作符和運行時函數的映射</p>\n<p>中間代碼不是彙編代碼，但是很接近彙編代碼，也用到一些寄存器，可說是彙編代碼的偽代碼（pseudo code），中間代碼形如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">pass trim begin</span><br><span class=\"line\">  pass trim end [<span class=\"number\">738</span> ns]</span><br><span class=\"line\">hello <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span></span><br><span class=\"line\">  b1:</span><br><span class=\"line\">    v1 = InitMem &lt;mem&gt;</span><br><span class=\"line\">    v10 = VarDef &lt;mem&gt; &#123;~r1&#125; v1</span><br><span class=\"line\">    v2 = SP &lt;<span class=\"keyword\">uintptr</span>&gt; : SP</span><br><span class=\"line\">    v6 = Arg &lt;<span class=\"keyword\">int</span>&gt; &#123;a&#125; : a[<span class=\"keyword\">int</span>]</span><br><span class=\"line\">    v8 = LoadReg &lt;<span class=\"keyword\">int</span>&gt; v6 : AX</span><br><span class=\"line\">    v9 = ADDQconst &lt;<span class=\"keyword\">int</span>&gt; [<span class=\"number\">2</span>] v8 : AX (c[<span class=\"keyword\">int</span>])</span><br><span class=\"line\">    v11 = MOVQstore &lt;mem&gt; &#123;~r1&#125; v2 v9 v10</span><br><span class=\"line\">    Ret v11</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5-機器碼生成\"><a href=\"#2-5-機器碼生成\" class=\"headerlink\" title=\"2.5 機器碼生成\"></a>2.5 機器碼生成</h2><p>機器碼的生成包含兩個部分：</p>\n<ol>\n<li><a href=\"https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa\">cmd/compile/internal/ssa</a> 進行 SSA 中間代碼的降級過程，執行架構特定的優化和重寫，最後生成架構特定的指令 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/obj.Prog\">cmd/compile/internal/obj.Prog</a>。</li>\n<li><a href=\"https://github.com/golang/go/tree/master/src/cmd/internal/obj\">cmd/internal/obj</a> 作爲彙編器將架構特定的指令轉成二進制代碼。</li>\n</ol>"},{"title":"Go內存模型","p":"it/go/go-memory-model.md","date":"2021-12-31T02:50:00.000Z","_content":"\n本文講述在何種情況下，一個協程（goroutine）中寫入的變量值可被另一個協程中觀察到。\n\n## 先發生（happens before）\n\n讓我們來理清下時間的發生順序。\n\n如果事件 e1在事件 e2 之前發生，那麼事件 e2 在事件 e1 之後發生。同樣，如果 e1 既不在事件 e2 之前也不在 e2 之後發生，那麼事件 e1 和 e2 同時發生。\n\n<!--more-->\n\n> 規則1: 在單個協程中，事件的發生順序就是程序語句的先後順序。\n\n當滿足以下條件時，對變量 v 的讀取 r 可以觀察到對 v 的寫入 w：\n\n1. r 不在 w 之前發生；\n2. 在 w 之後 r 之前，沒有其他的寫入。\n\n換句話說：\n\n1. w 在 r 之前發生；\n2. 其他的寫入要麼發生在 w 之前，要麼發生在 r 之後。\n\n單個協程下這兩種表述沒什麼不同，但在多協程下需要通過同步來建立先發生條件以保證觀察到其他協程對共享變量的寫入。\n\n## 同步（synchronization）\n\n（1）初始化（initialization）\n\n> 規則2: 若包 p 導入了包 q，則 q 的初始化方法（init）先發生於 p 的。主方法（main.main）發生在所有 init 方法完成之後。\n\n（2）協程創建（channel creation）\n\n> 規則3: go 語句新起一個協程先發生於協程執行。\n\n（3）協程銷毀（channel destruction）\n\n協程的銷毀不保證發生在任何事件之前。\n\n（4）通道通信（channel communication）\n\n通道是Go中最常用的同步方式，對於通道的事件順序有如下規則：\n\n> 規則4: 發送消息到 channel 先發生於對應的接收完成。\n\n> 規則5: 通道的關閉先發生於因通道關閉而接收到零值。\n\n> 規則6: 從無緩衝通道接收消息先發生於發送消息完成。\n\n> 規則7: 對於容量為 C 的緩衝通道，第 k 次接收消息先發生於第 k+C 次發送消息完成。\n\n（5）鎖（locks）\n\n當使用鎖進行同步時，需要注意鎖是一加一放的，不會先後加兩次鎖，也不會先後釋放兩次鎖。\n\n> 規則8: 對於任意類型為 sync.Mutex 或 sync.RWMutex 的變量 l，以及 n < m，第 n 次調用 l.Unlock() 先發生於第 m 次調用 l.Lock()。\n\n（6）僅執行一次（once）\n\nonce.Do(f) 能保證函數 f() 能在多協程環境下僅被調用一次。是 Go 中實現單例常用方法。\n\n> 規則9: 對函數 f() 的單次調用先發生（先返回）於 once.Do(f) 返回。\n\n## 延伸閱讀\n\n- [The Go Memory Model](http://docscn.studygolang.com/ref/mem)\n","source":"_posts/it/go/go-memory-model.md","raw":"---\ntitle: Go內存模型\np: it/go/go-memory-model.md\ndate: 2021-12-31 10:50:00\ntags:\n- Go\n---\n\n本文講述在何種情況下，一個協程（goroutine）中寫入的變量值可被另一個協程中觀察到。\n\n## 先發生（happens before）\n\n讓我們來理清下時間的發生順序。\n\n如果事件 e1在事件 e2 之前發生，那麼事件 e2 在事件 e1 之後發生。同樣，如果 e1 既不在事件 e2 之前也不在 e2 之後發生，那麼事件 e1 和 e2 同時發生。\n\n<!--more-->\n\n> 規則1: 在單個協程中，事件的發生順序就是程序語句的先後順序。\n\n當滿足以下條件時，對變量 v 的讀取 r 可以觀察到對 v 的寫入 w：\n\n1. r 不在 w 之前發生；\n2. 在 w 之後 r 之前，沒有其他的寫入。\n\n換句話說：\n\n1. w 在 r 之前發生；\n2. 其他的寫入要麼發生在 w 之前，要麼發生在 r 之後。\n\n單個協程下這兩種表述沒什麼不同，但在多協程下需要通過同步來建立先發生條件以保證觀察到其他協程對共享變量的寫入。\n\n## 同步（synchronization）\n\n（1）初始化（initialization）\n\n> 規則2: 若包 p 導入了包 q，則 q 的初始化方法（init）先發生於 p 的。主方法（main.main）發生在所有 init 方法完成之後。\n\n（2）協程創建（channel creation）\n\n> 規則3: go 語句新起一個協程先發生於協程執行。\n\n（3）協程銷毀（channel destruction）\n\n協程的銷毀不保證發生在任何事件之前。\n\n（4）通道通信（channel communication）\n\n通道是Go中最常用的同步方式，對於通道的事件順序有如下規則：\n\n> 規則4: 發送消息到 channel 先發生於對應的接收完成。\n\n> 規則5: 通道的關閉先發生於因通道關閉而接收到零值。\n\n> 規則6: 從無緩衝通道接收消息先發生於發送消息完成。\n\n> 規則7: 對於容量為 C 的緩衝通道，第 k 次接收消息先發生於第 k+C 次發送消息完成。\n\n（5）鎖（locks）\n\n當使用鎖進行同步時，需要注意鎖是一加一放的，不會先後加兩次鎖，也不會先後釋放兩次鎖。\n\n> 規則8: 對於任意類型為 sync.Mutex 或 sync.RWMutex 的變量 l，以及 n < m，第 n 次調用 l.Unlock() 先發生於第 m 次調用 l.Lock()。\n\n（6）僅執行一次（once）\n\nonce.Do(f) 能保證函數 f() 能在多協程環境下僅被調用一次。是 Go 中實現單例常用方法。\n\n> 規則9: 對函數 f() 的單次調用先發生（先返回）於 once.Do(f) 返回。\n\n## 延伸閱讀\n\n- [The Go Memory Model](http://docscn.studygolang.com/ref/mem)\n","slug":"it/go/go-memory-model","published":1,"updated":"2022-01-04T14:29:04.413Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxley000p1n9ke3sa1p7f","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>本文講述在何種情況下，一個協程（goroutine）中寫入的變量值可被另一個協程中觀察到。</p>\n<h2 id=\"先發生（happens-before）\"><a href=\"#先發生（happens-before）\" class=\"headerlink\" title=\"先發生（happens before）\"></a>先發生（happens before）</h2><p>讓我們來理清下時間的發生順序。</p>\n<p>如果事件 e1在事件 e2 之前發生，那麼事件 e2 在事件 e1 之後發生。同樣，如果 e1 既不在事件 e2 之前也不在 e2 之後發生，那麼事件 e1 和 e2 同時發生。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>規則1: 在單個協程中，事件的發生順序就是程序語句的先後順序。</p>\n</blockquote>\n<p>當滿足以下條件時，對變量 v 的讀取 r 可以觀察到對 v 的寫入 w：</p>\n<ol>\n<li>r 不在 w 之前發生；</li>\n<li>在 w 之後 r 之前，沒有其他的寫入。</li>\n</ol>\n<p>換句話說：</p>\n<ol>\n<li>w 在 r 之前發生；</li>\n<li>其他的寫入要麼發生在 w 之前，要麼發生在 r 之後。</li>\n</ol>\n<p>單個協程下這兩種表述沒什麼不同，但在多協程下需要通過同步來建立先發生條件以保證觀察到其他協程對共享變量的寫入。</p>\n<h2 id=\"同步（synchronization）\"><a href=\"#同步（synchronization）\" class=\"headerlink\" title=\"同步（synchronization）\"></a>同步（synchronization）</h2><p>（1）初始化（initialization）</p>\n<blockquote>\n<p>規則2: 若包 p 導入了包 q，則 q 的初始化方法（init）先發生於 p 的。主方法（main.main）發生在所有 init 方法完成之後。</p>\n</blockquote>\n<p>（2）協程創建（channel creation）</p>\n<blockquote>\n<p>規則3: go 語句新起一個協程先發生於協程執行。</p>\n</blockquote>\n<p>（3）協程銷毀（channel destruction）</p>\n<p>協程的銷毀不保證發生在任何事件之前。</p>\n<p>（4）通道通信（channel communication）</p>\n<p>通道是Go中最常用的同步方式，對於通道的事件順序有如下規則：</p>\n<blockquote>\n<p>規則4: 發送消息到 channel 先發生於對應的接收完成。</p>\n</blockquote>\n<blockquote>\n<p>規則5: 通道的關閉先發生於因通道關閉而接收到零值。</p>\n</blockquote>\n<blockquote>\n<p>規則6: 從無緩衝通道接收消息先發生於發送消息完成。</p>\n</blockquote>\n<blockquote>\n<p>規則7: 對於容量為 C 的緩衝通道，第 k 次接收消息先發生於第 k+C 次發送消息完成。</p>\n</blockquote>\n<p>（5）鎖（locks）</p>\n<p>當使用鎖進行同步時，需要注意鎖是一加一放的，不會先後加兩次鎖，也不會先後釋放兩次鎖。</p>\n<blockquote>\n<p>規則8: 對於任意類型為 sync.Mutex 或 sync.RWMutex 的變量 l，以及 n &lt; m，第 n 次調用 l.Unlock() 先發生於第 m 次調用 l.Lock()。</p>\n</blockquote>\n<p>（6）僅執行一次（once）</p>\n<p>once.Do(f) 能保證函數 f() 能在多協程環境下僅被調用一次。是 Go 中實現單例常用方法。</p>\n<blockquote>\n<p>規則9: 對函數 f() 的單次調用先發生（先返回）於 once.Do(f) 返回。</p>\n</blockquote>\n<h2 id=\"延伸閱讀\"><a href=\"#延伸閱讀\" class=\"headerlink\" title=\"延伸閱讀\"></a>延伸閱讀</h2><ul>\n<li><a href=\"http://docscn.studygolang.com/ref/mem\">The Go Memory Model</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文講述在何種情況下，一個協程（goroutine）中寫入的變量值可被另一個協程中觀察到。</p>\n<h2 id=\"先發生（happens-before）\"><a href=\"#先發生（happens-before）\" class=\"headerlink\" title=\"先發生（happens before）\"></a>先發生（happens before）</h2><p>讓我們來理清下時間的發生順序。</p>\n<p>如果事件 e1在事件 e2 之前發生，那麼事件 e2 在事件 e1 之後發生。同樣，如果 e1 既不在事件 e2 之前也不在 e2 之後發生，那麼事件 e1 和 e2 同時發生。</p>","more":"<blockquote>\n<p>規則1: 在單個協程中，事件的發生順序就是程序語句的先後順序。</p>\n</blockquote>\n<p>當滿足以下條件時，對變量 v 的讀取 r 可以觀察到對 v 的寫入 w：</p>\n<ol>\n<li>r 不在 w 之前發生；</li>\n<li>在 w 之後 r 之前，沒有其他的寫入。</li>\n</ol>\n<p>換句話說：</p>\n<ol>\n<li>w 在 r 之前發生；</li>\n<li>其他的寫入要麼發生在 w 之前，要麼發生在 r 之後。</li>\n</ol>\n<p>單個協程下這兩種表述沒什麼不同，但在多協程下需要通過同步來建立先發生條件以保證觀察到其他協程對共享變量的寫入。</p>\n<h2 id=\"同步（synchronization）\"><a href=\"#同步（synchronization）\" class=\"headerlink\" title=\"同步（synchronization）\"></a>同步（synchronization）</h2><p>（1）初始化（initialization）</p>\n<blockquote>\n<p>規則2: 若包 p 導入了包 q，則 q 的初始化方法（init）先發生於 p 的。主方法（main.main）發生在所有 init 方法完成之後。</p>\n</blockquote>\n<p>（2）協程創建（channel creation）</p>\n<blockquote>\n<p>規則3: go 語句新起一個協程先發生於協程執行。</p>\n</blockquote>\n<p>（3）協程銷毀（channel destruction）</p>\n<p>協程的銷毀不保證發生在任何事件之前。</p>\n<p>（4）通道通信（channel communication）</p>\n<p>通道是Go中最常用的同步方式，對於通道的事件順序有如下規則：</p>\n<blockquote>\n<p>規則4: 發送消息到 channel 先發生於對應的接收完成。</p>\n</blockquote>\n<blockquote>\n<p>規則5: 通道的關閉先發生於因通道關閉而接收到零值。</p>\n</blockquote>\n<blockquote>\n<p>規則6: 從無緩衝通道接收消息先發生於發送消息完成。</p>\n</blockquote>\n<blockquote>\n<p>規則7: 對於容量為 C 的緩衝通道，第 k 次接收消息先發生於第 k+C 次發送消息完成。</p>\n</blockquote>\n<p>（5）鎖（locks）</p>\n<p>當使用鎖進行同步時，需要注意鎖是一加一放的，不會先後加兩次鎖，也不會先後釋放兩次鎖。</p>\n<blockquote>\n<p>規則8: 對於任意類型為 sync.Mutex 或 sync.RWMutex 的變量 l，以及 n &lt; m，第 n 次調用 l.Unlock() 先發生於第 m 次調用 l.Lock()。</p>\n</blockquote>\n<p>（6）僅執行一次（once）</p>\n<p>once.Do(f) 能保證函數 f() 能在多協程環境下僅被調用一次。是 Go 中實現單例常用方法。</p>\n<blockquote>\n<p>規則9: 對函數 f() 的單次調用先發生（先返回）於 once.Do(f) 返回。</p>\n</blockquote>\n<h2 id=\"延伸閱讀\"><a href=\"#延伸閱讀\" class=\"headerlink\" title=\"延伸閱讀\"></a>延伸閱讀</h2><ul>\n<li><a href=\"http://docscn.studygolang.com/ref/mem\">The Go Memory Model</a></li>\n</ul>"},{"date":"2021-12-04T12:51:15.000Z","title":"介紹Go程序性能分析工具 pprof","p":"it/go/go-tool-pprof","_content":"\npprof 是 program profiling（程序分析）的縮寫，是 Go程序中重要的性能分析工具，包含兩個部分：\n\n1. 數據採集，由編譯到程序中的 pprof 庫實現。pprof 庫主要是指 \"runtime/pprof\" 包，另有 \"net/http/pprof\" 包引用 \"runtime/pprof\" 並以 HTTP 接口形式提供實時性能數據。\n2. 數據分析，使用 `go tool pprof <source>` 工具分析採集到的數據。 \n\n<!--more-->\n\n## 啓用 pprof\n\n**（1）使用 `go test`**\n\n`go test` 中內建支持基準測試的性能分析。運行下面的命令就可以啓動基準測試並將 CPU 性能數據寫入 cpu.prof，內存性能數據寫入 mem.prof：\n\n```bash\ngo test -cpuprofile cpu.prof -memprofile mem.prof -bench .\n```\n\n**（2）使用 \"runtime/pprof\" 包**\n\n```go\nvar cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to `file`\")\nvar memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\")\n\nfunc main() {\n    flag.Parse()\n    if *cpuprofile != \"\" {\n        f, err := os.Create(*cpuprofile)\n        if err != nil {\n            log.Fatal(\"could not create CPU profile: \", err)\n        }\n        defer f.Close() // error handling omitted for example\n        if err := pprof.StartCPUProfile(f); err != nil {\n            log.Fatal(\"could not start CPU profile: \", err)\n        }\n        defer pprof.StopCPUProfile()\n    }\n\n    // ... rest of the program ...\n\n    if *memprofile != \"\" {\n        f, err := os.Create(*memprofile)\n        if err != nil {\n            log.Fatal(\"could not create memory profile: \", err)\n        }\n        defer f.Close() // error handling omitted for example\n        runtime.GC() // get up-to-date statistics\n        if err := pprof.WriteHeapProfile(f); err != nil {\n            log.Fatal(\"could not write memory profile: \", err)\n        }\n    }\n}\n```\n\n**（3） 使用 \"net/http/pprof\" 包**\n\n如果原有 HTTP 服務使用默認路由，則直接導入該包即可，語句如下：\n\n```\nimport _ \"net/http/pprof\"\n```\n\n導入之後會在默認的服務路由（DefaultServeMux）中註冊 HTTP handler， 包含：\n\n```go\nfunc init() {\n    http.HandleFunc(\"/debug/pprof/\", Index)\n    http.HandleFunc(\"/debug/pprof/cmdline\", Cmdline)\n    http.HandleFunc(\"/debug/pprof/profile\", Profile)\n    http.HandleFunc(\"/debug/pprof/symbol\", Symbol)\n    http.HandleFunc(\"/debug/pprof/trace\", Trace)\n}\n```\n\n如果要在單獨的 HTTP 服務和端口中提供 pprof，則原有服務不要使用默認路由（DefaultServeMux），並使用默認路由和另外的端口啓動單獨的服務。\n\n```go\npackage service\n\nimport (\n    \"net/http\"\n    _ \"net/http/pprof\"\n)\n\nfunc RunPprof() {\n    go http.ListenAndServe(\"0.0.0.0:6060\", nil)\n}\n```\n\n當然，你還可以在自定義的服務路由中手動註冊 pprof Handler。\n\n## 分析數據\n\n使用 `go tool pprof` 可以進行數據分析。\n\n### 使用方式\n\npprof 有三種使用方式：\n\n**（1）生成報告**\n\n運行以下命令，將生成指定格式的報告：\n\n```bash\ngo tool pprof <format> [options] source\n```\n\n支持文本格式和圖形格式，\n\n文本格式包含：\n\n- -text，普通文本格式；\n- -tree，函數調用樹形文本格式；\n- -peek=*regex*，正則過濾函數；\n- -traces，打印每一個樣本。\n\n圖形格式包含：\n\n- -dot，.dot 格式；\n- -svg，SVG 格式；\n- -web，生成臨時的 SVG 格式文件，並使用瀏覽器打開；\n- -png, -jpg, -gif, -pdf\n\n\n例如：\n\n```bash\ngo tool pprof -text mem.prof\n```\n\n**（2）進入交互終端**\n\n運行以下命令進入交互終端：\n\n```\ngo tool pprof [options] source\n```\n\n例如：\n\n```bash\n# 實時分析堆內存（通過前文第三種方式啓動的pprof），會自動下載 profile文件\ngo tool pprof http://localhost:6060/debug/pprof/heap\n```\n\n進入類似以下界面的交互終端：\n\n```\nType: alloc_space\nTime: Dec 1, 2021 at 3:44pm (CST)\nEntering interactive mode (type \"help\" for commands, \"o\" for options)\n(pprof) \n```\n\n**（3）通過網絡接口**\n\n運行以下命令開啓網絡接口：\n\n```\ngo tool pprof -http=[host]:[port] [options] source\n```\n\n例如：\n\n```bash\n# 分析30s內的CPU性能（通過前文第三種方式啓動的pprof），會自動下載 profile文件\ngo tool pprof -http=:8080 http://localhost:6060/debug/pprof/profile?seconds=30\n```\n\n### options 說明\n\n- -flat [default], -cum，文本報告的排序指標，默認按 flat 值，也可指定為 cum 值。\n- -functions [default], -filefunctions, -files, -lines, -addresses，指定報告的粒度，默認函數級別。\n- -noinlines，將內聯函數的資源佔用歸到 out-of-line 調用者中。\n- -nodecount=*int*，指定報告字段的最大數量。\n- -focus=*regex*，僅分析匹配的樣本數據。\n- -ignore=*regex*，忽略匹配的樣本數據。\n- -show_from=*regex*，不顯示第一個匹配的字段。\n- -show=*regex*，僅顯示匹配的字段。\n- -hide=*regex*，不顯示匹配的字段。\n\n### 交互終端命令\n\n**（1）top**\n\n降序顯示佔用資源最高的 10 個函數。\n\n```go\n(pprof)  top\nShowing nodes accounting for 3189.91kB, 100% of 3189.91kB total\nShowing top 10 nodes out of 17\n      flat  flat%   sum%        cum   cum%\n 1184.27kB 37.13% 37.13%  1184.27kB 37.13%  runtime/pprof.StartCPUProfile\n  902.59kB 28.30% 65.42%  1485.59kB 46.57%  compress/flate.NewWriter\n  583.01kB 18.28% 83.70%   583.01kB 18.28%  compress/flate.newDeflateFast (inline)\n...\n```\n\n指標說明：\n\n1. flat：函數本身佔用的資源值。\n2. cum（cumulative）：函數及其調用的函數加總佔用的資源值。\n\n**（2）web**\n\n使用瀏覽器打開調用棧矢量圖(callgraph)。\n\n\n### 圖形報告說明\n\n![callgraph](go-tool-pprof/callgraph.png)\n\n圖形規則：\n\n1. 色彩越鮮艷表明 cum 越高；\n2. 方框越大表明 flat 越高；\n3. 虛箭頭表明中間有省略函數調用，實箭頭表明中間沒有函數調用；\n4. 粗和鮮艷的箭頭表明耗用資源多，細和灰色的箭頭表明耗用資源少。\n\n### 比較 profile\n\npprof 可以在提供兩個相同類型的 profile 文件時進行減法比較，有兩種方式：\n\n* -diff_base=*profile*，輸出數據中的百分比是相對於 base profile 中的總樣本。\n* -base=*prifile*，輸出數據中的 cum 是減去了 base profile 中的 cum值，百分比是相對於source profile 和 base profile 的差值。\n* -normalize，當使用上面的tag時，可以使用 -normalize 縮放 source profile 樣本數，使得 base profile 的樣本總數一樣。\n\n### 拉取 profiles\n\npprof 可以從一個文件或 URL 中讀取 profiles，並以 gzipped profile.proto 格式存儲。拉取時可配置選項：\n\n- -secondes=*int* ，讀取指定時間間隔內的profile。當且僅當對基於時間流逝的profile有用，比如 CPU profiles。\n- -timeout=*int*，設置當通過 URL 讀取 profile 時的超時時間，如未設置將通過試探法確定一個合理的超時時間。\n\n## 其他\n\npprof 採集的樣本數據會以 [profile.proto](https://github.com/google/pprof/blob/master/proto/profile.proto) 的格式寫入。\n\n## 延伸閱讀\n\n1. [pprof README文檔](https://github.com/google/pprof/blob/master/doc/README.md)\n2. [net/http/pprof 註釋](https://pkg.go.dev/net/http/pprof)\n3. [runtime/pprof 註釋](https://pkg.go.dev/runtime/pprof)\n4. [Profiling Go Programs -- go.dev](https://go.dev/blog/pprof)\n\n","source":"_posts/it/go/go-tool-pprof.md","raw":"---\ndate: 2021-12-04 20:51:15\ntitle: 介紹Go程序性能分析工具 pprof\np: it/go/go-tool-pprof\ntags:\n- Go\n- pprof\n---\n\npprof 是 program profiling（程序分析）的縮寫，是 Go程序中重要的性能分析工具，包含兩個部分：\n\n1. 數據採集，由編譯到程序中的 pprof 庫實現。pprof 庫主要是指 \"runtime/pprof\" 包，另有 \"net/http/pprof\" 包引用 \"runtime/pprof\" 並以 HTTP 接口形式提供實時性能數據。\n2. 數據分析，使用 `go tool pprof <source>` 工具分析採集到的數據。 \n\n<!--more-->\n\n## 啓用 pprof\n\n**（1）使用 `go test`**\n\n`go test` 中內建支持基準測試的性能分析。運行下面的命令就可以啓動基準測試並將 CPU 性能數據寫入 cpu.prof，內存性能數據寫入 mem.prof：\n\n```bash\ngo test -cpuprofile cpu.prof -memprofile mem.prof -bench .\n```\n\n**（2）使用 \"runtime/pprof\" 包**\n\n```go\nvar cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to `file`\")\nvar memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\")\n\nfunc main() {\n    flag.Parse()\n    if *cpuprofile != \"\" {\n        f, err := os.Create(*cpuprofile)\n        if err != nil {\n            log.Fatal(\"could not create CPU profile: \", err)\n        }\n        defer f.Close() // error handling omitted for example\n        if err := pprof.StartCPUProfile(f); err != nil {\n            log.Fatal(\"could not start CPU profile: \", err)\n        }\n        defer pprof.StopCPUProfile()\n    }\n\n    // ... rest of the program ...\n\n    if *memprofile != \"\" {\n        f, err := os.Create(*memprofile)\n        if err != nil {\n            log.Fatal(\"could not create memory profile: \", err)\n        }\n        defer f.Close() // error handling omitted for example\n        runtime.GC() // get up-to-date statistics\n        if err := pprof.WriteHeapProfile(f); err != nil {\n            log.Fatal(\"could not write memory profile: \", err)\n        }\n    }\n}\n```\n\n**（3） 使用 \"net/http/pprof\" 包**\n\n如果原有 HTTP 服務使用默認路由，則直接導入該包即可，語句如下：\n\n```\nimport _ \"net/http/pprof\"\n```\n\n導入之後會在默認的服務路由（DefaultServeMux）中註冊 HTTP handler， 包含：\n\n```go\nfunc init() {\n    http.HandleFunc(\"/debug/pprof/\", Index)\n    http.HandleFunc(\"/debug/pprof/cmdline\", Cmdline)\n    http.HandleFunc(\"/debug/pprof/profile\", Profile)\n    http.HandleFunc(\"/debug/pprof/symbol\", Symbol)\n    http.HandleFunc(\"/debug/pprof/trace\", Trace)\n}\n```\n\n如果要在單獨的 HTTP 服務和端口中提供 pprof，則原有服務不要使用默認路由（DefaultServeMux），並使用默認路由和另外的端口啓動單獨的服務。\n\n```go\npackage service\n\nimport (\n    \"net/http\"\n    _ \"net/http/pprof\"\n)\n\nfunc RunPprof() {\n    go http.ListenAndServe(\"0.0.0.0:6060\", nil)\n}\n```\n\n當然，你還可以在自定義的服務路由中手動註冊 pprof Handler。\n\n## 分析數據\n\n使用 `go tool pprof` 可以進行數據分析。\n\n### 使用方式\n\npprof 有三種使用方式：\n\n**（1）生成報告**\n\n運行以下命令，將生成指定格式的報告：\n\n```bash\ngo tool pprof <format> [options] source\n```\n\n支持文本格式和圖形格式，\n\n文本格式包含：\n\n- -text，普通文本格式；\n- -tree，函數調用樹形文本格式；\n- -peek=*regex*，正則過濾函數；\n- -traces，打印每一個樣本。\n\n圖形格式包含：\n\n- -dot，.dot 格式；\n- -svg，SVG 格式；\n- -web，生成臨時的 SVG 格式文件，並使用瀏覽器打開；\n- -png, -jpg, -gif, -pdf\n\n\n例如：\n\n```bash\ngo tool pprof -text mem.prof\n```\n\n**（2）進入交互終端**\n\n運行以下命令進入交互終端：\n\n```\ngo tool pprof [options] source\n```\n\n例如：\n\n```bash\n# 實時分析堆內存（通過前文第三種方式啓動的pprof），會自動下載 profile文件\ngo tool pprof http://localhost:6060/debug/pprof/heap\n```\n\n進入類似以下界面的交互終端：\n\n```\nType: alloc_space\nTime: Dec 1, 2021 at 3:44pm (CST)\nEntering interactive mode (type \"help\" for commands, \"o\" for options)\n(pprof) \n```\n\n**（3）通過網絡接口**\n\n運行以下命令開啓網絡接口：\n\n```\ngo tool pprof -http=[host]:[port] [options] source\n```\n\n例如：\n\n```bash\n# 分析30s內的CPU性能（通過前文第三種方式啓動的pprof），會自動下載 profile文件\ngo tool pprof -http=:8080 http://localhost:6060/debug/pprof/profile?seconds=30\n```\n\n### options 說明\n\n- -flat [default], -cum，文本報告的排序指標，默認按 flat 值，也可指定為 cum 值。\n- -functions [default], -filefunctions, -files, -lines, -addresses，指定報告的粒度，默認函數級別。\n- -noinlines，將內聯函數的資源佔用歸到 out-of-line 調用者中。\n- -nodecount=*int*，指定報告字段的最大數量。\n- -focus=*regex*，僅分析匹配的樣本數據。\n- -ignore=*regex*，忽略匹配的樣本數據。\n- -show_from=*regex*，不顯示第一個匹配的字段。\n- -show=*regex*，僅顯示匹配的字段。\n- -hide=*regex*，不顯示匹配的字段。\n\n### 交互終端命令\n\n**（1）top**\n\n降序顯示佔用資源最高的 10 個函數。\n\n```go\n(pprof)  top\nShowing nodes accounting for 3189.91kB, 100% of 3189.91kB total\nShowing top 10 nodes out of 17\n      flat  flat%   sum%        cum   cum%\n 1184.27kB 37.13% 37.13%  1184.27kB 37.13%  runtime/pprof.StartCPUProfile\n  902.59kB 28.30% 65.42%  1485.59kB 46.57%  compress/flate.NewWriter\n  583.01kB 18.28% 83.70%   583.01kB 18.28%  compress/flate.newDeflateFast (inline)\n...\n```\n\n指標說明：\n\n1. flat：函數本身佔用的資源值。\n2. cum（cumulative）：函數及其調用的函數加總佔用的資源值。\n\n**（2）web**\n\n使用瀏覽器打開調用棧矢量圖(callgraph)。\n\n\n### 圖形報告說明\n\n![callgraph](go-tool-pprof/callgraph.png)\n\n圖形規則：\n\n1. 色彩越鮮艷表明 cum 越高；\n2. 方框越大表明 flat 越高；\n3. 虛箭頭表明中間有省略函數調用，實箭頭表明中間沒有函數調用；\n4. 粗和鮮艷的箭頭表明耗用資源多，細和灰色的箭頭表明耗用資源少。\n\n### 比較 profile\n\npprof 可以在提供兩個相同類型的 profile 文件時進行減法比較，有兩種方式：\n\n* -diff_base=*profile*，輸出數據中的百分比是相對於 base profile 中的總樣本。\n* -base=*prifile*，輸出數據中的 cum 是減去了 base profile 中的 cum值，百分比是相對於source profile 和 base profile 的差值。\n* -normalize，當使用上面的tag時，可以使用 -normalize 縮放 source profile 樣本數，使得 base profile 的樣本總數一樣。\n\n### 拉取 profiles\n\npprof 可以從一個文件或 URL 中讀取 profiles，並以 gzipped profile.proto 格式存儲。拉取時可配置選項：\n\n- -secondes=*int* ，讀取指定時間間隔內的profile。當且僅當對基於時間流逝的profile有用，比如 CPU profiles。\n- -timeout=*int*，設置當通過 URL 讀取 profile 時的超時時間，如未設置將通過試探法確定一個合理的超時時間。\n\n## 其他\n\npprof 採集的樣本數據會以 [profile.proto](https://github.com/google/pprof/blob/master/proto/profile.proto) 的格式寫入。\n\n## 延伸閱讀\n\n1. [pprof README文檔](https://github.com/google/pprof/blob/master/doc/README.md)\n2. [net/http/pprof 註釋](https://pkg.go.dev/net/http/pprof)\n3. [runtime/pprof 註釋](https://pkg.go.dev/runtime/pprof)\n4. [Profiling Go Programs -- go.dev](https://go.dev/blog/pprof)\n\n","slug":"it/go/go-tool-pprof","published":1,"updated":"2021-12-04T13:46:28.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlez000r1n9k1o8h2rnj","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>pprof 是 program profiling（程序分析）的縮寫，是 Go程序中重要的性能分析工具，包含兩個部分：</p>\n<ol>\n<li>數據採集，由編譯到程序中的 pprof 庫實現。pprof 庫主要是指 “runtime/pprof” 包，另有 “net/http/pprof” 包引用 “runtime/pprof” 並以 HTTP 接口形式提供實時性能數據。</li>\n<li>數據分析，使用 <code>go tool pprof &lt;source&gt;</code> 工具分析採集到的數據。 </li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"啓用-pprof\"><a href=\"#啓用-pprof\" class=\"headerlink\" title=\"啓用 pprof\"></a>啓用 pprof</h2><p><strong>（1）使用 <code>go test</code></strong></p>\n<p><code>go test</code> 中內建支持基準測試的性能分析。運行下面的命令就可以啓動基準測試並將 CPU 性能數據寫入 cpu.prof，內存性能數據寫入 mem.prof：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">go <span class=\"built_in\">test</span> -cpuprofile cpu.prof -memprofile mem.prof -bench .</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）使用 “runtime/pprof” 包</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cpuprofile = flag.String(<span class=\"string\">&quot;cpuprofile&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;write cpu profile to `file`&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> memprofile = flag.String(<span class=\"string\">&quot;memprofile&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;write memory profile to `file`&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    flag.Parse()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> *cpuprofile != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        f, err := os.Create(*cpuprofile)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;could not create CPU profile: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> f.Close() <span class=\"comment\">// error handling omitted for example</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err := pprof.StartCPUProfile(f); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;could not start CPU profile: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> pprof.StopCPUProfile()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... rest of the program ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> *memprofile != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        f, err := os.Create(*memprofile)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;could not create memory profile: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> f.Close() <span class=\"comment\">// error handling omitted for example</span></span><br><span class=\"line\">        runtime.GC() <span class=\"comment\">// get up-to-date statistics</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err := pprof.WriteHeapProfile(f); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;could not write memory profile: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3） 使用 “net/http/pprof” 包</strong></p>\n<p>如果原有 HTTP 服務使用默認路由，則直接導入該包即可，語句如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import _ &quot;net/http/pprof&quot;</span><br></pre></td></tr></table></figure>\n\n<p>導入之後會在默認的服務路由（DefaultServeMux）中註冊 HTTP handler， 包含：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/debug/pprof/&quot;</span>, Index)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/debug/pprof/cmdline&quot;</span>, Cmdline)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/debug/pprof/profile&quot;</span>, Profile)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/debug/pprof/symbol&quot;</span>, Symbol)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/debug/pprof/trace&quot;</span>, Trace)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要在單獨的 HTTP 服務和端口中提供 pprof，則原有服務不要使用默認路由（DefaultServeMux），並使用默認路由和另外的端口啓動單獨的服務。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    _ <span class=\"string\">&quot;net/http/pprof&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RunPprof</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> http.ListenAndServe(<span class=\"string\">&quot;0.0.0.0:6060&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>當然，你還可以在自定義的服務路由中手動註冊 pprof Handler。</p>\n<h2 id=\"分析數據\"><a href=\"#分析數據\" class=\"headerlink\" title=\"分析數據\"></a>分析數據</h2><p>使用 <code>go tool pprof</code> 可以進行數據分析。</p>\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><p>pprof 有三種使用方式：</p>\n<p><strong>（1）生成報告</strong></p>\n<p>運行以下命令，將生成指定格式的報告：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">go tool pprof &lt;format&gt; [options] <span class=\"built_in\">source</span></span><br></pre></td></tr></table></figure>\n\n<p>支持文本格式和圖形格式，</p>\n<p>文本格式包含：</p>\n<ul>\n<li>-text，普通文本格式；</li>\n<li>-tree，函數調用樹形文本格式；</li>\n<li>-peek=<em>regex</em>，正則過濾函數；</li>\n<li>-traces，打印每一個樣本。</li>\n</ul>\n<p>圖形格式包含：</p>\n<ul>\n<li>-dot，.dot 格式；</li>\n<li>-svg，SVG 格式；</li>\n<li>-web，生成臨時的 SVG 格式文件，並使用瀏覽器打開；</li>\n<li>-png, -jpg, -gif, -pdf</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">go tool pprof -text mem.prof</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）進入交互終端</strong></p>\n<p>運行以下命令進入交互終端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">go tool pprof [options] source</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 實時分析堆內存（通過前文第三種方式啓動的pprof），會自動下載 profile文件</span></span><br><span class=\"line\">go tool pprof http://localhost:6060/debug/pprof/heap</span><br></pre></td></tr></table></figure>\n\n<p>進入類似以下界面的交互終端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Type: alloc_space</span><br><span class=\"line\">Time: Dec 1, 2021 at 3:44pm (CST)</span><br><span class=\"line\">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class=\"line\">(pprof) </span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）通過網絡接口</strong></p>\n<p>運行以下命令開啓網絡接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">go tool pprof -http=[host]:[port] [options] source</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分析30s內的CPU性能（通過前文第三種方式啓動的pprof），會自動下載 profile文件</span></span><br><span class=\"line\">go tool pprof -http=:8080 http://localhost:6060/debug/pprof/profile?seconds=30</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"options-說明\"><a href=\"#options-說明\" class=\"headerlink\" title=\"options 說明\"></a>options 說明</h3><ul>\n<li>-flat [default], -cum，文本報告的排序指標，默認按 flat 值，也可指定為 cum 值。</li>\n<li>-functions [default], -filefunctions, -files, -lines, -addresses，指定報告的粒度，默認函數級別。</li>\n<li>-noinlines，將內聯函數的資源佔用歸到 out-of-line 調用者中。</li>\n<li>-nodecount=<em>int</em>，指定報告字段的最大數量。</li>\n<li>-focus=<em>regex</em>，僅分析匹配的樣本數據。</li>\n<li>-ignore=<em>regex</em>，忽略匹配的樣本數據。</li>\n<li>-show_from=<em>regex</em>，不顯示第一個匹配的字段。</li>\n<li>-show=<em>regex</em>，僅顯示匹配的字段。</li>\n<li>-hide=<em>regex</em>，不顯示匹配的字段。</li>\n</ul>\n<h3 id=\"交互終端命令\"><a href=\"#交互終端命令\" class=\"headerlink\" title=\"交互終端命令\"></a>交互終端命令</h3><p><strong>（1）top</strong></p>\n<p>降序顯示佔用資源最高的 10 個函數。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">(pprof)  top</span><br><span class=\"line\">Showing nodes accounting <span class=\"keyword\">for</span> <span class=\"number\">3189.91</span>kB, <span class=\"number\">100</span>% of <span class=\"number\">3189.91</span>kB total</span><br><span class=\"line\">Showing top <span class=\"number\">10</span> nodes out of <span class=\"number\">17</span></span><br><span class=\"line\">      flat  flat%   sum%        cum   cum%</span><br><span class=\"line\"> <span class=\"number\">1184.27</span>kB <span class=\"number\">37.13</span>% <span class=\"number\">37.13</span>%  <span class=\"number\">1184.27</span>kB <span class=\"number\">37.13</span>%  runtime/pprof.StartCPUProfile</span><br><span class=\"line\">  <span class=\"number\">902.59</span>kB <span class=\"number\">28.30</span>% <span class=\"number\">65.42</span>%  <span class=\"number\">1485.59</span>kB <span class=\"number\">46.57</span>%  compress/flate.NewWriter</span><br><span class=\"line\">  <span class=\"number\">583.01</span>kB <span class=\"number\">18.28</span>% <span class=\"number\">83.70</span>%   <span class=\"number\">583.01</span>kB <span class=\"number\">18.28</span>%  compress/flate.newDeflateFast (inline)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>指標說明：</p>\n<ol>\n<li>flat：函數本身佔用的資源值。</li>\n<li>cum（cumulative）：函數及其調用的函數加總佔用的資源值。</li>\n</ol>\n<p><strong>（2）web</strong></p>\n<p>使用瀏覽器打開調用棧矢量圖(callgraph)。</p>\n<h3 id=\"圖形報告說明\"><a href=\"#圖形報告說明\" class=\"headerlink\" title=\"圖形報告說明\"></a>圖形報告說明</h3><p><img src=\"/it/go/go-tool-pprof/callgraph.png\" alt=\"callgraph\"></p>\n<p>圖形規則：</p>\n<ol>\n<li>色彩越鮮艷表明 cum 越高；</li>\n<li>方框越大表明 flat 越高；</li>\n<li>虛箭頭表明中間有省略函數調用，實箭頭表明中間沒有函數調用；</li>\n<li>粗和鮮艷的箭頭表明耗用資源多，細和灰色的箭頭表明耗用資源少。</li>\n</ol>\n<h3 id=\"比較-profile\"><a href=\"#比較-profile\" class=\"headerlink\" title=\"比較 profile\"></a>比較 profile</h3><p>pprof 可以在提供兩個相同類型的 profile 文件時進行減法比較，有兩種方式：</p>\n<ul>\n<li>-diff_base=<em>profile</em>，輸出數據中的百分比是相對於 base profile 中的總樣本。</li>\n<li>-base=<em>prifile</em>，輸出數據中的 cum 是減去了 base profile 中的 cum值，百分比是相對於source profile 和 base profile 的差值。</li>\n<li>-normalize，當使用上面的tag時，可以使用 -normalize 縮放 source profile 樣本數，使得 base profile 的樣本總數一樣。</li>\n</ul>\n<h3 id=\"拉取-profiles\"><a href=\"#拉取-profiles\" class=\"headerlink\" title=\"拉取 profiles\"></a>拉取 profiles</h3><p>pprof 可以從一個文件或 URL 中讀取 profiles，並以 gzipped profile.proto 格式存儲。拉取時可配置選項：</p>\n<ul>\n<li>-secondes=<em>int</em> ，讀取指定時間間隔內的profile。當且僅當對基於時間流逝的profile有用，比如 CPU profiles。</li>\n<li>-timeout=<em>int</em>，設置當通過 URL 讀取 profile 時的超時時間，如未設置將通過試探法確定一個合理的超時時間。</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>pprof 採集的樣本數據會以 <a href=\"https://github.com/google/pprof/blob/master/proto/profile.proto\">profile.proto</a> 的格式寫入。</p>\n<h2 id=\"延伸閱讀\"><a href=\"#延伸閱讀\" class=\"headerlink\" title=\"延伸閱讀\"></a>延伸閱讀</h2><ol>\n<li><a href=\"https://github.com/google/pprof/blob/master/doc/README.md\">pprof README文檔</a></li>\n<li><a href=\"https://pkg.go.dev/net/http/pprof\">net/http/pprof 註釋</a></li>\n<li><a href=\"https://pkg.go.dev/runtime/pprof\">runtime/pprof 註釋</a></li>\n<li><a href=\"https://go.dev/blog/pprof\">Profiling Go Programs – go.dev</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>pprof 是 program profiling（程序分析）的縮寫，是 Go程序中重要的性能分析工具，包含兩個部分：</p>\n<ol>\n<li>數據採集，由編譯到程序中的 pprof 庫實現。pprof 庫主要是指 “runtime/pprof” 包，另有 “net/http/pprof” 包引用 “runtime/pprof” 並以 HTTP 接口形式提供實時性能數據。</li>\n<li>數據分析，使用 <code>go tool pprof &lt;source&gt;</code> 工具分析採集到的數據。 </li>\n</ol>","more":"<h2 id=\"啓用-pprof\"><a href=\"#啓用-pprof\" class=\"headerlink\" title=\"啓用 pprof\"></a>啓用 pprof</h2><p><strong>（1）使用 <code>go test</code></strong></p>\n<p><code>go test</code> 中內建支持基準測試的性能分析。運行下面的命令就可以啓動基準測試並將 CPU 性能數據寫入 cpu.prof，內存性能數據寫入 mem.prof：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">go <span class=\"built_in\">test</span> -cpuprofile cpu.prof -memprofile mem.prof -bench .</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）使用 “runtime/pprof” 包</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cpuprofile = flag.String(<span class=\"string\">&quot;cpuprofile&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;write cpu profile to `file`&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> memprofile = flag.String(<span class=\"string\">&quot;memprofile&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;write memory profile to `file`&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    flag.Parse()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> *cpuprofile != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        f, err := os.Create(*cpuprofile)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;could not create CPU profile: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> f.Close() <span class=\"comment\">// error handling omitted for example</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err := pprof.StartCPUProfile(f); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;could not start CPU profile: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> pprof.StopCPUProfile()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... rest of the program ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> *memprofile != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        f, err := os.Create(*memprofile)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;could not create memory profile: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> f.Close() <span class=\"comment\">// error handling omitted for example</span></span><br><span class=\"line\">        runtime.GC() <span class=\"comment\">// get up-to-date statistics</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err := pprof.WriteHeapProfile(f); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;could not write memory profile: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3） 使用 “net/http/pprof” 包</strong></p>\n<p>如果原有 HTTP 服務使用默認路由，則直接導入該包即可，語句如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">import _ &quot;net/http/pprof&quot;</span><br></pre></td></tr></table></figure>\n\n<p>導入之後會在默認的服務路由（DefaultServeMux）中註冊 HTTP handler， 包含：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/debug/pprof/&quot;</span>, Index)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/debug/pprof/cmdline&quot;</span>, Cmdline)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/debug/pprof/profile&quot;</span>, Profile)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/debug/pprof/symbol&quot;</span>, Symbol)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/debug/pprof/trace&quot;</span>, Trace)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要在單獨的 HTTP 服務和端口中提供 pprof，則原有服務不要使用默認路由（DefaultServeMux），並使用默認路由和另外的端口啓動單獨的服務。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    _ <span class=\"string\">&quot;net/http/pprof&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RunPprof</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> http.ListenAndServe(<span class=\"string\">&quot;0.0.0.0:6060&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>當然，你還可以在自定義的服務路由中手動註冊 pprof Handler。</p>\n<h2 id=\"分析數據\"><a href=\"#分析數據\" class=\"headerlink\" title=\"分析數據\"></a>分析數據</h2><p>使用 <code>go tool pprof</code> 可以進行數據分析。</p>\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><p>pprof 有三種使用方式：</p>\n<p><strong>（1）生成報告</strong></p>\n<p>運行以下命令，將生成指定格式的報告：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">go tool pprof &lt;format&gt; [options] <span class=\"built_in\">source</span></span><br></pre></td></tr></table></figure>\n\n<p>支持文本格式和圖形格式，</p>\n<p>文本格式包含：</p>\n<ul>\n<li>-text，普通文本格式；</li>\n<li>-tree，函數調用樹形文本格式；</li>\n<li>-peek=<em>regex</em>，正則過濾函數；</li>\n<li>-traces，打印每一個樣本。</li>\n</ul>\n<p>圖形格式包含：</p>\n<ul>\n<li>-dot，.dot 格式；</li>\n<li>-svg，SVG 格式；</li>\n<li>-web，生成臨時的 SVG 格式文件，並使用瀏覽器打開；</li>\n<li>-png, -jpg, -gif, -pdf</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">go tool pprof -text mem.prof</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）進入交互終端</strong></p>\n<p>運行以下命令進入交互終端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">go tool pprof [options] source</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 實時分析堆內存（通過前文第三種方式啓動的pprof），會自動下載 profile文件</span></span><br><span class=\"line\">go tool pprof http://localhost:6060/debug/pprof/heap</span><br></pre></td></tr></table></figure>\n\n<p>進入類似以下界面的交互終端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Type: alloc_space</span><br><span class=\"line\">Time: Dec 1, 2021 at 3:44pm (CST)</span><br><span class=\"line\">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class=\"line\">(pprof) </span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）通過網絡接口</strong></p>\n<p>運行以下命令開啓網絡接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">go tool pprof -http=[host]:[port] [options] source</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 分析30s內的CPU性能（通過前文第三種方式啓動的pprof），會自動下載 profile文件</span></span><br><span class=\"line\">go tool pprof -http=:8080 http://localhost:6060/debug/pprof/profile?seconds=30</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"options-說明\"><a href=\"#options-說明\" class=\"headerlink\" title=\"options 說明\"></a>options 說明</h3><ul>\n<li>-flat [default], -cum，文本報告的排序指標，默認按 flat 值，也可指定為 cum 值。</li>\n<li>-functions [default], -filefunctions, -files, -lines, -addresses，指定報告的粒度，默認函數級別。</li>\n<li>-noinlines，將內聯函數的資源佔用歸到 out-of-line 調用者中。</li>\n<li>-nodecount=<em>int</em>，指定報告字段的最大數量。</li>\n<li>-focus=<em>regex</em>，僅分析匹配的樣本數據。</li>\n<li>-ignore=<em>regex</em>，忽略匹配的樣本數據。</li>\n<li>-show_from=<em>regex</em>，不顯示第一個匹配的字段。</li>\n<li>-show=<em>regex</em>，僅顯示匹配的字段。</li>\n<li>-hide=<em>regex</em>，不顯示匹配的字段。</li>\n</ul>\n<h3 id=\"交互終端命令\"><a href=\"#交互終端命令\" class=\"headerlink\" title=\"交互終端命令\"></a>交互終端命令</h3><p><strong>（1）top</strong></p>\n<p>降序顯示佔用資源最高的 10 個函數。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">(pprof)  top</span><br><span class=\"line\">Showing nodes accounting <span class=\"keyword\">for</span> <span class=\"number\">3189.91</span>kB, <span class=\"number\">100</span>% of <span class=\"number\">3189.91</span>kB total</span><br><span class=\"line\">Showing top <span class=\"number\">10</span> nodes out of <span class=\"number\">17</span></span><br><span class=\"line\">      flat  flat%   sum%        cum   cum%</span><br><span class=\"line\"> <span class=\"number\">1184.27</span>kB <span class=\"number\">37.13</span>% <span class=\"number\">37.13</span>%  <span class=\"number\">1184.27</span>kB <span class=\"number\">37.13</span>%  runtime/pprof.StartCPUProfile</span><br><span class=\"line\">  <span class=\"number\">902.59</span>kB <span class=\"number\">28.30</span>% <span class=\"number\">65.42</span>%  <span class=\"number\">1485.59</span>kB <span class=\"number\">46.57</span>%  compress/flate.NewWriter</span><br><span class=\"line\">  <span class=\"number\">583.01</span>kB <span class=\"number\">18.28</span>% <span class=\"number\">83.70</span>%   <span class=\"number\">583.01</span>kB <span class=\"number\">18.28</span>%  compress/flate.newDeflateFast (inline)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>指標說明：</p>\n<ol>\n<li>flat：函數本身佔用的資源值。</li>\n<li>cum（cumulative）：函數及其調用的函數加總佔用的資源值。</li>\n</ol>\n<p><strong>（2）web</strong></p>\n<p>使用瀏覽器打開調用棧矢量圖(callgraph)。</p>\n<h3 id=\"圖形報告說明\"><a href=\"#圖形報告說明\" class=\"headerlink\" title=\"圖形報告說明\"></a>圖形報告說明</h3><p><img src=\"/it/go/go-tool-pprof/callgraph.png\" alt=\"callgraph\"></p>\n<p>圖形規則：</p>\n<ol>\n<li>色彩越鮮艷表明 cum 越高；</li>\n<li>方框越大表明 flat 越高；</li>\n<li>虛箭頭表明中間有省略函數調用，實箭頭表明中間沒有函數調用；</li>\n<li>粗和鮮艷的箭頭表明耗用資源多，細和灰色的箭頭表明耗用資源少。</li>\n</ol>\n<h3 id=\"比較-profile\"><a href=\"#比較-profile\" class=\"headerlink\" title=\"比較 profile\"></a>比較 profile</h3><p>pprof 可以在提供兩個相同類型的 profile 文件時進行減法比較，有兩種方式：</p>\n<ul>\n<li>-diff_base=<em>profile</em>，輸出數據中的百分比是相對於 base profile 中的總樣本。</li>\n<li>-base=<em>prifile</em>，輸出數據中的 cum 是減去了 base profile 中的 cum值，百分比是相對於source profile 和 base profile 的差值。</li>\n<li>-normalize，當使用上面的tag時，可以使用 -normalize 縮放 source profile 樣本數，使得 base profile 的樣本總數一樣。</li>\n</ul>\n<h3 id=\"拉取-profiles\"><a href=\"#拉取-profiles\" class=\"headerlink\" title=\"拉取 profiles\"></a>拉取 profiles</h3><p>pprof 可以從一個文件或 URL 中讀取 profiles，並以 gzipped profile.proto 格式存儲。拉取時可配置選項：</p>\n<ul>\n<li>-secondes=<em>int</em> ，讀取指定時間間隔內的profile。當且僅當對基於時間流逝的profile有用，比如 CPU profiles。</li>\n<li>-timeout=<em>int</em>，設置當通過 URL 讀取 profile 時的超時時間，如未設置將通過試探法確定一個合理的超時時間。</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>pprof 採集的樣本數據會以 <a href=\"https://github.com/google/pprof/blob/master/proto/profile.proto\">profile.proto</a> 的格式寫入。</p>\n<h2 id=\"延伸閱讀\"><a href=\"#延伸閱讀\" class=\"headerlink\" title=\"延伸閱讀\"></a>延伸閱讀</h2><ol>\n<li><a href=\"https://github.com/google/pprof/blob/master/doc/README.md\">pprof README文檔</a></li>\n<li><a href=\"https://pkg.go.dev/net/http/pprof\">net/http/pprof 註釋</a></li>\n<li><a href=\"https://pkg.go.dev/runtime/pprof\">runtime/pprof 註釋</a></li>\n<li><a href=\"https://go.dev/blog/pprof\">Profiling Go Programs – go.dev</a></li>\n</ol>"},{"title":"Go調度器","p":"it/go/go-scheduler.md","date":"2021-12-27T03:00:00.000Z","_content":"\n現在有三種常見的線程模型，包括：\n1. N:1，即 N 個用戶線程對應一個系統線程，節省上下文（context switch）切換開銷；\n2. 1:1，即 1 個用戶線程對應一個系統線程，充分利用多個核心（multi-core）；\n3. M:N，即 M 個用戶線程對應 N 個系統線程，節省上下文開銷並充分利用多個核心。\n\nGo的線程調度模型就是 M:N。\n\n<!-- more -->\n\n我們使用三個實體來表示 Go 的線程：\n1. 三角框的 M，代表系統線程，在運行時代碼中寫作 M（Machine）；\n2. 圓框的 G，代表 goroutine，包含棧和指令指針等等信息；\n3. 方框的 P，代表調度的上下文（context for scheduling），在運行時代碼中寫作 P（Processor）。\n\n![M-P-G](go-scheduler/mpg.png)\n\n在這種模型中，M 持有 P 來運行 G（M hold P to run G），藍色的G表示正在運行，灰色的G置於P本地的 runqueue 中等待被調度，P 的數量可以通過 GOMAXPROC 設置（從GO1.5起默認等於CPU核心數）。\n\n為什麼不直接將 G 掛在 M 上，而是通過 P 來調度呢？\n\n因為使用P可以靈活高效地管理G，具體如下：\n\n第一，P 可以在 M 阻塞（比如syscall）時，從阻塞的M脫離，掛到其他可用的M上，保證後續的G正常運行。\n\n![Syscall](go-scheduler/syscall.jpg)\n\n第二，在阻塞的M解除阻塞狀態時，會從其他M搶奪P；如果搶不到，就將G置放到全局的 runqueue中，然後將自己放入線程緩存並休眠。\n\n第三，P 會定時檢查全局的 runqueue 中是否有G，有的話拿過來運行。\n\n第四，當 P 運行完本地 runqueue中的任務後，會檢察全局的 runqueue 是否有G；如果沒有，就從其他P搶奪一半的G過來運行。\n\n![Steal Work](go-scheduler/steal.jpg)\n\n參考：[The Go scheduler - Morsing's blog](https://www.morsmachine.dk/go-scheduler)\n","source":"_posts/it/go/go-scheduler.md","raw":"---\ntitle: Go調度器\np: it/go/go-scheduler.md\ndate: 2021-12-27 11:00:00\ntags:\n- Go\n---\n\n現在有三種常見的線程模型，包括：\n1. N:1，即 N 個用戶線程對應一個系統線程，節省上下文（context switch）切換開銷；\n2. 1:1，即 1 個用戶線程對應一個系統線程，充分利用多個核心（multi-core）；\n3. M:N，即 M 個用戶線程對應 N 個系統線程，節省上下文開銷並充分利用多個核心。\n\nGo的線程調度模型就是 M:N。\n\n<!-- more -->\n\n我們使用三個實體來表示 Go 的線程：\n1. 三角框的 M，代表系統線程，在運行時代碼中寫作 M（Machine）；\n2. 圓框的 G，代表 goroutine，包含棧和指令指針等等信息；\n3. 方框的 P，代表調度的上下文（context for scheduling），在運行時代碼中寫作 P（Processor）。\n\n![M-P-G](go-scheduler/mpg.png)\n\n在這種模型中，M 持有 P 來運行 G（M hold P to run G），藍色的G表示正在運行，灰色的G置於P本地的 runqueue 中等待被調度，P 的數量可以通過 GOMAXPROC 設置（從GO1.5起默認等於CPU核心數）。\n\n為什麼不直接將 G 掛在 M 上，而是通過 P 來調度呢？\n\n因為使用P可以靈活高效地管理G，具體如下：\n\n第一，P 可以在 M 阻塞（比如syscall）時，從阻塞的M脫離，掛到其他可用的M上，保證後續的G正常運行。\n\n![Syscall](go-scheduler/syscall.jpg)\n\n第二，在阻塞的M解除阻塞狀態時，會從其他M搶奪P；如果搶不到，就將G置放到全局的 runqueue中，然後將自己放入線程緩存並休眠。\n\n第三，P 會定時檢查全局的 runqueue 中是否有G，有的話拿過來運行。\n\n第四，當 P 運行完本地 runqueue中的任務後，會檢察全局的 runqueue 是否有G；如果沒有，就從其他P搶奪一半的G過來運行。\n\n![Steal Work](go-scheduler/steal.jpg)\n\n參考：[The Go scheduler - Morsing's blog](https://www.morsmachine.dk/go-scheduler)\n","slug":"it/go/go-scheduler","published":1,"updated":"2022-01-04T14:29:22.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlf0000u1n9kcfc955du","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>現在有三種常見的線程模型，包括：</p>\n<ol>\n<li>N:1，即 N 個用戶線程對應一個系統線程，節省上下文（context switch）切換開銷；</li>\n<li>1:1，即 1 個用戶線程對應一個系統線程，充分利用多個核心（multi-core）；</li>\n<li>M:N，即 M 個用戶線程對應 N 個系統線程，節省上下文開銷並充分利用多個核心。</li>\n</ol>\n<p>Go的線程調度模型就是 M:N。</p>\n<span id=\"more\"></span>\n\n<p>我們使用三個實體來表示 Go 的線程：</p>\n<ol>\n<li>三角框的 M，代表系統線程，在運行時代碼中寫作 M（Machine）；</li>\n<li>圓框的 G，代表 goroutine，包含棧和指令指針等等信息；</li>\n<li>方框的 P，代表調度的上下文（context for scheduling），在運行時代碼中寫作 P（Processor）。</li>\n</ol>\n<p><img src=\"/it/go/go-scheduler/mpg.png\" alt=\"M-P-G\"></p>\n<p>在這種模型中，M 持有 P 來運行 G（M hold P to run G），藍色的G表示正在運行，灰色的G置於P本地的 runqueue 中等待被調度，P 的數量可以通過 GOMAXPROC 設置（從GO1.5起默認等於CPU核心數）。</p>\n<p>為什麼不直接將 G 掛在 M 上，而是通過 P 來調度呢？</p>\n<p>因為使用P可以靈活高效地管理G，具體如下：</p>\n<p>第一，P 可以在 M 阻塞（比如syscall）時，從阻塞的M脫離，掛到其他可用的M上，保證後續的G正常運行。</p>\n<p><img src=\"/it/go/go-scheduler/syscall.jpg\" alt=\"Syscall\"></p>\n<p>第二，在阻塞的M解除阻塞狀態時，會從其他M搶奪P；如果搶不到，就將G置放到全局的 runqueue中，然後將自己放入線程緩存並休眠。</p>\n<p>第三，P 會定時檢查全局的 runqueue 中是否有G，有的話拿過來運行。</p>\n<p>第四，當 P 運行完本地 runqueue中的任務後，會檢察全局的 runqueue 是否有G；如果沒有，就從其他P搶奪一半的G過來運行。</p>\n<p><img src=\"/it/go/go-scheduler/steal.jpg\" alt=\"Steal Work\"></p>\n<p>參考：<a href=\"https://www.morsmachine.dk/go-scheduler\">The Go scheduler - Morsing’s blog</a></p>\n","site":{"data":{}},"excerpt":"<p>現在有三種常見的線程模型，包括：</p>\n<ol>\n<li>N:1，即 N 個用戶線程對應一個系統線程，節省上下文（context switch）切換開銷；</li>\n<li>1:1，即 1 個用戶線程對應一個系統線程，充分利用多個核心（multi-core）；</li>\n<li>M:N，即 M 個用戶線程對應 N 個系統線程，節省上下文開銷並充分利用多個核心。</li>\n</ol>\n<p>Go的線程調度模型就是 M:N。</p>","more":"<p>我們使用三個實體來表示 Go 的線程：</p>\n<ol>\n<li>三角框的 M，代表系統線程，在運行時代碼中寫作 M（Machine）；</li>\n<li>圓框的 G，代表 goroutine，包含棧和指令指針等等信息；</li>\n<li>方框的 P，代表調度的上下文（context for scheduling），在運行時代碼中寫作 P（Processor）。</li>\n</ol>\n<p><img src=\"/it/go/go-scheduler/mpg.png\" alt=\"M-P-G\"></p>\n<p>在這種模型中，M 持有 P 來運行 G（M hold P to run G），藍色的G表示正在運行，灰色的G置於P本地的 runqueue 中等待被調度，P 的數量可以通過 GOMAXPROC 設置（從GO1.5起默認等於CPU核心數）。</p>\n<p>為什麼不直接將 G 掛在 M 上，而是通過 P 來調度呢？</p>\n<p>因為使用P可以靈活高效地管理G，具體如下：</p>\n<p>第一，P 可以在 M 阻塞（比如syscall）時，從阻塞的M脫離，掛到其他可用的M上，保證後續的G正常運行。</p>\n<p><img src=\"/it/go/go-scheduler/syscall.jpg\" alt=\"Syscall\"></p>\n<p>第二，在阻塞的M解除阻塞狀態時，會從其他M搶奪P；如果搶不到，就將G置放到全局的 runqueue中，然後將自己放入線程緩存並休眠。</p>\n<p>第三，P 會定時檢查全局的 runqueue 中是否有G，有的話拿過來運行。</p>\n<p>第四，當 P 運行完本地 runqueue中的任務後，會檢察全局的 runqueue 是否有G；如果沒有，就從其他P搶奪一半的G過來運行。</p>\n<p><img src=\"/it/go/go-scheduler/steal.jpg\" alt=\"Steal Work\"></p>\n<p>參考：<a href=\"https://www.morsmachine.dk/go-scheduler\">The Go scheduler - Morsing’s blog</a></p>"},{"title":"十二生肖、干支紀年法與Go語言編程","p":"it/go/zodiac-ganzhi-go.md","date":"2020-12-01T15:57:00.000Z","_content":"\n如無特殊說明，本文標音採用甲子話拼音方案。甲子話系陸豐市甲子鎮通行的語言，屬閩南語潮汕話三甲片。\n\n## 十二生肖\n\n十二生肖本地讀音爲：\n\n- 鼠牛虎兔 /cu² ngu⁵ hao² tao³/\n- 龍蛇馬羊 /lêng⁵ zua⁵ bhê² ion⁵/\n- 猴雞狗豬 /gao⁵ goi¹ gao² du¹/\n\n## 干支紀年法\n\n「干」是天干，有 10：\n\n- 甲乙丙丁 /gah⁴ ig⁴ bian² dêng¹/\n- 戊己庚辛 /bhao⁷ gi² gên¹ sing¹/\n- 壬癸 /rim⁶ gui³/\n\n「支」是地支，有 12：\n\n- 子丑寅卯 /zu² tiu² ing⁵ bhao²/\n- 辰巳午未 /sing⁵ zi⁶ ngao² bhi⁷/\n- 申酉戌亥 /sing¹ iu² sug⁴ hai⁶/\n\n天干從甲開始，地支從子開始，天干地支相配形成 60 種組合，用來紀年。從甲子出發，60 年後又回到甲子，因此稱 60 年爲「一甲子」。\n\n十二地支與十二生肖相對應，因此也用生肖紀年。如甲子年，地支爲「子」，對應生肖「鼠」，因此甲子年也稱之為「鼠年」。\n\n## 問題\n\n**問題1：已知 2020 年是鼠年，請問 2021 年是什麼年？**\n\n排在鼠之後的生肖是牛，因此 2021 年是牛年。\n\n**問題2：已知 2020 年是庚子年 /gên¹ zu² ni⁵/，請問 2021 年是什麼年？**\n\n庚之後爲辛，子之後爲丑，因此 2021 年是辛丑年 /sing¹ tiu² ni⁵/。\n\n**問題3：已知 1024 年是甲子年，問最近過去的甲子年和將要到來的甲子年是公元多少年？**\n\n<!-- more -->\n\n使用 Go 語言解決，編碼如下：\n\n```go\nfunc f1() {\n\tjz := 1024\n\tfor {\n\t\tjz = jz + 60\n\t\tif jz > 2020 {\n\t\t\tprintln(jz-60, jz)\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n執行後輸出結果爲：\n\n```go\n1984 2044\n```\n\n因此，最近過去的甲子年是 1984 年，將要到來的甲子年是 2044 年。\n\n**問題4：已知干支紀年法中有 10 天干，12 地支，有 60 種合法組合，求所有非法的組合，並探討其中規律。**\n\n先說結論：\n\n1. 所有非法的組合爲：\n甲丑 甲卯 甲巳 甲未 甲酉 甲亥 乙子 乙寅 乙辰 乙午 乙申 乙戌 丙丑 丙卯 丙巳 丙未 丙酉 丙亥 丁子 丁寅 丁辰 丁午 丁申 丁戌 戊丑 戊卯 戊巳 戊未 戊酉 戊亥 己子 己寅 己辰 己午 辛寅 辛辰 辛午 辛申 辛戌 壬丑 壬卯 壬巳 壬未 壬酉 壬亥 癸子 癸寅 癸辰 癸午 癸申 癸戌\n2. 其中的規律是：使用 1～10 給天干編號，1～12給地支編號，分別從天干和地支的編號中任取一個，如果其和爲偶數則是合法的組合，否則就是非法的組合。例如「甲丑」中「甲」的編號是 1，「丑」的編號是 2，1+2=3 爲奇數，是非法的組合。\n\n試著使用編程來解決此問題。\n\n首先，將天干和地址的字符串定義如下：\n\n```go\nconst gs = \"甲乙丙丁戊己庚辛壬癸\"\nconst zs = \"子丑寅卯辰巳午未申酉戌亥\"\n```\n\n第一種思路是：先求出所有合法的組合，然後窮盡所有組合，如組合不在合法組合中即是非法組合，輸出即可，編程到函數 f1 如下：\n\n```go\nfunc f1() {\n\t// 天干數組\n\tgarr := []rune(gs)\n\t// 地支數組\n\tzarr := []rune(zs)\n\t// 保存合法的干支組合的Map\n\t// Key爲干支，Value爲天干索引與地支索引之和\n\ttdmap := make(map[string]int)\n\n\t// 將干支組合保存到Map中，直到出現第一個重複項就停止遍歷\n\tfor i, j := 0, 0; i < len(garr) && j < len(zarr); i, j = (i+1)%len(garr), (j+1)%len(zarr) {\n\t\tk := string(garr[i]) + string(zarr[j])\n\t\tif _, ok := tdmap[k]; ok {\n\t\t\tbreak\n\t\t}\n\t\ttdmap[k] = i + j\n\t}\n\n\t// 輸出所有合法的組合\n\tprintln(\"\\n所有合法的組合：\")\n\n\tfor k, v := range tdmap {\n\t\tfmt.Printf(\"%s:%d \", k, v)\n\t}\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tfor j := 0; j < len(zarr); j++ {\n\t\t\tk := string(garr[i]) + string(zarr[j])\n\t\t\tif _, ok := tdmap[k]; !ok {\n\t\t\t\tfmt.Printf(\"%s:%d \", k, i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果爲：\n\n```go\n所有合法的組合：\n庚午:12 己卯:8 甲申:8 己酉:14 丙寅:4 丁卯:6 己巳:10 癸酉:18 戊寅:6 戊戌:14 癸巳:14 癸卯:12 甲辰:4 乙卯:4 辛巳:12 丙戌:12 壬辰:12 乙未:8 辛亥:18 戊午:10 丁巳:8 己未:12 辛 壬申:16 甲午:6 庚子:6 辛丑:8 庚戌:16 丙辰:6 戊辰:8 癸未:16 甲子:0 丙申:10 丁未:10 壬子:8 庚辰:10 甲戌:10 丁丑:4 壬午:14 丙子:2 庚寅:8 壬寅:10 戊申:12 甲寅:2 乙丑:2 辛未:14 丁亥:14 戊子:4 己亥:16 丙午:8 庚申:14 癸亥:20 丁酉:12 \n所有非法的組合：\n甲丑:1 甲卯:3 甲巳:5 甲未:7 甲酉:9 甲亥:11 乙子:1 乙寅:3 乙辰:5 乙午:7 乙申:9 乙戌:11 丙丑:3 丙卯:5 丙巳:7 丙未:9 丙酉:11 丙亥:13 丁子:3 丁寅:5 丁辰:7 丁午:9 丁申:11 丁 己辰:9 己午:11 己申:13 己戌:15 庚丑:7 庚卯:9 庚巳:11 庚未:13 庚酉:15 庚亥:17 辛子:7 辛寅:9 辛辰:11 辛午:13 辛申:15 辛戌:17 壬丑:9 壬卯:11 壬巳:13 壬未:15 壬酉:17 壬亥:19 癸子:9 癸寅:11 癸辰:13 癸午:15 癸申:17 癸戌:19 \n```\n\n嗯，符合預期，合法的組合和非法的組合各佔 60 個。\n\n觀察發現，所有合法的組合的Value值都是偶數，所有非法的組合的Value值都是奇數。\n\n因此有第二種思路求出非法組合：\n\n```go\nfunc f2() {\n\tgarr := []rune(gs)\n\tzarr := []rune(zs)\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tfor j := 0; j < len(zarr); j++ {\n\t\t\tif (i+j)%2 != 0 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果：\n\n```go\n所有非法的組合：\n甲丑:1 甲卯:3 甲巳:5 甲未:7 甲酉:9 甲亥:11 乙子:1 乙寅:3 乙辰:5 乙午:7 乙申:9 乙戌:11 丙丑:3 丙卯:5 丙巳:7 丙未:9 丙酉:11 丙亥:13 丁子:3 丁寅:5 丁辰:7 丁午:9 丁申:11 丁 己辰:9 己午:11 己申:13 己戌:15 庚丑:7 庚卯:9 庚巳:11 庚未:13 庚酉:15 庚亥:17 辛子:7 辛寅:9 辛辰:11 辛午:13 辛申:15 辛戌:17 壬丑:9 壬卯:11 壬巳:13 壬未:15 壬酉:17 壬亥:19 癸子:9 癸寅:11 癸辰:13 癸午:15 癸申:17 癸戌:19\n```\n\n很棒，跟思路一的非法組合一致。\n\n學過小學數學的都知道，奇數+偶數=奇數，奇數+奇數=偶數，偶數+偶數=偶數。於是有了第三種思路，只要保證 i 和 j 的奇偶性不同即可保證 i 和 j 的組合爲非法組合。代碼如下：\n\n```go\nfunc f3() {\n\tgarr := []rune(gs)\n\tzarr := []rune(zs)\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tif i%2 == 0 {\n\t\t\tfor j := 1; j < len(zarr); j = j + 2 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t} else {\n\t\t\tfor j := 0; j < len(zarr); j = j + 2 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果同思路二的一致。\n\n完結","source":"_posts/it/go/zodiac-ganzhi-go.md","raw":"---\ntitle: 十二生肖、干支紀年法與Go語言編程\np: it/go/zodiac-ganzhi-go.md\ndate: 2020-11-31 23:57:00\ntags:\n- 甲子話\n- 十二生肖\n- 干支紀年法\n- Go\n---\n\n如無特殊說明，本文標音採用甲子話拼音方案。甲子話系陸豐市甲子鎮通行的語言，屬閩南語潮汕話三甲片。\n\n## 十二生肖\n\n十二生肖本地讀音爲：\n\n- 鼠牛虎兔 /cu² ngu⁵ hao² tao³/\n- 龍蛇馬羊 /lêng⁵ zua⁵ bhê² ion⁵/\n- 猴雞狗豬 /gao⁵ goi¹ gao² du¹/\n\n## 干支紀年法\n\n「干」是天干，有 10：\n\n- 甲乙丙丁 /gah⁴ ig⁴ bian² dêng¹/\n- 戊己庚辛 /bhao⁷ gi² gên¹ sing¹/\n- 壬癸 /rim⁶ gui³/\n\n「支」是地支，有 12：\n\n- 子丑寅卯 /zu² tiu² ing⁵ bhao²/\n- 辰巳午未 /sing⁵ zi⁶ ngao² bhi⁷/\n- 申酉戌亥 /sing¹ iu² sug⁴ hai⁶/\n\n天干從甲開始，地支從子開始，天干地支相配形成 60 種組合，用來紀年。從甲子出發，60 年後又回到甲子，因此稱 60 年爲「一甲子」。\n\n十二地支與十二生肖相對應，因此也用生肖紀年。如甲子年，地支爲「子」，對應生肖「鼠」，因此甲子年也稱之為「鼠年」。\n\n## 問題\n\n**問題1：已知 2020 年是鼠年，請問 2021 年是什麼年？**\n\n排在鼠之後的生肖是牛，因此 2021 年是牛年。\n\n**問題2：已知 2020 年是庚子年 /gên¹ zu² ni⁵/，請問 2021 年是什麼年？**\n\n庚之後爲辛，子之後爲丑，因此 2021 年是辛丑年 /sing¹ tiu² ni⁵/。\n\n**問題3：已知 1024 年是甲子年，問最近過去的甲子年和將要到來的甲子年是公元多少年？**\n\n<!-- more -->\n\n使用 Go 語言解決，編碼如下：\n\n```go\nfunc f1() {\n\tjz := 1024\n\tfor {\n\t\tjz = jz + 60\n\t\tif jz > 2020 {\n\t\t\tprintln(jz-60, jz)\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n執行後輸出結果爲：\n\n```go\n1984 2044\n```\n\n因此，最近過去的甲子年是 1984 年，將要到來的甲子年是 2044 年。\n\n**問題4：已知干支紀年法中有 10 天干，12 地支，有 60 種合法組合，求所有非法的組合，並探討其中規律。**\n\n先說結論：\n\n1. 所有非法的組合爲：\n甲丑 甲卯 甲巳 甲未 甲酉 甲亥 乙子 乙寅 乙辰 乙午 乙申 乙戌 丙丑 丙卯 丙巳 丙未 丙酉 丙亥 丁子 丁寅 丁辰 丁午 丁申 丁戌 戊丑 戊卯 戊巳 戊未 戊酉 戊亥 己子 己寅 己辰 己午 辛寅 辛辰 辛午 辛申 辛戌 壬丑 壬卯 壬巳 壬未 壬酉 壬亥 癸子 癸寅 癸辰 癸午 癸申 癸戌\n2. 其中的規律是：使用 1～10 給天干編號，1～12給地支編號，分別從天干和地支的編號中任取一個，如果其和爲偶數則是合法的組合，否則就是非法的組合。例如「甲丑」中「甲」的編號是 1，「丑」的編號是 2，1+2=3 爲奇數，是非法的組合。\n\n試著使用編程來解決此問題。\n\n首先，將天干和地址的字符串定義如下：\n\n```go\nconst gs = \"甲乙丙丁戊己庚辛壬癸\"\nconst zs = \"子丑寅卯辰巳午未申酉戌亥\"\n```\n\n第一種思路是：先求出所有合法的組合，然後窮盡所有組合，如組合不在合法組合中即是非法組合，輸出即可，編程到函數 f1 如下：\n\n```go\nfunc f1() {\n\t// 天干數組\n\tgarr := []rune(gs)\n\t// 地支數組\n\tzarr := []rune(zs)\n\t// 保存合法的干支組合的Map\n\t// Key爲干支，Value爲天干索引與地支索引之和\n\ttdmap := make(map[string]int)\n\n\t// 將干支組合保存到Map中，直到出現第一個重複項就停止遍歷\n\tfor i, j := 0, 0; i < len(garr) && j < len(zarr); i, j = (i+1)%len(garr), (j+1)%len(zarr) {\n\t\tk := string(garr[i]) + string(zarr[j])\n\t\tif _, ok := tdmap[k]; ok {\n\t\t\tbreak\n\t\t}\n\t\ttdmap[k] = i + j\n\t}\n\n\t// 輸出所有合法的組合\n\tprintln(\"\\n所有合法的組合：\")\n\n\tfor k, v := range tdmap {\n\t\tfmt.Printf(\"%s:%d \", k, v)\n\t}\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tfor j := 0; j < len(zarr); j++ {\n\t\t\tk := string(garr[i]) + string(zarr[j])\n\t\t\tif _, ok := tdmap[k]; !ok {\n\t\t\t\tfmt.Printf(\"%s:%d \", k, i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果爲：\n\n```go\n所有合法的組合：\n庚午:12 己卯:8 甲申:8 己酉:14 丙寅:4 丁卯:6 己巳:10 癸酉:18 戊寅:6 戊戌:14 癸巳:14 癸卯:12 甲辰:4 乙卯:4 辛巳:12 丙戌:12 壬辰:12 乙未:8 辛亥:18 戊午:10 丁巳:8 己未:12 辛 壬申:16 甲午:6 庚子:6 辛丑:8 庚戌:16 丙辰:6 戊辰:8 癸未:16 甲子:0 丙申:10 丁未:10 壬子:8 庚辰:10 甲戌:10 丁丑:4 壬午:14 丙子:2 庚寅:8 壬寅:10 戊申:12 甲寅:2 乙丑:2 辛未:14 丁亥:14 戊子:4 己亥:16 丙午:8 庚申:14 癸亥:20 丁酉:12 \n所有非法的組合：\n甲丑:1 甲卯:3 甲巳:5 甲未:7 甲酉:9 甲亥:11 乙子:1 乙寅:3 乙辰:5 乙午:7 乙申:9 乙戌:11 丙丑:3 丙卯:5 丙巳:7 丙未:9 丙酉:11 丙亥:13 丁子:3 丁寅:5 丁辰:7 丁午:9 丁申:11 丁 己辰:9 己午:11 己申:13 己戌:15 庚丑:7 庚卯:9 庚巳:11 庚未:13 庚酉:15 庚亥:17 辛子:7 辛寅:9 辛辰:11 辛午:13 辛申:15 辛戌:17 壬丑:9 壬卯:11 壬巳:13 壬未:15 壬酉:17 壬亥:19 癸子:9 癸寅:11 癸辰:13 癸午:15 癸申:17 癸戌:19 \n```\n\n嗯，符合預期，合法的組合和非法的組合各佔 60 個。\n\n觀察發現，所有合法的組合的Value值都是偶數，所有非法的組合的Value值都是奇數。\n\n因此有第二種思路求出非法組合：\n\n```go\nfunc f2() {\n\tgarr := []rune(gs)\n\tzarr := []rune(zs)\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tfor j := 0; j < len(zarr); j++ {\n\t\t\tif (i+j)%2 != 0 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果：\n\n```go\n所有非法的組合：\n甲丑:1 甲卯:3 甲巳:5 甲未:7 甲酉:9 甲亥:11 乙子:1 乙寅:3 乙辰:5 乙午:7 乙申:9 乙戌:11 丙丑:3 丙卯:5 丙巳:7 丙未:9 丙酉:11 丙亥:13 丁子:3 丁寅:5 丁辰:7 丁午:9 丁申:11 丁 己辰:9 己午:11 己申:13 己戌:15 庚丑:7 庚卯:9 庚巳:11 庚未:13 庚酉:15 庚亥:17 辛子:7 辛寅:9 辛辰:11 辛午:13 辛申:15 辛戌:17 壬丑:9 壬卯:11 壬巳:13 壬未:15 壬酉:17 壬亥:19 癸子:9 癸寅:11 癸辰:13 癸午:15 癸申:17 癸戌:19\n```\n\n很棒，跟思路一的非法組合一致。\n\n學過小學數學的都知道，奇數+偶數=奇數，奇數+奇數=偶數，偶數+偶數=偶數。於是有了第三種思路，只要保證 i 和 j 的奇偶性不同即可保證 i 和 j 的組合爲非法組合。代碼如下：\n\n```go\nfunc f3() {\n\tgarr := []rune(gs)\n\tzarr := []rune(zs)\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tif i%2 == 0 {\n\t\t\tfor j := 1; j < len(zarr); j = j + 2 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t} else {\n\t\t\tfor j := 0; j < len(zarr); j = j + 2 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果同思路二的一致。\n\n完結","slug":"it/go/zodiac-ganzhi-go","published":1,"updated":"2021-09-13T14:12:31.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlf1000w1n9ke52lf5gs","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>如無特殊說明，本文標音採用甲子話拼音方案。甲子話系陸豐市甲子鎮通行的語言，屬閩南語潮汕話三甲片。</p>\n<h2 id=\"十二生肖\"><a href=\"#十二生肖\" class=\"headerlink\" title=\"十二生肖\"></a>十二生肖</h2><p>十二生肖本地讀音爲：</p>\n<ul>\n<li>鼠牛虎兔 /cu² ngu⁵ hao² tao³/</li>\n<li>龍蛇馬羊 /lêng⁵ zua⁵ bhê² ion⁵/</li>\n<li>猴雞狗豬 /gao⁵ goi¹ gao² du¹/</li>\n</ul>\n<h2 id=\"干支紀年法\"><a href=\"#干支紀年法\" class=\"headerlink\" title=\"干支紀年法\"></a>干支紀年法</h2><p>「干」是天干，有 10：</p>\n<ul>\n<li>甲乙丙丁 /gah⁴ ig⁴ bian² dêng¹/</li>\n<li>戊己庚辛 /bhao⁷ gi² gên¹ sing¹/</li>\n<li>壬癸 /rim⁶ gui³/</li>\n</ul>\n<p>「支」是地支，有 12：</p>\n<ul>\n<li>子丑寅卯 /zu² tiu² ing⁵ bhao²/</li>\n<li>辰巳午未 /sing⁵ zi⁶ ngao² bhi⁷/</li>\n<li>申酉戌亥 /sing¹ iu² sug⁴ hai⁶/</li>\n</ul>\n<p>天干從甲開始，地支從子開始，天干地支相配形成 60 種組合，用來紀年。從甲子出發，60 年後又回到甲子，因此稱 60 年爲「一甲子」。</p>\n<p>十二地支與十二生肖相對應，因此也用生肖紀年。如甲子年，地支爲「子」，對應生肖「鼠」，因此甲子年也稱之為「鼠年」。</p>\n<h2 id=\"問題\"><a href=\"#問題\" class=\"headerlink\" title=\"問題\"></a>問題</h2><p><strong>問題1：已知 2020 年是鼠年，請問 2021 年是什麼年？</strong></p>\n<p>排在鼠之後的生肖是牛，因此 2021 年是牛年。</p>\n<p><strong>問題2：已知 2020 年是庚子年 /gên¹ zu² ni⁵/，請問 2021 年是什麼年？</strong></p>\n<p>庚之後爲辛，子之後爲丑，因此 2021 年是辛丑年 /sing¹ tiu² ni⁵/。</p>\n<p><strong>問題3：已知 1024 年是甲子年，問最近過去的甲子年和將要到來的甲子年是公元多少年？</strong></p>\n<span id=\"more\"></span>\n\n<p>使用 Go 語言解決，編碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  jz := <span class=\"number\">1024</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    jz = jz + <span class=\"number\">60</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> jz &gt; <span class=\"number\">2020</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">println</span>(jz<span class=\"number\">-60</span>, jz)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行後輸出結果爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1984</span> <span class=\"number\">2044</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，最近過去的甲子年是 1984 年，將要到來的甲子年是 2044 年。</p>\n<p><strong>問題4：已知干支紀年法中有 10 天干，12 地支，有 60 種合法組合，求所有非法的組合，並探討其中規律。</strong></p>\n<p>先說結論：</p>\n<ol>\n<li>所有非法的組合爲：<br>甲丑 甲卯 甲巳 甲未 甲酉 甲亥 乙子 乙寅 乙辰 乙午 乙申 乙戌 丙丑 丙卯 丙巳 丙未 丙酉 丙亥 丁子 丁寅 丁辰 丁午 丁申 丁戌 戊丑 戊卯 戊巳 戊未 戊酉 戊亥 己子 己寅 己辰 己午 辛寅 辛辰 辛午 辛申 辛戌 壬丑 壬卯 壬巳 壬未 壬酉 壬亥 癸子 癸寅 癸辰 癸午 癸申 癸戌</li>\n<li>其中的規律是：使用 1～10 給天干編號，1～12給地支編號，分別從天干和地支的編號中任取一個，如果其和爲偶數則是合法的組合，否則就是非法的組合。例如「甲丑」中「甲」的編號是 1，「丑」的編號是 2，1+2=3 爲奇數，是非法的組合。</li>\n</ol>\n<p>試著使用編程來解決此問題。</p>\n<p>首先，將天干和地址的字符串定義如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gs = <span class=\"string\">&quot;甲乙丙丁戊己庚辛壬癸&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> zs = <span class=\"string\">&quot;子丑寅卯辰巳午未申酉戌亥&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>第一種思路是：先求出所有合法的組合，然後窮盡所有組合，如組合不在合法組合中即是非法組合，輸出即可，編程到函數 f1 如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 天干數組</span></span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  <span class=\"comment\">// 地支數組</span></span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\">  <span class=\"comment\">// 保存合法的干支組合的Map</span></span><br><span class=\"line\">  <span class=\"comment\">// Key爲干支，Value爲天干索引與地支索引之和</span></span><br><span class=\"line\">  tdmap := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 將干支組合保存到Map中，直到出現第一個重複項就停止遍歷</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i, j := <span class=\"number\">0</span>, <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr) &amp;&amp; j &lt; <span class=\"built_in\">len</span>(zarr); i, j = (i+<span class=\"number\">1</span>)%<span class=\"built_in\">len</span>(garr), (j+<span class=\"number\">1</span>)%<span class=\"built_in\">len</span>(zarr) &#123;</span><br><span class=\"line\">    k := <span class=\"keyword\">string</span>(garr[i]) + <span class=\"keyword\">string</span>(zarr[j])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, ok := tdmap[k]; ok &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tdmap[k] = i + j</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有合法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有合法的組合：&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> tdmap &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, k, v)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j++ &#123;</span><br><span class=\"line\">      k := <span class=\"keyword\">string</span>(garr[i]) + <span class=\"keyword\">string</span>(zarr[j])</span><br><span class=\"line\">      <span class=\"keyword\">if</span> _, ok := tdmap[k]; !ok &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, k, i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">所有合法的組合：</span><br><span class=\"line\">庚午:<span class=\"number\">12</span> 己卯:<span class=\"number\">8</span> 甲申:<span class=\"number\">8</span> 己酉:<span class=\"number\">14</span> 丙寅:<span class=\"number\">4</span> 丁卯:<span class=\"number\">6</span> 己巳:<span class=\"number\">10</span> 癸酉:<span class=\"number\">18</span> 戊寅:<span class=\"number\">6</span> 戊戌:<span class=\"number\">14</span> 癸巳:<span class=\"number\">14</span> 癸卯:<span class=\"number\">12</span> 甲辰:<span class=\"number\">4</span> 乙卯:<span class=\"number\">4</span> 辛巳:<span class=\"number\">12</span> 丙戌:<span class=\"number\">12</span> 壬辰:<span class=\"number\">12</span> 乙未:<span class=\"number\">8</span> 辛亥:<span class=\"number\">18</span> 戊午:<span class=\"number\">10</span> 丁巳:<span class=\"number\">8</span> 己未:<span class=\"number\">12</span> 辛 壬申:<span class=\"number\">16</span> 甲午:<span class=\"number\">6</span> 庚子:<span class=\"number\">6</span> 辛丑:<span class=\"number\">8</span> 庚戌:<span class=\"number\">16</span> 丙辰:<span class=\"number\">6</span> 戊辰:<span class=\"number\">8</span> 癸未:<span class=\"number\">16</span> 甲子:<span class=\"number\">0</span> 丙申:<span class=\"number\">10</span> 丁未:<span class=\"number\">10</span> 壬子:<span class=\"number\">8</span> 庚辰:<span class=\"number\">10</span> 甲戌:<span class=\"number\">10</span> 丁丑:<span class=\"number\">4</span> 壬午:<span class=\"number\">14</span> 丙子:<span class=\"number\">2</span> 庚寅:<span class=\"number\">8</span> 壬寅:<span class=\"number\">10</span> 戊申:<span class=\"number\">12</span> 甲寅:<span class=\"number\">2</span> 乙丑:<span class=\"number\">2</span> 辛未:<span class=\"number\">14</span> 丁亥:<span class=\"number\">14</span> 戊子:<span class=\"number\">4</span> 己亥:<span class=\"number\">16</span> 丙午:<span class=\"number\">8</span> 庚申:<span class=\"number\">14</span> 癸亥:<span class=\"number\">20</span> 丁酉:<span class=\"number\">12</span> </span><br><span class=\"line\">所有非法的組合：</span><br><span class=\"line\">甲丑:<span class=\"number\">1</span> 甲卯:<span class=\"number\">3</span> 甲巳:<span class=\"number\">5</span> 甲未:<span class=\"number\">7</span> 甲酉:<span class=\"number\">9</span> 甲亥:<span class=\"number\">11</span> 乙子:<span class=\"number\">1</span> 乙寅:<span class=\"number\">3</span> 乙辰:<span class=\"number\">5</span> 乙午:<span class=\"number\">7</span> 乙申:<span class=\"number\">9</span> 乙戌:<span class=\"number\">11</span> 丙丑:<span class=\"number\">3</span> 丙卯:<span class=\"number\">5</span> 丙巳:<span class=\"number\">7</span> 丙未:<span class=\"number\">9</span> 丙酉:<span class=\"number\">11</span> 丙亥:<span class=\"number\">13</span> 丁子:<span class=\"number\">3</span> 丁寅:<span class=\"number\">5</span> 丁辰:<span class=\"number\">7</span> 丁午:<span class=\"number\">9</span> 丁申:<span class=\"number\">11</span> 丁 己辰:<span class=\"number\">9</span> 己午:<span class=\"number\">11</span> 己申:<span class=\"number\">13</span> 己戌:<span class=\"number\">15</span> 庚丑:<span class=\"number\">7</span> 庚卯:<span class=\"number\">9</span> 庚巳:<span class=\"number\">11</span> 庚未:<span class=\"number\">13</span> 庚酉:<span class=\"number\">15</span> 庚亥:<span class=\"number\">17</span> 辛子:<span class=\"number\">7</span> 辛寅:<span class=\"number\">9</span> 辛辰:<span class=\"number\">11</span> 辛午:<span class=\"number\">13</span> 辛申:<span class=\"number\">15</span> 辛戌:<span class=\"number\">17</span> 壬丑:<span class=\"number\">9</span> 壬卯:<span class=\"number\">11</span> 壬巳:<span class=\"number\">13</span> 壬未:<span class=\"number\">15</span> 壬酉:<span class=\"number\">17</span> 壬亥:<span class=\"number\">19</span> 癸子:<span class=\"number\">9</span> 癸寅:<span class=\"number\">11</span> 癸辰:<span class=\"number\">13</span> 癸午:<span class=\"number\">15</span> 癸申:<span class=\"number\">17</span> 癸戌:<span class=\"number\">19</span> </span><br></pre></td></tr></table></figure>\n\n<p>嗯，符合預期，合法的組合和非法的組合各佔 60 個。</p>\n<p>觀察發現，所有合法的組合的Value值都是偶數，所有非法的組合的Value值都是奇數。</p>\n<p>因此有第二種思路求出非法組合：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j++ &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i+j)%<span class=\"number\">2</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">所有非法的組合：</span><br><span class=\"line\">甲丑:<span class=\"number\">1</span> 甲卯:<span class=\"number\">3</span> 甲巳:<span class=\"number\">5</span> 甲未:<span class=\"number\">7</span> 甲酉:<span class=\"number\">9</span> 甲亥:<span class=\"number\">11</span> 乙子:<span class=\"number\">1</span> 乙寅:<span class=\"number\">3</span> 乙辰:<span class=\"number\">5</span> 乙午:<span class=\"number\">7</span> 乙申:<span class=\"number\">9</span> 乙戌:<span class=\"number\">11</span> 丙丑:<span class=\"number\">3</span> 丙卯:<span class=\"number\">5</span> 丙巳:<span class=\"number\">7</span> 丙未:<span class=\"number\">9</span> 丙酉:<span class=\"number\">11</span> 丙亥:<span class=\"number\">13</span> 丁子:<span class=\"number\">3</span> 丁寅:<span class=\"number\">5</span> 丁辰:<span class=\"number\">7</span> 丁午:<span class=\"number\">9</span> 丁申:<span class=\"number\">11</span> 丁 己辰:<span class=\"number\">9</span> 己午:<span class=\"number\">11</span> 己申:<span class=\"number\">13</span> 己戌:<span class=\"number\">15</span> 庚丑:<span class=\"number\">7</span> 庚卯:<span class=\"number\">9</span> 庚巳:<span class=\"number\">11</span> 庚未:<span class=\"number\">13</span> 庚酉:<span class=\"number\">15</span> 庚亥:<span class=\"number\">17</span> 辛子:<span class=\"number\">7</span> 辛寅:<span class=\"number\">9</span> 辛辰:<span class=\"number\">11</span> 辛午:<span class=\"number\">13</span> 辛申:<span class=\"number\">15</span> 辛戌:<span class=\"number\">17</span> 壬丑:<span class=\"number\">9</span> 壬卯:<span class=\"number\">11</span> 壬巳:<span class=\"number\">13</span> 壬未:<span class=\"number\">15</span> 壬酉:<span class=\"number\">17</span> 壬亥:<span class=\"number\">19</span> 癸子:<span class=\"number\">9</span> 癸寅:<span class=\"number\">11</span> 癸辰:<span class=\"number\">13</span> 癸午:<span class=\"number\">15</span> 癸申:<span class=\"number\">17</span> 癸戌:<span class=\"number\">19</span></span><br></pre></td></tr></table></figure>\n\n<p>很棒，跟思路一的非法組合一致。</p>\n<p>學過小學數學的都知道，奇數+偶數=奇數，奇數+奇數=偶數，偶數+偶數=偶數。於是有了第三種思路，只要保證 i 和 j 的奇偶性不同即可保證 i 和 j 的組合爲非法組合。代碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> j := <span class=\"number\">1</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j = j + <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j = j + <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果同思路二的一致。</p>\n<p>完結</p>\n","site":{"data":{}},"excerpt":"<p>如無特殊說明，本文標音採用甲子話拼音方案。甲子話系陸豐市甲子鎮通行的語言，屬閩南語潮汕話三甲片。</p>\n<h2 id=\"十二生肖\"><a href=\"#十二生肖\" class=\"headerlink\" title=\"十二生肖\"></a>十二生肖</h2><p>十二生肖本地讀音爲：</p>\n<ul>\n<li>鼠牛虎兔 /cu² ngu⁵ hao² tao³/</li>\n<li>龍蛇馬羊 /lêng⁵ zua⁵ bhê² ion⁵/</li>\n<li>猴雞狗豬 /gao⁵ goi¹ gao² du¹/</li>\n</ul>\n<h2 id=\"干支紀年法\"><a href=\"#干支紀年法\" class=\"headerlink\" title=\"干支紀年法\"></a>干支紀年法</h2><p>「干」是天干，有 10：</p>\n<ul>\n<li>甲乙丙丁 /gah⁴ ig⁴ bian² dêng¹/</li>\n<li>戊己庚辛 /bhao⁷ gi² gên¹ sing¹/</li>\n<li>壬癸 /rim⁶ gui³/</li>\n</ul>\n<p>「支」是地支，有 12：</p>\n<ul>\n<li>子丑寅卯 /zu² tiu² ing⁵ bhao²/</li>\n<li>辰巳午未 /sing⁵ zi⁶ ngao² bhi⁷/</li>\n<li>申酉戌亥 /sing¹ iu² sug⁴ hai⁶/</li>\n</ul>\n<p>天干從甲開始，地支從子開始，天干地支相配形成 60 種組合，用來紀年。從甲子出發，60 年後又回到甲子，因此稱 60 年爲「一甲子」。</p>\n<p>十二地支與十二生肖相對應，因此也用生肖紀年。如甲子年，地支爲「子」，對應生肖「鼠」，因此甲子年也稱之為「鼠年」。</p>\n<h2 id=\"問題\"><a href=\"#問題\" class=\"headerlink\" title=\"問題\"></a>問題</h2><p><strong>問題1：已知 2020 年是鼠年，請問 2021 年是什麼年？</strong></p>\n<p>排在鼠之後的生肖是牛，因此 2021 年是牛年。</p>\n<p><strong>問題2：已知 2020 年是庚子年 /gên¹ zu² ni⁵/，請問 2021 年是什麼年？</strong></p>\n<p>庚之後爲辛，子之後爲丑，因此 2021 年是辛丑年 /sing¹ tiu² ni⁵/。</p>\n<p><strong>問題3：已知 1024 年是甲子年，問最近過去的甲子年和將要到來的甲子年是公元多少年？</strong></p>","more":"<p>使用 Go 語言解決，編碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  jz := <span class=\"number\">1024</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    jz = jz + <span class=\"number\">60</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> jz &gt; <span class=\"number\">2020</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">println</span>(jz<span class=\"number\">-60</span>, jz)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行後輸出結果爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1984</span> <span class=\"number\">2044</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，最近過去的甲子年是 1984 年，將要到來的甲子年是 2044 年。</p>\n<p><strong>問題4：已知干支紀年法中有 10 天干，12 地支，有 60 種合法組合，求所有非法的組合，並探討其中規律。</strong></p>\n<p>先說結論：</p>\n<ol>\n<li>所有非法的組合爲：<br>甲丑 甲卯 甲巳 甲未 甲酉 甲亥 乙子 乙寅 乙辰 乙午 乙申 乙戌 丙丑 丙卯 丙巳 丙未 丙酉 丙亥 丁子 丁寅 丁辰 丁午 丁申 丁戌 戊丑 戊卯 戊巳 戊未 戊酉 戊亥 己子 己寅 己辰 己午 辛寅 辛辰 辛午 辛申 辛戌 壬丑 壬卯 壬巳 壬未 壬酉 壬亥 癸子 癸寅 癸辰 癸午 癸申 癸戌</li>\n<li>其中的規律是：使用 1～10 給天干編號，1～12給地支編號，分別從天干和地支的編號中任取一個，如果其和爲偶數則是合法的組合，否則就是非法的組合。例如「甲丑」中「甲」的編號是 1，「丑」的編號是 2，1+2=3 爲奇數，是非法的組合。</li>\n</ol>\n<p>試著使用編程來解決此問題。</p>\n<p>首先，將天干和地址的字符串定義如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gs = <span class=\"string\">&quot;甲乙丙丁戊己庚辛壬癸&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> zs = <span class=\"string\">&quot;子丑寅卯辰巳午未申酉戌亥&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>第一種思路是：先求出所有合法的組合，然後窮盡所有組合，如組合不在合法組合中即是非法組合，輸出即可，編程到函數 f1 如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 天干數組</span></span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  <span class=\"comment\">// 地支數組</span></span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\">  <span class=\"comment\">// 保存合法的干支組合的Map</span></span><br><span class=\"line\">  <span class=\"comment\">// Key爲干支，Value爲天干索引與地支索引之和</span></span><br><span class=\"line\">  tdmap := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 將干支組合保存到Map中，直到出現第一個重複項就停止遍歷</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i, j := <span class=\"number\">0</span>, <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr) &amp;&amp; j &lt; <span class=\"built_in\">len</span>(zarr); i, j = (i+<span class=\"number\">1</span>)%<span class=\"built_in\">len</span>(garr), (j+<span class=\"number\">1</span>)%<span class=\"built_in\">len</span>(zarr) &#123;</span><br><span class=\"line\">    k := <span class=\"keyword\">string</span>(garr[i]) + <span class=\"keyword\">string</span>(zarr[j])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, ok := tdmap[k]; ok &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tdmap[k] = i + j</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有合法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有合法的組合：&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> tdmap &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, k, v)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j++ &#123;</span><br><span class=\"line\">      k := <span class=\"keyword\">string</span>(garr[i]) + <span class=\"keyword\">string</span>(zarr[j])</span><br><span class=\"line\">      <span class=\"keyword\">if</span> _, ok := tdmap[k]; !ok &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, k, i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">所有合法的組合：</span><br><span class=\"line\">庚午:<span class=\"number\">12</span> 己卯:<span class=\"number\">8</span> 甲申:<span class=\"number\">8</span> 己酉:<span class=\"number\">14</span> 丙寅:<span class=\"number\">4</span> 丁卯:<span class=\"number\">6</span> 己巳:<span class=\"number\">10</span> 癸酉:<span class=\"number\">18</span> 戊寅:<span class=\"number\">6</span> 戊戌:<span class=\"number\">14</span> 癸巳:<span class=\"number\">14</span> 癸卯:<span class=\"number\">12</span> 甲辰:<span class=\"number\">4</span> 乙卯:<span class=\"number\">4</span> 辛巳:<span class=\"number\">12</span> 丙戌:<span class=\"number\">12</span> 壬辰:<span class=\"number\">12</span> 乙未:<span class=\"number\">8</span> 辛亥:<span class=\"number\">18</span> 戊午:<span class=\"number\">10</span> 丁巳:<span class=\"number\">8</span> 己未:<span class=\"number\">12</span> 辛 壬申:<span class=\"number\">16</span> 甲午:<span class=\"number\">6</span> 庚子:<span class=\"number\">6</span> 辛丑:<span class=\"number\">8</span> 庚戌:<span class=\"number\">16</span> 丙辰:<span class=\"number\">6</span> 戊辰:<span class=\"number\">8</span> 癸未:<span class=\"number\">16</span> 甲子:<span class=\"number\">0</span> 丙申:<span class=\"number\">10</span> 丁未:<span class=\"number\">10</span> 壬子:<span class=\"number\">8</span> 庚辰:<span class=\"number\">10</span> 甲戌:<span class=\"number\">10</span> 丁丑:<span class=\"number\">4</span> 壬午:<span class=\"number\">14</span> 丙子:<span class=\"number\">2</span> 庚寅:<span class=\"number\">8</span> 壬寅:<span class=\"number\">10</span> 戊申:<span class=\"number\">12</span> 甲寅:<span class=\"number\">2</span> 乙丑:<span class=\"number\">2</span> 辛未:<span class=\"number\">14</span> 丁亥:<span class=\"number\">14</span> 戊子:<span class=\"number\">4</span> 己亥:<span class=\"number\">16</span> 丙午:<span class=\"number\">8</span> 庚申:<span class=\"number\">14</span> 癸亥:<span class=\"number\">20</span> 丁酉:<span class=\"number\">12</span> </span><br><span class=\"line\">所有非法的組合：</span><br><span class=\"line\">甲丑:<span class=\"number\">1</span> 甲卯:<span class=\"number\">3</span> 甲巳:<span class=\"number\">5</span> 甲未:<span class=\"number\">7</span> 甲酉:<span class=\"number\">9</span> 甲亥:<span class=\"number\">11</span> 乙子:<span class=\"number\">1</span> 乙寅:<span class=\"number\">3</span> 乙辰:<span class=\"number\">5</span> 乙午:<span class=\"number\">7</span> 乙申:<span class=\"number\">9</span> 乙戌:<span class=\"number\">11</span> 丙丑:<span class=\"number\">3</span> 丙卯:<span class=\"number\">5</span> 丙巳:<span class=\"number\">7</span> 丙未:<span class=\"number\">9</span> 丙酉:<span class=\"number\">11</span> 丙亥:<span class=\"number\">13</span> 丁子:<span class=\"number\">3</span> 丁寅:<span class=\"number\">5</span> 丁辰:<span class=\"number\">7</span> 丁午:<span class=\"number\">9</span> 丁申:<span class=\"number\">11</span> 丁 己辰:<span class=\"number\">9</span> 己午:<span class=\"number\">11</span> 己申:<span class=\"number\">13</span> 己戌:<span class=\"number\">15</span> 庚丑:<span class=\"number\">7</span> 庚卯:<span class=\"number\">9</span> 庚巳:<span class=\"number\">11</span> 庚未:<span class=\"number\">13</span> 庚酉:<span class=\"number\">15</span> 庚亥:<span class=\"number\">17</span> 辛子:<span class=\"number\">7</span> 辛寅:<span class=\"number\">9</span> 辛辰:<span class=\"number\">11</span> 辛午:<span class=\"number\">13</span> 辛申:<span class=\"number\">15</span> 辛戌:<span class=\"number\">17</span> 壬丑:<span class=\"number\">9</span> 壬卯:<span class=\"number\">11</span> 壬巳:<span class=\"number\">13</span> 壬未:<span class=\"number\">15</span> 壬酉:<span class=\"number\">17</span> 壬亥:<span class=\"number\">19</span> 癸子:<span class=\"number\">9</span> 癸寅:<span class=\"number\">11</span> 癸辰:<span class=\"number\">13</span> 癸午:<span class=\"number\">15</span> 癸申:<span class=\"number\">17</span> 癸戌:<span class=\"number\">19</span> </span><br></pre></td></tr></table></figure>\n\n<p>嗯，符合預期，合法的組合和非法的組合各佔 60 個。</p>\n<p>觀察發現，所有合法的組合的Value值都是偶數，所有非法的組合的Value值都是奇數。</p>\n<p>因此有第二種思路求出非法組合：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j++ &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i+j)%<span class=\"number\">2</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">所有非法的組合：</span><br><span class=\"line\">甲丑:<span class=\"number\">1</span> 甲卯:<span class=\"number\">3</span> 甲巳:<span class=\"number\">5</span> 甲未:<span class=\"number\">7</span> 甲酉:<span class=\"number\">9</span> 甲亥:<span class=\"number\">11</span> 乙子:<span class=\"number\">1</span> 乙寅:<span class=\"number\">3</span> 乙辰:<span class=\"number\">5</span> 乙午:<span class=\"number\">7</span> 乙申:<span class=\"number\">9</span> 乙戌:<span class=\"number\">11</span> 丙丑:<span class=\"number\">3</span> 丙卯:<span class=\"number\">5</span> 丙巳:<span class=\"number\">7</span> 丙未:<span class=\"number\">9</span> 丙酉:<span class=\"number\">11</span> 丙亥:<span class=\"number\">13</span> 丁子:<span class=\"number\">3</span> 丁寅:<span class=\"number\">5</span> 丁辰:<span class=\"number\">7</span> 丁午:<span class=\"number\">9</span> 丁申:<span class=\"number\">11</span> 丁 己辰:<span class=\"number\">9</span> 己午:<span class=\"number\">11</span> 己申:<span class=\"number\">13</span> 己戌:<span class=\"number\">15</span> 庚丑:<span class=\"number\">7</span> 庚卯:<span class=\"number\">9</span> 庚巳:<span class=\"number\">11</span> 庚未:<span class=\"number\">13</span> 庚酉:<span class=\"number\">15</span> 庚亥:<span class=\"number\">17</span> 辛子:<span class=\"number\">7</span> 辛寅:<span class=\"number\">9</span> 辛辰:<span class=\"number\">11</span> 辛午:<span class=\"number\">13</span> 辛申:<span class=\"number\">15</span> 辛戌:<span class=\"number\">17</span> 壬丑:<span class=\"number\">9</span> 壬卯:<span class=\"number\">11</span> 壬巳:<span class=\"number\">13</span> 壬未:<span class=\"number\">15</span> 壬酉:<span class=\"number\">17</span> 壬亥:<span class=\"number\">19</span> 癸子:<span class=\"number\">9</span> 癸寅:<span class=\"number\">11</span> 癸辰:<span class=\"number\">13</span> 癸午:<span class=\"number\">15</span> 癸申:<span class=\"number\">17</span> 癸戌:<span class=\"number\">19</span></span><br></pre></td></tr></table></figure>\n\n<p>很棒，跟思路一的非法組合一致。</p>\n<p>學過小學數學的都知道，奇數+偶數=奇數，奇數+奇數=偶數，偶數+偶數=偶數。於是有了第三種思路，只要保證 i 和 j 的奇偶性不同即可保證 i 和 j 的組合爲非法組合。代碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> j := <span class=\"number\">1</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j = j + <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j = j + <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果同思路二的一致。</p>\n<p>完結</p>"},{"title":"携帯で日本語（手机上的日语）","p":"language/jp/keitai-de-nihongo.md","date":"2019-09-07T01:06:00.000Z","_content":"\n有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。\n\n<!--more-->\n\n## 一、アプリ（应用程序）\n\n手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。\n\n下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。\n\n### （一）システムアプリ（系统应用）\n\n| アプリ                   | Applications         | 应用程序      | 應用程式   |\n| ------------------------ | -------------------- | ------------- | ---------- |\n| アプリストア(apurisutoa) | App store            | 应用商店      | 應用商店   |\n| パスウードとアカウード   | Passwords & Accounts | 密码与账户    | 密碼與賬號 |\n| メール                   | Mail                 | 邮件          | 郵件       |\n| 連絡先（れんらくさき）   | Contacts             | 通讯录        | 聯絡資訊   |\n| カレンダー               | Calendar             | 日历          | 行事曆     |\n| メモ                     | Notes                | 备忘录        | 備忘錄     |\n| リマインダー             | Reminders            | 提醒事项      | 提醒事項   |\n| ボイスメモ               | Voice Memos          | 语言备忘录    | 語音備忘錄 |\n| 電話（でんわ）           | Phone                | 电话          | 電話       |\n| メッセージ               | Messages             | 信息          | 訊息       |\n| FaceTime                 | FaceTime             | FaceTime      | FaceTime   |\n| マップ                   | Maps                 | 地图          | 地圖       |\n| コンパス                 | Compass              | 指南针        | 指南針     |\n| 計測（けいそく）         | Measure              | 测距仪        | 測距儀     |\n| Safari                   | Safari               | Safari 浏览器 | Safari     |\n| 株価（かぶか）           | Stocks               | 股市          | 股市       |\n| ミュージック             | Music                | 音乐          | 音樂       |\n| ビデオ                   | Videos               | 视频          | 影片       |\n| 写真（しゃしん）         | Photos               | 照片          | 照片       |\n| カメラ                   | Camera               | 相机          | 相機       |\n| ブック                   | Books                | 图书          | 書籍       |\n\n备注：\n\n1. 股票：株式（かぶしき）\n2. 股市：株式市場（かぶしきしじょう）\n3. 股价：株価（かぶか）\n\n### （二）ユーザーアプリ（用户应用）\n\n| アプリ                          | Applications | 应用程序 | 應用程式 |\n| ------------------------------- | --------------- | -------- | -------- |\n| 微信 / ウェイシン \\| WeChat / ウィチャット | Wechat          | 微信     | 微信   |\n| QQ / キュキュ           | QQ              | QQ       | QQ     |\n| アリペイ                | Alipay          | 支付宝   | 支付寶 |\n| ビリビリ              | Bilibili        | 哔哩哔哩 | 嗶哩嗶哩 |\n| Google / グーグル       | Google          | 谷歌     | 谷歌   |\n| Kindle / キンドル | Kindle          | Kindle   | Kindle |\n| Chrome / クロム | Chrome | Chrome | Chrome |\n| YouTube / ユーチューブ | YouTube | YouTube | YouTube |\n| Gmail / ジメイル | Gmail | Gmail | Gmail |\n| Google フォト | Google Photo | Google相册 | Google相簿 |\n| 翻訳（ほにゃく） | Translate | 翻译 | 翻譯 |\n| Instagram / インスタグラム | Instagram | Instagram | Instagram |\n| WhatsApp / ワッツアップ | WhatsApp | WhatsApp | WhatsApp |\n| Wunderlist / ワンダーリスト | Wunderlist | 奇妙清单 | 奇妙清單 |\n| NetEase Music / ネットイース ミュージック | NetEase Music | 网易云音乐 | 網易云音樂 |\n| 好奇心日報（こうきしんにっぽう） | Qdaily | 好奇心日报 | 好奇心日報 |\n| Taobao / タオバオ | Taobao | 手机淘宝 | 手機淘寶 |\n| 京東 / ジンドン | JD | 京东 | 京東 |\n| 高德地図 / こうとくちず | Amap | 高德地图 | 高德地圖 |\n| 印象メモ | Evernote | 印象笔记 | 印象筆記 |\n| 招商銀行 / しょうしょうぎんこう | CMB | 招商银行 | 招商銀行 |\n| WeChat 読書（どくしょ 1）? | WeRead | 微信读书 | 微信讀書 |\n| Youku（ヨウク） | Youku | 优酷 | 優酷 |\n| 愛奇芸（アイキゲー） | IQiyi | 爱奇艺 | 愛奇藝 |\n\n## 二、設定（せってい）\n\n「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。\n\n下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。\n\n### （一）接続（せつぞく）設定（连接设置）\n\n| 設定（せってい）                 | Settings         | 设置         | 設定     |\n| -------------------------------- | ---------------- | ------------ | -------- |\n| 機内モード（きない 1）           | Airplane Mode    | 飞行模式     | 飛航模式 |\n| WLAN                             | WLAN             | 无线网络     | WLAN     |\n| Bluetooth                        | Bluetooth        | 蓝牙         | 藍牙     |\n| モバイル通信（つうしん）         | Cellular         | 蜂窝移动网络 | 行動服務 |\n| インターネット共有（きょうゆう） | Personal Hotspot | 个人热点     | 個人熱點 |\n| VPN                              | VPN              | VPN          | VPN      |\n\n### （二）フィードバック設定（反馈设置）\n\n| 設定（せってい）             | Settings        | 设置         | 設定           |\n| ---------------------------- | --------------- | ------------ | -------------- |\n| 通知（つうち）               | Notifications   | 通知         | 通知           |\n| サウンドと触覚（しょっかく） | Sounds＆Haptics | 声音与触感   | 聲音與觸覺回饋 |\n| おやすみモード               | Do Not Disturb  | 勿扰模式     | 勿擾模式       |\n| スクリーンタイム             | Screen Time     | 屏幕使用时间 | 熒幕使用時間   |\n\n### （三）一般設定（通用设置）\n\n| 設定（せってい）                             | Settings              | 设置           | 設定           |\n| -------------------------------------------- | --------------------- | -------------- | -------------- |\n| 一般（いっぱん）                             | General               | 通用           | 一般           |\n| コントロールセンター                         | Control Center        | 控制中心       | 控制中心       |\n| 画面表示と明るさ（がめんひょうじとあかるさ） | Display ＆ Brightness | 显示与亮度     | 熒幕顯示與亮度 |\n| 壁紙（かべがみ）                             | Wallpaper             | 墙纸           | 背景圖片       |\n| Siriと検索（けんさく）                       | Siri ＆Search         | Siri 与搜索    | Siri 與搜尋    |\n| Face ID とパスコード                         | Face ID & Passcode    | 面容 ID 与密码 | Face ID 與密碼 |\n| 緊急SOS（きんきゅう）                        | Emergency SOS         | SOS 紧急联络   | SOS 緊急服務   |\n| バッテリー                                   | Battery               | 电池           | 電池           |\n| プライバシー                                 | Privacy               | 隐私           | 隱私權         |\n\n### （四）ストアー設定（商店设置）\n\n| 設定（せってい）          | Settings                | 设置                      | 設定                      |\n| ------------------------- | ----------------------- | ------------------------- | ------------------------- |\n| iTunes Store と App Store | iTunes Store＆App Store | iTunes Store 与 App Store | iTunes Store 與 App Store |\n| WalletとApple Pay         | Wallet＆Apple Pay       | 钱包与 Apple Pay          | 錢包與 Apple Pay          |\n\n## 三、操作（そうさ）\n\nアプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：\n\n| 日本語               | English | 汉语 | 漢語 |\n| -------------------- | ------- | ---- | ---- |\n| OK                   | OK      | 好的 | 好的 |\n| 確認                 | Comfirm | 确定 | 確定 |\n| キャンセル           | Cancel  | 取消 | 取消 |\n| 完了（かんりょう）   | Finish  | 完成 | 完成 |\n| オン                 | On      | 开启 | 開啟 |\n| オフ                 | Off     | 关闭 | 關閉 |\n| 消去（しょうきょ 1） | Clear   | 清除 | 清除 |\n| 検索（けんさく）     | Search  | 搜索 | 搜尋 |\n| 削除（さくじょ 1）   | Delete  | 删除 | 删除 |\n| 破棄（はき 1）       | Discard | 废弃 | 捨棄 |\n| 元に戻す（もとにもどす） | Undo | 撤消 | 復原 |\n| 開く（ひらく2）      | Open    | 打开 | 打開 |\n| 閉じる（とじる 2）   | Close   | 关闭 | 關閉 |\n| 編集（へんしゅう）   | Edit    | 编辑 | 編輯 |\n| 表示（ひょうじ） | View | 查看 | 檢視 |\n| 送る（おくる） | Send    | 发送 | 發送 |\n| 追加（ついか） | Add | 添加 | 加入 |\n| 新着（しんちゃく） | New | 新增 | 新增 |\n| 報告（ほうこく） | Report | 举报 | 回報 |\n| マーク | Mark | 标记 | 標示 |\n| 再生（さいせい） | Play | 播放 | 播放 |\n| 一時停止（いちじていし） | Pause | 暂停 | 暫停 |\n| 停止（ていし） | Stop | 停止 | 停止 |\n| 登録（とうろく） | Sign Up | 注册 | 註冊 |\n| ログイン | Sign In / Log In | 登录 | 登入 |\n| ログアウト | Sign Out / Log Out | 退出 | 登出 / 退出 |\n\n","source":"_posts/language/jp/keitai-de-nihongo.md","raw":"---\ntitle: 携帯で日本語（手机上的日语）\np: language/jp/keitai-de-nihongo.md\ndate: 2019-09-07 09:06:00\ntags:\n- 日本語\n---\n\n有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。\n\n<!--more-->\n\n## 一、アプリ（应用程序）\n\n手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。\n\n下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。\n\n### （一）システムアプリ（系统应用）\n\n| アプリ                   | Applications         | 应用程序      | 應用程式   |\n| ------------------------ | -------------------- | ------------- | ---------- |\n| アプリストア(apurisutoa) | App store            | 应用商店      | 應用商店   |\n| パスウードとアカウード   | Passwords & Accounts | 密码与账户    | 密碼與賬號 |\n| メール                   | Mail                 | 邮件          | 郵件       |\n| 連絡先（れんらくさき）   | Contacts             | 通讯录        | 聯絡資訊   |\n| カレンダー               | Calendar             | 日历          | 行事曆     |\n| メモ                     | Notes                | 备忘录        | 備忘錄     |\n| リマインダー             | Reminders            | 提醒事项      | 提醒事項   |\n| ボイスメモ               | Voice Memos          | 语言备忘录    | 語音備忘錄 |\n| 電話（でんわ）           | Phone                | 电话          | 電話       |\n| メッセージ               | Messages             | 信息          | 訊息       |\n| FaceTime                 | FaceTime             | FaceTime      | FaceTime   |\n| マップ                   | Maps                 | 地图          | 地圖       |\n| コンパス                 | Compass              | 指南针        | 指南針     |\n| 計測（けいそく）         | Measure              | 测距仪        | 測距儀     |\n| Safari                   | Safari               | Safari 浏览器 | Safari     |\n| 株価（かぶか）           | Stocks               | 股市          | 股市       |\n| ミュージック             | Music                | 音乐          | 音樂       |\n| ビデオ                   | Videos               | 视频          | 影片       |\n| 写真（しゃしん）         | Photos               | 照片          | 照片       |\n| カメラ                   | Camera               | 相机          | 相機       |\n| ブック                   | Books                | 图书          | 書籍       |\n\n备注：\n\n1. 股票：株式（かぶしき）\n2. 股市：株式市場（かぶしきしじょう）\n3. 股价：株価（かぶか）\n\n### （二）ユーザーアプリ（用户应用）\n\n| アプリ                          | Applications | 应用程序 | 應用程式 |\n| ------------------------------- | --------------- | -------- | -------- |\n| 微信 / ウェイシン \\| WeChat / ウィチャット | Wechat          | 微信     | 微信   |\n| QQ / キュキュ           | QQ              | QQ       | QQ     |\n| アリペイ                | Alipay          | 支付宝   | 支付寶 |\n| ビリビリ              | Bilibili        | 哔哩哔哩 | 嗶哩嗶哩 |\n| Google / グーグル       | Google          | 谷歌     | 谷歌   |\n| Kindle / キンドル | Kindle          | Kindle   | Kindle |\n| Chrome / クロム | Chrome | Chrome | Chrome |\n| YouTube / ユーチューブ | YouTube | YouTube | YouTube |\n| Gmail / ジメイル | Gmail | Gmail | Gmail |\n| Google フォト | Google Photo | Google相册 | Google相簿 |\n| 翻訳（ほにゃく） | Translate | 翻译 | 翻譯 |\n| Instagram / インスタグラム | Instagram | Instagram | Instagram |\n| WhatsApp / ワッツアップ | WhatsApp | WhatsApp | WhatsApp |\n| Wunderlist / ワンダーリスト | Wunderlist | 奇妙清单 | 奇妙清單 |\n| NetEase Music / ネットイース ミュージック | NetEase Music | 网易云音乐 | 網易云音樂 |\n| 好奇心日報（こうきしんにっぽう） | Qdaily | 好奇心日报 | 好奇心日報 |\n| Taobao / タオバオ | Taobao | 手机淘宝 | 手機淘寶 |\n| 京東 / ジンドン | JD | 京东 | 京東 |\n| 高德地図 / こうとくちず | Amap | 高德地图 | 高德地圖 |\n| 印象メモ | Evernote | 印象笔记 | 印象筆記 |\n| 招商銀行 / しょうしょうぎんこう | CMB | 招商银行 | 招商銀行 |\n| WeChat 読書（どくしょ 1）? | WeRead | 微信读书 | 微信讀書 |\n| Youku（ヨウク） | Youku | 优酷 | 優酷 |\n| 愛奇芸（アイキゲー） | IQiyi | 爱奇艺 | 愛奇藝 |\n\n## 二、設定（せってい）\n\n「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。\n\n下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。\n\n### （一）接続（せつぞく）設定（连接设置）\n\n| 設定（せってい）                 | Settings         | 设置         | 設定     |\n| -------------------------------- | ---------------- | ------------ | -------- |\n| 機内モード（きない 1）           | Airplane Mode    | 飞行模式     | 飛航模式 |\n| WLAN                             | WLAN             | 无线网络     | WLAN     |\n| Bluetooth                        | Bluetooth        | 蓝牙         | 藍牙     |\n| モバイル通信（つうしん）         | Cellular         | 蜂窝移动网络 | 行動服務 |\n| インターネット共有（きょうゆう） | Personal Hotspot | 个人热点     | 個人熱點 |\n| VPN                              | VPN              | VPN          | VPN      |\n\n### （二）フィードバック設定（反馈设置）\n\n| 設定（せってい）             | Settings        | 设置         | 設定           |\n| ---------------------------- | --------------- | ------------ | -------------- |\n| 通知（つうち）               | Notifications   | 通知         | 通知           |\n| サウンドと触覚（しょっかく） | Sounds＆Haptics | 声音与触感   | 聲音與觸覺回饋 |\n| おやすみモード               | Do Not Disturb  | 勿扰模式     | 勿擾模式       |\n| スクリーンタイム             | Screen Time     | 屏幕使用时间 | 熒幕使用時間   |\n\n### （三）一般設定（通用设置）\n\n| 設定（せってい）                             | Settings              | 设置           | 設定           |\n| -------------------------------------------- | --------------------- | -------------- | -------------- |\n| 一般（いっぱん）                             | General               | 通用           | 一般           |\n| コントロールセンター                         | Control Center        | 控制中心       | 控制中心       |\n| 画面表示と明るさ（がめんひょうじとあかるさ） | Display ＆ Brightness | 显示与亮度     | 熒幕顯示與亮度 |\n| 壁紙（かべがみ）                             | Wallpaper             | 墙纸           | 背景圖片       |\n| Siriと検索（けんさく）                       | Siri ＆Search         | Siri 与搜索    | Siri 與搜尋    |\n| Face ID とパスコード                         | Face ID & Passcode    | 面容 ID 与密码 | Face ID 與密碼 |\n| 緊急SOS（きんきゅう）                        | Emergency SOS         | SOS 紧急联络   | SOS 緊急服務   |\n| バッテリー                                   | Battery               | 电池           | 電池           |\n| プライバシー                                 | Privacy               | 隐私           | 隱私權         |\n\n### （四）ストアー設定（商店设置）\n\n| 設定（せってい）          | Settings                | 设置                      | 設定                      |\n| ------------------------- | ----------------------- | ------------------------- | ------------------------- |\n| iTunes Store と App Store | iTunes Store＆App Store | iTunes Store 与 App Store | iTunes Store 與 App Store |\n| WalletとApple Pay         | Wallet＆Apple Pay       | 钱包与 Apple Pay          | 錢包與 Apple Pay          |\n\n## 三、操作（そうさ）\n\nアプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：\n\n| 日本語               | English | 汉语 | 漢語 |\n| -------------------- | ------- | ---- | ---- |\n| OK                   | OK      | 好的 | 好的 |\n| 確認                 | Comfirm | 确定 | 確定 |\n| キャンセル           | Cancel  | 取消 | 取消 |\n| 完了（かんりょう）   | Finish  | 完成 | 完成 |\n| オン                 | On      | 开启 | 開啟 |\n| オフ                 | Off     | 关闭 | 關閉 |\n| 消去（しょうきょ 1） | Clear   | 清除 | 清除 |\n| 検索（けんさく）     | Search  | 搜索 | 搜尋 |\n| 削除（さくじょ 1）   | Delete  | 删除 | 删除 |\n| 破棄（はき 1）       | Discard | 废弃 | 捨棄 |\n| 元に戻す（もとにもどす） | Undo | 撤消 | 復原 |\n| 開く（ひらく2）      | Open    | 打开 | 打開 |\n| 閉じる（とじる 2）   | Close   | 关闭 | 關閉 |\n| 編集（へんしゅう）   | Edit    | 编辑 | 編輯 |\n| 表示（ひょうじ） | View | 查看 | 檢視 |\n| 送る（おくる） | Send    | 发送 | 發送 |\n| 追加（ついか） | Add | 添加 | 加入 |\n| 新着（しんちゃく） | New | 新增 | 新增 |\n| 報告（ほうこく） | Report | 举报 | 回報 |\n| マーク | Mark | 标记 | 標示 |\n| 再生（さいせい） | Play | 播放 | 播放 |\n| 一時停止（いちじていし） | Pause | 暂停 | 暫停 |\n| 停止（ていし） | Stop | 停止 | 停止 |\n| 登録（とうろく） | Sign Up | 注册 | 註冊 |\n| ログイン | Sign In / Log In | 登录 | 登入 |\n| ログアウト | Sign Out / Log Out | 退出 | 登出 / 退出 |\n\n","slug":"language/jp/keitai-de-nihongo","published":1,"updated":"2021-09-13T14:09:55.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlf1000x1n9k1w364p19","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、アプリ（应用程序）\"><a href=\"#一、アプリ（应用程序）\" class=\"headerlink\" title=\"一、アプリ（应用程序）\"></a>一、アプリ（应用程序）</h2><p>手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。</p>\n<p>下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。</p>\n<h3 id=\"（一）システムアプリ（系统应用）\"><a href=\"#（一）システムアプリ（系统应用）\" class=\"headerlink\" title=\"（一）システムアプリ（系统应用）\"></a>（一）システムアプリ（系统应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>アプリストア(apurisutoa)</td>\n<td>App store</td>\n<td>应用商店</td>\n<td>應用商店</td>\n</tr>\n<tr>\n<td>パスウードとアカウード</td>\n<td>Passwords &amp; Accounts</td>\n<td>密码与账户</td>\n<td>密碼與賬號</td>\n</tr>\n<tr>\n<td>メール</td>\n<td>Mail</td>\n<td>邮件</td>\n<td>郵件</td>\n</tr>\n<tr>\n<td>連絡先（れんらくさき）</td>\n<td>Contacts</td>\n<td>通讯录</td>\n<td>聯絡資訊</td>\n</tr>\n<tr>\n<td>カレンダー</td>\n<td>Calendar</td>\n<td>日历</td>\n<td>行事曆</td>\n</tr>\n<tr>\n<td>メモ</td>\n<td>Notes</td>\n<td>备忘录</td>\n<td>備忘錄</td>\n</tr>\n<tr>\n<td>リマインダー</td>\n<td>Reminders</td>\n<td>提醒事项</td>\n<td>提醒事項</td>\n</tr>\n<tr>\n<td>ボイスメモ</td>\n<td>Voice Memos</td>\n<td>语言备忘录</td>\n<td>語音備忘錄</td>\n</tr>\n<tr>\n<td>電話（でんわ）</td>\n<td>Phone</td>\n<td>电话</td>\n<td>電話</td>\n</tr>\n<tr>\n<td>メッセージ</td>\n<td>Messages</td>\n<td>信息</td>\n<td>訊息</td>\n</tr>\n<tr>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n</tr>\n<tr>\n<td>マップ</td>\n<td>Maps</td>\n<td>地图</td>\n<td>地圖</td>\n</tr>\n<tr>\n<td>コンパス</td>\n<td>Compass</td>\n<td>指南针</td>\n<td>指南針</td>\n</tr>\n<tr>\n<td>計測（けいそく）</td>\n<td>Measure</td>\n<td>测距仪</td>\n<td>測距儀</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>Safari</td>\n<td>Safari 浏览器</td>\n<td>Safari</td>\n</tr>\n<tr>\n<td>株価（かぶか）</td>\n<td>Stocks</td>\n<td>股市</td>\n<td>股市</td>\n</tr>\n<tr>\n<td>ミュージック</td>\n<td>Music</td>\n<td>音乐</td>\n<td>音樂</td>\n</tr>\n<tr>\n<td>ビデオ</td>\n<td>Videos</td>\n<td>视频</td>\n<td>影片</td>\n</tr>\n<tr>\n<td>写真（しゃしん）</td>\n<td>Photos</td>\n<td>照片</td>\n<td>照片</td>\n</tr>\n<tr>\n<td>カメラ</td>\n<td>Camera</td>\n<td>相机</td>\n<td>相機</td>\n</tr>\n<tr>\n<td>ブック</td>\n<td>Books</td>\n<td>图书</td>\n<td>書籍</td>\n</tr>\n</tbody></table>\n<p>备注：</p>\n<ol>\n<li>股票：株式（かぶしき）</li>\n<li>股市：株式市場（かぶしきしじょう）</li>\n<li>股价：株価（かぶか）</li>\n</ol>\n<h3 id=\"（二）ユーザーアプリ（用户应用）\"><a href=\"#（二）ユーザーアプリ（用户应用）\" class=\"headerlink\" title=\"（二）ユーザーアプリ（用户应用）\"></a>（二）ユーザーアプリ（用户应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微信 / ウェイシン | WeChat / ウィチャット</td>\n<td>Wechat</td>\n<td>微信</td>\n<td>微信</td>\n</tr>\n<tr>\n<td>QQ / キュキュ</td>\n<td>QQ</td>\n<td>QQ</td>\n<td>QQ</td>\n</tr>\n<tr>\n<td>アリペイ</td>\n<td>Alipay</td>\n<td>支付宝</td>\n<td>支付寶</td>\n</tr>\n<tr>\n<td>ビリビリ</td>\n<td>Bilibili</td>\n<td>哔哩哔哩</td>\n<td>嗶哩嗶哩</td>\n</tr>\n<tr>\n<td>Google / グーグル</td>\n<td>Google</td>\n<td>谷歌</td>\n<td>谷歌</td>\n</tr>\n<tr>\n<td>Kindle / キンドル</td>\n<td>Kindle</td>\n<td>Kindle</td>\n<td>Kindle</td>\n</tr>\n<tr>\n<td>Chrome / クロム</td>\n<td>Chrome</td>\n<td>Chrome</td>\n<td>Chrome</td>\n</tr>\n<tr>\n<td>YouTube / ユーチューブ</td>\n<td>YouTube</td>\n<td>YouTube</td>\n<td>YouTube</td>\n</tr>\n<tr>\n<td>Gmail / ジメイル</td>\n<td>Gmail</td>\n<td>Gmail</td>\n<td>Gmail</td>\n</tr>\n<tr>\n<td>Google フォト</td>\n<td>Google Photo</td>\n<td>Google相册</td>\n<td>Google相簿</td>\n</tr>\n<tr>\n<td>翻訳（ほにゃく）</td>\n<td>Translate</td>\n<td>翻译</td>\n<td>翻譯</td>\n</tr>\n<tr>\n<td>Instagram / インスタグラム</td>\n<td>Instagram</td>\n<td>Instagram</td>\n<td>Instagram</td>\n</tr>\n<tr>\n<td>WhatsApp / ワッツアップ</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n</tr>\n<tr>\n<td>Wunderlist / ワンダーリスト</td>\n<td>Wunderlist</td>\n<td>奇妙清单</td>\n<td>奇妙清單</td>\n</tr>\n<tr>\n<td>NetEase Music / ネットイース ミュージック</td>\n<td>NetEase Music</td>\n<td>网易云音乐</td>\n<td>網易云音樂</td>\n</tr>\n<tr>\n<td>好奇心日報（こうきしんにっぽう）</td>\n<td>Qdaily</td>\n<td>好奇心日报</td>\n<td>好奇心日報</td>\n</tr>\n<tr>\n<td>Taobao / タオバオ</td>\n<td>Taobao</td>\n<td>手机淘宝</td>\n<td>手機淘寶</td>\n</tr>\n<tr>\n<td>京東 / ジンドン</td>\n<td>JD</td>\n<td>京东</td>\n<td>京東</td>\n</tr>\n<tr>\n<td>高德地図 / こうとくちず</td>\n<td>Amap</td>\n<td>高德地图</td>\n<td>高德地圖</td>\n</tr>\n<tr>\n<td>印象メモ</td>\n<td>Evernote</td>\n<td>印象笔记</td>\n<td>印象筆記</td>\n</tr>\n<tr>\n<td>招商銀行 / しょうしょうぎんこう</td>\n<td>CMB</td>\n<td>招商银行</td>\n<td>招商銀行</td>\n</tr>\n<tr>\n<td>WeChat 読書（どくしょ 1）?</td>\n<td>WeRead</td>\n<td>微信读书</td>\n<td>微信讀書</td>\n</tr>\n<tr>\n<td>Youku（ヨウク）</td>\n<td>Youku</td>\n<td>优酷</td>\n<td>優酷</td>\n</tr>\n<tr>\n<td>愛奇芸（アイキゲー）</td>\n<td>IQiyi</td>\n<td>爱奇艺</td>\n<td>愛奇藝</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、設定（せってい）\"><a href=\"#二、設定（せってい）\" class=\"headerlink\" title=\"二、設定（せってい）\"></a>二、設定（せってい）</h2><p>「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。</p>\n<p>下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。</p>\n<h3 id=\"（一）接続（せつぞく）設定（连接设置）\"><a href=\"#（一）接続（せつぞく）設定（连接设置）\" class=\"headerlink\" title=\"（一）接続（せつぞく）設定（连接设置）\"></a>（一）接続（せつぞく）設定（连接设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>機内モード（きない 1）</td>\n<td>Airplane Mode</td>\n<td>飞行模式</td>\n<td>飛航模式</td>\n</tr>\n<tr>\n<td>WLAN</td>\n<td>WLAN</td>\n<td>无线网络</td>\n<td>WLAN</td>\n</tr>\n<tr>\n<td>Bluetooth</td>\n<td>Bluetooth</td>\n<td>蓝牙</td>\n<td>藍牙</td>\n</tr>\n<tr>\n<td>モバイル通信（つうしん）</td>\n<td>Cellular</td>\n<td>蜂窝移动网络</td>\n<td>行動服務</td>\n</tr>\n<tr>\n<td>インターネット共有（きょうゆう）</td>\n<td>Personal Hotspot</td>\n<td>个人热点</td>\n<td>個人熱點</td>\n</tr>\n<tr>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n</tr>\n</tbody></table>\n<h3 id=\"（二）フィードバック設定（反馈设置）\"><a href=\"#（二）フィードバック設定（反馈设置）\" class=\"headerlink\" title=\"（二）フィードバック設定（反馈设置）\"></a>（二）フィードバック設定（反馈设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通知（つうち）</td>\n<td>Notifications</td>\n<td>通知</td>\n<td>通知</td>\n</tr>\n<tr>\n<td>サウンドと触覚（しょっかく）</td>\n<td>Sounds＆Haptics</td>\n<td>声音与触感</td>\n<td>聲音與觸覺回饋</td>\n</tr>\n<tr>\n<td>おやすみモード</td>\n<td>Do Not Disturb</td>\n<td>勿扰模式</td>\n<td>勿擾模式</td>\n</tr>\n<tr>\n<td>スクリーンタイム</td>\n<td>Screen Time</td>\n<td>屏幕使用时间</td>\n<td>熒幕使用時間</td>\n</tr>\n</tbody></table>\n<h3 id=\"（三）一般設定（通用设置）\"><a href=\"#（三）一般設定（通用设置）\" class=\"headerlink\" title=\"（三）一般設定（通用设置）\"></a>（三）一般設定（通用设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一般（いっぱん）</td>\n<td>General</td>\n<td>通用</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>コントロールセンター</td>\n<td>Control Center</td>\n<td>控制中心</td>\n<td>控制中心</td>\n</tr>\n<tr>\n<td>画面表示と明るさ（がめんひょうじとあかるさ）</td>\n<td>Display ＆ Brightness</td>\n<td>显示与亮度</td>\n<td>熒幕顯示與亮度</td>\n</tr>\n<tr>\n<td>壁紙（かべがみ）</td>\n<td>Wallpaper</td>\n<td>墙纸</td>\n<td>背景圖片</td>\n</tr>\n<tr>\n<td>Siriと検索（けんさく）</td>\n<td>Siri ＆Search</td>\n<td>Siri 与搜索</td>\n<td>Siri 與搜尋</td>\n</tr>\n<tr>\n<td>Face ID とパスコード</td>\n<td>Face ID &amp; Passcode</td>\n<td>面容 ID 与密码</td>\n<td>Face ID 與密碼</td>\n</tr>\n<tr>\n<td>緊急SOS（きんきゅう）</td>\n<td>Emergency SOS</td>\n<td>SOS 紧急联络</td>\n<td>SOS 緊急服務</td>\n</tr>\n<tr>\n<td>バッテリー</td>\n<td>Battery</td>\n<td>电池</td>\n<td>電池</td>\n</tr>\n<tr>\n<td>プライバシー</td>\n<td>Privacy</td>\n<td>隐私</td>\n<td>隱私權</td>\n</tr>\n</tbody></table>\n<h3 id=\"（四）ストアー設定（商店设置）\"><a href=\"#（四）ストアー設定（商店设置）\" class=\"headerlink\" title=\"（四）ストアー設定（商店设置）\"></a>（四）ストアー設定（商店设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iTunes Store と App Store</td>\n<td>iTunes Store＆App Store</td>\n<td>iTunes Store 与 App Store</td>\n<td>iTunes Store 與 App Store</td>\n</tr>\n<tr>\n<td>WalletとApple Pay</td>\n<td>Wallet＆Apple Pay</td>\n<td>钱包与 Apple Pay</td>\n<td>錢包與 Apple Pay</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、操作（そうさ）\"><a href=\"#三、操作（そうさ）\" class=\"headerlink\" title=\"三、操作（そうさ）\"></a>三、操作（そうさ）</h2><p>アプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：</p>\n<table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>English</th>\n<th>汉语</th>\n<th>漢語</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OK</td>\n<td>OK</td>\n<td>好的</td>\n<td>好的</td>\n</tr>\n<tr>\n<td>確認</td>\n<td>Comfirm</td>\n<td>确定</td>\n<td>確定</td>\n</tr>\n<tr>\n<td>キャンセル</td>\n<td>Cancel</td>\n<td>取消</td>\n<td>取消</td>\n</tr>\n<tr>\n<td>完了（かんりょう）</td>\n<td>Finish</td>\n<td>完成</td>\n<td>完成</td>\n</tr>\n<tr>\n<td>オン</td>\n<td>On</td>\n<td>开启</td>\n<td>開啟</td>\n</tr>\n<tr>\n<td>オフ</td>\n<td>Off</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>消去（しょうきょ 1）</td>\n<td>Clear</td>\n<td>清除</td>\n<td>清除</td>\n</tr>\n<tr>\n<td>検索（けんさく）</td>\n<td>Search</td>\n<td>搜索</td>\n<td>搜尋</td>\n</tr>\n<tr>\n<td>削除（さくじょ 1）</td>\n<td>Delete</td>\n<td>删除</td>\n<td>删除</td>\n</tr>\n<tr>\n<td>破棄（はき 1）</td>\n<td>Discard</td>\n<td>废弃</td>\n<td>捨棄</td>\n</tr>\n<tr>\n<td>元に戻す（もとにもどす）</td>\n<td>Undo</td>\n<td>撤消</td>\n<td>復原</td>\n</tr>\n<tr>\n<td>開く（ひらく2）</td>\n<td>Open</td>\n<td>打开</td>\n<td>打開</td>\n</tr>\n<tr>\n<td>閉じる（とじる 2）</td>\n<td>Close</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>編集（へんしゅう）</td>\n<td>Edit</td>\n<td>编辑</td>\n<td>編輯</td>\n</tr>\n<tr>\n<td>表示（ひょうじ）</td>\n<td>View</td>\n<td>查看</td>\n<td>檢視</td>\n</tr>\n<tr>\n<td>送る（おくる）</td>\n<td>Send</td>\n<td>发送</td>\n<td>發送</td>\n</tr>\n<tr>\n<td>追加（ついか）</td>\n<td>Add</td>\n<td>添加</td>\n<td>加入</td>\n</tr>\n<tr>\n<td>新着（しんちゃく）</td>\n<td>New</td>\n<td>新增</td>\n<td>新增</td>\n</tr>\n<tr>\n<td>報告（ほうこく）</td>\n<td>Report</td>\n<td>举报</td>\n<td>回報</td>\n</tr>\n<tr>\n<td>マーク</td>\n<td>Mark</td>\n<td>标记</td>\n<td>標示</td>\n</tr>\n<tr>\n<td>再生（さいせい）</td>\n<td>Play</td>\n<td>播放</td>\n<td>播放</td>\n</tr>\n<tr>\n<td>一時停止（いちじていし）</td>\n<td>Pause</td>\n<td>暂停</td>\n<td>暫停</td>\n</tr>\n<tr>\n<td>停止（ていし）</td>\n<td>Stop</td>\n<td>停止</td>\n<td>停止</td>\n</tr>\n<tr>\n<td>登録（とうろく）</td>\n<td>Sign Up</td>\n<td>注册</td>\n<td>註冊</td>\n</tr>\n<tr>\n<td>ログイン</td>\n<td>Sign In / Log In</td>\n<td>登录</td>\n<td>登入</td>\n</tr>\n<tr>\n<td>ログアウト</td>\n<td>Sign Out / Log Out</td>\n<td>退出</td>\n<td>登出 / 退出</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<p>有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。</p>","more":"<h2 id=\"一、アプリ（应用程序）\"><a href=\"#一、アプリ（应用程序）\" class=\"headerlink\" title=\"一、アプリ（应用程序）\"></a>一、アプリ（应用程序）</h2><p>手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。</p>\n<p>下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。</p>\n<h3 id=\"（一）システムアプリ（系统应用）\"><a href=\"#（一）システムアプリ（系统应用）\" class=\"headerlink\" title=\"（一）システムアプリ（系统应用）\"></a>（一）システムアプリ（系统应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>アプリストア(apurisutoa)</td>\n<td>App store</td>\n<td>应用商店</td>\n<td>應用商店</td>\n</tr>\n<tr>\n<td>パスウードとアカウード</td>\n<td>Passwords &amp; Accounts</td>\n<td>密码与账户</td>\n<td>密碼與賬號</td>\n</tr>\n<tr>\n<td>メール</td>\n<td>Mail</td>\n<td>邮件</td>\n<td>郵件</td>\n</tr>\n<tr>\n<td>連絡先（れんらくさき）</td>\n<td>Contacts</td>\n<td>通讯录</td>\n<td>聯絡資訊</td>\n</tr>\n<tr>\n<td>カレンダー</td>\n<td>Calendar</td>\n<td>日历</td>\n<td>行事曆</td>\n</tr>\n<tr>\n<td>メモ</td>\n<td>Notes</td>\n<td>备忘录</td>\n<td>備忘錄</td>\n</tr>\n<tr>\n<td>リマインダー</td>\n<td>Reminders</td>\n<td>提醒事项</td>\n<td>提醒事項</td>\n</tr>\n<tr>\n<td>ボイスメモ</td>\n<td>Voice Memos</td>\n<td>语言备忘录</td>\n<td>語音備忘錄</td>\n</tr>\n<tr>\n<td>電話（でんわ）</td>\n<td>Phone</td>\n<td>电话</td>\n<td>電話</td>\n</tr>\n<tr>\n<td>メッセージ</td>\n<td>Messages</td>\n<td>信息</td>\n<td>訊息</td>\n</tr>\n<tr>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n</tr>\n<tr>\n<td>マップ</td>\n<td>Maps</td>\n<td>地图</td>\n<td>地圖</td>\n</tr>\n<tr>\n<td>コンパス</td>\n<td>Compass</td>\n<td>指南针</td>\n<td>指南針</td>\n</tr>\n<tr>\n<td>計測（けいそく）</td>\n<td>Measure</td>\n<td>测距仪</td>\n<td>測距儀</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>Safari</td>\n<td>Safari 浏览器</td>\n<td>Safari</td>\n</tr>\n<tr>\n<td>株価（かぶか）</td>\n<td>Stocks</td>\n<td>股市</td>\n<td>股市</td>\n</tr>\n<tr>\n<td>ミュージック</td>\n<td>Music</td>\n<td>音乐</td>\n<td>音樂</td>\n</tr>\n<tr>\n<td>ビデオ</td>\n<td>Videos</td>\n<td>视频</td>\n<td>影片</td>\n</tr>\n<tr>\n<td>写真（しゃしん）</td>\n<td>Photos</td>\n<td>照片</td>\n<td>照片</td>\n</tr>\n<tr>\n<td>カメラ</td>\n<td>Camera</td>\n<td>相机</td>\n<td>相機</td>\n</tr>\n<tr>\n<td>ブック</td>\n<td>Books</td>\n<td>图书</td>\n<td>書籍</td>\n</tr>\n</tbody></table>\n<p>备注：</p>\n<ol>\n<li>股票：株式（かぶしき）</li>\n<li>股市：株式市場（かぶしきしじょう）</li>\n<li>股价：株価（かぶか）</li>\n</ol>\n<h3 id=\"（二）ユーザーアプリ（用户应用）\"><a href=\"#（二）ユーザーアプリ（用户应用）\" class=\"headerlink\" title=\"（二）ユーザーアプリ（用户应用）\"></a>（二）ユーザーアプリ（用户应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微信 / ウェイシン | WeChat / ウィチャット</td>\n<td>Wechat</td>\n<td>微信</td>\n<td>微信</td>\n</tr>\n<tr>\n<td>QQ / キュキュ</td>\n<td>QQ</td>\n<td>QQ</td>\n<td>QQ</td>\n</tr>\n<tr>\n<td>アリペイ</td>\n<td>Alipay</td>\n<td>支付宝</td>\n<td>支付寶</td>\n</tr>\n<tr>\n<td>ビリビリ</td>\n<td>Bilibili</td>\n<td>哔哩哔哩</td>\n<td>嗶哩嗶哩</td>\n</tr>\n<tr>\n<td>Google / グーグル</td>\n<td>Google</td>\n<td>谷歌</td>\n<td>谷歌</td>\n</tr>\n<tr>\n<td>Kindle / キンドル</td>\n<td>Kindle</td>\n<td>Kindle</td>\n<td>Kindle</td>\n</tr>\n<tr>\n<td>Chrome / クロム</td>\n<td>Chrome</td>\n<td>Chrome</td>\n<td>Chrome</td>\n</tr>\n<tr>\n<td>YouTube / ユーチューブ</td>\n<td>YouTube</td>\n<td>YouTube</td>\n<td>YouTube</td>\n</tr>\n<tr>\n<td>Gmail / ジメイル</td>\n<td>Gmail</td>\n<td>Gmail</td>\n<td>Gmail</td>\n</tr>\n<tr>\n<td>Google フォト</td>\n<td>Google Photo</td>\n<td>Google相册</td>\n<td>Google相簿</td>\n</tr>\n<tr>\n<td>翻訳（ほにゃく）</td>\n<td>Translate</td>\n<td>翻译</td>\n<td>翻譯</td>\n</tr>\n<tr>\n<td>Instagram / インスタグラム</td>\n<td>Instagram</td>\n<td>Instagram</td>\n<td>Instagram</td>\n</tr>\n<tr>\n<td>WhatsApp / ワッツアップ</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n</tr>\n<tr>\n<td>Wunderlist / ワンダーリスト</td>\n<td>Wunderlist</td>\n<td>奇妙清单</td>\n<td>奇妙清單</td>\n</tr>\n<tr>\n<td>NetEase Music / ネットイース ミュージック</td>\n<td>NetEase Music</td>\n<td>网易云音乐</td>\n<td>網易云音樂</td>\n</tr>\n<tr>\n<td>好奇心日報（こうきしんにっぽう）</td>\n<td>Qdaily</td>\n<td>好奇心日报</td>\n<td>好奇心日報</td>\n</tr>\n<tr>\n<td>Taobao / タオバオ</td>\n<td>Taobao</td>\n<td>手机淘宝</td>\n<td>手機淘寶</td>\n</tr>\n<tr>\n<td>京東 / ジンドン</td>\n<td>JD</td>\n<td>京东</td>\n<td>京東</td>\n</tr>\n<tr>\n<td>高德地図 / こうとくちず</td>\n<td>Amap</td>\n<td>高德地图</td>\n<td>高德地圖</td>\n</tr>\n<tr>\n<td>印象メモ</td>\n<td>Evernote</td>\n<td>印象笔记</td>\n<td>印象筆記</td>\n</tr>\n<tr>\n<td>招商銀行 / しょうしょうぎんこう</td>\n<td>CMB</td>\n<td>招商银行</td>\n<td>招商銀行</td>\n</tr>\n<tr>\n<td>WeChat 読書（どくしょ 1）?</td>\n<td>WeRead</td>\n<td>微信读书</td>\n<td>微信讀書</td>\n</tr>\n<tr>\n<td>Youku（ヨウク）</td>\n<td>Youku</td>\n<td>优酷</td>\n<td>優酷</td>\n</tr>\n<tr>\n<td>愛奇芸（アイキゲー）</td>\n<td>IQiyi</td>\n<td>爱奇艺</td>\n<td>愛奇藝</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、設定（せってい）\"><a href=\"#二、設定（せってい）\" class=\"headerlink\" title=\"二、設定（せってい）\"></a>二、設定（せってい）</h2><p>「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。</p>\n<p>下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。</p>\n<h3 id=\"（一）接続（せつぞく）設定（连接设置）\"><a href=\"#（一）接続（せつぞく）設定（连接设置）\" class=\"headerlink\" title=\"（一）接続（せつぞく）設定（连接设置）\"></a>（一）接続（せつぞく）設定（连接设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>機内モード（きない 1）</td>\n<td>Airplane Mode</td>\n<td>飞行模式</td>\n<td>飛航模式</td>\n</tr>\n<tr>\n<td>WLAN</td>\n<td>WLAN</td>\n<td>无线网络</td>\n<td>WLAN</td>\n</tr>\n<tr>\n<td>Bluetooth</td>\n<td>Bluetooth</td>\n<td>蓝牙</td>\n<td>藍牙</td>\n</tr>\n<tr>\n<td>モバイル通信（つうしん）</td>\n<td>Cellular</td>\n<td>蜂窝移动网络</td>\n<td>行動服務</td>\n</tr>\n<tr>\n<td>インターネット共有（きょうゆう）</td>\n<td>Personal Hotspot</td>\n<td>个人热点</td>\n<td>個人熱點</td>\n</tr>\n<tr>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n</tr>\n</tbody></table>\n<h3 id=\"（二）フィードバック設定（反馈设置）\"><a href=\"#（二）フィードバック設定（反馈设置）\" class=\"headerlink\" title=\"（二）フィードバック設定（反馈设置）\"></a>（二）フィードバック設定（反馈设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通知（つうち）</td>\n<td>Notifications</td>\n<td>通知</td>\n<td>通知</td>\n</tr>\n<tr>\n<td>サウンドと触覚（しょっかく）</td>\n<td>Sounds＆Haptics</td>\n<td>声音与触感</td>\n<td>聲音與觸覺回饋</td>\n</tr>\n<tr>\n<td>おやすみモード</td>\n<td>Do Not Disturb</td>\n<td>勿扰模式</td>\n<td>勿擾模式</td>\n</tr>\n<tr>\n<td>スクリーンタイム</td>\n<td>Screen Time</td>\n<td>屏幕使用时间</td>\n<td>熒幕使用時間</td>\n</tr>\n</tbody></table>\n<h3 id=\"（三）一般設定（通用设置）\"><a href=\"#（三）一般設定（通用设置）\" class=\"headerlink\" title=\"（三）一般設定（通用设置）\"></a>（三）一般設定（通用设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一般（いっぱん）</td>\n<td>General</td>\n<td>通用</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>コントロールセンター</td>\n<td>Control Center</td>\n<td>控制中心</td>\n<td>控制中心</td>\n</tr>\n<tr>\n<td>画面表示と明るさ（がめんひょうじとあかるさ）</td>\n<td>Display ＆ Brightness</td>\n<td>显示与亮度</td>\n<td>熒幕顯示與亮度</td>\n</tr>\n<tr>\n<td>壁紙（かべがみ）</td>\n<td>Wallpaper</td>\n<td>墙纸</td>\n<td>背景圖片</td>\n</tr>\n<tr>\n<td>Siriと検索（けんさく）</td>\n<td>Siri ＆Search</td>\n<td>Siri 与搜索</td>\n<td>Siri 與搜尋</td>\n</tr>\n<tr>\n<td>Face ID とパスコード</td>\n<td>Face ID &amp; Passcode</td>\n<td>面容 ID 与密码</td>\n<td>Face ID 與密碼</td>\n</tr>\n<tr>\n<td>緊急SOS（きんきゅう）</td>\n<td>Emergency SOS</td>\n<td>SOS 紧急联络</td>\n<td>SOS 緊急服務</td>\n</tr>\n<tr>\n<td>バッテリー</td>\n<td>Battery</td>\n<td>电池</td>\n<td>電池</td>\n</tr>\n<tr>\n<td>プライバシー</td>\n<td>Privacy</td>\n<td>隐私</td>\n<td>隱私權</td>\n</tr>\n</tbody></table>\n<h3 id=\"（四）ストアー設定（商店设置）\"><a href=\"#（四）ストアー設定（商店设置）\" class=\"headerlink\" title=\"（四）ストアー設定（商店设置）\"></a>（四）ストアー設定（商店设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iTunes Store と App Store</td>\n<td>iTunes Store＆App Store</td>\n<td>iTunes Store 与 App Store</td>\n<td>iTunes Store 與 App Store</td>\n</tr>\n<tr>\n<td>WalletとApple Pay</td>\n<td>Wallet＆Apple Pay</td>\n<td>钱包与 Apple Pay</td>\n<td>錢包與 Apple Pay</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、操作（そうさ）\"><a href=\"#三、操作（そうさ）\" class=\"headerlink\" title=\"三、操作（そうさ）\"></a>三、操作（そうさ）</h2><p>アプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：</p>\n<table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>English</th>\n<th>汉语</th>\n<th>漢語</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OK</td>\n<td>OK</td>\n<td>好的</td>\n<td>好的</td>\n</tr>\n<tr>\n<td>確認</td>\n<td>Comfirm</td>\n<td>确定</td>\n<td>確定</td>\n</tr>\n<tr>\n<td>キャンセル</td>\n<td>Cancel</td>\n<td>取消</td>\n<td>取消</td>\n</tr>\n<tr>\n<td>完了（かんりょう）</td>\n<td>Finish</td>\n<td>完成</td>\n<td>完成</td>\n</tr>\n<tr>\n<td>オン</td>\n<td>On</td>\n<td>开启</td>\n<td>開啟</td>\n</tr>\n<tr>\n<td>オフ</td>\n<td>Off</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>消去（しょうきょ 1）</td>\n<td>Clear</td>\n<td>清除</td>\n<td>清除</td>\n</tr>\n<tr>\n<td>検索（けんさく）</td>\n<td>Search</td>\n<td>搜索</td>\n<td>搜尋</td>\n</tr>\n<tr>\n<td>削除（さくじょ 1）</td>\n<td>Delete</td>\n<td>删除</td>\n<td>删除</td>\n</tr>\n<tr>\n<td>破棄（はき 1）</td>\n<td>Discard</td>\n<td>废弃</td>\n<td>捨棄</td>\n</tr>\n<tr>\n<td>元に戻す（もとにもどす）</td>\n<td>Undo</td>\n<td>撤消</td>\n<td>復原</td>\n</tr>\n<tr>\n<td>開く（ひらく2）</td>\n<td>Open</td>\n<td>打开</td>\n<td>打開</td>\n</tr>\n<tr>\n<td>閉じる（とじる 2）</td>\n<td>Close</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>編集（へんしゅう）</td>\n<td>Edit</td>\n<td>编辑</td>\n<td>編輯</td>\n</tr>\n<tr>\n<td>表示（ひょうじ）</td>\n<td>View</td>\n<td>查看</td>\n<td>檢視</td>\n</tr>\n<tr>\n<td>送る（おくる）</td>\n<td>Send</td>\n<td>发送</td>\n<td>發送</td>\n</tr>\n<tr>\n<td>追加（ついか）</td>\n<td>Add</td>\n<td>添加</td>\n<td>加入</td>\n</tr>\n<tr>\n<td>新着（しんちゃく）</td>\n<td>New</td>\n<td>新增</td>\n<td>新增</td>\n</tr>\n<tr>\n<td>報告（ほうこく）</td>\n<td>Report</td>\n<td>举报</td>\n<td>回報</td>\n</tr>\n<tr>\n<td>マーク</td>\n<td>Mark</td>\n<td>标记</td>\n<td>標示</td>\n</tr>\n<tr>\n<td>再生（さいせい）</td>\n<td>Play</td>\n<td>播放</td>\n<td>播放</td>\n</tr>\n<tr>\n<td>一時停止（いちじていし）</td>\n<td>Pause</td>\n<td>暂停</td>\n<td>暫停</td>\n</tr>\n<tr>\n<td>停止（ていし）</td>\n<td>Stop</td>\n<td>停止</td>\n<td>停止</td>\n</tr>\n<tr>\n<td>登録（とうろく）</td>\n<td>Sign Up</td>\n<td>注册</td>\n<td>註冊</td>\n</tr>\n<tr>\n<td>ログイン</td>\n<td>Sign In / Log In</td>\n<td>登录</td>\n<td>登入</td>\n</tr>\n<tr>\n<td>ログアウト</td>\n<td>Sign Out / Log Out</td>\n<td>退出</td>\n<td>登出 / 退出</td>\n</tr>\n</tbody></table>"},{"title":"閩南語拼音方案怎樣選？","p":"language/min/how-to-select-pinyin-for-minnan-language","date":"2021-09-15T15:49:00.000Z","_content":"\n閩南語各個分支，甚至同個分支，使用了酷㩼毋平樣亓拼音方案，交流上酷毋方便，且讓人迷惑，毋知愛怎樣選擇。這次咱來談談幾種拼音方案，睇睇伊儂亓區別，佮提供幾點選擇亓意見。\n\n閩南語有悠久亓羅馬字傳統，19世紀亓傳教士麥都思等帶來了教會羅馬字。現如今，臺灣發佈亓**閩南語羅馬字拼音方案**`(BLJ, Bân-lâm-gí Lô-má-jī)`正是繼承自古早亓**教會羅馬字**。\n\n潮州話現在也有**現代潮汕閩語/潮州話羅馬字**`(MTR, Modern Teochew Romanized/Romanization)`，脫胎自19世紀傳教士傳入亓**潮州白話字**`(PUJ, Pêh-uē-jī)`。\n\n兩者平樣是脫胎自教會羅馬字，兼容性好。\n\n另一方面，廣東省教育部門於1960年9月公布了廣東話拼音方案，其中有**潮州話拼音方案**`(DP, Diê⁵ziu¹uê⁷ Pêng¹im¹ huang¹uan³)`。廈門大學於1982年10月推出了一套**閩南話拼音方案**`(BP, Bbínpīng)`。\n\n<!--more-->\n\n這兩者毋相兼容。\n\n除此之外，還有林林總總、各式各樣亓拼音方案。\n\n今日咱只比較這四種方案亓聲母、韻母佮聲調亓表示。這四種方案咱倒轉來睇下，分別是：\n\n1. BLJ：閩南語羅馬字\n2. MTR：現代潮州話羅馬字\n3. DP：潮州話拼音方案\n4. BP：閩南話拼音方案\n\n其中 BLJ 佮 MTR 可歸類爲**世界通用拼音系統**，簡稱 W 系統；DP 佮 BP 可以歸類爲**中國通用拼音系統**，簡稱 C 系統。兩種系統最明顯其區別就是 W 系統用 b, d , g 要標示濁音，而 C 系統用來表示不送氣清音，如下圖：\n\n![W系統佮C系統（來自網絡，侵權立刪）](how-to-select-pinyin-for-minnan-language/W系統和C系統.jpeg)\n\n具體到這四種方案，聲母亓區別如下：\n\n![聲母對比](how-to-select-pinyin-for-minnan-language/聲母.png)\n\n可見最主要亓區別除了前面呾亓塞音外，還有塞擦音。舉兩個例子分別說明：\n\n1. 表中序號4 有例字「無」，聲母爲雙唇-塞音-不送氣-濁音，BLJ 佮 MTR 記其聲母爲 b，而 BP 記爲 bb，DP 記爲 bh；\n2. 表中序號14 有例字「早」，聲母爲齒齦-塞擦音-不送氣-清音，BLJ 佮 MTR 記爲 ts，而 BP 佮 DP 記爲 z。\n\n仔細觀察，還可以發現同爲 C 系統亓 BP 佮 DP 並不兼容，而同爲 W 系統亓 BLJ 佮 MTR 基本兼容。\n\n再比較韻母，如下表`（無全部列出）`：\n\n![韻母對比](how-to-select-pinyin-for-minnan-language/韻母.png)\n\n可見最主要亓區別是 e / ê 亓表示、入聲韻`(-p, -t, -k, -h) `佮鼻化韻無平樣，舉例說明如下：\n\n1. 序號2有例字「蝦」，BLJ、MTR 佮 BP 記其韻母爲 e，而 DP 記爲 ê。而著序號8有例字「豬」，MTR 記爲 ur，而 DP 記爲 e，這是個酷潮州亓音，「豬」著其他地區韻母爲 u 或 i。\n2. 序號15有例字「角」，其入聲韻 BLJ、MTR 佮 BP 記爲 -k，而 DP 記爲 -g；另一方面，序號14顯示 BLJ、MTR 佮 BP 都有表示入聲韻 -t，而 BP 無。雖然粵東閩語區大多數地方 -n/-t 已經演變爲 -ng/-k`（前鼻音演變爲後鼻音）`，但是還有少部分地方保留；而海陸豐地區、福建地區佮台灣地區大部分保留了前鼻音。\n3. 序號11有例字「衫」，其鼻化韻 BLJ、MTR 記爲 nn / ⁿ，而 BP 記爲 n-，DP 記爲 -n。\n\nBLJ 佮 MTR 還是基本兼容，而 BP 佮 DP 並不兼容，且 BP 鼻化韻亓表示實在奇葩，用前綴 n；DP 哩無變表示前鼻音，且 ê 亓表示除了無變佮其他三種方案兼容外，還限制了伊只能用數字表示聲調。\n\n呾到聲調，不外乎四聲八調。雖然大多數地區已經無了陽上調，但著潮州話中還有保留。試比較如下：\n\n![聲調](how-to-select-pinyin-for-minnan-language/聲調.png)\n\n有幾個結論：\n\n1. BP 完全無陽上調亓表示，無變用來標示潮州話；\n2. DP 只能用數字調號。頭頂舉了 ê 亓例子；\n3. BLJ、MTR 相互兼容。\n\n比較了這四種方案，我個人亓睇法是`（僅供參考）`：\n\n1. **DP 佮 BP 屬於 C 系統，非常適合漢語拼音使用者入門；**\n2. **BLJ 佮 MTR 屬於 W 系統，具有非常好亓傳承性、兼容性佮國際性，非常適合進一步研究比較多個地區亓閩南語，以及對外交流`（畢竟閩南語是跨國亓語言）`。**\n\n早期我多用 DP 方案，以後我將以 BLJ 及 MTR 爲主。\n\n煞尾，用 BLJ 佮 MTR 上困難亓地方是拍這個調號。我尋著一款軟件可方便亓拍出這些調號，頭頂表格中亓聲調完全是用這款軟件拍出其。軟件亓下載鏈接著下骹：\n\n> 我用阿里雲盤分享了「TBHS」，你可以不限速下載🚀複製這段內容打開「阿里雲盤」App 即可獲取鏈接：https://www.aliyundrive.com/s/RhSRcQScacu\n\n有 Windows、Mac 佮 Linux 版，任君選擇。\n\n","source":"_posts/language/min/how-to-select-pinyin-for-minnan-language.md","raw":"---\ntitle: 閩南語拼音方案怎樣選？\np: language/min/how-to-select-pinyin-for-minnan-language\ndate: 2021-09-15 23:49:00\ntags:\n- 閩南語\n---\n\n閩南語各個分支，甚至同個分支，使用了酷㩼毋平樣亓拼音方案，交流上酷毋方便，且讓人迷惑，毋知愛怎樣選擇。這次咱來談談幾種拼音方案，睇睇伊儂亓區別，佮提供幾點選擇亓意見。\n\n閩南語有悠久亓羅馬字傳統，19世紀亓傳教士麥都思等帶來了教會羅馬字。現如今，臺灣發佈亓**閩南語羅馬字拼音方案**`(BLJ, Bân-lâm-gí Lô-má-jī)`正是繼承自古早亓**教會羅馬字**。\n\n潮州話現在也有**現代潮汕閩語/潮州話羅馬字**`(MTR, Modern Teochew Romanized/Romanization)`，脫胎自19世紀傳教士傳入亓**潮州白話字**`(PUJ, Pêh-uē-jī)`。\n\n兩者平樣是脫胎自教會羅馬字，兼容性好。\n\n另一方面，廣東省教育部門於1960年9月公布了廣東話拼音方案，其中有**潮州話拼音方案**`(DP, Diê⁵ziu¹uê⁷ Pêng¹im¹ huang¹uan³)`。廈門大學於1982年10月推出了一套**閩南話拼音方案**`(BP, Bbínpīng)`。\n\n<!--more-->\n\n這兩者毋相兼容。\n\n除此之外，還有林林總總、各式各樣亓拼音方案。\n\n今日咱只比較這四種方案亓聲母、韻母佮聲調亓表示。這四種方案咱倒轉來睇下，分別是：\n\n1. BLJ：閩南語羅馬字\n2. MTR：現代潮州話羅馬字\n3. DP：潮州話拼音方案\n4. BP：閩南話拼音方案\n\n其中 BLJ 佮 MTR 可歸類爲**世界通用拼音系統**，簡稱 W 系統；DP 佮 BP 可以歸類爲**中國通用拼音系統**，簡稱 C 系統。兩種系統最明顯其區別就是 W 系統用 b, d , g 要標示濁音，而 C 系統用來表示不送氣清音，如下圖：\n\n![W系統佮C系統（來自網絡，侵權立刪）](how-to-select-pinyin-for-minnan-language/W系統和C系統.jpeg)\n\n具體到這四種方案，聲母亓區別如下：\n\n![聲母對比](how-to-select-pinyin-for-minnan-language/聲母.png)\n\n可見最主要亓區別除了前面呾亓塞音外，還有塞擦音。舉兩個例子分別說明：\n\n1. 表中序號4 有例字「無」，聲母爲雙唇-塞音-不送氣-濁音，BLJ 佮 MTR 記其聲母爲 b，而 BP 記爲 bb，DP 記爲 bh；\n2. 表中序號14 有例字「早」，聲母爲齒齦-塞擦音-不送氣-清音，BLJ 佮 MTR 記爲 ts，而 BP 佮 DP 記爲 z。\n\n仔細觀察，還可以發現同爲 C 系統亓 BP 佮 DP 並不兼容，而同爲 W 系統亓 BLJ 佮 MTR 基本兼容。\n\n再比較韻母，如下表`（無全部列出）`：\n\n![韻母對比](how-to-select-pinyin-for-minnan-language/韻母.png)\n\n可見最主要亓區別是 e / ê 亓表示、入聲韻`(-p, -t, -k, -h) `佮鼻化韻無平樣，舉例說明如下：\n\n1. 序號2有例字「蝦」，BLJ、MTR 佮 BP 記其韻母爲 e，而 DP 記爲 ê。而著序號8有例字「豬」，MTR 記爲 ur，而 DP 記爲 e，這是個酷潮州亓音，「豬」著其他地區韻母爲 u 或 i。\n2. 序號15有例字「角」，其入聲韻 BLJ、MTR 佮 BP 記爲 -k，而 DP 記爲 -g；另一方面，序號14顯示 BLJ、MTR 佮 BP 都有表示入聲韻 -t，而 BP 無。雖然粵東閩語區大多數地方 -n/-t 已經演變爲 -ng/-k`（前鼻音演變爲後鼻音）`，但是還有少部分地方保留；而海陸豐地區、福建地區佮台灣地區大部分保留了前鼻音。\n3. 序號11有例字「衫」，其鼻化韻 BLJ、MTR 記爲 nn / ⁿ，而 BP 記爲 n-，DP 記爲 -n。\n\nBLJ 佮 MTR 還是基本兼容，而 BP 佮 DP 並不兼容，且 BP 鼻化韻亓表示實在奇葩，用前綴 n；DP 哩無變表示前鼻音，且 ê 亓表示除了無變佮其他三種方案兼容外，還限制了伊只能用數字表示聲調。\n\n呾到聲調，不外乎四聲八調。雖然大多數地區已經無了陽上調，但著潮州話中還有保留。試比較如下：\n\n![聲調](how-to-select-pinyin-for-minnan-language/聲調.png)\n\n有幾個結論：\n\n1. BP 完全無陽上調亓表示，無變用來標示潮州話；\n2. DP 只能用數字調號。頭頂舉了 ê 亓例子；\n3. BLJ、MTR 相互兼容。\n\n比較了這四種方案，我個人亓睇法是`（僅供參考）`：\n\n1. **DP 佮 BP 屬於 C 系統，非常適合漢語拼音使用者入門；**\n2. **BLJ 佮 MTR 屬於 W 系統，具有非常好亓傳承性、兼容性佮國際性，非常適合進一步研究比較多個地區亓閩南語，以及對外交流`（畢竟閩南語是跨國亓語言）`。**\n\n早期我多用 DP 方案，以後我將以 BLJ 及 MTR 爲主。\n\n煞尾，用 BLJ 佮 MTR 上困難亓地方是拍這個調號。我尋著一款軟件可方便亓拍出這些調號，頭頂表格中亓聲調完全是用這款軟件拍出其。軟件亓下載鏈接著下骹：\n\n> 我用阿里雲盤分享了「TBHS」，你可以不限速下載🚀複製這段內容打開「阿里雲盤」App 即可獲取鏈接：https://www.aliyundrive.com/s/RhSRcQScacu\n\n有 Windows、Mac 佮 Linux 版，任君選擇。\n\n","slug":"language/min/how-to-select-pinyin-for-minnan-language","published":1,"updated":"2021-09-17T14:34:14.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlf200101n9kc10m1m16","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>閩南語各個分支，甚至同個分支，使用了酷㩼毋平樣亓拼音方案，交流上酷毋方便，且讓人迷惑，毋知愛怎樣選擇。這次咱來談談幾種拼音方案，睇睇伊儂亓區別，佮提供幾點選擇亓意見。</p>\n<p>閩南語有悠久亓羅馬字傳統，19世紀亓傳教士麥都思等帶來了教會羅馬字。現如今，臺灣發佈亓<strong>閩南語羅馬字拼音方案</strong><code>(BLJ, Bân-lâm-gí Lô-má-jī)</code>正是繼承自古早亓<strong>教會羅馬字</strong>。</p>\n<p>潮州話現在也有<strong>現代潮汕閩語/潮州話羅馬字</strong><code>(MTR, Modern Teochew Romanized/Romanization)</code>，脫胎自19世紀傳教士傳入亓<strong>潮州白話字</strong><code>(PUJ, Pêh-uē-jī)</code>。</p>\n<p>兩者平樣是脫胎自教會羅馬字，兼容性好。</p>\n<p>另一方面，廣東省教育部門於1960年9月公布了廣東話拼音方案，其中有<strong>潮州話拼音方案</strong><code>(DP, Diê⁵ziu¹uê⁷ Pêng¹im¹ huang¹uan³)</code>。廈門大學於1982年10月推出了一套<strong>閩南話拼音方案</strong><code>(BP, Bbínpīng)</code>。</p>\n<span id=\"more\"></span>\n\n<p>這兩者毋相兼容。</p>\n<p>除此之外，還有林林總總、各式各樣亓拼音方案。</p>\n<p>今日咱只比較這四種方案亓聲母、韻母佮聲調亓表示。這四種方案咱倒轉來睇下，分別是：</p>\n<ol>\n<li>BLJ：閩南語羅馬字</li>\n<li>MTR：現代潮州話羅馬字</li>\n<li>DP：潮州話拼音方案</li>\n<li>BP：閩南話拼音方案</li>\n</ol>\n<p>其中 BLJ 佮 MTR 可歸類爲<strong>世界通用拼音系統</strong>，簡稱 W 系統；DP 佮 BP 可以歸類爲<strong>中國通用拼音系統</strong>，簡稱 C 系統。兩種系統最明顯其區別就是 W 系統用 b, d , g 要標示濁音，而 C 系統用來表示不送氣清音，如下圖：</p>\n<p><img src=\"/language/min/how-to-select-pinyin-for-minnan-language/W%E7%B3%BB%E7%B5%B1%E5%92%8CC%E7%B3%BB%E7%B5%B1.jpeg\" alt=\"W系統佮C系統（來自網絡，侵權立刪）\"></p>\n<p>具體到這四種方案，聲母亓區別如下：</p>\n<p><img src=\"/language/min/how-to-select-pinyin-for-minnan-language/%E8%81%B2%E6%AF%8D.png\" alt=\"聲母對比\"></p>\n<p>可見最主要亓區別除了前面呾亓塞音外，還有塞擦音。舉兩個例子分別說明：</p>\n<ol>\n<li>表中序號4 有例字「無」，聲母爲雙唇-塞音-不送氣-濁音，BLJ 佮 MTR 記其聲母爲 b，而 BP 記爲 bb，DP 記爲 bh；</li>\n<li>表中序號14 有例字「早」，聲母爲齒齦-塞擦音-不送氣-清音，BLJ 佮 MTR 記爲 ts，而 BP 佮 DP 記爲 z。</li>\n</ol>\n<p>仔細觀察，還可以發現同爲 C 系統亓 BP 佮 DP 並不兼容，而同爲 W 系統亓 BLJ 佮 MTR 基本兼容。</p>\n<p>再比較韻母，如下表<code>（無全部列出）</code>：</p>\n<p><img src=\"/language/min/how-to-select-pinyin-for-minnan-language/%E9%9F%BB%E6%AF%8D.png\" alt=\"韻母對比\"></p>\n<p>可見最主要亓區別是 e / ê 亓表示、入聲韻<code>(-p, -t, -k, -h)</code>佮鼻化韻無平樣，舉例說明如下：</p>\n<ol>\n<li>序號2有例字「蝦」，BLJ、MTR 佮 BP 記其韻母爲 e，而 DP 記爲 ê。而著序號8有例字「豬」，MTR 記爲 ur，而 DP 記爲 e，這是個酷潮州亓音，「豬」著其他地區韻母爲 u 或 i。</li>\n<li>序號15有例字「角」，其入聲韻 BLJ、MTR 佮 BP 記爲 -k，而 DP 記爲 -g；另一方面，序號14顯示 BLJ、MTR 佮 BP 都有表示入聲韻 -t，而 BP 無。雖然粵東閩語區大多數地方 -n/-t 已經演變爲 -ng/-k<code>（前鼻音演變爲後鼻音）</code>，但是還有少部分地方保留；而海陸豐地區、福建地區佮台灣地區大部分保留了前鼻音。</li>\n<li>序號11有例字「衫」，其鼻化韻 BLJ、MTR 記爲 nn / ⁿ，而 BP 記爲 n-，DP 記爲 -n。</li>\n</ol>\n<p>BLJ 佮 MTR 還是基本兼容，而 BP 佮 DP 並不兼容，且 BP 鼻化韻亓表示實在奇葩，用前綴 n；DP 哩無變表示前鼻音，且 ê 亓表示除了無變佮其他三種方案兼容外，還限制了伊只能用數字表示聲調。</p>\n<p>呾到聲調，不外乎四聲八調。雖然大多數地區已經無了陽上調，但著潮州話中還有保留。試比較如下：</p>\n<p><img src=\"/language/min/how-to-select-pinyin-for-minnan-language/%E8%81%B2%E8%AA%BF.png\" alt=\"聲調\"></p>\n<p>有幾個結論：</p>\n<ol>\n<li>BP 完全無陽上調亓表示，無變用來標示潮州話；</li>\n<li>DP 只能用數字調號。頭頂舉了 ê 亓例子；</li>\n<li>BLJ、MTR 相互兼容。</li>\n</ol>\n<p>比較了這四種方案，我個人亓睇法是<code>（僅供參考）</code>：</p>\n<ol>\n<li><strong>DP 佮 BP 屬於 C 系統，非常適合漢語拼音使用者入門；</strong></li>\n<li><strong>BLJ 佮 MTR 屬於 W 系統，具有非常好亓傳承性、兼容性佮國際性，非常適合進一步研究比較多個地區亓閩南語，以及對外交流<code>（畢竟閩南語是跨國亓語言）</code>。</strong></li>\n</ol>\n<p>早期我多用 DP 方案，以後我將以 BLJ 及 MTR 爲主。</p>\n<p>煞尾，用 BLJ 佮 MTR 上困難亓地方是拍這個調號。我尋著一款軟件可方便亓拍出這些調號，頭頂表格中亓聲調完全是用這款軟件拍出其。軟件亓下載鏈接著下骹：</p>\n<blockquote>\n<p>我用阿里雲盤分享了「TBHS」，你可以不限速下載🚀複製這段內容打開「阿里雲盤」App 即可獲取鏈接：<a href=\"https://www.aliyundrive.com/s/RhSRcQScacu\">https://www.aliyundrive.com/s/RhSRcQScacu</a></p>\n</blockquote>\n<p>有 Windows、Mac 佮 Linux 版，任君選擇。</p>\n","site":{"data":{}},"excerpt":"<p>閩南語各個分支，甚至同個分支，使用了酷㩼毋平樣亓拼音方案，交流上酷毋方便，且讓人迷惑，毋知愛怎樣選擇。這次咱來談談幾種拼音方案，睇睇伊儂亓區別，佮提供幾點選擇亓意見。</p>\n<p>閩南語有悠久亓羅馬字傳統，19世紀亓傳教士麥都思等帶來了教會羅馬字。現如今，臺灣發佈亓<strong>閩南語羅馬字拼音方案</strong><code>(BLJ, Bân-lâm-gí Lô-má-jī)</code>正是繼承自古早亓<strong>教會羅馬字</strong>。</p>\n<p>潮州話現在也有<strong>現代潮汕閩語/潮州話羅馬字</strong><code>(MTR, Modern Teochew Romanized/Romanization)</code>，脫胎自19世紀傳教士傳入亓<strong>潮州白話字</strong><code>(PUJ, Pêh-uē-jī)</code>。</p>\n<p>兩者平樣是脫胎自教會羅馬字，兼容性好。</p>\n<p>另一方面，廣東省教育部門於1960年9月公布了廣東話拼音方案，其中有<strong>潮州話拼音方案</strong><code>(DP, Diê⁵ziu¹uê⁷ Pêng¹im¹ huang¹uan³)</code>。廈門大學於1982年10月推出了一套<strong>閩南話拼音方案</strong><code>(BP, Bbínpīng)</code>。</p>","more":"<p>這兩者毋相兼容。</p>\n<p>除此之外，還有林林總總、各式各樣亓拼音方案。</p>\n<p>今日咱只比較這四種方案亓聲母、韻母佮聲調亓表示。這四種方案咱倒轉來睇下，分別是：</p>\n<ol>\n<li>BLJ：閩南語羅馬字</li>\n<li>MTR：現代潮州話羅馬字</li>\n<li>DP：潮州話拼音方案</li>\n<li>BP：閩南話拼音方案</li>\n</ol>\n<p>其中 BLJ 佮 MTR 可歸類爲<strong>世界通用拼音系統</strong>，簡稱 W 系統；DP 佮 BP 可以歸類爲<strong>中國通用拼音系統</strong>，簡稱 C 系統。兩種系統最明顯其區別就是 W 系統用 b, d , g 要標示濁音，而 C 系統用來表示不送氣清音，如下圖：</p>\n<p><img src=\"/language/min/how-to-select-pinyin-for-minnan-language/W%E7%B3%BB%E7%B5%B1%E5%92%8CC%E7%B3%BB%E7%B5%B1.jpeg\" alt=\"W系統佮C系統（來自網絡，侵權立刪）\"></p>\n<p>具體到這四種方案，聲母亓區別如下：</p>\n<p><img src=\"/language/min/how-to-select-pinyin-for-minnan-language/%E8%81%B2%E6%AF%8D.png\" alt=\"聲母對比\"></p>\n<p>可見最主要亓區別除了前面呾亓塞音外，還有塞擦音。舉兩個例子分別說明：</p>\n<ol>\n<li>表中序號4 有例字「無」，聲母爲雙唇-塞音-不送氣-濁音，BLJ 佮 MTR 記其聲母爲 b，而 BP 記爲 bb，DP 記爲 bh；</li>\n<li>表中序號14 有例字「早」，聲母爲齒齦-塞擦音-不送氣-清音，BLJ 佮 MTR 記爲 ts，而 BP 佮 DP 記爲 z。</li>\n</ol>\n<p>仔細觀察，還可以發現同爲 C 系統亓 BP 佮 DP 並不兼容，而同爲 W 系統亓 BLJ 佮 MTR 基本兼容。</p>\n<p>再比較韻母，如下表<code>（無全部列出）</code>：</p>\n<p><img src=\"/language/min/how-to-select-pinyin-for-minnan-language/%E9%9F%BB%E6%AF%8D.png\" alt=\"韻母對比\"></p>\n<p>可見最主要亓區別是 e / ê 亓表示、入聲韻<code>(-p, -t, -k, -h)</code>佮鼻化韻無平樣，舉例說明如下：</p>\n<ol>\n<li>序號2有例字「蝦」，BLJ、MTR 佮 BP 記其韻母爲 e，而 DP 記爲 ê。而著序號8有例字「豬」，MTR 記爲 ur，而 DP 記爲 e，這是個酷潮州亓音，「豬」著其他地區韻母爲 u 或 i。</li>\n<li>序號15有例字「角」，其入聲韻 BLJ、MTR 佮 BP 記爲 -k，而 DP 記爲 -g；另一方面，序號14顯示 BLJ、MTR 佮 BP 都有表示入聲韻 -t，而 BP 無。雖然粵東閩語區大多數地方 -n/-t 已經演變爲 -ng/-k<code>（前鼻音演變爲後鼻音）</code>，但是還有少部分地方保留；而海陸豐地區、福建地區佮台灣地區大部分保留了前鼻音。</li>\n<li>序號11有例字「衫」，其鼻化韻 BLJ、MTR 記爲 nn / ⁿ，而 BP 記爲 n-，DP 記爲 -n。</li>\n</ol>\n<p>BLJ 佮 MTR 還是基本兼容，而 BP 佮 DP 並不兼容，且 BP 鼻化韻亓表示實在奇葩，用前綴 n；DP 哩無變表示前鼻音，且 ê 亓表示除了無變佮其他三種方案兼容外，還限制了伊只能用數字表示聲調。</p>\n<p>呾到聲調，不外乎四聲八調。雖然大多數地區已經無了陽上調，但著潮州話中還有保留。試比較如下：</p>\n<p><img src=\"/language/min/how-to-select-pinyin-for-minnan-language/%E8%81%B2%E8%AA%BF.png\" alt=\"聲調\"></p>\n<p>有幾個結論：</p>\n<ol>\n<li>BP 完全無陽上調亓表示，無變用來標示潮州話；</li>\n<li>DP 只能用數字調號。頭頂舉了 ê 亓例子；</li>\n<li>BLJ、MTR 相互兼容。</li>\n</ol>\n<p>比較了這四種方案，我個人亓睇法是<code>（僅供參考）</code>：</p>\n<ol>\n<li><strong>DP 佮 BP 屬於 C 系統，非常適合漢語拼音使用者入門；</strong></li>\n<li><strong>BLJ 佮 MTR 屬於 W 系統，具有非常好亓傳承性、兼容性佮國際性，非常適合進一步研究比較多個地區亓閩南語，以及對外交流<code>（畢竟閩南語是跨國亓語言）</code>。</strong></li>\n</ol>\n<p>早期我多用 DP 方案，以後我將以 BLJ 及 MTR 爲主。</p>\n<p>煞尾，用 BLJ 佮 MTR 上困難亓地方是拍這個調號。我尋著一款軟件可方便亓拍出這些調號，頭頂表格中亓聲調完全是用這款軟件拍出其。軟件亓下載鏈接著下骹：</p>\n<blockquote>\n<p>我用阿里雲盤分享了「TBHS」，你可以不限速下載🚀複製這段內容打開「阿里雲盤」App 即可獲取鏈接：<a href=\"https://www.aliyundrive.com/s/RhSRcQScacu\">https://www.aliyundrive.com/s/RhSRcQScacu</a></p>\n</blockquote>\n<p>有 Windows、Mac 佮 Linux 版，任君選擇。</p>"},{"title":"nâng-tu-kāng-ím(人豬共飲)","p":"language/min/nang-tu-kang-im","date":"2021-09-28T14:16:00.000Z","_content":"\n![Àng(甕)](nang-tu-kang-im/ang.jpg)\n\nSènn Nguáng(阮) kâi nâng tsôi`--`ik sǐ hoh`--`ǒi tsia̍h-tsiú`--`âi. Ǔ tse̍k`--`ji̍k, Nguáng Hâm(阮咸) kah i`--`âi tso̍k-nâng tsia̍h tsiú, ēng tuā àng. Tsia̍h-tiānn-nînn, ǔ tse̍k`--`kûng tu phīnn-tioh phang-bhī tshong`--`ji̍p-lâi. Suà tsôi`--`ik tsia̍h tsiú.\n\n<!--more-->\n\n姓阮其人齊一是酷會食酒亓。有一日，阮咸佮伊亓族人食酒，用大甕。食定然，有一群豬鼻著芳味衝入來。Suà 齊一食酒。\n\n------\n\n（普通话）\n\n姓阮的人都是很会喝酒的。有一天，阮咸跟他的族人喝酒，用大瓮。正喝着，有一群猪闻到香味冲进来。于是一起喝酒。\n\n","source":"_posts/language/min/nang-tu-kang-im.md","raw":"---\ntitle: nâng-tu-kāng-ím(人豬共飲)\np: language/min/nang-tu-kang-im\ndate: 2021-09-28 22:16:00\ntags:\n- 魏晉風流\n- 甲子話\n- 閩南語\n---\n\n![Àng(甕)](nang-tu-kang-im/ang.jpg)\n\nSènn Nguáng(阮) kâi nâng tsôi`--`ik sǐ hoh`--`ǒi tsia̍h-tsiú`--`âi. Ǔ tse̍k`--`ji̍k, Nguáng Hâm(阮咸) kah i`--`âi tso̍k-nâng tsia̍h tsiú, ēng tuā àng. Tsia̍h-tiānn-nînn, ǔ tse̍k`--`kûng tu phīnn-tioh phang-bhī tshong`--`ji̍p-lâi. Suà tsôi`--`ik tsia̍h tsiú.\n\n<!--more-->\n\n姓阮其人齊一是酷會食酒亓。有一日，阮咸佮伊亓族人食酒，用大甕。食定然，有一群豬鼻著芳味衝入來。Suà 齊一食酒。\n\n------\n\n（普通话）\n\n姓阮的人都是很会喝酒的。有一天，阮咸跟他的族人喝酒，用大瓮。正喝着，有一群猪闻到香味冲进来。于是一起喝酒。\n\n","slug":"language/min/nang-tu-kang-im","published":1,"updated":"2021-09-29T13:57:12.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfi002m1n9k7l3q8948","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><img src=\"/language/min/nang-tu-kang-im/ang.jpg\" alt=\"Àng(甕)\"></p>\n<p>Sènn Nguáng(阮) kâi nâng tsôi<code>--</code>ik sǐ hoh<code>--</code>ǒi tsia̍h-tsiú<code>--</code>âi. Ǔ tse̍k<code>--</code>ji̍k, Nguáng Hâm(阮咸) kah i<code>--</code>âi tso̍k-nâng tsia̍h tsiú, ēng tuā àng. Tsia̍h-tiānn-nînn, ǔ tse̍k<code>--</code>kûng tu phīnn-tioh phang-bhī tshong<code>--</code>ji̍p-lâi. Suà tsôi<code>--</code>ik tsia̍h tsiú.</p>\n<span id=\"more\"></span>\n\n<p>姓阮其人齊一是酷會食酒亓。有一日，阮咸佮伊亓族人食酒，用大甕。食定然，有一群豬鼻著芳味衝入來。Suà 齊一食酒。</p>\n<hr>\n<p>（普通话）</p>\n<p>姓阮的人都是很会喝酒的。有一天，阮咸跟他的族人喝酒，用大瓮。正喝着，有一群猪闻到香味冲进来。于是一起喝酒。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/language/min/nang-tu-kang-im/ang.jpg\" alt=\"Àng(甕)\"></p>\n<p>Sènn Nguáng(阮) kâi nâng tsôi<code>--</code>ik sǐ hoh<code>--</code>ǒi tsia̍h-tsiú<code>--</code>âi. Ǔ tse̍k<code>--</code>ji̍k, Nguáng Hâm(阮咸) kah i<code>--</code>âi tso̍k-nâng tsia̍h tsiú, ēng tuā àng. Tsia̍h-tiānn-nînn, ǔ tse̍k<code>--</code>kûng tu phīnn-tioh phang-bhī tshong<code>--</code>ji̍p-lâi. Suà tsôi<code>--</code>ik tsia̍h tsiú.</p>","more":"<p>姓阮其人齊一是酷會食酒亓。有一日，阮咸佮伊亓族人食酒，用大甕。食定然，有一群豬鼻著芳味衝入來。Suà 齊一食酒。</p>\n<hr>\n<p>（普通话）</p>\n<p>姓阮的人都是很会喝酒的。有一天，阮咸跟他的族人喝酒，用大瓮。正喝着，有一群猪闻到香味冲进来。于是一起喝酒。</p>"},{"title":"《破陣子·爲陳同甫賦壯詞以寄之》陸豐甲子話閩羅注音朗讀","p":"language/min/phua-ting-tsu-ui-tang-thong-phou","date":"2021-11-02T23:38:07.000Z","_content":"\n《Puà-tīng-tsú, Uî Tâng Thông-phóu hù tsàng-sû í kià tsu》Sing Khì-tsi̍p\n\nTsuì-lí thiàu teng khàng kiàm, māng hôi tshoi kak liâng êng.\nPueh-peh lí hung hui-ě tsià, ngou-tsa̍p hînn huang sài-guā siann.\nSua-tiônn tsiu tiám piânn.\n\nBé zak te̍k-lû pue-khuài, keng jû phek-le̍h hînn kiann.\n\n\n<!--more-->\n\n《破陣子·爲陳同甫賦壯詞以寄之》辛棄疾\n\n醉裡挑燈看劍，夢回吹角連營。\n八百里分麾下炙，五十弦翻塞外聲。\n沙場秋點兵。\n\n馬作的盧飛快，弓如霹靂弦驚。\n了卻君王天下事，贏得生前身後名。\n可憐白髮生。\n\n","source":"_posts/language/min/phua-ting-tsu-ui-tang-thong-phou.md","raw":"---\ntitle: 《破陣子·爲陳同甫賦壯詞以寄之》陸豐甲子話閩羅注音朗讀\np: language/min/phua-ting-tsu-ui-tang-thong-phou\ndate: 2021-11-03 07:38:07\ntags:\n- 宋詞\n- 甲子話\n- 閩南語\n---\n\n《Puà-tīng-tsú, Uî Tâng Thông-phóu hù tsàng-sû í kià tsu》Sing Khì-tsi̍p\n\nTsuì-lí thiàu teng khàng kiàm, māng hôi tshoi kak liâng êng.\nPueh-peh lí hung hui-ě tsià, ngou-tsa̍p hînn huang sài-guā siann.\nSua-tiônn tsiu tiám piânn.\n\nBé zak te̍k-lû pue-khuài, keng jû phek-le̍h hînn kiann.\n\n\n<!--more-->\n\n《破陣子·爲陳同甫賦壯詞以寄之》辛棄疾\n\n醉裡挑燈看劍，夢回吹角連營。\n八百里分麾下炙，五十弦翻塞外聲。\n沙場秋點兵。\n\n馬作的盧飛快，弓如霹靂弦驚。\n了卻君王天下事，贏得生前身後名。\n可憐白髮生。\n\n","slug":"language/min/phua-ting-tsu-ui-tang-thong-phou","published":1,"updated":"2021-11-02T23:57:16.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfj002n1n9k6p10dnom","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>《Puà-tīng-tsú, Uî Tâng Thông-phóu hù tsàng-sû í kià tsu》Sing Khì-tsi̍p</p>\n<p>Tsuì-lí thiàu teng khàng kiàm, māng hôi tshoi kak liâng êng.<br>Pueh-peh lí hung hui-ě tsià, ngou-tsa̍p hînn huang sài-guā siann.<br>Sua-tiônn tsiu tiám piânn.</p>\n<p>Bé zak te̍k-lû pue-khuài, keng jû phek-le̍h hînn kiann.</p>\n<span id=\"more\"></span>\n\n<p>《破陣子·爲陳同甫賦壯詞以寄之》辛棄疾</p>\n<p>醉裡挑燈看劍，夢回吹角連營。<br>八百里分麾下炙，五十弦翻塞外聲。<br>沙場秋點兵。</p>\n<p>馬作的盧飛快，弓如霹靂弦驚。<br>了卻君王天下事，贏得生前身後名。<br>可憐白髮生。</p>\n","site":{"data":{}},"excerpt":"<p>《Puà-tīng-tsú, Uî Tâng Thông-phóu hù tsàng-sû í kià tsu》Sing Khì-tsi̍p</p>\n<p>Tsuì-lí thiàu teng khàng kiàm, māng hôi tshoi kak liâng êng.<br>Pueh-peh lí hung hui-ě tsià, ngou-tsa̍p hînn huang sài-guā siann.<br>Sua-tiônn tsiu tiám piânn.</p>\n<p>Bé zak te̍k-lû pue-khuài, keng jû phek-le̍h hînn kiann.</p>","more":"<p>《破陣子·爲陳同甫賦壯詞以寄之》辛棄疾</p>\n<p>醉裡挑燈看劍，夢回吹角連營。<br>八百里分麾下炙，五十弦翻塞外聲。<br>沙場秋點兵。</p>\n<p>馬作的盧飛快，弓如霹靂弦驚。<br>了卻君王天下事，贏得生前身後名。<br>可憐白髮生。</p>"},{"title":"詩經·秦風‧蒹葭 (甲子話注音版)","p":"language/min/sigêng-giamgia","date":"2020-10-06T06:10:00.000Z","_content":"\n![](sigêng-giamgia/202010060948.jpg)\n\n{% aplayer \"蒹葭\" \"Hua\" \"/language/min/sigêng-giamgia/蒹葭.m4a\" \"/music.png\" %}\n\n蒹葭[^1]蒼蒼[^2]，白露爲霜。所謂伊人，在水一方。溯洄[^3]從之，道阻且長。溯游[^4]從之，宛在水中央。[^5]\ngiam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.\n\n蒹葭萋萋，白露未晞[^6]。所謂伊人，在水之湄[^7]。溯洄從之，道阻且躋。溯游從之，宛在水中坻[^8]。[^9]\ngiam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².\n\n蒹葭采采，白露未已[^10]。所謂伊人，在水之涘[^11]。溯洄從之，道阻且右[^12]。溯游從之，宛在水中沚[^13]。[^14]_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².\n\n<!--more-->\n\n[^1]:\t「蒹」，荻草；「葭」，蘆草。\n\n[^2]:\t按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\n\n[^3]:\t逆著河流走。\n\n[^4]:\t順著河流走。\n\n[^5]:\t蒼、霜、方、長、央，陽部。\n\n[^6]:\t露水未乾。\n\n[^7]:\t水草交接處，即岸邊。\n\n[^8]:\t水中小沙洲。\n\n[^9]:\t萋、晞、湄、躋、坻，脂部。\n\n[^10]:\t「已」完全。言露水還未完全乾。\n\n[^11]:\t岸邊。\n\n[^12]:\t水路彎曲。\n\n[^13]:\t水中小沙洲。\n\n[^14]:\t采、已、涘、右、沚，之部。","source":"_posts/language/min/sigêng-giamgia.md","raw":"---\ntitle: 詩經·秦風‧蒹葭 (甲子話注音版)\np: language/min/sigêng-giamgia\ndate: 2020-10-06 14:10:00\ntags:\n- 詩經\n- 甲子話\n- 閩南語\n---\n\n![](sigêng-giamgia/202010060948.jpg)\n\n{% aplayer \"蒹葭\" \"Hua\" \"/language/min/sigêng-giamgia/蒹葭.m4a\" \"/music.png\" %}\n\n蒹葭[^1]蒼蒼[^2]，白露爲霜。所謂伊人，在水一方。溯洄[^3]從之，道阻且長。溯游[^4]從之，宛在水中央。[^5]\ngiam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.\n\n蒹葭萋萋，白露未晞[^6]。所謂伊人，在水之湄[^7]。溯洄從之，道阻且躋。溯游從之，宛在水中坻[^8]。[^9]\ngiam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².\n\n蒹葭采采，白露未已[^10]。所謂伊人，在水之涘[^11]。溯洄從之，道阻且右[^12]。溯游從之，宛在水中沚[^13]。[^14]_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².\n\n<!--more-->\n\n[^1]:\t「蒹」，荻草；「葭」，蘆草。\n\n[^2]:\t按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\n\n[^3]:\t逆著河流走。\n\n[^4]:\t順著河流走。\n\n[^5]:\t蒼、霜、方、長、央，陽部。\n\n[^6]:\t露水未乾。\n\n[^7]:\t水草交接處，即岸邊。\n\n[^8]:\t水中小沙洲。\n\n[^9]:\t萋、晞、湄、躋、坻，脂部。\n\n[^10]:\t「已」完全。言露水還未完全乾。\n\n[^11]:\t岸邊。\n\n[^12]:\t水路彎曲。\n\n[^13]:\t水中小沙洲。\n\n[^14]:\t采、已、涘、右、沚，之部。","slug":"language/min/sigêng-giamgia","published":1,"updated":"2021-11-01T16:01:50.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfk002p1n9kcobp0u87","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><img src=\"/language/min/sig%C3%AAng-giamgia/202010060948.jpg\" alt></p>\n\n        <div id=\"aplayer-qgNeriuf\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-qgNeriuf\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"蒹葭\",\n              author: \"Hua\",\n              url: \"/language/min/sigêng-giamgia/蒹葭.m4a\",\n              pic: \"/music.png\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<p>蒹葭<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「蒹」，荻草；「葭」，蘆草。\">[1]</span></a></sup>蒼蒼<sup id=\"fnref:2\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\">[2]</span></a></sup>，白露爲霜。所謂伊人，在水一方。溯洄<sup id=\"fnref:3\"><a href=\"#fn:3\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    逆著河流走。\">[3]</span></a></sup>從之，道阻且長。溯游<sup id=\"fnref:4\"><a href=\"#fn:4\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    順著河流走。\">[4]</span></a></sup>從之，宛在水中央。<sup id=\"fnref:5\"><a href=\"#fn:5\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    蒼、霜、方、長、央，陽部。\">[5]</span></a></sup><br>giam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.</p>\n<p>蒹葭萋萋，白露未晞<sup id=\"fnref:6\"><a href=\"#fn:6\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    露水未乾。\">[6]</span></a></sup>。所謂伊人，在水之湄<sup id=\"fnref:7\"><a href=\"#fn:7\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水草交接處，即岸邊。\">[7]</span></a></sup>。溯洄從之，道阻且躋。溯游從之，宛在水中坻<sup id=\"fnref:8\"><a href=\"#fn:8\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[8]</span></a></sup>。<sup id=\"fnref:9\"><a href=\"#fn:9\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    萋、晞、湄、躋、坻，脂部。\">[9]</span></a></sup><br>giam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².</p>\n<p>蒹葭采采，白露未已<sup id=\"fnref:10\"><a href=\"#fn:10\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「已」完全。言露水還未完全乾。\">[10]</span></a></sup>。所謂伊人，在水之涘<sup id=\"fnref:11\"><a href=\"#fn:11\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    岸邊。\">[11]</span></a></sup>。溯洄從之，道阻且右<sup id=\"fnref:12\"><a href=\"#fn:12\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水路彎曲。\">[12]</span></a></sup>。溯游從之，宛在水中沚<sup id=\"fnref:13\"><a href=\"#fn:13\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[13]</span></a></sup>。<sup id=\"fnref:14\"><a href=\"#fn:14\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    采、已、涘、右、沚，之部。\">[14]</span></a></sup>_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².</p>\n<span id=\"more\"></span>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<div id=\"footnotes\"><hr><div id=\"footnotelist\"><ol style=\"list-style: none; padding-left: 0; margin-left: 40px\"><li id=\"fn:1\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">1.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「蒹」，荻草；「葭」，蘆草。<a href=\"#fnref:1\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:2\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">2.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。<a href=\"#fnref:2\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:3\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">3.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">逆著河流走。<a href=\"#fnref:3\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:4\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">4.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">順著河流走。<a href=\"#fnref:4\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:5\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">5.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">蒼、霜、方、長、央，陽部。<a href=\"#fnref:5\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:6\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">6.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">露水未乾。<a href=\"#fnref:6\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:7\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">7.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水草交接處，即岸邊。<a href=\"#fnref:7\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:8\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">8.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:8\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:9\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">9.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">萋、晞、湄、躋、坻，脂部。<a href=\"#fnref:9\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:10\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">10.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「已」完全。言露水還未完全乾。<a href=\"#fnref:10\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:11\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">11.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">岸邊。<a href=\"#fnref:11\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:12\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">12.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水路彎曲。<a href=\"#fnref:12\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:13\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">13.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:13\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:14\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">14.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">采、已、涘、右、沚，之部。<a href=\"#fnref:14\" rev=\"footnote\"> ↩</a></span></li></ol></div></div>","site":{"data":{}},"excerpt":"<p><img src=\"/language/min/sig%C3%AAng-giamgia/202010060948.jpg\" alt></p>\n\n        <div id=\"aplayer-qgNeriuf\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-qgNeriuf\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"蒹葭\",\n              author: \"Hua\",\n              url: \"/language/min/sigêng-giamgia/蒹葭.m4a\",\n              pic: \"/music.png\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<p>蒹葭<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「蒹」，荻草；「葭」，蘆草。\">[1]</span></a></sup>蒼蒼<sup id=\"fnref:2\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\">[2]</span></a></sup>，白露爲霜。所謂伊人，在水一方。溯洄<sup id=\"fnref:3\"><a href=\"#fn:3\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    逆著河流走。\">[3]</span></a></sup>從之，道阻且長。溯游<sup id=\"fnref:4\"><a href=\"#fn:4\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    順著河流走。\">[4]</span></a></sup>從之，宛在水中央。<sup id=\"fnref:5\"><a href=\"#fn:5\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    蒼、霜、方、長、央，陽部。\">[5]</span></a></sup><br>giam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.</p>\n<p>蒹葭萋萋，白露未晞<sup id=\"fnref:6\"><a href=\"#fn:6\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    露水未乾。\">[6]</span></a></sup>。所謂伊人，在水之湄<sup id=\"fnref:7\"><a href=\"#fn:7\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水草交接處，即岸邊。\">[7]</span></a></sup>。溯洄從之，道阻且躋。溯游從之，宛在水中坻<sup id=\"fnref:8\"><a href=\"#fn:8\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[8]</span></a></sup>。<sup id=\"fnref:9\"><a href=\"#fn:9\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    萋、晞、湄、躋、坻，脂部。\">[9]</span></a></sup><br>giam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².</p>\n<p>蒹葭采采，白露未已<sup id=\"fnref:10\"><a href=\"#fn:10\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「已」完全。言露水還未完全乾。\">[10]</span></a></sup>。所謂伊人，在水之涘<sup id=\"fnref:11\"><a href=\"#fn:11\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    岸邊。\">[11]</span></a></sup>。溯洄從之，道阻且右<sup id=\"fnref:12\"><a href=\"#fn:12\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水路彎曲。\">[12]</span></a></sup>。溯游從之，宛在水中沚<sup id=\"fnref:13\"><a href=\"#fn:13\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[13]</span></a></sup>。<sup id=\"fnref:14\"><a href=\"#fn:14\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    采、已、涘、右、沚，之部。\">[14]</span></a></sup>_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².</p>","more":"<div id=\"footnotes\"><hr><div id=\"footnotelist\"><ol style=\"list-style: none; padding-left: 0; margin-left: 40px\"><li id=\"fn:1\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">1.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「蒹」，荻草；「葭」，蘆草。<a href=\"#fnref:1\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:2\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">2.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。<a href=\"#fnref:2\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:3\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">3.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">逆著河流走。<a href=\"#fnref:3\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:4\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">4.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">順著河流走。<a href=\"#fnref:4\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:5\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">5.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">蒼、霜、方、長、央，陽部。<a href=\"#fnref:5\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:6\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">6.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">露水未乾。<a href=\"#fnref:6\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:7\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">7.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水草交接處，即岸邊。<a href=\"#fnref:7\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:8\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">8.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:8\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:9\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">9.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">萋、晞、湄、躋、坻，脂部。<a href=\"#fnref:9\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:10\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">10.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「已」完全。言露水還未完全乾。<a href=\"#fnref:10\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:11\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">11.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">岸邊。<a href=\"#fnref:11\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:12\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">12.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水路彎曲。<a href=\"#fnref:12\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:13\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">13.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:13\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:14\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">14.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">采、已、涘、右、沚，之部。<a href=\"#fnref:14\" rev=\"footnote\"> ↩</a></span></li></ol></div></div>"},{"title":"Nǹg uá khòu-thâu(鑽我褲頭)","date":"2021-09-29T13:38:48.000Z","p":"language/min/nng-ua-khou-thau","_content":"\nLâu Lêng(劉伶) sâinn`--`sî tsia̍h tsiú huàng-tsòng, ǔ`--`sî nā tshù-lǎi tǹg-pe̍h-pe̍h. Nâng thói-tioh i, tsang i kiàng-siàu, A-lêng(阿伶) tànn: \"uá ínn thinn-tī uî lâu-pâng, pâng-kainn uî khòu-thâu, níng-hiá-nâng nǹg uá khòu-thâu muā`--`âi mō?\"\n\n<!--more-->\n\n劉伶先時食酒放縱，有時 nā 茨內褪白白。儂睇著伊，tsang 伊見笑，阿伶呾：「我以天地爲樓房，房間爲褲頭，恁遐儂鑽我褲頭摩來麼！」\n\n------\n\n(文言文)\n劉伶嘗縱酒放達，或脫衣裸形在屋中。人見譏之，伶曰：「我以天地爲棟宇，屋室爲褌衣，諸君何為入我褌中！」\n-- 《世說新語》\n\n------\n\n(普通话)\n刘伶曾经喝酒放达，有时在屋中赤身裸体。人们看到了都笑话他，刘伶回应说：「我以天地为楼房，屋室为内裤，你们进到我内裤来干嘛！」\n\n","source":"_posts/language/min/nng-ua-khou-thau.md","raw":"---\ntitle: Nǹg uá khòu-thâu(鑽我褲頭)\ndate: 2021-09-29 21:38:48\np: language/min/nng-ua-khou-thau\ntags:\n- 魏晉風流\n- 甲子話\n- 閩南語\n---\n\nLâu Lêng(劉伶) sâinn`--`sî tsia̍h tsiú huàng-tsòng, ǔ`--`sî nā tshù-lǎi tǹg-pe̍h-pe̍h. Nâng thói-tioh i, tsang i kiàng-siàu, A-lêng(阿伶) tànn: \"uá ínn thinn-tī uî lâu-pâng, pâng-kainn uî khòu-thâu, níng-hiá-nâng nǹg uá khòu-thâu muā`--`âi mō?\"\n\n<!--more-->\n\n劉伶先時食酒放縱，有時 nā 茨內褪白白。儂睇著伊，tsang 伊見笑，阿伶呾：「我以天地爲樓房，房間爲褲頭，恁遐儂鑽我褲頭摩來麼！」\n\n------\n\n(文言文)\n劉伶嘗縱酒放達，或脫衣裸形在屋中。人見譏之，伶曰：「我以天地爲棟宇，屋室爲褌衣，諸君何為入我褌中！」\n-- 《世說新語》\n\n------\n\n(普通话)\n刘伶曾经喝酒放达，有时在屋中赤身裸体。人们看到了都笑话他，刘伶回应说：「我以天地为楼房，屋室为内裤，你们进到我内裤来干嘛！」\n\n","slug":"language/min/nng-ua-khou-thau","published":1,"updated":"2021-09-29T15:43:39.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfl002q1n9k5znhf7an","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>Lâu Lêng(劉伶) sâinn<code>--</code>sî tsia̍h tsiú huàng-tsòng, ǔ<code>--</code>sî nā tshù-lǎi tǹg-pe̍h-pe̍h. Nâng thói-tioh i, tsang i kiàng-siàu, A-lêng(阿伶) tànn: “uá ínn thinn-tī uî lâu-pâng, pâng-kainn uî khòu-thâu, níng-hiá-nâng nǹg uá khòu-thâu muā<code>--</code>âi mō?”</p>\n<span id=\"more\"></span>\n\n<p>劉伶先時食酒放縱，有時 nā 茨內褪白白。儂睇著伊，tsang 伊見笑，阿伶呾：「我以天地爲樓房，房間爲褲頭，恁遐儂鑽我褲頭摩來麼！」</p>\n<hr>\n<p>(文言文)<br>劉伶嘗縱酒放達，或脫衣裸形在屋中。人見譏之，伶曰：「我以天地爲棟宇，屋室爲褌衣，諸君何為入我褌中！」<br>– 《世說新語》</p>\n<hr>\n<p>(普通话)<br>刘伶曾经喝酒放达，有时在屋中赤身裸体。人们看到了都笑话他，刘伶回应说：「我以天地为楼房，屋室为内裤，你们进到我内裤来干嘛！」</p>\n","site":{"data":{}},"excerpt":"<p>Lâu Lêng(劉伶) sâinn<code>--</code>sî tsia̍h tsiú huàng-tsòng, ǔ<code>--</code>sî nā tshù-lǎi tǹg-pe̍h-pe̍h. Nâng thói-tioh i, tsang i kiàng-siàu, A-lêng(阿伶) tànn: “uá ínn thinn-tī uî lâu-pâng, pâng-kainn uî khòu-thâu, níng-hiá-nâng nǹg uá khòu-thâu muā<code>--</code>âi mō?”</p>","more":"<p>劉伶先時食酒放縱，有時 nā 茨內褪白白。儂睇著伊，tsang 伊見笑，阿伶呾：「我以天地爲樓房，房間爲褲頭，恁遐儂鑽我褲頭摩來麼！」</p>\n<hr>\n<p>(文言文)<br>劉伶嘗縱酒放達，或脫衣裸形在屋中。人見譏之，伶曰：「我以天地爲棟宇，屋室爲褌衣，諸君何為入我褌中！」<br>– 《世說新語》</p>\n<hr>\n<p>(普通话)<br>刘伶曾经喝酒放达，有时在屋中赤身裸体。人们看到了都笑话他，刘伶回应说：「我以天地为楼房，屋室为内裤，你们进到我内裤来干嘛！」</p>"},{"title":"潮州話與甲子話韻母差異（稿）","p":"language/min/vowel","date":"2020-11-04T14:44:00.000Z","_content":"\n![](teochew-kahtsi-vowel/202010042112.png)\n\n## 概述\n\n本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。\n通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。\n\n<!--more-->\n\n## 潮州 do(to) / 甲子 dê(tê)\n\n例如：\n1. do / dê：短、代、袋\n2. to / tê：退、褪、推、胎、蛻\n\n例外：\n1. do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄\n2. to / to：討、妥、唾、橢、馱、陀、沱、跎、桃\n\n## 潮州 e(eh) / 甲子 u(uh)\n\n例如：\n1. e / u：於\n2. ce / cu：蛆、此、鼠、徐\n3. de / du：豬、除、鋤、箸\n4. ge / gu：車、居、舉、齲、據、距\n5. ghe / ghu：馭、御\n6. he / hu：虛、墟、噓、許、滸、魚、漁\n7. ke / ku：去、渠、瞿\n8. le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾\n9. re / ru：爾、而、荋\n10. se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜\n11. ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 \n\n例外：\n1. ghe / ngo：語\n2. he / hê：許（～搭）\n3. keh / kig：乞（～丐）\n4. keh / koh：乞（～汝）\n5. re / ri：耳（木～）、洱、餌、貳、膩\n6. se / si：始\n\n☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：\n1. u / ngo： 吾\n2. nge / ngo： 語\n3. ngo / ngo：悟、晤、梧、寤、遇、愚\n\n## 潮州 eng / 甲子 ing、ng\n\n例如：\n1. eng / ing：恩、摁\n2. geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲\n3. ngeng / nging：銀、垠、齦、鄞、元、圓\n4. heng / hing：很、狠、恨\n5. keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）\n6. ceng / cng：倉、瘡、艙、村、床\n7. deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞\n8. keng / kng：勸、囥、糠\n9. meng / mng：晚、門、們、捫、問\n10. neng / nng：女、軟、鑽、郎、卵、浪\n11. seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算\n12. teng / tng：湯、捅、燙、褪、糖\n13. zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋\n\n例外：\n1. seng / siong 桑\n2. keng / kêng：墾、懇\n\n## 潮州 eg / 甲子 ig、iag\n\n例如：\n1. keg / kig ：仡（～佬族）\n2. keg / kiag：橛、镢\n3. ngeg / ngiag：迄、訖、屹\n\n例外：\n1. ngeg / ngib：吃\n\n## 潮州 iê(iêh) / 甲子 io(ioh)\n\n例如：\n1. iê / io：腰、姚、窯、揺\n2. iêh / ioh：約、藥\n3. biê / bio：表\n4. biê & piao / pio & biao：標、飆\n5. bhiê / bhio：描、廟\n6. ciê / cio：笑、唱\n7. ciêh / cioh：尺、席\n8. diê / dio：跳、潮\n9. diêh / dioh： 著\n10. giê / gio：叫、茄、橋\n11. hiêh / hioh：葉、頁\n12. kiêh / kioh：挈/𢭪\n13. liê / lio：撈\n14. niê / nio：兩、娘、量、讓 \n15. piê / pio：票、鰾\n16. riê / rio：尿\n17. riêh / rioh：若\n18. siê / sio：相、燒、小\n19. siêh / sioh：惜、液\n20. tiê / tio：挑、糶\n21. ziê / zio：招、蕉、少、照\n22. ziêh / zioh：質、借、石\n\n## 潮州 iên / 甲子 ion\n\n例如：\n1. iên / ion：鴦、羊、陽、楊、洋、樣\n2. ciên / cion：槍、鯧、搶、牆、象、匠\n3. diên / dion：張、長、帳、脹、賬、場、丈、趙\n4. giên / gion： 姜、強、彊\n5. hiên / hion：香、鄉\n6. kiên / kion：腔\n7. siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗\n8. ziên / zion 漿、章、樟、蔣、掌、醬、上、癢\n\n例外： \n1. diên / dio 釣（☞ 鼻音完全脫落）\n\n## 潮州 iêng(iêg) / iang(iag)\n\n例如：\n1. iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援\n2. biêng / biang：邊、砭、鞭、變、遍、便、辯\n3. ciêng / ciang：阡、遷、芊、纖、淺\n4. ciêg / ciag：切\n5. diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍\n6. giêng /giang：堅、捐、鵑、見、建、鍵\n7. hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇\n8. kiêng /kiang：虔、愆、騫、犬、乾\n9. liêng / liang：臉、連、憐、蓮、吝、躪、練\n10. miêng /miang：免、勉、娩、憫、敏、緬、腼、綿\n11. ngiêng / ngiang：妍、研、齴\n12. ngiêg / ngiag：嚙（～齒）\n\n## 潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\n\n例如：\n1. mig / mêg：默、陌\n2. ing / iang：沿、鉛\n3. mig / miag：滅、蔑\n4. zing / ziang：薦\n\n例外：\n1. ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演\n2. ing / hing：暈\n3. bing / bing：乒、賓、彬、斌、稟\n4. big / big：筆、必、畢、蓽、篳、弼\n5. bhig / bhig：蜜\n6. cing / cing：親、臣、秦\n7. cig / cig：七\n8. ding / ding：顛、振、鎮、塵、藤、陣\n9. cing / cim：襯\n10. king / king：輕、氫\n11. ling / ling：鄰、遴、嶙、麟\n12. ming / ming：民、氓、泯、眠、面\n13. mig / mig 密、蜜、冪、覓、謐\n14. ning / ning 恁\n15. ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻\n16. bing / ping：品\n17. ring / ring：人、仁、認\n18. sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛\n19. ting / ting： 烴、陳、澄\n20. zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼\n21. zing / ding 珍\n\n## 潮州 iou(iouh) / 甲子 iao(iaoh)\n\n例如：\n1. iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀\n2. biou / biao：表、婊\n3. ciou / ciao：悄、稍、朝、嘲、瞧、晁\n4. diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉\n5. giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬\n6. hiou / hiao：僥、梟、驍、曉\n7. kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑\n8. liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺\n9. miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）\n10. niou / niao：撓、裊、皺\n11. ngiou / ngiao：貓、堯\n12. piou / piao：飄、漂、嫖、樸\n13. piou / biao：標\n14. riou / riao：爪、擾、嬈、繞、饒\n15. siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶\n16. tiou / tiao：迢、挑、超、窕、柱\n17. ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭\n\n## 潮州 iong / 甲子 êng\n\n例如：\n1. iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴\n\n## 潮州 ong / iong\n\n例如：\n1. dong / diong：重、中、忠、仲\n2. rong / riong：戎、絨、茸\n3. zong / ziong：眾\n4. rong / riong：仍、扔\n5. song / siong：松、訟、誦、頌\n\n例外：\n1. cong / cong：從、充、衝\n\n## 潮州 ng / 甲子 ing\n\n例如：\n1. ng / ing：尹、隱\n2. hng / hing：軒、欣、鍁、勳、殷\n\n## 潮州 oin / 甲子 ain\n\n例如：\n1. oin / ain：閒\n2. boin / bain：斑、反、板、爿\n3. coin / cain：千、蠶\n4. doin / dain：殿\n5. goin / gain：間、肩、繭\n6. hoin / hain：蜆、還、莧\n7. koin / kain：蓋\n8. soin / sain：先\n\n例外：\n1. toin / toin：睇\n2. noin / nai：蓮（☞ 鼻音完全脫落）\n\n☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。\n\n## 潮州 uê(uêh) / 甲子 oi(oih)\n\n例如：\n1. uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛\n2. uêh / oih：划、畫\n3. buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩\n4. buê / poi：陪\n5. bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未\n6. cuê / coi：吹、炊、髓、覓\n7. duê / doi：綴、兌\n8. guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）\n9. guêh / goih：郭、橛\n10. ghuêh / ghoih8：月\n11. huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）\n12. huêh / hoih：血\n13. kuê / koi：科、蝌、課、稞、瘸\n14. kuêh / koih：缺、闕、闋\n15. muêh / moih：物\n16. muê / moi：每、糜、妹、昧、寐、魅、袂\n17. nuê / noi：餒\n18. puê / poi：皮、被、坯、胚、配、裴\n19. puêh / poih：詖、坺\n20. ruê / roi：枘、蚋、銳、睿\n21. suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅\n22. suêh / soih：說\n23. tuê / toi：頹\n24. zuê / zoi：最、襊、罪、㩼\n\n例外：\n1. bhuêh / ghoih：襪\n2. kuê / kui：盔\n3. suêh / suah：刷、涮\n\n## 潮州 uên / 甲子 oin\n\n例如：\n1. guên / goin：關、果\n2. huên / hoin：橫\n\n## 潮州 uêng(uêg) / 甲子 uang(uag)\n\n例如：\n1. uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣\n2. uêg / uag：曰、斡、鉞、越、粵\n3. buêng / puang：叛\n4. buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤\n5. bhuêng / muan：幔（☞ 後鼻音退成鼻化音）\n6. cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓\n7. cuêg / cuag：啜、綴、輟\n8. duêng / duang：端、斷、鍛、段（又音deng）、篆\n9. guêng / guang：關、觀、冠、鰥\n10. guêg / guag：決、訣、抉、玦、聒、譎\n11. guêg / kuag：括\n12. huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢\n13. huêg / huag：發、髮、乏、穴、伐、罰、閥\n14. kuêng / kuang：寬、圈、髖、權、款、蜷\n15. kuêg / kuag：擴\n16. luêng / luang：暖、戀、巒、孿、鸞、亂\n17. luêg / luag：劣\n18. muêg / muag：末、沫、秣\n19. nguêng / nguang：阮、玩、頑、元、原、源、願\n20. puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣\n21. puêng / puan：般（☞ 後鼻音退成鼻化音）\n22. puêg / puag：潑、銖\n23. ruêng / ruang：亂\n24. ruêg / ruag：悅\n25. suêng / suang：選、算（又音 seng）、旋、漩\n26. tuêng / tuang：湍、團、傳\n27. zuêng / zuang： 專、轉、鐫、顓、撰\n28. zuêg / zuag：拙、茁、咄、絀\n\n例外：\n1. bhuêng/mang：萬、饅、慢、漫\n2. kuêng /  kêng：傾、頃、卿\n3. huêng / hoin：衡\n4. huêg / hoig：或 、惑\n5. uêg / oig：獲 、域、役、鑊\n6. guêng / goin：囧、炯、耿、穎\n7. nguêng / ngiang：顏\n8. nguêng / iang：芫\n\n## 其餘\n1. 宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³\n2. 唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²\n3. 言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²\n4. 瓊、煢：潮州kuang⁵ / 甲子kêng⁵\n5. 舀：潮州 io² / 甲子ion² ","source":"_posts/language/min/teochew-kahtsi-vowel.md","raw":"---\ntitle: 潮州話與甲子話韻母差異（稿）\np: language/min/vowel\ndate: 2020-11-04 22:44:00\ntags:\n- 閩南語\n- 潮州話\n- 甲子話\n---\n\n![](teochew-kahtsi-vowel/202010042112.png)\n\n## 概述\n\n本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。\n通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。\n\n<!--more-->\n\n## 潮州 do(to) / 甲子 dê(tê)\n\n例如：\n1. do / dê：短、代、袋\n2. to / tê：退、褪、推、胎、蛻\n\n例外：\n1. do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄\n2. to / to：討、妥、唾、橢、馱、陀、沱、跎、桃\n\n## 潮州 e(eh) / 甲子 u(uh)\n\n例如：\n1. e / u：於\n2. ce / cu：蛆、此、鼠、徐\n3. de / du：豬、除、鋤、箸\n4. ge / gu：車、居、舉、齲、據、距\n5. ghe / ghu：馭、御\n6. he / hu：虛、墟、噓、許、滸、魚、漁\n7. ke / ku：去、渠、瞿\n8. le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾\n9. re / ru：爾、而、荋\n10. se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜\n11. ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 \n\n例外：\n1. ghe / ngo：語\n2. he / hê：許（～搭）\n3. keh / kig：乞（～丐）\n4. keh / koh：乞（～汝）\n5. re / ri：耳（木～）、洱、餌、貳、膩\n6. se / si：始\n\n☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：\n1. u / ngo： 吾\n2. nge / ngo： 語\n3. ngo / ngo：悟、晤、梧、寤、遇、愚\n\n## 潮州 eng / 甲子 ing、ng\n\n例如：\n1. eng / ing：恩、摁\n2. geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲\n3. ngeng / nging：銀、垠、齦、鄞、元、圓\n4. heng / hing：很、狠、恨\n5. keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）\n6. ceng / cng：倉、瘡、艙、村、床\n7. deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞\n8. keng / kng：勸、囥、糠\n9. meng / mng：晚、門、們、捫、問\n10. neng / nng：女、軟、鑽、郎、卵、浪\n11. seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算\n12. teng / tng：湯、捅、燙、褪、糖\n13. zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋\n\n例外：\n1. seng / siong 桑\n2. keng / kêng：墾、懇\n\n## 潮州 eg / 甲子 ig、iag\n\n例如：\n1. keg / kig ：仡（～佬族）\n2. keg / kiag：橛、镢\n3. ngeg / ngiag：迄、訖、屹\n\n例外：\n1. ngeg / ngib：吃\n\n## 潮州 iê(iêh) / 甲子 io(ioh)\n\n例如：\n1. iê / io：腰、姚、窯、揺\n2. iêh / ioh：約、藥\n3. biê / bio：表\n4. biê & piao / pio & biao：標、飆\n5. bhiê / bhio：描、廟\n6. ciê / cio：笑、唱\n7. ciêh / cioh：尺、席\n8. diê / dio：跳、潮\n9. diêh / dioh： 著\n10. giê / gio：叫、茄、橋\n11. hiêh / hioh：葉、頁\n12. kiêh / kioh：挈/𢭪\n13. liê / lio：撈\n14. niê / nio：兩、娘、量、讓 \n15. piê / pio：票、鰾\n16. riê / rio：尿\n17. riêh / rioh：若\n18. siê / sio：相、燒、小\n19. siêh / sioh：惜、液\n20. tiê / tio：挑、糶\n21. ziê / zio：招、蕉、少、照\n22. ziêh / zioh：質、借、石\n\n## 潮州 iên / 甲子 ion\n\n例如：\n1. iên / ion：鴦、羊、陽、楊、洋、樣\n2. ciên / cion：槍、鯧、搶、牆、象、匠\n3. diên / dion：張、長、帳、脹、賬、場、丈、趙\n4. giên / gion： 姜、強、彊\n5. hiên / hion：香、鄉\n6. kiên / kion：腔\n7. siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗\n8. ziên / zion 漿、章、樟、蔣、掌、醬、上、癢\n\n例外： \n1. diên / dio 釣（☞ 鼻音完全脫落）\n\n## 潮州 iêng(iêg) / iang(iag)\n\n例如：\n1. iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援\n2. biêng / biang：邊、砭、鞭、變、遍、便、辯\n3. ciêng / ciang：阡、遷、芊、纖、淺\n4. ciêg / ciag：切\n5. diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍\n6. giêng /giang：堅、捐、鵑、見、建、鍵\n7. hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇\n8. kiêng /kiang：虔、愆、騫、犬、乾\n9. liêng / liang：臉、連、憐、蓮、吝、躪、練\n10. miêng /miang：免、勉、娩、憫、敏、緬、腼、綿\n11. ngiêng / ngiang：妍、研、齴\n12. ngiêg / ngiag：嚙（～齒）\n\n## 潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\n\n例如：\n1. mig / mêg：默、陌\n2. ing / iang：沿、鉛\n3. mig / miag：滅、蔑\n4. zing / ziang：薦\n\n例外：\n1. ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演\n2. ing / hing：暈\n3. bing / bing：乒、賓、彬、斌、稟\n4. big / big：筆、必、畢、蓽、篳、弼\n5. bhig / bhig：蜜\n6. cing / cing：親、臣、秦\n7. cig / cig：七\n8. ding / ding：顛、振、鎮、塵、藤、陣\n9. cing / cim：襯\n10. king / king：輕、氫\n11. ling / ling：鄰、遴、嶙、麟\n12. ming / ming：民、氓、泯、眠、面\n13. mig / mig 密、蜜、冪、覓、謐\n14. ning / ning 恁\n15. ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻\n16. bing / ping：品\n17. ring / ring：人、仁、認\n18. sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛\n19. ting / ting： 烴、陳、澄\n20. zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼\n21. zing / ding 珍\n\n## 潮州 iou(iouh) / 甲子 iao(iaoh)\n\n例如：\n1. iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀\n2. biou / biao：表、婊\n3. ciou / ciao：悄、稍、朝、嘲、瞧、晁\n4. diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉\n5. giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬\n6. hiou / hiao：僥、梟、驍、曉\n7. kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑\n8. liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺\n9. miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）\n10. niou / niao：撓、裊、皺\n11. ngiou / ngiao：貓、堯\n12. piou / piao：飄、漂、嫖、樸\n13. piou / biao：標\n14. riou / riao：爪、擾、嬈、繞、饒\n15. siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶\n16. tiou / tiao：迢、挑、超、窕、柱\n17. ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭\n\n## 潮州 iong / 甲子 êng\n\n例如：\n1. iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴\n\n## 潮州 ong / iong\n\n例如：\n1. dong / diong：重、中、忠、仲\n2. rong / riong：戎、絨、茸\n3. zong / ziong：眾\n4. rong / riong：仍、扔\n5. song / siong：松、訟、誦、頌\n\n例外：\n1. cong / cong：從、充、衝\n\n## 潮州 ng / 甲子 ing\n\n例如：\n1. ng / ing：尹、隱\n2. hng / hing：軒、欣、鍁、勳、殷\n\n## 潮州 oin / 甲子 ain\n\n例如：\n1. oin / ain：閒\n2. boin / bain：斑、反、板、爿\n3. coin / cain：千、蠶\n4. doin / dain：殿\n5. goin / gain：間、肩、繭\n6. hoin / hain：蜆、還、莧\n7. koin / kain：蓋\n8. soin / sain：先\n\n例外：\n1. toin / toin：睇\n2. noin / nai：蓮（☞ 鼻音完全脫落）\n\n☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。\n\n## 潮州 uê(uêh) / 甲子 oi(oih)\n\n例如：\n1. uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛\n2. uêh / oih：划、畫\n3. buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩\n4. buê / poi：陪\n5. bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未\n6. cuê / coi：吹、炊、髓、覓\n7. duê / doi：綴、兌\n8. guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）\n9. guêh / goih：郭、橛\n10. ghuêh / ghoih8：月\n11. huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）\n12. huêh / hoih：血\n13. kuê / koi：科、蝌、課、稞、瘸\n14. kuêh / koih：缺、闕、闋\n15. muêh / moih：物\n16. muê / moi：每、糜、妹、昧、寐、魅、袂\n17. nuê / noi：餒\n18. puê / poi：皮、被、坯、胚、配、裴\n19. puêh / poih：詖、坺\n20. ruê / roi：枘、蚋、銳、睿\n21. suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅\n22. suêh / soih：說\n23. tuê / toi：頹\n24. zuê / zoi：最、襊、罪、㩼\n\n例外：\n1. bhuêh / ghoih：襪\n2. kuê / kui：盔\n3. suêh / suah：刷、涮\n\n## 潮州 uên / 甲子 oin\n\n例如：\n1. guên / goin：關、果\n2. huên / hoin：橫\n\n## 潮州 uêng(uêg) / 甲子 uang(uag)\n\n例如：\n1. uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣\n2. uêg / uag：曰、斡、鉞、越、粵\n3. buêng / puang：叛\n4. buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤\n5. bhuêng / muan：幔（☞ 後鼻音退成鼻化音）\n6. cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓\n7. cuêg / cuag：啜、綴、輟\n8. duêng / duang：端、斷、鍛、段（又音deng）、篆\n9. guêng / guang：關、觀、冠、鰥\n10. guêg / guag：決、訣、抉、玦、聒、譎\n11. guêg / kuag：括\n12. huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢\n13. huêg / huag：發、髮、乏、穴、伐、罰、閥\n14. kuêng / kuang：寬、圈、髖、權、款、蜷\n15. kuêg / kuag：擴\n16. luêng / luang：暖、戀、巒、孿、鸞、亂\n17. luêg / luag：劣\n18. muêg / muag：末、沫、秣\n19. nguêng / nguang：阮、玩、頑、元、原、源、願\n20. puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣\n21. puêng / puan：般（☞ 後鼻音退成鼻化音）\n22. puêg / puag：潑、銖\n23. ruêng / ruang：亂\n24. ruêg / ruag：悅\n25. suêng / suang：選、算（又音 seng）、旋、漩\n26. tuêng / tuang：湍、團、傳\n27. zuêng / zuang： 專、轉、鐫、顓、撰\n28. zuêg / zuag：拙、茁、咄、絀\n\n例外：\n1. bhuêng/mang：萬、饅、慢、漫\n2. kuêng /  kêng：傾、頃、卿\n3. huêng / hoin：衡\n4. huêg / hoig：或 、惑\n5. uêg / oig：獲 、域、役、鑊\n6. guêng / goin：囧、炯、耿、穎\n7. nguêng / ngiang：顏\n8. nguêng / iang：芫\n\n## 其餘\n1. 宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³\n2. 唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²\n3. 言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²\n4. 瓊、煢：潮州kuang⁵ / 甲子kêng⁵\n5. 舀：潮州 io² / 甲子ion² ","slug":"language/min/teochew-kahtsi-vowel","published":1,"updated":"2021-09-13T14:08:09.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfm002r1n9kb6zsa5jv","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><img src=\"/language/min/teochew-kahtsi-vowel/202010042112.png\" alt></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。<br>通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"潮州-do-to-甲子-de-te\"><a href=\"#潮州-do-to-甲子-de-te\" class=\"headerlink\" title=\"潮州 do(to) / 甲子 dê(tê)\"></a>潮州 do(to) / 甲子 dê(tê)</h2><p>例如：</p>\n<ol>\n<li>do / dê：短、代、袋</li>\n<li>to / tê：退、褪、推、胎、蛻</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄</li>\n<li>to / to：討、妥、唾、橢、馱、陀、沱、跎、桃</li>\n</ol>\n<h2 id=\"潮州-e-eh-甲子-u-uh\"><a href=\"#潮州-e-eh-甲子-u-uh\" class=\"headerlink\" title=\"潮州 e(eh) / 甲子 u(uh)\"></a>潮州 e(eh) / 甲子 u(uh)</h2><p>例如：</p>\n<ol>\n<li>e / u：於</li>\n<li>ce / cu：蛆、此、鼠、徐</li>\n<li>de / du：豬、除、鋤、箸</li>\n<li>ge / gu：車、居、舉、齲、據、距</li>\n<li>ghe / ghu：馭、御</li>\n<li>he / hu：虛、墟、噓、許、滸、魚、漁</li>\n<li>ke / ku：去、渠、瞿</li>\n<li>le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾</li>\n<li>re / ru：爾、而、荋</li>\n<li>se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜</li>\n<li>ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 </li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ghe / ngo：語</li>\n<li>he / hê：許（～搭）</li>\n<li>keh / kig：乞（～丐）</li>\n<li>keh / koh：乞（～汝）</li>\n<li>re / ri：耳（木～）、洱、餌、貳、膩</li>\n<li>se / si：始</li>\n</ol>\n<p>☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：</p>\n<ol>\n<li>u / ngo： 吾</li>\n<li>nge / ngo： 語</li>\n<li>ngo / ngo：悟、晤、梧、寤、遇、愚</li>\n</ol>\n<h2 id=\"潮州-eng-甲子-ing、ng\"><a href=\"#潮州-eng-甲子-ing、ng\" class=\"headerlink\" title=\"潮州 eng / 甲子 ing、ng\"></a>潮州 eng / 甲子 ing、ng</h2><p>例如：</p>\n<ol>\n<li>eng / ing：恩、摁</li>\n<li>geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲</li>\n<li>ngeng / nging：銀、垠、齦、鄞、元、圓</li>\n<li>heng / hing：很、狠、恨</li>\n<li>keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）</li>\n<li>ceng / cng：倉、瘡、艙、村、床</li>\n<li>deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞</li>\n<li>keng / kng：勸、囥、糠</li>\n<li>meng / mng：晚、門、們、捫、問</li>\n<li>neng / nng：女、軟、鑽、郎、卵、浪</li>\n<li>seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算</li>\n<li>teng / tng：湯、捅、燙、褪、糖</li>\n<li>zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>seng / siong 桑</li>\n<li>keng / kêng：墾、懇</li>\n</ol>\n<h2 id=\"潮州-eg-甲子-ig、iag\"><a href=\"#潮州-eg-甲子-ig、iag\" class=\"headerlink\" title=\"潮州 eg / 甲子 ig、iag\"></a>潮州 eg / 甲子 ig、iag</h2><p>例如：</p>\n<ol>\n<li>keg / kig ：仡（～佬族）</li>\n<li>keg / kiag：橛、镢</li>\n<li>ngeg / ngiag：迄、訖、屹</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ngeg / ngib：吃</li>\n</ol>\n<h2 id=\"潮州-ie-ieh-甲子-io-ioh\"><a href=\"#潮州-ie-ieh-甲子-io-ioh\" class=\"headerlink\" title=\"潮州 iê(iêh) / 甲子 io(ioh)\"></a>潮州 iê(iêh) / 甲子 io(ioh)</h2><p>例如：</p>\n<ol>\n<li>iê / io：腰、姚、窯、揺</li>\n<li>iêh / ioh：約、藥</li>\n<li>biê / bio：表</li>\n<li>biê &amp; piao / pio &amp; biao：標、飆</li>\n<li>bhiê / bhio：描、廟</li>\n<li>ciê / cio：笑、唱</li>\n<li>ciêh / cioh：尺、席</li>\n<li>diê / dio：跳、潮</li>\n<li>diêh / dioh： 著</li>\n<li>giê / gio：叫、茄、橋</li>\n<li>hiêh / hioh：葉、頁</li>\n<li>kiêh / kioh：挈/𢭪</li>\n<li>liê / lio：撈</li>\n<li>niê / nio：兩、娘、量、讓 </li>\n<li>piê / pio：票、鰾</li>\n<li>riê / rio：尿</li>\n<li>riêh / rioh：若</li>\n<li>siê / sio：相、燒、小</li>\n<li>siêh / sioh：惜、液</li>\n<li>tiê / tio：挑、糶</li>\n<li>ziê / zio：招、蕉、少、照</li>\n<li>ziêh / zioh：質、借、石</li>\n</ol>\n<h2 id=\"潮州-ien-甲子-ion\"><a href=\"#潮州-ien-甲子-ion\" class=\"headerlink\" title=\"潮州 iên / 甲子 ion\"></a>潮州 iên / 甲子 ion</h2><p>例如：</p>\n<ol>\n<li>iên / ion：鴦、羊、陽、楊、洋、樣</li>\n<li>ciên / cion：槍、鯧、搶、牆、象、匠</li>\n<li>diên / dion：張、長、帳、脹、賬、場、丈、趙</li>\n<li>giên / gion： 姜、強、彊</li>\n<li>hiên / hion：香、鄉</li>\n<li>kiên / kion：腔</li>\n<li>siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗</li>\n<li>ziên / zion 漿、章、樟、蔣、掌、醬、上、癢</li>\n</ol>\n<p>例外： </p>\n<ol>\n<li>diên / dio 釣（☞ 鼻音完全脫落）</li>\n</ol>\n<h2 id=\"潮州-ieng-ieg-iang-iag\"><a href=\"#潮州-ieng-ieg-iang-iag\" class=\"headerlink\" title=\"潮州 iêng(iêg) / iang(iag)\"></a>潮州 iêng(iêg) / iang(iag)</h2><p>例如：</p>\n<ol>\n<li>iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援</li>\n<li>biêng / biang：邊、砭、鞭、變、遍、便、辯</li>\n<li>ciêng / ciang：阡、遷、芊、纖、淺</li>\n<li>ciêg / ciag：切</li>\n<li>diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍</li>\n<li>giêng /giang：堅、捐、鵑、見、建、鍵</li>\n<li>hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇</li>\n<li>kiêng /kiang：虔、愆、騫、犬、乾</li>\n<li>liêng / liang：臉、連、憐、蓮、吝、躪、練</li>\n<li>miêng /miang：免、勉、娩、憫、敏、緬、腼、綿</li>\n<li>ngiêng / ngiang：妍、研、齴</li>\n<li>ngiêg / ngiag：嚙（～齒）</li>\n</ol>\n<h2 id=\"潮州-ing-ig-甲子eng-eg-、-iang-iag\"><a href=\"#潮州-ing-ig-甲子eng-eg-、-iang-iag\" class=\"headerlink\" title=\"潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\"></a>潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)</h2><p>例如：</p>\n<ol>\n<li>mig / mêg：默、陌</li>\n<li>ing / iang：沿、鉛</li>\n<li>mig / miag：滅、蔑</li>\n<li>zing / ziang：薦</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演</li>\n<li>ing / hing：暈</li>\n<li>bing / bing：乒、賓、彬、斌、稟</li>\n<li>big / big：筆、必、畢、蓽、篳、弼</li>\n<li>bhig / bhig：蜜</li>\n<li>cing / cing：親、臣、秦</li>\n<li>cig / cig：七</li>\n<li>ding / ding：顛、振、鎮、塵、藤、陣</li>\n<li>cing / cim：襯</li>\n<li>king / king：輕、氫</li>\n<li>ling / ling：鄰、遴、嶙、麟</li>\n<li>ming / ming：民、氓、泯、眠、面</li>\n<li>mig / mig 密、蜜、冪、覓、謐</li>\n<li>ning / ning 恁</li>\n<li>ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻</li>\n<li>bing / ping：品</li>\n<li>ring / ring：人、仁、認</li>\n<li>sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛</li>\n<li>ting / ting： 烴、陳、澄</li>\n<li>zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼</li>\n<li>zing / ding 珍</li>\n</ol>\n<h2 id=\"潮州-iou-iouh-甲子-iao-iaoh\"><a href=\"#潮州-iou-iouh-甲子-iao-iaoh\" class=\"headerlink\" title=\"潮州 iou(iouh) / 甲子 iao(iaoh)\"></a>潮州 iou(iouh) / 甲子 iao(iaoh)</h2><p>例如：</p>\n<ol>\n<li>iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀</li>\n<li>biou / biao：表、婊</li>\n<li>ciou / ciao：悄、稍、朝、嘲、瞧、晁</li>\n<li>diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉</li>\n<li>giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬</li>\n<li>hiou / hiao：僥、梟、驍、曉</li>\n<li>kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑</li>\n<li>liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺</li>\n<li>miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）</li>\n<li>niou / niao：撓、裊、皺</li>\n<li>ngiou / ngiao：貓、堯</li>\n<li>piou / piao：飄、漂、嫖、樸</li>\n<li>piou / biao：標</li>\n<li>riou / riao：爪、擾、嬈、繞、饒</li>\n<li>siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶</li>\n<li>tiou / tiao：迢、挑、超、窕、柱</li>\n<li>ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭</li>\n</ol>\n<h2 id=\"潮州-iong-甲子-eng\"><a href=\"#潮州-iong-甲子-eng\" class=\"headerlink\" title=\"潮州 iong / 甲子 êng\"></a>潮州 iong / 甲子 êng</h2><p>例如：</p>\n<ol>\n<li>iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴</li>\n</ol>\n<h2 id=\"潮州-ong-iong\"><a href=\"#潮州-ong-iong\" class=\"headerlink\" title=\"潮州 ong / iong\"></a>潮州 ong / iong</h2><p>例如：</p>\n<ol>\n<li>dong / diong：重、中、忠、仲</li>\n<li>rong / riong：戎、絨、茸</li>\n<li>zong / ziong：眾</li>\n<li>rong / riong：仍、扔</li>\n<li>song / siong：松、訟、誦、頌</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>cong / cong：從、充、衝</li>\n</ol>\n<h2 id=\"潮州-ng-甲子-ing\"><a href=\"#潮州-ng-甲子-ing\" class=\"headerlink\" title=\"潮州 ng / 甲子 ing\"></a>潮州 ng / 甲子 ing</h2><p>例如：</p>\n<ol>\n<li>ng / ing：尹、隱</li>\n<li>hng / hing：軒、欣、鍁、勳、殷</li>\n</ol>\n<h2 id=\"潮州-oin-甲子-ain\"><a href=\"#潮州-oin-甲子-ain\" class=\"headerlink\" title=\"潮州 oin / 甲子 ain\"></a>潮州 oin / 甲子 ain</h2><p>例如：</p>\n<ol>\n<li>oin / ain：閒</li>\n<li>boin / bain：斑、反、板、爿</li>\n<li>coin / cain：千、蠶</li>\n<li>doin / dain：殿</li>\n<li>goin / gain：間、肩、繭</li>\n<li>hoin / hain：蜆、還、莧</li>\n<li>koin / kain：蓋</li>\n<li>soin / sain：先</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>toin / toin：睇</li>\n<li>noin / nai：蓮（☞ 鼻音完全脫落）</li>\n</ol>\n<p>☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。</p>\n<h2 id=\"潮州-ue-ueh-甲子-oi-oih\"><a href=\"#潮州-ue-ueh-甲子-oi-oih\" class=\"headerlink\" title=\"潮州 uê(uêh) / 甲子 oi(oih)\"></a>潮州 uê(uêh) / 甲子 oi(oih)</h2><p>例如：</p>\n<ol>\n<li>uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛</li>\n<li>uêh / oih：划、畫</li>\n<li>buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩</li>\n<li>buê / poi：陪</li>\n<li>bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未</li>\n<li>cuê / coi：吹、炊、髓、覓</li>\n<li>duê / doi：綴、兌</li>\n<li>guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）</li>\n<li>guêh / goih：郭、橛</li>\n<li>ghuêh / ghoih8：月</li>\n<li>huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）</li>\n<li>huêh / hoih：血</li>\n<li>kuê / koi：科、蝌、課、稞、瘸</li>\n<li>kuêh / koih：缺、闕、闋</li>\n<li>muêh / moih：物</li>\n<li>muê / moi：每、糜、妹、昧、寐、魅、袂</li>\n<li>nuê / noi：餒</li>\n<li>puê / poi：皮、被、坯、胚、配、裴</li>\n<li>puêh / poih：詖、坺</li>\n<li>ruê / roi：枘、蚋、銳、睿</li>\n<li>suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅</li>\n<li>suêh / soih：說</li>\n<li>tuê / toi：頹</li>\n<li>zuê / zoi：最、襊、罪、㩼</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêh / ghoih：襪</li>\n<li>kuê / kui：盔</li>\n<li>suêh / suah：刷、涮</li>\n</ol>\n<h2 id=\"潮州-uen-甲子-oin\"><a href=\"#潮州-uen-甲子-oin\" class=\"headerlink\" title=\"潮州 uên / 甲子 oin\"></a>潮州 uên / 甲子 oin</h2><p>例如：</p>\n<ol>\n<li>guên / goin：關、果</li>\n<li>huên / hoin：橫</li>\n</ol>\n<h2 id=\"潮州-ueng-ueg-甲子-uang-uag\"><a href=\"#潮州-ueng-ueg-甲子-uang-uag\" class=\"headerlink\" title=\"潮州 uêng(uêg) / 甲子 uang(uag)\"></a>潮州 uêng(uêg) / 甲子 uang(uag)</h2><p>例如：</p>\n<ol>\n<li>uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣</li>\n<li>uêg / uag：曰、斡、鉞、越、粵</li>\n<li>buêng / puang：叛</li>\n<li>buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤</li>\n<li>bhuêng / muan：幔（☞ 後鼻音退成鼻化音）</li>\n<li>cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓</li>\n<li>cuêg / cuag：啜、綴、輟</li>\n<li>duêng / duang：端、斷、鍛、段（又音deng）、篆</li>\n<li>guêng / guang：關、觀、冠、鰥</li>\n<li>guêg / guag：決、訣、抉、玦、聒、譎</li>\n<li>guêg / kuag：括</li>\n<li>huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢</li>\n<li>huêg / huag：發、髮、乏、穴、伐、罰、閥</li>\n<li>kuêng / kuang：寬、圈、髖、權、款、蜷</li>\n<li>kuêg / kuag：擴</li>\n<li>luêng / luang：暖、戀、巒、孿、鸞、亂</li>\n<li>luêg / luag：劣</li>\n<li>muêg / muag：末、沫、秣</li>\n<li>nguêng / nguang：阮、玩、頑、元、原、源、願</li>\n<li>puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣</li>\n<li>puêng / puan：般（☞ 後鼻音退成鼻化音）</li>\n<li>puêg / puag：潑、銖</li>\n<li>ruêng / ruang：亂</li>\n<li>ruêg / ruag：悅</li>\n<li>suêng / suang：選、算（又音 seng）、旋、漩</li>\n<li>tuêng / tuang：湍、團、傳</li>\n<li>zuêng / zuang： 專、轉、鐫、顓、撰</li>\n<li>zuêg / zuag：拙、茁、咄、絀</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêng/mang：萬、饅、慢、漫</li>\n<li>kuêng /  kêng：傾、頃、卿</li>\n<li>huêng / hoin：衡</li>\n<li>huêg / hoig：或 、惑</li>\n<li>uêg / oig：獲 、域、役、鑊</li>\n<li>guêng / goin：囧、炯、耿、穎</li>\n<li>nguêng / ngiang：顏</li>\n<li>nguêng / iang：芫</li>\n</ol>\n<h2 id=\"其餘\"><a href=\"#其餘\" class=\"headerlink\" title=\"其餘\"></a>其餘</h2><ol>\n<li>宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³</li>\n<li>唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²</li>\n<li>言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²</li>\n<li>瓊、煢：潮州kuang⁵ / 甲子kêng⁵</li>\n<li>舀：潮州 io² / 甲子ion² </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><img src=\"/language/min/teochew-kahtsi-vowel/202010042112.png\" alt></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。<br>通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。</p>","more":"<h2 id=\"潮州-do-to-甲子-de-te\"><a href=\"#潮州-do-to-甲子-de-te\" class=\"headerlink\" title=\"潮州 do(to) / 甲子 dê(tê)\"></a>潮州 do(to) / 甲子 dê(tê)</h2><p>例如：</p>\n<ol>\n<li>do / dê：短、代、袋</li>\n<li>to / tê：退、褪、推、胎、蛻</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄</li>\n<li>to / to：討、妥、唾、橢、馱、陀、沱、跎、桃</li>\n</ol>\n<h2 id=\"潮州-e-eh-甲子-u-uh\"><a href=\"#潮州-e-eh-甲子-u-uh\" class=\"headerlink\" title=\"潮州 e(eh) / 甲子 u(uh)\"></a>潮州 e(eh) / 甲子 u(uh)</h2><p>例如：</p>\n<ol>\n<li>e / u：於</li>\n<li>ce / cu：蛆、此、鼠、徐</li>\n<li>de / du：豬、除、鋤、箸</li>\n<li>ge / gu：車、居、舉、齲、據、距</li>\n<li>ghe / ghu：馭、御</li>\n<li>he / hu：虛、墟、噓、許、滸、魚、漁</li>\n<li>ke / ku：去、渠、瞿</li>\n<li>le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾</li>\n<li>re / ru：爾、而、荋</li>\n<li>se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜</li>\n<li>ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 </li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ghe / ngo：語</li>\n<li>he / hê：許（～搭）</li>\n<li>keh / kig：乞（～丐）</li>\n<li>keh / koh：乞（～汝）</li>\n<li>re / ri：耳（木～）、洱、餌、貳、膩</li>\n<li>se / si：始</li>\n</ol>\n<p>☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：</p>\n<ol>\n<li>u / ngo： 吾</li>\n<li>nge / ngo： 語</li>\n<li>ngo / ngo：悟、晤、梧、寤、遇、愚</li>\n</ol>\n<h2 id=\"潮州-eng-甲子-ing、ng\"><a href=\"#潮州-eng-甲子-ing、ng\" class=\"headerlink\" title=\"潮州 eng / 甲子 ing、ng\"></a>潮州 eng / 甲子 ing、ng</h2><p>例如：</p>\n<ol>\n<li>eng / ing：恩、摁</li>\n<li>geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲</li>\n<li>ngeng / nging：銀、垠、齦、鄞、元、圓</li>\n<li>heng / hing：很、狠、恨</li>\n<li>keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）</li>\n<li>ceng / cng：倉、瘡、艙、村、床</li>\n<li>deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞</li>\n<li>keng / kng：勸、囥、糠</li>\n<li>meng / mng：晚、門、們、捫、問</li>\n<li>neng / nng：女、軟、鑽、郎、卵、浪</li>\n<li>seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算</li>\n<li>teng / tng：湯、捅、燙、褪、糖</li>\n<li>zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>seng / siong 桑</li>\n<li>keng / kêng：墾、懇</li>\n</ol>\n<h2 id=\"潮州-eg-甲子-ig、iag\"><a href=\"#潮州-eg-甲子-ig、iag\" class=\"headerlink\" title=\"潮州 eg / 甲子 ig、iag\"></a>潮州 eg / 甲子 ig、iag</h2><p>例如：</p>\n<ol>\n<li>keg / kig ：仡（～佬族）</li>\n<li>keg / kiag：橛、镢</li>\n<li>ngeg / ngiag：迄、訖、屹</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ngeg / ngib：吃</li>\n</ol>\n<h2 id=\"潮州-ie-ieh-甲子-io-ioh\"><a href=\"#潮州-ie-ieh-甲子-io-ioh\" class=\"headerlink\" title=\"潮州 iê(iêh) / 甲子 io(ioh)\"></a>潮州 iê(iêh) / 甲子 io(ioh)</h2><p>例如：</p>\n<ol>\n<li>iê / io：腰、姚、窯、揺</li>\n<li>iêh / ioh：約、藥</li>\n<li>biê / bio：表</li>\n<li>biê &amp; piao / pio &amp; biao：標、飆</li>\n<li>bhiê / bhio：描、廟</li>\n<li>ciê / cio：笑、唱</li>\n<li>ciêh / cioh：尺、席</li>\n<li>diê / dio：跳、潮</li>\n<li>diêh / dioh： 著</li>\n<li>giê / gio：叫、茄、橋</li>\n<li>hiêh / hioh：葉、頁</li>\n<li>kiêh / kioh：挈/𢭪</li>\n<li>liê / lio：撈</li>\n<li>niê / nio：兩、娘、量、讓 </li>\n<li>piê / pio：票、鰾</li>\n<li>riê / rio：尿</li>\n<li>riêh / rioh：若</li>\n<li>siê / sio：相、燒、小</li>\n<li>siêh / sioh：惜、液</li>\n<li>tiê / tio：挑、糶</li>\n<li>ziê / zio：招、蕉、少、照</li>\n<li>ziêh / zioh：質、借、石</li>\n</ol>\n<h2 id=\"潮州-ien-甲子-ion\"><a href=\"#潮州-ien-甲子-ion\" class=\"headerlink\" title=\"潮州 iên / 甲子 ion\"></a>潮州 iên / 甲子 ion</h2><p>例如：</p>\n<ol>\n<li>iên / ion：鴦、羊、陽、楊、洋、樣</li>\n<li>ciên / cion：槍、鯧、搶、牆、象、匠</li>\n<li>diên / dion：張、長、帳、脹、賬、場、丈、趙</li>\n<li>giên / gion： 姜、強、彊</li>\n<li>hiên / hion：香、鄉</li>\n<li>kiên / kion：腔</li>\n<li>siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗</li>\n<li>ziên / zion 漿、章、樟、蔣、掌、醬、上、癢</li>\n</ol>\n<p>例外： </p>\n<ol>\n<li>diên / dio 釣（☞ 鼻音完全脫落）</li>\n</ol>\n<h2 id=\"潮州-ieng-ieg-iang-iag\"><a href=\"#潮州-ieng-ieg-iang-iag\" class=\"headerlink\" title=\"潮州 iêng(iêg) / iang(iag)\"></a>潮州 iêng(iêg) / iang(iag)</h2><p>例如：</p>\n<ol>\n<li>iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援</li>\n<li>biêng / biang：邊、砭、鞭、變、遍、便、辯</li>\n<li>ciêng / ciang：阡、遷、芊、纖、淺</li>\n<li>ciêg / ciag：切</li>\n<li>diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍</li>\n<li>giêng /giang：堅、捐、鵑、見、建、鍵</li>\n<li>hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇</li>\n<li>kiêng /kiang：虔、愆、騫、犬、乾</li>\n<li>liêng / liang：臉、連、憐、蓮、吝、躪、練</li>\n<li>miêng /miang：免、勉、娩、憫、敏、緬、腼、綿</li>\n<li>ngiêng / ngiang：妍、研、齴</li>\n<li>ngiêg / ngiag：嚙（～齒）</li>\n</ol>\n<h2 id=\"潮州-ing-ig-甲子eng-eg-、-iang-iag\"><a href=\"#潮州-ing-ig-甲子eng-eg-、-iang-iag\" class=\"headerlink\" title=\"潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\"></a>潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)</h2><p>例如：</p>\n<ol>\n<li>mig / mêg：默、陌</li>\n<li>ing / iang：沿、鉛</li>\n<li>mig / miag：滅、蔑</li>\n<li>zing / ziang：薦</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演</li>\n<li>ing / hing：暈</li>\n<li>bing / bing：乒、賓、彬、斌、稟</li>\n<li>big / big：筆、必、畢、蓽、篳、弼</li>\n<li>bhig / bhig：蜜</li>\n<li>cing / cing：親、臣、秦</li>\n<li>cig / cig：七</li>\n<li>ding / ding：顛、振、鎮、塵、藤、陣</li>\n<li>cing / cim：襯</li>\n<li>king / king：輕、氫</li>\n<li>ling / ling：鄰、遴、嶙、麟</li>\n<li>ming / ming：民、氓、泯、眠、面</li>\n<li>mig / mig 密、蜜、冪、覓、謐</li>\n<li>ning / ning 恁</li>\n<li>ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻</li>\n<li>bing / ping：品</li>\n<li>ring / ring：人、仁、認</li>\n<li>sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛</li>\n<li>ting / ting： 烴、陳、澄</li>\n<li>zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼</li>\n<li>zing / ding 珍</li>\n</ol>\n<h2 id=\"潮州-iou-iouh-甲子-iao-iaoh\"><a href=\"#潮州-iou-iouh-甲子-iao-iaoh\" class=\"headerlink\" title=\"潮州 iou(iouh) / 甲子 iao(iaoh)\"></a>潮州 iou(iouh) / 甲子 iao(iaoh)</h2><p>例如：</p>\n<ol>\n<li>iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀</li>\n<li>biou / biao：表、婊</li>\n<li>ciou / ciao：悄、稍、朝、嘲、瞧、晁</li>\n<li>diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉</li>\n<li>giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬</li>\n<li>hiou / hiao：僥、梟、驍、曉</li>\n<li>kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑</li>\n<li>liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺</li>\n<li>miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）</li>\n<li>niou / niao：撓、裊、皺</li>\n<li>ngiou / ngiao：貓、堯</li>\n<li>piou / piao：飄、漂、嫖、樸</li>\n<li>piou / biao：標</li>\n<li>riou / riao：爪、擾、嬈、繞、饒</li>\n<li>siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶</li>\n<li>tiou / tiao：迢、挑、超、窕、柱</li>\n<li>ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭</li>\n</ol>\n<h2 id=\"潮州-iong-甲子-eng\"><a href=\"#潮州-iong-甲子-eng\" class=\"headerlink\" title=\"潮州 iong / 甲子 êng\"></a>潮州 iong / 甲子 êng</h2><p>例如：</p>\n<ol>\n<li>iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴</li>\n</ol>\n<h2 id=\"潮州-ong-iong\"><a href=\"#潮州-ong-iong\" class=\"headerlink\" title=\"潮州 ong / iong\"></a>潮州 ong / iong</h2><p>例如：</p>\n<ol>\n<li>dong / diong：重、中、忠、仲</li>\n<li>rong / riong：戎、絨、茸</li>\n<li>zong / ziong：眾</li>\n<li>rong / riong：仍、扔</li>\n<li>song / siong：松、訟、誦、頌</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>cong / cong：從、充、衝</li>\n</ol>\n<h2 id=\"潮州-ng-甲子-ing\"><a href=\"#潮州-ng-甲子-ing\" class=\"headerlink\" title=\"潮州 ng / 甲子 ing\"></a>潮州 ng / 甲子 ing</h2><p>例如：</p>\n<ol>\n<li>ng / ing：尹、隱</li>\n<li>hng / hing：軒、欣、鍁、勳、殷</li>\n</ol>\n<h2 id=\"潮州-oin-甲子-ain\"><a href=\"#潮州-oin-甲子-ain\" class=\"headerlink\" title=\"潮州 oin / 甲子 ain\"></a>潮州 oin / 甲子 ain</h2><p>例如：</p>\n<ol>\n<li>oin / ain：閒</li>\n<li>boin / bain：斑、反、板、爿</li>\n<li>coin / cain：千、蠶</li>\n<li>doin / dain：殿</li>\n<li>goin / gain：間、肩、繭</li>\n<li>hoin / hain：蜆、還、莧</li>\n<li>koin / kain：蓋</li>\n<li>soin / sain：先</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>toin / toin：睇</li>\n<li>noin / nai：蓮（☞ 鼻音完全脫落）</li>\n</ol>\n<p>☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。</p>\n<h2 id=\"潮州-ue-ueh-甲子-oi-oih\"><a href=\"#潮州-ue-ueh-甲子-oi-oih\" class=\"headerlink\" title=\"潮州 uê(uêh) / 甲子 oi(oih)\"></a>潮州 uê(uêh) / 甲子 oi(oih)</h2><p>例如：</p>\n<ol>\n<li>uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛</li>\n<li>uêh / oih：划、畫</li>\n<li>buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩</li>\n<li>buê / poi：陪</li>\n<li>bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未</li>\n<li>cuê / coi：吹、炊、髓、覓</li>\n<li>duê / doi：綴、兌</li>\n<li>guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）</li>\n<li>guêh / goih：郭、橛</li>\n<li>ghuêh / ghoih8：月</li>\n<li>huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）</li>\n<li>huêh / hoih：血</li>\n<li>kuê / koi：科、蝌、課、稞、瘸</li>\n<li>kuêh / koih：缺、闕、闋</li>\n<li>muêh / moih：物</li>\n<li>muê / moi：每、糜、妹、昧、寐、魅、袂</li>\n<li>nuê / noi：餒</li>\n<li>puê / poi：皮、被、坯、胚、配、裴</li>\n<li>puêh / poih：詖、坺</li>\n<li>ruê / roi：枘、蚋、銳、睿</li>\n<li>suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅</li>\n<li>suêh / soih：說</li>\n<li>tuê / toi：頹</li>\n<li>zuê / zoi：最、襊、罪、㩼</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêh / ghoih：襪</li>\n<li>kuê / kui：盔</li>\n<li>suêh / suah：刷、涮</li>\n</ol>\n<h2 id=\"潮州-uen-甲子-oin\"><a href=\"#潮州-uen-甲子-oin\" class=\"headerlink\" title=\"潮州 uên / 甲子 oin\"></a>潮州 uên / 甲子 oin</h2><p>例如：</p>\n<ol>\n<li>guên / goin：關、果</li>\n<li>huên / hoin：橫</li>\n</ol>\n<h2 id=\"潮州-ueng-ueg-甲子-uang-uag\"><a href=\"#潮州-ueng-ueg-甲子-uang-uag\" class=\"headerlink\" title=\"潮州 uêng(uêg) / 甲子 uang(uag)\"></a>潮州 uêng(uêg) / 甲子 uang(uag)</h2><p>例如：</p>\n<ol>\n<li>uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣</li>\n<li>uêg / uag：曰、斡、鉞、越、粵</li>\n<li>buêng / puang：叛</li>\n<li>buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤</li>\n<li>bhuêng / muan：幔（☞ 後鼻音退成鼻化音）</li>\n<li>cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓</li>\n<li>cuêg / cuag：啜、綴、輟</li>\n<li>duêng / duang：端、斷、鍛、段（又音deng）、篆</li>\n<li>guêng / guang：關、觀、冠、鰥</li>\n<li>guêg / guag：決、訣、抉、玦、聒、譎</li>\n<li>guêg / kuag：括</li>\n<li>huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢</li>\n<li>huêg / huag：發、髮、乏、穴、伐、罰、閥</li>\n<li>kuêng / kuang：寬、圈、髖、權、款、蜷</li>\n<li>kuêg / kuag：擴</li>\n<li>luêng / luang：暖、戀、巒、孿、鸞、亂</li>\n<li>luêg / luag：劣</li>\n<li>muêg / muag：末、沫、秣</li>\n<li>nguêng / nguang：阮、玩、頑、元、原、源、願</li>\n<li>puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣</li>\n<li>puêng / puan：般（☞ 後鼻音退成鼻化音）</li>\n<li>puêg / puag：潑、銖</li>\n<li>ruêng / ruang：亂</li>\n<li>ruêg / ruag：悅</li>\n<li>suêng / suang：選、算（又音 seng）、旋、漩</li>\n<li>tuêng / tuang：湍、團、傳</li>\n<li>zuêng / zuang： 專、轉、鐫、顓、撰</li>\n<li>zuêg / zuag：拙、茁、咄、絀</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêng/mang：萬、饅、慢、漫</li>\n<li>kuêng /  kêng：傾、頃、卿</li>\n<li>huêng / hoin：衡</li>\n<li>huêg / hoig：或 、惑</li>\n<li>uêg / oig：獲 、域、役、鑊</li>\n<li>guêng / goin：囧、炯、耿、穎</li>\n<li>nguêng / ngiang：顏</li>\n<li>nguêng / iang：芫</li>\n</ol>\n<h2 id=\"其餘\"><a href=\"#其餘\" class=\"headerlink\" title=\"其餘\"></a>其餘</h2><ol>\n<li>宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³</li>\n<li>唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²</li>\n<li>言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²</li>\n<li>瓊、煢：潮州kuang⁵ / 甲子kêng⁵</li>\n<li>舀：潮州 io² / 甲子ion² </li>\n</ol>"},{"title":"在潮劇中學之《玉堂春》","p":"language/min/teochew-opera-ghêgdengcung","date":"2020-10-16T04:00:00.000Z","_content":"\n潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。\n\n潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）\n\n<!--more-->\n\n今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n## 故事概要\n蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。\n\n另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。\n\n恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。\n\n在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。\n\n網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：\n- 明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。\n- 20世紀30年代，**林如烈**編導《王金龍》，即《玉堂春》。\n-  1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。\n- 1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計**黃欽賜**，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。\n\n## 潮劇筆記\n\n### 上集第一場 \n故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。\n1. 5:01 衋(gêg⁴)心：傷心。\n2. 5:13 煩惱(huang⁵ lo²)：擔心。\n3. 5:22 變(bin³)作寶。\n4. 5:44 相(siên³)輔：幫忙。\n5. 5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。\n6. 7:24 鴇(bao²)婆。\n7. 9:12 人客：客人。\n8. 10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。\n9. 10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。\n10. 10:55 十五貫錢，買作菜脯，儉儉好食一年。\n11. 10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。\n12. 11:27 個面七個空，怎知汝是乜人。\n13. 11:37 縣衙(guin⁷ ghê⁵)。\n14. 11:41 頭欹欹(ki¹)：歪頭狀。\n15. 11:57 常來常往，若敢胡來，就著知慘。\n16. 12:47 稍(ciao²)候。\n17. 13:10 至切：一定。如：至切勿上錯牀。\n18. 15:04 吃(ngeg⁴)。\n19. 15:48 參詳：商量。如：這事好參詳。\n20. 15:49 偪側(bêg⁴ cêg⁴)：逼迫。\n21. 16:14 娉婷(pêng³ têng⁵)。\n22. 16:53 後生人：年輕人。\n23. 16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。\n24. 17:03 愈更：更加。如：愈更胡說。\n25. 17:20 強扭之瓜不甜，強掰之花不香。\n26. 17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。\n\n### 上集第二場\n故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。\n1. 21:14王(hêng⁵)瓊。\n2. 23:09 才華洋溢(iang⁵ êg⁸)。\n3. 25:12 鴛鴦(uang¹ iang¹)。\n4. 27:56 絢(sung¹)麗。\n5. 28:09 秦樓楚館煙(ing¹)花地。\n6. 30:30 銅錢落草草會青，豈容坐食破大家。\n7. 30:42 仔細：客氣。如：免仔細。\n8. 30:43 熟人免行生(cên¹)禮(loi²)。\n9. 32:02 一朝無食夫妻無義。\n10. 33:33 沈溺(dim⁵ nêg⁸)。\n11. 33:33 紈絝(iang⁵ kou³)子弟。\n12. 33:51 戰戰兢兢(kêng¹)。\n13. 35:08 食罪陷百罹(li⁵)。\n14. 38:15 鵬程(pong⁵ têng⁵)。\n15. 38:30 擔承：承擔。\n16. 39:25 畜(têg⁴)生。\n17. 40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。\n18. 40:13 如其不然。\n\n### 上集第三場 關王廟♥️\n![](teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png)\n故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。\n1. 41:40 奇事年年有，無年奇相同。\n2. 42:00 花子(hua¹ ze²)：叫花子。\n3. 42:13 庵寺：尼寺、僧寺的通稱。\n4. 42:24 照書行事。\n5. 44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。\n6. 45:16 殷勤(heng¹ keng⁵)。\n7. 46:57 人事不省(sêng³)。\n8. 48:12 五行：面相，處境。\n9. 48:37 忍淚吞聲(sêng¹)。\n10. 49:35 訴(su³)苦。\n11. 49:35 顏(nguang⁵)色。\n12. 50:13 烏雲密佈(bu³)。\n13. 50:24 時運不濟。\n14. 52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。\n15. 53:52 坫(diam³)：躲藏。如：走去坫牀下。\n16. 55:09 祭奠(diang⁶)。\n17. 56:14 齊備(ci⁵ bi⁶)：齊全完備。\n18. 56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。\n19. 1:00:27 愁雲冉冉難見晴空。\n20. 1:00:49 飛禍疊(tah⁸)至慘無窮。\n21. 1:01:13 噩耗(ngag⁸ ho³)。\n22. 1:04:35 衣衫襤褸(nam⁵ nu²)。\n23. 1:05:08 邂逅(hai⁶ hou⁶)。\n24. 1:05:44 一霎(siab⁴)時。\n25. 1:07:09 果(guan²)然。\n26. 1:07:17 妾願隨君陰曹去，從此聚首不分離。\n27. 1:09:23 嗟嘆(za¹ tam³)。\n28. 1:09:55 寂寞(sog⁴ mog⁸)。\n29. 1:10:49 啜(coih⁴)泣。\n30. 1:11:43 甌：大碗。\n31. 1:11:44 箸：筷子。\n32. 1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。\n33. 1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。\n34. 1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。\n\n### 上集第四場\n故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。\n1. 1:19:22 未是孥囝砌宮闈，騙汝好怎呢？\n2. 1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」\n3. 1:22:48 主僕(bog⁸)。\n4. 1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。\n5. 1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。\n6. 1:26:29 惆悵(tiu⁵ ziang³)。\n7. 1:26:46 贖(sog⁸)身。\n8. 1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。\n9. 1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？\n\n### 上集第五場\n故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。\n1. 1:34:11 眼中釘(ding¹/dêng¹)。\n2. 1:40:47 聰穎(kêng²)。\n3. 1:41:22 物輕意重。\n4. 1:42:26 狗母蛇假龍。\n5. 1:42:45 好心分你作歹意。\n6. 1:42:56 皮燈籠，肚內明。\n7. 1:43:45 二山相疊出出出。\n8. 1:48:16 拖三延四。\n9. 1:51:36 糙米錔(tag⁴)空臼(ku⁶)。\n\n### 上集第六場 縣衙公堂\n故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。\n1. 2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。\n2. 2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。\n3. 2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。\n4. 2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。\n5. 2:05:40 好貨墊底。\n6. 2:09:42 砒(bi¹)霜。\n7. 2:11:02 舵(dua⁶)。如：轉舵往回走。\n8. 2:14:41 因依：原委、緣由。如：時晴時雨何因依。\n9. 2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。\n10. 2:17:32 死牢(lo⁵)。\n\n### 下集第一場\n故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。\n1. 名譽(u⁶)。\n2. 花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。\n3. 蹺蹊(kiao¹ ki¹)：蹊蹺。\n\n### 下集第二場 荒野 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png)\n故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。\n1. 2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。\n2. 2:36:54 跋涉(buag⁸ siab⁴)。\n3. 2:37:35 拚駁：盡力辯駁。\n4. 2:41:20 勿許生哩免這生，欲許生哩著這生。\n5. 2:42:18 含冤負屈。\n6. 2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。\n7. 2:49:18 一死如死，現死駁賒死。\n8. 2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。\n9. 2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。\n\n### 下集第三場 太原府公堂 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png)\n故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。\n1. 2:55:28布(bu³)政使(sai³)，官名。\n2. 2:59:24寸步難行(hêng⁵)。\n3. 3:03:13 昏厥(kiag⁴)。\n4. 3:12:26 修葺(cib⁴)。\n5. 3:16:50 梟(hiao¹)情絕義：無情無義。\n6. 3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。\n\n### 下集第四場\n故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。\n1. 3:28:46 金釵(toi¹)。\n2. 3:29:16 擺宴(ang³)。\n3. 3:31:55 家無常禮(li²)。\n\n### 下集第五場♥️ 城外五里亭（梅亭）\n![](teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png)\n故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。\n1. 3:37:56 怨疊疊(tah⁸)，恨重重。\n2. 3:41:05 履(li²)薄衣單(dang¹)。\n3. 3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。\n4. 3:44:04 坐摩(mua⁵)些。摩，近。\n5. 3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。\n6. 3:55:39 啱(ngam¹)：恰好。\n7. 3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。\n8. 4:01:06 假惺惺(sêng¹)。\n9. 4:01:07 寒夜無燈心自明。\n10. 4:08:46 失寵(tong²)。\n11. 4:17:10 珍重(diang¹ dong⁶)。\n12. 4:19:12 草芥(gai⁶)。如：功名利祿如草芥。\n\n### 下集第六場\n故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。\n1. 4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。\n2. 4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。\n3. 4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。\n","source":"_posts/language/min/teochew-opera-ghêgdengcung.md","raw":"---\ntitle: 在潮劇中學之《玉堂春》\np: language/min/teochew-opera-ghêgdengcung\ndate: 2020-10-16 12:00:00\ntags:\n- 潮劇\n- 潮州話\n- 閩南語\n---\n\n潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。\n\n潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）\n\n<!--more-->\n\n今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n## 故事概要\n蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。\n\n另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。\n\n恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。\n\n在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。\n\n網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：\n- 明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。\n- 20世紀30年代，**林如烈**編導《王金龍》，即《玉堂春》。\n-  1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。\n- 1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計**黃欽賜**，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。\n\n## 潮劇筆記\n\n### 上集第一場 \n故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。\n1. 5:01 衋(gêg⁴)心：傷心。\n2. 5:13 煩惱(huang⁵ lo²)：擔心。\n3. 5:22 變(bin³)作寶。\n4. 5:44 相(siên³)輔：幫忙。\n5. 5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。\n6. 7:24 鴇(bao²)婆。\n7. 9:12 人客：客人。\n8. 10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。\n9. 10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。\n10. 10:55 十五貫錢，買作菜脯，儉儉好食一年。\n11. 10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。\n12. 11:27 個面七個空，怎知汝是乜人。\n13. 11:37 縣衙(guin⁷ ghê⁵)。\n14. 11:41 頭欹欹(ki¹)：歪頭狀。\n15. 11:57 常來常往，若敢胡來，就著知慘。\n16. 12:47 稍(ciao²)候。\n17. 13:10 至切：一定。如：至切勿上錯牀。\n18. 15:04 吃(ngeg⁴)。\n19. 15:48 參詳：商量。如：這事好參詳。\n20. 15:49 偪側(bêg⁴ cêg⁴)：逼迫。\n21. 16:14 娉婷(pêng³ têng⁵)。\n22. 16:53 後生人：年輕人。\n23. 16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。\n24. 17:03 愈更：更加。如：愈更胡說。\n25. 17:20 強扭之瓜不甜，強掰之花不香。\n26. 17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。\n\n### 上集第二場\n故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。\n1. 21:14王(hêng⁵)瓊。\n2. 23:09 才華洋溢(iang⁵ êg⁸)。\n3. 25:12 鴛鴦(uang¹ iang¹)。\n4. 27:56 絢(sung¹)麗。\n5. 28:09 秦樓楚館煙(ing¹)花地。\n6. 30:30 銅錢落草草會青，豈容坐食破大家。\n7. 30:42 仔細：客氣。如：免仔細。\n8. 30:43 熟人免行生(cên¹)禮(loi²)。\n9. 32:02 一朝無食夫妻無義。\n10. 33:33 沈溺(dim⁵ nêg⁸)。\n11. 33:33 紈絝(iang⁵ kou³)子弟。\n12. 33:51 戰戰兢兢(kêng¹)。\n13. 35:08 食罪陷百罹(li⁵)。\n14. 38:15 鵬程(pong⁵ têng⁵)。\n15. 38:30 擔承：承擔。\n16. 39:25 畜(têg⁴)生。\n17. 40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。\n18. 40:13 如其不然。\n\n### 上集第三場 關王廟♥️\n![](teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png)\n故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。\n1. 41:40 奇事年年有，無年奇相同。\n2. 42:00 花子(hua¹ ze²)：叫花子。\n3. 42:13 庵寺：尼寺、僧寺的通稱。\n4. 42:24 照書行事。\n5. 44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。\n6. 45:16 殷勤(heng¹ keng⁵)。\n7. 46:57 人事不省(sêng³)。\n8. 48:12 五行：面相，處境。\n9. 48:37 忍淚吞聲(sêng¹)。\n10. 49:35 訴(su³)苦。\n11. 49:35 顏(nguang⁵)色。\n12. 50:13 烏雲密佈(bu³)。\n13. 50:24 時運不濟。\n14. 52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。\n15. 53:52 坫(diam³)：躲藏。如：走去坫牀下。\n16. 55:09 祭奠(diang⁶)。\n17. 56:14 齊備(ci⁵ bi⁶)：齊全完備。\n18. 56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。\n19. 1:00:27 愁雲冉冉難見晴空。\n20. 1:00:49 飛禍疊(tah⁸)至慘無窮。\n21. 1:01:13 噩耗(ngag⁸ ho³)。\n22. 1:04:35 衣衫襤褸(nam⁵ nu²)。\n23. 1:05:08 邂逅(hai⁶ hou⁶)。\n24. 1:05:44 一霎(siab⁴)時。\n25. 1:07:09 果(guan²)然。\n26. 1:07:17 妾願隨君陰曹去，從此聚首不分離。\n27. 1:09:23 嗟嘆(za¹ tam³)。\n28. 1:09:55 寂寞(sog⁴ mog⁸)。\n29. 1:10:49 啜(coih⁴)泣。\n30. 1:11:43 甌：大碗。\n31. 1:11:44 箸：筷子。\n32. 1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。\n33. 1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。\n34. 1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。\n\n### 上集第四場\n故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。\n1. 1:19:22 未是孥囝砌宮闈，騙汝好怎呢？\n2. 1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」\n3. 1:22:48 主僕(bog⁸)。\n4. 1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。\n5. 1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。\n6. 1:26:29 惆悵(tiu⁵ ziang³)。\n7. 1:26:46 贖(sog⁸)身。\n8. 1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。\n9. 1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？\n\n### 上集第五場\n故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。\n1. 1:34:11 眼中釘(ding¹/dêng¹)。\n2. 1:40:47 聰穎(kêng²)。\n3. 1:41:22 物輕意重。\n4. 1:42:26 狗母蛇假龍。\n5. 1:42:45 好心分你作歹意。\n6. 1:42:56 皮燈籠，肚內明。\n7. 1:43:45 二山相疊出出出。\n8. 1:48:16 拖三延四。\n9. 1:51:36 糙米錔(tag⁴)空臼(ku⁶)。\n\n### 上集第六場 縣衙公堂\n故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。\n1. 2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。\n2. 2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。\n3. 2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。\n4. 2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。\n5. 2:05:40 好貨墊底。\n6. 2:09:42 砒(bi¹)霜。\n7. 2:11:02 舵(dua⁶)。如：轉舵往回走。\n8. 2:14:41 因依：原委、緣由。如：時晴時雨何因依。\n9. 2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。\n10. 2:17:32 死牢(lo⁵)。\n\n### 下集第一場\n故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。\n1. 名譽(u⁶)。\n2. 花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。\n3. 蹺蹊(kiao¹ ki¹)：蹊蹺。\n\n### 下集第二場 荒野 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png)\n故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。\n1. 2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。\n2. 2:36:54 跋涉(buag⁸ siab⁴)。\n3. 2:37:35 拚駁：盡力辯駁。\n4. 2:41:20 勿許生哩免這生，欲許生哩著這生。\n5. 2:42:18 含冤負屈。\n6. 2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。\n7. 2:49:18 一死如死，現死駁賒死。\n8. 2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。\n9. 2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。\n\n### 下集第三場 太原府公堂 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png)\n故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。\n1. 2:55:28布(bu³)政使(sai³)，官名。\n2. 2:59:24寸步難行(hêng⁵)。\n3. 3:03:13 昏厥(kiag⁴)。\n4. 3:12:26 修葺(cib⁴)。\n5. 3:16:50 梟(hiao¹)情絕義：無情無義。\n6. 3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。\n\n### 下集第四場\n故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。\n1. 3:28:46 金釵(toi¹)。\n2. 3:29:16 擺宴(ang³)。\n3. 3:31:55 家無常禮(li²)。\n\n### 下集第五場♥️ 城外五里亭（梅亭）\n![](teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png)\n故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。\n1. 3:37:56 怨疊疊(tah⁸)，恨重重。\n2. 3:41:05 履(li²)薄衣單(dang¹)。\n3. 3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。\n4. 3:44:04 坐摩(mua⁵)些。摩，近。\n5. 3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。\n6. 3:55:39 啱(ngam¹)：恰好。\n7. 3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。\n8. 4:01:06 假惺惺(sêng¹)。\n9. 4:01:07 寒夜無燈心自明。\n10. 4:08:46 失寵(tong²)。\n11. 4:17:10 珍重(diang¹ dong⁶)。\n12. 4:19:12 草芥(gai⁶)。如：功名利祿如草芥。\n\n### 下集第六場\n故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。\n1. 4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。\n2. 4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。\n3. 4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。\n","slug":"language/min/teochew-opera-ghêgdengcung","published":1,"updated":"2021-09-13T14:05:14.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfn002u1n9kh13eeldd","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。</p>\n<p>潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）</p>\n<span id=\"more\"></span>\n\n<p>今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：</p>\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<h2 id=\"故事概要\"><a href=\"#故事概要\" class=\"headerlink\" title=\"故事概要\"></a>故事概要</h2><p>蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。</p>\n<p>另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。</p>\n<p>恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。</p>\n<p>在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。</p>\n<p>網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：</p>\n<ul>\n<li>明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。</li>\n<li>20世紀30年代，<strong>林如烈</strong>編導《王金龍》，即《玉堂春》。</li>\n<li>1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。</li>\n<li>1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計<strong>黃欽賜</strong>，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。</li>\n</ul>\n<h2 id=\"潮劇筆記\"><a href=\"#潮劇筆記\" class=\"headerlink\" title=\"潮劇筆記\"></a>潮劇筆記</h2><h3 id=\"上集第一場\"><a href=\"#上集第一場\" class=\"headerlink\" title=\"上集第一場\"></a>上集第一場</h3><p>故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。</p>\n<ol>\n<li>5:01 衋(gêg⁴)心：傷心。</li>\n<li>5:13 煩惱(huang⁵ lo²)：擔心。</li>\n<li>5:22 變(bin³)作寶。</li>\n<li>5:44 相(siên³)輔：幫忙。</li>\n<li>5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。</li>\n<li>7:24 鴇(bao²)婆。</li>\n<li>9:12 人客：客人。</li>\n<li>10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。</li>\n<li>10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。</li>\n<li>10:55 十五貫錢，買作菜脯，儉儉好食一年。</li>\n<li>10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。</li>\n<li>11:27 個面七個空，怎知汝是乜人。</li>\n<li>11:37 縣衙(guin⁷ ghê⁵)。</li>\n<li>11:41 頭欹欹(ki¹)：歪頭狀。</li>\n<li>11:57 常來常往，若敢胡來，就著知慘。</li>\n<li>12:47 稍(ciao²)候。</li>\n<li>13:10 至切：一定。如：至切勿上錯牀。</li>\n<li>15:04 吃(ngeg⁴)。</li>\n<li>15:48 參詳：商量。如：這事好參詳。</li>\n<li>15:49 偪側(bêg⁴ cêg⁴)：逼迫。</li>\n<li>16:14 娉婷(pêng³ têng⁵)。</li>\n<li>16:53 後生人：年輕人。</li>\n<li>16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。</li>\n<li>17:03 愈更：更加。如：愈更胡說。</li>\n<li>17:20 強扭之瓜不甜，強掰之花不香。</li>\n<li>17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。</li>\n</ol>\n<h3 id=\"上集第二場\"><a href=\"#上集第二場\" class=\"headerlink\" title=\"上集第二場\"></a>上集第二場</h3><p>故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。</p>\n<ol>\n<li>21:14王(hêng⁵)瓊。</li>\n<li>23:09 才華洋溢(iang⁵ êg⁸)。</li>\n<li>25:12 鴛鴦(uang¹ iang¹)。</li>\n<li>27:56 絢(sung¹)麗。</li>\n<li>28:09 秦樓楚館煙(ing¹)花地。</li>\n<li>30:30 銅錢落草草會青，豈容坐食破大家。</li>\n<li>30:42 仔細：客氣。如：免仔細。</li>\n<li>30:43 熟人免行生(cên¹)禮(loi²)。</li>\n<li>32:02 一朝無食夫妻無義。</li>\n<li>33:33 沈溺(dim⁵ nêg⁸)。</li>\n<li>33:33 紈絝(iang⁵ kou³)子弟。</li>\n<li>33:51 戰戰兢兢(kêng¹)。</li>\n<li>35:08 食罪陷百罹(li⁵)。</li>\n<li>38:15 鵬程(pong⁵ têng⁵)。</li>\n<li>38:30 擔承：承擔。</li>\n<li>39:25 畜(têg⁴)生。</li>\n<li>40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。</li>\n<li>40:13 如其不然。</li>\n</ol>\n<h3 id=\"上集第三場-關王廟♥️\"><a href=\"#上集第三場-關王廟♥️\" class=\"headerlink\" title=\"上集第三場 關王廟♥️\"></a>上集第三場 關王廟♥️</h3><p><img src=\"/language/min/teochew-opera-gh%C3%AAgdengcung/2020-10-14-12.41.34.png\" alt><br>故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。</p>\n<ol>\n<li>41:40 奇事年年有，無年奇相同。</li>\n<li>42:00 花子(hua¹ ze²)：叫花子。</li>\n<li>42:13 庵寺：尼寺、僧寺的通稱。</li>\n<li>42:24 照書行事。</li>\n<li>44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。</li>\n<li>45:16 殷勤(heng¹ keng⁵)。</li>\n<li>46:57 人事不省(sêng³)。</li>\n<li>48:12 五行：面相，處境。</li>\n<li>48:37 忍淚吞聲(sêng¹)。</li>\n<li>49:35 訴(su³)苦。</li>\n<li>49:35 顏(nguang⁵)色。</li>\n<li>50:13 烏雲密佈(bu³)。</li>\n<li>50:24 時運不濟。</li>\n<li>52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。</li>\n<li>53:52 坫(diam³)：躲藏。如：走去坫牀下。</li>\n<li>55:09 祭奠(diang⁶)。</li>\n<li>56:14 齊備(ci⁵ bi⁶)：齊全完備。</li>\n<li>56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。</li>\n<li>1:00:27 愁雲冉冉難見晴空。</li>\n<li>1:00:49 飛禍疊(tah⁸)至慘無窮。</li>\n<li>1:01:13 噩耗(ngag⁸ ho³)。</li>\n<li>1:04:35 衣衫襤褸(nam⁵ nu²)。</li>\n<li>1:05:08 邂逅(hai⁶ hou⁶)。</li>\n<li>1:05:44 一霎(siab⁴)時。</li>\n<li>1:07:09 果(guan²)然。</li>\n<li>1:07:17 妾願隨君陰曹去，從此聚首不分離。</li>\n<li>1:09:23 嗟嘆(za¹ tam³)。</li>\n<li>1:09:55 寂寞(sog⁴ mog⁸)。</li>\n<li>1:10:49 啜(coih⁴)泣。</li>\n<li>1:11:43 甌：大碗。</li>\n<li>1:11:44 箸：筷子。</li>\n<li>1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。</li>\n<li>1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。</li>\n<li>1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。</li>\n</ol>\n<h3 id=\"上集第四場\"><a href=\"#上集第四場\" class=\"headerlink\" title=\"上集第四場\"></a>上集第四場</h3><p>故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。</p>\n<ol>\n<li>1:19:22 未是孥囝砌宮闈，騙汝好怎呢？</li>\n<li>1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」</li>\n<li>1:22:48 主僕(bog⁸)。</li>\n<li>1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。</li>\n<li>1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。</li>\n<li>1:26:29 惆悵(tiu⁵ ziang³)。</li>\n<li>1:26:46 贖(sog⁸)身。</li>\n<li>1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。</li>\n<li>1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？</li>\n</ol>\n<h3 id=\"上集第五場\"><a href=\"#上集第五場\" class=\"headerlink\" title=\"上集第五場\"></a>上集第五場</h3><p>故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。</p>\n<ol>\n<li>1:34:11 眼中釘(ding¹/dêng¹)。</li>\n<li>1:40:47 聰穎(kêng²)。</li>\n<li>1:41:22 物輕意重。</li>\n<li>1:42:26 狗母蛇假龍。</li>\n<li>1:42:45 好心分你作歹意。</li>\n<li>1:42:56 皮燈籠，肚內明。</li>\n<li>1:43:45 二山相疊出出出。</li>\n<li>1:48:16 拖三延四。</li>\n<li>1:51:36 糙米錔(tag⁴)空臼(ku⁶)。</li>\n</ol>\n<h3 id=\"上集第六場-縣衙公堂\"><a href=\"#上集第六場-縣衙公堂\" class=\"headerlink\" title=\"上集第六場 縣衙公堂\"></a>上集第六場 縣衙公堂</h3><p>故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。</p>\n<ol>\n<li>2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。</li>\n<li>2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。</li>\n<li>2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。</li>\n<li>2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。</li>\n<li>2:05:40 好貨墊底。</li>\n<li>2:09:42 砒(bi¹)霜。</li>\n<li>2:11:02 舵(dua⁶)。如：轉舵往回走。</li>\n<li>2:14:41 因依：原委、緣由。如：時晴時雨何因依。</li>\n<li>2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。</li>\n<li>2:17:32 死牢(lo⁵)。</li>\n</ol>\n<h3 id=\"下集第一場\"><a href=\"#下集第一場\" class=\"headerlink\" title=\"下集第一場\"></a>下集第一場</h3><p>故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。</p>\n<ol>\n<li>名譽(u⁶)。</li>\n<li>花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。</li>\n<li>蹺蹊(kiao¹ ki¹)：蹊蹺。</li>\n</ol>\n<h3 id=\"下集第二場-荒野-♥️\"><a href=\"#下集第二場-荒野-♥️\" class=\"headerlink\" title=\"下集第二場 荒野 ♥️\"></a>下集第二場 荒野 ♥️</h3><p><img src=\"/language/min/teochew-opera-gh%C3%AAgdengcung/2020-10-15-1.10.20.png\" alt><br>故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。</p>\n<ol>\n<li>2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。</li>\n<li>2:36:54 跋涉(buag⁸ siab⁴)。</li>\n<li>2:37:35 拚駁：盡力辯駁。</li>\n<li>2:41:20 勿許生哩免這生，欲許生哩著這生。</li>\n<li>2:42:18 含冤負屈。</li>\n<li>2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。</li>\n<li>2:49:18 一死如死，現死駁賒死。</li>\n<li>2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。</li>\n<li>2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。</li>\n</ol>\n<h3 id=\"下集第三場-太原府公堂-♥️\"><a href=\"#下集第三場-太原府公堂-♥️\" class=\"headerlink\" title=\"下集第三場 太原府公堂 ♥️\"></a>下集第三場 太原府公堂 ♥️</h3><p><img src=\"/language/min/teochew-opera-gh%C3%AAgdengcung/2020-10-15-1.11.30.png\" alt><br>故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。</p>\n<ol>\n<li>2:55:28布(bu³)政使(sai³)，官名。</li>\n<li>2:59:24寸步難行(hêng⁵)。</li>\n<li>3:03:13 昏厥(kiag⁴)。</li>\n<li>3:12:26 修葺(cib⁴)。</li>\n<li>3:16:50 梟(hiao¹)情絕義：無情無義。</li>\n<li>3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。</li>\n</ol>\n<h3 id=\"下集第四場\"><a href=\"#下集第四場\" class=\"headerlink\" title=\"下集第四場\"></a>下集第四場</h3><p>故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。</p>\n<ol>\n<li>3:28:46 金釵(toi¹)。</li>\n<li>3:29:16 擺宴(ang³)。</li>\n<li>3:31:55 家無常禮(li²)。</li>\n</ol>\n<h3 id=\"下集第五場♥️-城外五里亭（梅亭）\"><a href=\"#下集第五場♥️-城外五里亭（梅亭）\" class=\"headerlink\" title=\"下集第五場♥️ 城外五里亭（梅亭）\"></a>下集第五場♥️ 城外五里亭（梅亭）</h3><p><img src=\"/language/min/teochew-opera-gh%C3%AAgdengcung/2020-10-15-1.12.28.png\" alt><br>故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。</p>\n<ol>\n<li>3:37:56 怨疊疊(tah⁸)，恨重重。</li>\n<li>3:41:05 履(li²)薄衣單(dang¹)。</li>\n<li>3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。</li>\n<li>3:44:04 坐摩(mua⁵)些。摩，近。</li>\n<li>3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。</li>\n<li>3:55:39 啱(ngam¹)：恰好。</li>\n<li>3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。</li>\n<li>4:01:06 假惺惺(sêng¹)。</li>\n<li>4:01:07 寒夜無燈心自明。</li>\n<li>4:08:46 失寵(tong²)。</li>\n<li>4:17:10 珍重(diang¹ dong⁶)。</li>\n<li>4:19:12 草芥(gai⁶)。如：功名利祿如草芥。</li>\n</ol>\n<h3 id=\"下集第六場\"><a href=\"#下集第六場\" class=\"headerlink\" title=\"下集第六場\"></a>下集第六場</h3><p>故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。</p>\n<ol>\n<li>4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。</li>\n<li>4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。</li>\n<li>4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。</p>\n<p>潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）</p>","more":"<p>今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：</p>\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<h2 id=\"故事概要\"><a href=\"#故事概要\" class=\"headerlink\" title=\"故事概要\"></a>故事概要</h2><p>蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。</p>\n<p>另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。</p>\n<p>恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。</p>\n<p>在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。</p>\n<p>網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：</p>\n<ul>\n<li>明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。</li>\n<li>20世紀30年代，<strong>林如烈</strong>編導《王金龍》，即《玉堂春》。</li>\n<li>1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。</li>\n<li>1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計<strong>黃欽賜</strong>，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。</li>\n</ul>\n<h2 id=\"潮劇筆記\"><a href=\"#潮劇筆記\" class=\"headerlink\" title=\"潮劇筆記\"></a>潮劇筆記</h2><h3 id=\"上集第一場\"><a href=\"#上集第一場\" class=\"headerlink\" title=\"上集第一場\"></a>上集第一場</h3><p>故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。</p>\n<ol>\n<li>5:01 衋(gêg⁴)心：傷心。</li>\n<li>5:13 煩惱(huang⁵ lo²)：擔心。</li>\n<li>5:22 變(bin³)作寶。</li>\n<li>5:44 相(siên³)輔：幫忙。</li>\n<li>5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。</li>\n<li>7:24 鴇(bao²)婆。</li>\n<li>9:12 人客：客人。</li>\n<li>10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。</li>\n<li>10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。</li>\n<li>10:55 十五貫錢，買作菜脯，儉儉好食一年。</li>\n<li>10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。</li>\n<li>11:27 個面七個空，怎知汝是乜人。</li>\n<li>11:37 縣衙(guin⁷ ghê⁵)。</li>\n<li>11:41 頭欹欹(ki¹)：歪頭狀。</li>\n<li>11:57 常來常往，若敢胡來，就著知慘。</li>\n<li>12:47 稍(ciao²)候。</li>\n<li>13:10 至切：一定。如：至切勿上錯牀。</li>\n<li>15:04 吃(ngeg⁴)。</li>\n<li>15:48 參詳：商量。如：這事好參詳。</li>\n<li>15:49 偪側(bêg⁴ cêg⁴)：逼迫。</li>\n<li>16:14 娉婷(pêng³ têng⁵)。</li>\n<li>16:53 後生人：年輕人。</li>\n<li>16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。</li>\n<li>17:03 愈更：更加。如：愈更胡說。</li>\n<li>17:20 強扭之瓜不甜，強掰之花不香。</li>\n<li>17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。</li>\n</ol>\n<h3 id=\"上集第二場\"><a href=\"#上集第二場\" class=\"headerlink\" title=\"上集第二場\"></a>上集第二場</h3><p>故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。</p>\n<ol>\n<li>21:14王(hêng⁵)瓊。</li>\n<li>23:09 才華洋溢(iang⁵ êg⁸)。</li>\n<li>25:12 鴛鴦(uang¹ iang¹)。</li>\n<li>27:56 絢(sung¹)麗。</li>\n<li>28:09 秦樓楚館煙(ing¹)花地。</li>\n<li>30:30 銅錢落草草會青，豈容坐食破大家。</li>\n<li>30:42 仔細：客氣。如：免仔細。</li>\n<li>30:43 熟人免行生(cên¹)禮(loi²)。</li>\n<li>32:02 一朝無食夫妻無義。</li>\n<li>33:33 沈溺(dim⁵ nêg⁸)。</li>\n<li>33:33 紈絝(iang⁵ kou³)子弟。</li>\n<li>33:51 戰戰兢兢(kêng¹)。</li>\n<li>35:08 食罪陷百罹(li⁵)。</li>\n<li>38:15 鵬程(pong⁵ têng⁵)。</li>\n<li>38:30 擔承：承擔。</li>\n<li>39:25 畜(têg⁴)生。</li>\n<li>40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。</li>\n<li>40:13 如其不然。</li>\n</ol>\n<h3 id=\"上集第三場-關王廟♥️\"><a href=\"#上集第三場-關王廟♥️\" class=\"headerlink\" title=\"上集第三場 關王廟♥️\"></a>上集第三場 關王廟♥️</h3><p><img src=\"/language/min/teochew-opera-gh%C3%AAgdengcung/2020-10-14-12.41.34.png\" alt><br>故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。</p>\n<ol>\n<li>41:40 奇事年年有，無年奇相同。</li>\n<li>42:00 花子(hua¹ ze²)：叫花子。</li>\n<li>42:13 庵寺：尼寺、僧寺的通稱。</li>\n<li>42:24 照書行事。</li>\n<li>44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。</li>\n<li>45:16 殷勤(heng¹ keng⁵)。</li>\n<li>46:57 人事不省(sêng³)。</li>\n<li>48:12 五行：面相，處境。</li>\n<li>48:37 忍淚吞聲(sêng¹)。</li>\n<li>49:35 訴(su³)苦。</li>\n<li>49:35 顏(nguang⁵)色。</li>\n<li>50:13 烏雲密佈(bu³)。</li>\n<li>50:24 時運不濟。</li>\n<li>52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。</li>\n<li>53:52 坫(diam³)：躲藏。如：走去坫牀下。</li>\n<li>55:09 祭奠(diang⁶)。</li>\n<li>56:14 齊備(ci⁵ bi⁶)：齊全完備。</li>\n<li>56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。</li>\n<li>1:00:27 愁雲冉冉難見晴空。</li>\n<li>1:00:49 飛禍疊(tah⁸)至慘無窮。</li>\n<li>1:01:13 噩耗(ngag⁸ ho³)。</li>\n<li>1:04:35 衣衫襤褸(nam⁵ nu²)。</li>\n<li>1:05:08 邂逅(hai⁶ hou⁶)。</li>\n<li>1:05:44 一霎(siab⁴)時。</li>\n<li>1:07:09 果(guan²)然。</li>\n<li>1:07:17 妾願隨君陰曹去，從此聚首不分離。</li>\n<li>1:09:23 嗟嘆(za¹ tam³)。</li>\n<li>1:09:55 寂寞(sog⁴ mog⁸)。</li>\n<li>1:10:49 啜(coih⁴)泣。</li>\n<li>1:11:43 甌：大碗。</li>\n<li>1:11:44 箸：筷子。</li>\n<li>1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。</li>\n<li>1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。</li>\n<li>1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。</li>\n</ol>\n<h3 id=\"上集第四場\"><a href=\"#上集第四場\" class=\"headerlink\" title=\"上集第四場\"></a>上集第四場</h3><p>故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。</p>\n<ol>\n<li>1:19:22 未是孥囝砌宮闈，騙汝好怎呢？</li>\n<li>1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」</li>\n<li>1:22:48 主僕(bog⁸)。</li>\n<li>1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。</li>\n<li>1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。</li>\n<li>1:26:29 惆悵(tiu⁵ ziang³)。</li>\n<li>1:26:46 贖(sog⁸)身。</li>\n<li>1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。</li>\n<li>1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？</li>\n</ol>\n<h3 id=\"上集第五場\"><a href=\"#上集第五場\" class=\"headerlink\" title=\"上集第五場\"></a>上集第五場</h3><p>故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。</p>\n<ol>\n<li>1:34:11 眼中釘(ding¹/dêng¹)。</li>\n<li>1:40:47 聰穎(kêng²)。</li>\n<li>1:41:22 物輕意重。</li>\n<li>1:42:26 狗母蛇假龍。</li>\n<li>1:42:45 好心分你作歹意。</li>\n<li>1:42:56 皮燈籠，肚內明。</li>\n<li>1:43:45 二山相疊出出出。</li>\n<li>1:48:16 拖三延四。</li>\n<li>1:51:36 糙米錔(tag⁴)空臼(ku⁶)。</li>\n</ol>\n<h3 id=\"上集第六場-縣衙公堂\"><a href=\"#上集第六場-縣衙公堂\" class=\"headerlink\" title=\"上集第六場 縣衙公堂\"></a>上集第六場 縣衙公堂</h3><p>故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。</p>\n<ol>\n<li>2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。</li>\n<li>2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。</li>\n<li>2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。</li>\n<li>2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。</li>\n<li>2:05:40 好貨墊底。</li>\n<li>2:09:42 砒(bi¹)霜。</li>\n<li>2:11:02 舵(dua⁶)。如：轉舵往回走。</li>\n<li>2:14:41 因依：原委、緣由。如：時晴時雨何因依。</li>\n<li>2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。</li>\n<li>2:17:32 死牢(lo⁵)。</li>\n</ol>\n<h3 id=\"下集第一場\"><a href=\"#下集第一場\" class=\"headerlink\" title=\"下集第一場\"></a>下集第一場</h3><p>故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。</p>\n<ol>\n<li>名譽(u⁶)。</li>\n<li>花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。</li>\n<li>蹺蹊(kiao¹ ki¹)：蹊蹺。</li>\n</ol>\n<h3 id=\"下集第二場-荒野-♥️\"><a href=\"#下集第二場-荒野-♥️\" class=\"headerlink\" title=\"下集第二場 荒野 ♥️\"></a>下集第二場 荒野 ♥️</h3><p><img src=\"/language/min/teochew-opera-gh%C3%AAgdengcung/2020-10-15-1.10.20.png\" alt><br>故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。</p>\n<ol>\n<li>2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。</li>\n<li>2:36:54 跋涉(buag⁸ siab⁴)。</li>\n<li>2:37:35 拚駁：盡力辯駁。</li>\n<li>2:41:20 勿許生哩免這生，欲許生哩著這生。</li>\n<li>2:42:18 含冤負屈。</li>\n<li>2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。</li>\n<li>2:49:18 一死如死，現死駁賒死。</li>\n<li>2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。</li>\n<li>2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。</li>\n</ol>\n<h3 id=\"下集第三場-太原府公堂-♥️\"><a href=\"#下集第三場-太原府公堂-♥️\" class=\"headerlink\" title=\"下集第三場 太原府公堂 ♥️\"></a>下集第三場 太原府公堂 ♥️</h3><p><img src=\"/language/min/teochew-opera-gh%C3%AAgdengcung/2020-10-15-1.11.30.png\" alt><br>故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。</p>\n<ol>\n<li>2:55:28布(bu³)政使(sai³)，官名。</li>\n<li>2:59:24寸步難行(hêng⁵)。</li>\n<li>3:03:13 昏厥(kiag⁴)。</li>\n<li>3:12:26 修葺(cib⁴)。</li>\n<li>3:16:50 梟(hiao¹)情絕義：無情無義。</li>\n<li>3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。</li>\n</ol>\n<h3 id=\"下集第四場\"><a href=\"#下集第四場\" class=\"headerlink\" title=\"下集第四場\"></a>下集第四場</h3><p>故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。</p>\n<ol>\n<li>3:28:46 金釵(toi¹)。</li>\n<li>3:29:16 擺宴(ang³)。</li>\n<li>3:31:55 家無常禮(li²)。</li>\n</ol>\n<h3 id=\"下集第五場♥️-城外五里亭（梅亭）\"><a href=\"#下集第五場♥️-城外五里亭（梅亭）\" class=\"headerlink\" title=\"下集第五場♥️ 城外五里亭（梅亭）\"></a>下集第五場♥️ 城外五里亭（梅亭）</h3><p><img src=\"/language/min/teochew-opera-gh%C3%AAgdengcung/2020-10-15-1.12.28.png\" alt><br>故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。</p>\n<ol>\n<li>3:37:56 怨疊疊(tah⁸)，恨重重。</li>\n<li>3:41:05 履(li²)薄衣單(dang¹)。</li>\n<li>3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。</li>\n<li>3:44:04 坐摩(mua⁵)些。摩，近。</li>\n<li>3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。</li>\n<li>3:55:39 啱(ngam¹)：恰好。</li>\n<li>3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。</li>\n<li>4:01:06 假惺惺(sêng¹)。</li>\n<li>4:01:07 寒夜無燈心自明。</li>\n<li>4:08:46 失寵(tong²)。</li>\n<li>4:17:10 珍重(diang¹ dong⁶)。</li>\n<li>4:19:12 草芥(gai⁶)。如：功名利祿如草芥。</li>\n</ol>\n<h3 id=\"下集第六場\"><a href=\"#下集第六場\" class=\"headerlink\" title=\"下集第六場\"></a>下集第六場</h3><p>故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。</p>\n<ol>\n<li>4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。</li>\n<li>4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。</li>\n<li>4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。</li>\n</ol>"},{"title":"《清平樂·村居》陸豐甲子話閩羅注音朗讀","p":"language/min/tsheng-pheng-ngak-tshng-ku","date":"2021-10-30T15:22:00.000Z","_content":"\n《Tshêng-phêng-nga̍k Tshng-ku》Sing Khì-tsi̍p\n\nMâu-siâm ti-siáu, khoi-tsiōnn tshenn-tshenn tsháu.\nTsuì-lí ngôu-im siang mǐ-háu, pe̍h-huak suî ke ong-áu.\n\nTǎi-jî tû tāu khoi-tang, Tiong-jî tsiànn tsik koi-lâng.\nTsòi hí siáu-jî bô-lǎi, khoi-thâu ǒ pak nâinn-phâng.\n\n<!--more-->\n\n{% aplayer \"清平樂·村居\" \"Lim\" \"/language/min/tsheng-pheng-ngak-tshng-ku/清平樂·村居.m4a\" \"/music.png\" %}\n\n-----\n\n《清平樂·村居》\n\n茅檐低小，溪上青青草。\n醉里吳音相媚好，白髮誰家翁媼。\n\n大兒鋤豆溪東，中兒正織雞籠。\n最喜小兒無賴，溪頭臥剝蓮篷。\n","source":"_posts/language/min/tsheng-pheng-ngak-tshng-ku.md","raw":"---\ntitle: 《清平樂·村居》陸豐甲子話閩羅注音朗讀\np: language/min/tsheng-pheng-ngak-tshng-ku\ndate: 2021-10-30 23:22:00\ntags:\n- 宋詞\n- 甲子話\n- 閩南語\n---\n\n《Tshêng-phêng-nga̍k Tshng-ku》Sing Khì-tsi̍p\n\nMâu-siâm ti-siáu, khoi-tsiōnn tshenn-tshenn tsháu.\nTsuì-lí ngôu-im siang mǐ-háu, pe̍h-huak suî ke ong-áu.\n\nTǎi-jî tû tāu khoi-tang, Tiong-jî tsiànn tsik koi-lâng.\nTsòi hí siáu-jî bô-lǎi, khoi-thâu ǒ pak nâinn-phâng.\n\n<!--more-->\n\n{% aplayer \"清平樂·村居\" \"Lim\" \"/language/min/tsheng-pheng-ngak-tshng-ku/清平樂·村居.m4a\" \"/music.png\" %}\n\n-----\n\n《清平樂·村居》\n\n茅檐低小，溪上青青草。\n醉里吳音相媚好，白髮誰家翁媼。\n\n大兒鋤豆溪東，中兒正織雞籠。\n最喜小兒無賴，溪頭臥剝蓮篷。\n","slug":"language/min/tsheng-pheng-ngak-tshng-ku","published":1,"updated":"2021-11-01T22:54:00.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfn002w1n9k9q12070l","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>《Tshêng-phêng-nga̍k Tshng-ku》Sing Khì-tsi̍p</p>\n<p>Mâu-siâm ti-siáu, khoi-tsiōnn tshenn-tshenn tsháu.<br>Tsuì-lí ngôu-im siang mǐ-háu, pe̍h-huak suî ke ong-áu.</p>\n<p>Tǎi-jî tû tāu khoi-tang, Tiong-jî tsiànn tsik koi-lâng.<br>Tsòi hí siáu-jî bô-lǎi, khoi-thâu ǒ pak nâinn-phâng.</p>\n<span id=\"more\"></span>\n\n\n        <div id=\"aplayer-VqhkIAgn\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-VqhkIAgn\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"清平樂·村居\",\n              author: \"Lim\",\n              url: \"/language/min/tsheng-pheng-ngak-tshng-ku/清平樂·村居.m4a\",\n              pic: \"/music.png\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<hr>\n<p>《清平樂·村居》</p>\n<p>茅檐低小，溪上青青草。<br>醉里吳音相媚好，白髮誰家翁媼。</p>\n<p>大兒鋤豆溪東，中兒正織雞籠。<br>最喜小兒無賴，溪頭臥剝蓮篷。</p>\n","site":{"data":{}},"excerpt":"<p>《Tshêng-phêng-nga̍k Tshng-ku》Sing Khì-tsi̍p</p>\n<p>Mâu-siâm ti-siáu, khoi-tsiōnn tshenn-tshenn tsháu.<br>Tsuì-lí ngôu-im siang mǐ-háu, pe̍h-huak suî ke ong-áu.</p>\n<p>Tǎi-jî tû tāu khoi-tang, Tiong-jî tsiànn tsik koi-lâng.<br>Tsòi hí siáu-jî bô-lǎi, khoi-thâu ǒ pak nâinn-phâng.</p>","more":"<div id=\"aplayer-VqhkIAgn\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-VqhkIAgn\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"清平樂·村居\",\n              author: \"Lim\",\n              url: \"/language/min/tsheng-pheng-ngak-tshng-ku/清平樂·村居.m4a\",\n              pic: \"/music.png\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<hr>\n<p>《清平樂·村居》</p>\n<p>茅檐低小，溪上青青草。<br>醉里吳音相媚好，白髮誰家翁媼。</p>\n<p>大兒鋤豆溪東，中兒正織雞籠。<br>最喜小兒無賴，溪頭臥剝蓮篷。</p>"},{"title":"比較 JSON 和 protobuf 並介紹 protobuf編碼、語法及 protobuf over HTTP 示例","p":"it/common/protobuf_intro","date":"2021-11-21T06:12:51.000Z","_content":"\nProtocol Buffers`（簡稱 protobuf）`，是 Google 推出的一種數據交換格式，採用 Varint 和 ZigZag 等二進制編碼，數據壓縮效果顯著，可用來傳輸數據或持久化數據。\n\n## JSON 是什麼？\n\nJSON 全稱爲 JavaScript Object Notation`（JavaScript對象標記）`，即 JS對象的字符串表示。其採用文本編碼，是現今最通用的數據交換格式。2001年3月，State Software公司的聯合創始人設計了此種格式，並隨後進行了標準化。現在有 ECMA-404（2013年）和 RFC-8259（2017年）兩種標準。\n\n## protobuf 是什麼？\n\nprotobuf 全稱爲 Protocol Buffers`（“協議緩衝”）`，是一種數據壓縮性能優秀的數據存儲和交換格式。其採用二進制編碼，通常跟 gRPC 一起使用。\n\n2001年 Google公司內部誕生了proto1版本，並隨後在2008年以BSD協議開源了proto2，2016年釋出proto3正式版。\n\n對於 proto2，官方推出了針對 C++、Java、C# 和 Python 語言的 protobuf編譯器 protoc；而在 proto3 中，增加了對 Dart、GO、Kotlin 和 Ruby 的官方支持。另外，第三方有提供對 JavaScript 和 PHP 等等語言的支持。\n\n<!--more-->\n\n## 開始使用 protobuf\n\n（1）下載編譯器並設置環境變量。\n\n```bash\n# protoc\nPB_REL=\"https://github.com/protocolbuffers/protobuf/releases\"\ncurl -LO $PB_REL/download/v3.15.8/protoc-3.15.8-osx-x86_64.zip\nunzip protoc-3.15.8-osx-x86_64.zip -d ~/go/bin/protoc-3.15.8\ncp ~/go/bin/protoc-3.15.8/bin/protoc ~/go/bin\n\n# protoc-gen-go 和 protoc-gen-go-grpc\ngo get google.golang.org/protobuf/cmd/protoc-gen-go \\\n   google.golang.org/grpc/cmd/protoc-gen-go-grpc\nexport PATH=\"$PATH:$(go env GOPATH)/bin\"\n```\n\n（2）選擇使用 proto2 還是 proto3，不同的版本有不同的語法，且不兼容。相對而言，proto3 的語法更簡單。\n\n（3）根據語法編寫 proto 文件。\n\n```protobuf\nsyntax = \"proto3\";\n\noption go_package = \"/pb\";\n\noption java_package = \"com.example.m.pb\";\noption java_outer_classname = \"AnimalProto\";\n\npackage pb;\n\nmessage Animal{\n  // reserved 1 to 10;\n  // reserved \"id\";\n  int64 id = 1;\n  string name = 2;\n}\n```\n\n（4）生成需要的語言代碼\n\n```bash\nprotoc --go_out=.  animal.proto\n```\n\n生成後的文件 animal.pb.go 如下：\n\n```go\n// Code generated by protoc-gen-go. DO NOT EDIT.\n// versions:\n// \tprotoc-gen-go v1.27.1\n// \tprotoc        v3.15.8\n// source: animal.proto\n\npackage pb\n\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\n\nconst (\n\t// Verify that this generated code is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n)\n\ntype Animal struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tId   int64  `protobuf:\"varint,1,opt,name=id,proto3\" json:\"id,omitempty\"`\n\tName string `protobuf:\"bytes,2,opt,name=name,proto3\" json:\"name,omitempty\"`\n}\n\n...\n```\n\n## JSON 和 protobuf 的編碼大不同\n\n我們舉一個例子來說明會比較直觀。\n\n![柯基犬](protobuf-intro/w644.jpeg)\n\n這是一隻柯基犬，它叫 Dokky，編號 12。我們可以將這些信息結構化成對象如下：\n\n```go\ntype Animal struct{\n    Id      int64   // 12\n    Name    string  // \"Dokky\"\n}\n```\n\n編寫程序分別對該 Animal 進行 JSON 和 protobuf 序列化：\n\n\n```go\nfunc marshal() {\n\tdokky := pb.Animal{\n\t\tId:   12,\n\t\tName: \"Dokky\",\n\t}\n\n\tpbs, _ := proto.Marshal(&dokky)\n\tprintBytes(pbs)\n\n\tjbs, _ := json.Marshal(&dokky)\n\tprintBytes(jbs)\n}\n\nfunc printBytes(bs []byte) {\n\tprintln(len(bs), hex.EncodeToString(bs))\n}\n```\n\n\n結果：\n\n```\n9 080c1205446f6b6b79\n24 7b226964223a31322c226e616d65223a22446f6b6b79227d\n```\n\n**（1）JSON 序列化**\n\n```json\n{\n    \"id\": 12,\n    \"name\": \"Dokky\"\n}\n```\n\n二進制形式（Unicode編碼）：\n\n```\n7b\n    22 6964 22 3a 3132 2c\n    22 6e616d65 22 3a 22 446f6b6b79 22\n7d\n```\n\n共佔用 24 個字節。\n\n**（2）protobuf 序列化**\n\n```\n086c 1205 446fb6b79\n```\n\n共佔用 9 個字節。\n\n通過輸出的結果簡單對比兩種序列化方式可見，protobuf\n\n1. 不編碼變量名；\n2. 沒有額外的 `{}[],:\"\"` 等字符；\n3. 對整型不使用文本編碼。\n\n要具體解讀這串序列，我們還得先來了解下 protobuf 的編碼方式。\n\n### Varint 編碼\n\nVarint 即 Variable int，可變長整型編碼，是 protobuf 中最主要的編碼方式。其採用小端二進制編碼，即 LSB`（Least Significant Bit，最低有效位）`置於低地址。每個字節的首位即 MSB`（Most Significant Bit，最高有效位）`用來標識下個字節是否需要讀取， 1 表示需要，0 反之。\n\n以數字 12 為例（爲簡便起見，假定類型爲 int16）：\n\n```·\n      二進制序列：0000 0000 0000 1100\n從末尾開始7位一組： 000 1100\n        添加MSB：0000 1100\n    十六進制表示：0C\n```\n\n再以數字 255 為例（爲簡便起見，假定類型爲 int16）：\n\n```\n      二進制序列：0000 0000 1111 1110\n從末尾開始7位一組： 111 1110  000 0001\n        添加MSB：1111 1110 0000 0001\n    十六進制表示：FE01\n```\n\n### protobuf 編碼規則\n\n一般來說，在protobuf 中每個字段拆分成四個部分進行編碼，依次是：\n\n![protobuf 字段結構](protobuf-intro/protobuf-field-structure.jpeg)\n\n1. number：字段序號；\n2. type：字段類型，佔用 3 個比特位，與 number 一起構成字段標識 tag，佔用一個或多個字節，採用 Varint 編碼；其取值含義見下表；\n3. length（可選）：字段長度，當 type 爲 2 時有值；\n4. value：字段值，爲零值的字段不會進行編碼。\n\n| Type     | Meaning                      | Used for                                                 |\n| -------- | ---------------------------- | -------------------------------------------------------- |\n| 0（000） | Varint（可變長整型）         | int32、int64、uint32、uint64、sint32、sint64、bool、enum |\n| 1（001） | 64-bit（固定64位）           | fixed64、sfixed64、double                                |\n| 2（010） | Length-delimited（指定長度） | string、bytes、embedded message、packed repeated fields  |\n| 5（101） | 32-bit（固定32位）           | fixed32、sfixed32、float                                 |\n\n### 解讀序列 086c 1205 446fb6b79\n\n```js\n08 => 00001 000 => number: 1, type: 0\n0C => value: 12\n```\n\n序號爲 1 的字段，類型爲 Varint，值爲 12。\n\n```js\n12 => 00010 010 => number: 2, type: 2\n\n05 => length: 5\n\n446fb6b79 => value: Dokky\n```\n\n序號爲 2 的字段，類型爲 Length-delimited，值爲 Dokky。\n\n### ZigZag 編碼\n\n前面我們討論了非負數的 Varint 編碼，現在我們來看看負數。其實對於負數，並不建議使用 int32 或 int64 等類型，而應使用 sint32 或 sint64，即帶符號的整型。為什麼呢？下面我們對 -1 分別指定 int 32 和 sint32 類型進行編碼：\n\n**（1）int32(-1)**\n\n使用 int32 或 int64 類型時，進行 Varint 編碼，負數總是佔用 10 個字節。因此 int32(-1) 編碼爲：\n\n```\n      二進制序列：11111111  11111111  11111111  11111111\n                11111111  11111111  11111111  11111111\n從尾部開始7位一組： 1111111   1111111   1111111   1111111\n                 1111111   1111111   1111111   1111111  1111111 0000001\n        添加MSB：11111111  11111111  11111111  11111111\n                11111111  11111111  11111111  11111111  11111111 00000001\n    十六進制表示：FF FF FF FF\n                FF FF FF FF FF 01\n```\n\n**（2）sint32(-1)**\n\n當使用 sint32 或 sint64 時，會先進行 ZigZag 編碼再進行 Varint 編碼。ZigZag 就是將負數放到整數前面，交替進行編碼，呈“Z” 或 “之” 字形，故有此稱。\n\n對 sint32， 數字 n 的 ZigZag 編碼爲：(n << 1) ^ (n >> 31)\n\n對 sint64， 數字 n 的 ZigZag 編碼爲：(n << 1) ^ (n >> 63)\n\n因此 sint32(-1) 編碼爲：\n\n```\n      二進制序列： 11111111  11111111  11111111  11111111\n        n << 1： 11111111  11111111  11111111  11111110\n       n >> 31： 11111111  11111111  11111111  11111111\n           異或： 00000000  00000000  00000000   00000001\n從尾部開始7位一組：   0000001\n        添加MSB： 00000001\n    十六進制表示： 01\n```\n\n可見，int32(-1) 佔用 10 個字節，而 sint32(-1)  佔用 1 個字節。在值可能爲負數的情況下，應使用帶符號整型，可以大大減少負數的編碼量。\n\n## proto3 語法\n\n```protobuf\n// 指定使用的語言版本\nsyntax = \"proto3\";\n\n// 指定生成文件的 Go 包路徑，使用 '/' 分隔\noption go_package = \"/pb\";\n\n// 指定生成文件的 Java 包路徑，使用 '.' 分隔\noption  java_package = \"com.example.m.pb\";\n// 定義生成文件的 Java 類名\noption java_outer_classname = \"AnimalProto\";\n\n// 指定包名\npackage pb;\n\n// 定義一個名為 Animal 的消息\nmessage Animal{\n  // 定義一個名為 id 的 int64 字段\n  int64 id = 1;\n  // 定義一個名為 name 的 string 字段\n  string name = 2;\n  // 保留第3～5的字段序號\n  reserved 3 to 5;\n  // 保留字段名 kind\n  reserved \"kind\";\n  // 使用 enum 類型\n  Vision vision = 6;\n\n  // 以下字段的值只允許是 HumanDifference 或 OtherAnimalDifference\n  // 設置其中一個值將會清除另一個的值\n  oneof difference{\n    // 使用自定義的結構類型\n    HumanDifference human = 8;\n    OtherAnimalDifference other = 9;\n  }\n}\n\n// 定義一個枚舉類型，按風格要求第一個值須設置為未指定\nenum Vision{\n  VISION_UNSPECSIFIED = 0;\n  VISION_GREAT = 1;\n  VISION_BURRED = 2;\n  VISION_BLIND = 3;\n}\n\nmessage HumanDifference{\n  // 定義一個名為 lang 的 string 數組\n  repeated string langs = 1;\n}\n\nmessage OtherAnimalDifference{\n  // 字段名採用全小寫下划線連接\n  repeated string natural_enemies = 1;\n}\n```\n\n注意：\n\n1. 建议将变量序号 1～15 的给最常用的字段用，并保留扩展；\n2. message 可以导入；\n3. 字段有默认零值，零值不会被序列化；\n4. 字段序號一旦指定，一般不改動，否則會向後不兼容。\n5. 當值為 1～128（2^7） 時使用 int32 類型僅用 1 個字節，當值為 129～2^14 時僅用 2 個字節；\n6. 對大於 2^28 的數，需要用到 5 個字節及以上的空間，這時候使用 fixed32 或 fixed64 更為划算。\n\nproto3 定義了以下的標量類型`（Scalar Type, hold one value at a time）`：\n\n| Scalar Type | Meaning                             | Go Type | Java/Kotlin Type |\n| ----------- | ----------------------------------- | ------- | ---------------- |\n| double      | 雙精度浮點型                        | float64 | double           |\n| float       | 浮點型                              | float   | float            |\n| int32       | 使用Varint編碼的32位整型            | int32   | int              |\n| int64       | 使用Varint編碼的64位整型            | int64   | long             |\n| uint32      | 使用Varint編碼的無符號32位整型      | uint32  | long             |\n| uint64      | 使用Varint編碼的無符號64位整型      | uint64  | long             |\n| sint32      | 使用Varint編碼的有符號32位整型      | int32   | int              |\n| sint64      | 使用Varint編碼的有符號64位整型      | int64   | long             |\n| fixed32     | 固定32位的整型                      | uint32  | int              |\n| fixed64     | 固定64位的整型                      | uint64  | long             |\n| sfixed32    | 固定長度的有符號32位整型            | int32   | int              |\n| sfixed64    | 固定長度的有符號64位整型            | int64   | long             |\n| bool        | 布爾型                              | bool    | boolean          |\n| string      | 採用UTF-8或者7位ASCII碼編碼的字符串 | string  | String           |\n| bytes       | 字節序列                            | []byte  | ByteString       |\n\n### proto 風格\n\n1. 文件名、字段名建議使用全小寫字母加下划線`（lower_snake_case）`；\n2. 每行長度限定在 80 個字符；\n3. 使用 2 個空格作為縮緊；\n4. 字符串使用雙引號包裹；\n5. repeated 類型的字段名使用複數形式；\n6. enum 類型第一個枚舉值建議以 UNSPECIFIED 為後綴標明為「未指定值」，值為 0；\n7. RPC 服務名及方法名採用大駝峰。\n\n## 不適用 protobuf 的情況\n\n1. 目前官方僅支持 C++、C#、Dart、Go、Java、Kotlin、Python 和 Ruby，其它語言有的有第三方支持，需慎重考慮；\n2. 傳輸超過 1MB 的 message 時建議另擇策略，protobuf 並非爲大數據集而設計；\n3. 當枚舉值的零值在應用中有特殊含義時，不應使用 protobuf 中的 enum，因 protobuf 中的 enum 默認零值只應該是未指定的意思；\n4. 需要使用到 protobuf 中未定義或不完善的類型時。\n\n## 問答\n\n### 為什麼 protobuf 叫 protobuf？\n\nProtocol 即協議，指的是商定的消息協議或者說消息格式，它存放在 proto 文件中。\n\n而 Buffers 呢？\n\n在早期的實現中並沒有編譯器自動生成類，而是有一個名為 ProtocolBuffer 的類實現了一個 Buffer，用戶通過 AddValue(tag, value) 方法添加 tag/value 對（以原始字節方式存儲）到 Buffer中，然後再讀取出來。這個 tag 其實是用來標示字段序號和類型，value 則是編碼後的字段值。\n\n這個 Buffer 在新的版本中已經不在，但名稱保留下來了。\n\n### protobuf 是否可以在 HTTP 中使用？\n\ngRPC 基於 HTTP2 二進制協議，比 HTTP 文本協議傳輸數據量小；而且長連接，減少建立連接的消耗。protobuf 是一種二進制的數據交換格式，序列化後傳輸的數據量很小，可以說 protobuf + gRPC 結合很登對。\n\n通常 JSON + HTTP 在上層應用中很流行，JSON 是一種文本型的數據交換格式，易讀，簡單地將對象轉為 JSON 字符串，然後再以其二進制形式傳輸即可。\n\n但其實 protobuf 是可以在 HTTP 協議中運用的，使用 Content-Type 為 application/x-protobuf，將使用 proto 序列化後的二進制流傳輸到客戶端，客戶端再使用 proto 的反序列化方法解析即可。\n\n### 示例：HTTP over protobuf\n\n#### Go 服務端\n\nserver.go\n\n```go\npackage main\n\nimport (\n\t\"encoding/hex\"\n\n\t\"example.com/m/pb\"\n\t\"github.com/gin-gonic/gin\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc main() {\n\ts := gin.Default()\n\ts.GET(\"/whoami\", func(c *gin.Context) {\n\t\tanimal := pb.Animal{\n\t\t\tId:   12,\n\t\t\tName: \"Dokky\",\n\t\t}\n\t\tbs, _ := proto.Marshal(&animal)\n\t\tprintln(hex.EncodeToString(bs))\n\t\tc.Data(200, \"application/x-protobuf\", bs)\n\t})\n\ts.Run()\n}\n```\n\nserver_test.go\n\n```go\npackage main\n\nimport (\n\t\"encoding/hex\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"testing\"\n\t\"example.com/m/pb\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc TestWhoami(t *testing.T) {\n\trequest, err := http.NewRequest(\"GET\", \"http://localhost:8080/whoami\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\trequest.Header.Add(\"Content-Type\", \"application/x-protobuf\")\n\tresponse, err := http.DefaultClient.Do(request)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tbs, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tt.Log(hex.EncodeToString(bs))\n\twhami := &pb.Animal{}\n\tproto.Unmarshal(bs, whami)\n\tt.Log(whami)\n}\n```\n\n運行命令：\n\n```bash\n# 運行服務端\ngo run server.go\n# 運行測試程序\ngo test -test.v server_test.go\n# 或直接通過 curl 訪問\ncurl --header \"Content-Type: application/x-protobuf\" localhost:8080/whoami\n```\n\n#### Java 服務端\n\nServer.java\n\n```java\npackage com.example.m;\n\nimport com.example.m.pb.AnimalProto;\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpHandler;\nimport com.sun.net.httpserver.HttpServer;\nimport org.apache.commons.codec.binary.Hex;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.util.List;\n\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        HttpServer server = HttpServer.create(new InetSocketAddress(\"localhost\", 8080), 0);\n        server.createContext(\"/whoami\", new WhoamiHandler());\n        server.start();\n    }\n\n    static class WhoamiHandler implements HttpHandler{\n        @Override\n        public void handle(HttpExchange exchange) throws IOException {\n            List<String> contentTypes = exchange.getRequestHeaders().get(\"Content-Type\");\n            if (contentTypes==null || (contentTypes.size()>0 && !contentTypes.get(0).equals(\"application/x-protobuf\"))){\n                exchange.sendResponseHeaders(404,0);\n                exchange.close();\n                return;\n            }\n\n            OutputStream outputStream = exchange.getResponseBody();\n            AnimalProto.Animal animal  = AnimalProto.Animal.newBuilder().setId(12).setName(\"Dokky\").build();\n            byte[] bs = animal.toByteArray();\n            System.out.println(Hex.encodeHexString(bs));\n            exchange.sendResponseHeaders(200, bs.length);\n            outputStream.write(bs);\n            outputStream.flush();\n            outputStream.close();\n            exchange.close();\n        }\n    }\n}\n```\n\nServerTest.java\n\n```java\npackage com.example.m;\n\nimport com.example.m.pb.AnimalProto;\nimport org.apache.commons.codec.binary.Hex;\nimport org.apache.hc.client5.http.classic.methods.HttpGet;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpClient;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;\nimport org.apache.hc.client5.http.impl.classic.HttpClients;\nimport org.apache.hc.core5.http.io.entity.EntityUtils;\nimport org.junit.jupiter.api.Test;\nimport sun.misc.IOUtils;\n\nimport java.io.IOException;\n\nclass ServerTest {\n\n    @Test\n    public  void testServer() throws IOException {\n        CloseableHttpClient httpClient = HttpClients.createDefault();\n        HttpGet httpGet = new HttpGet(\"http://localhost:8080/whoami\");\n        httpGet.setHeader(\"Content-Type\",\"application/x-protobuf\");\n        CloseableHttpResponse response = httpClient.execute(httpGet);\n        byte[] bs = IOUtils.readAllBytes(response.getEntity().getContent());\n        System.out.printf(\"%d, %s\\n\",response.getCode(), Hex.encodeHexString(bs));\n        AnimalProto.Animal animal = AnimalProto.Animal.parseFrom(bs);\n        System.out.printf(\"%d, %s\\n\", animal.getId(),animal.getName());\n        EntityUtils.consume(response.getEntity());\n        httpClient.close();\n    }\n}\n```\n\n## 閱讀更多\n\n1. [protobuf 官方文檔](https://developers.google.cn/protocol-buffers?hl=zh-cn)\n2. [protobuf 代碼倉庫](https://github.com/protocolbuffers/protobuf)\n\n\n\n","source":"_posts/it/common/protobuf-intro.md","raw":"---\ntitle: 比較 JSON 和 protobuf 並介紹 protobuf編碼、語法及 protobuf over HTTP 示例\np: it/common/protobuf_intro\ndate: 2021-11-21 14:12:51\ntags:\n- protobuf\n- JSON\n- Go\n- Java\n---\n\nProtocol Buffers`（簡稱 protobuf）`，是 Google 推出的一種數據交換格式，採用 Varint 和 ZigZag 等二進制編碼，數據壓縮效果顯著，可用來傳輸數據或持久化數據。\n\n## JSON 是什麼？\n\nJSON 全稱爲 JavaScript Object Notation`（JavaScript對象標記）`，即 JS對象的字符串表示。其採用文本編碼，是現今最通用的數據交換格式。2001年3月，State Software公司的聯合創始人設計了此種格式，並隨後進行了標準化。現在有 ECMA-404（2013年）和 RFC-8259（2017年）兩種標準。\n\n## protobuf 是什麼？\n\nprotobuf 全稱爲 Protocol Buffers`（“協議緩衝”）`，是一種數據壓縮性能優秀的數據存儲和交換格式。其採用二進制編碼，通常跟 gRPC 一起使用。\n\n2001年 Google公司內部誕生了proto1版本，並隨後在2008年以BSD協議開源了proto2，2016年釋出proto3正式版。\n\n對於 proto2，官方推出了針對 C++、Java、C# 和 Python 語言的 protobuf編譯器 protoc；而在 proto3 中，增加了對 Dart、GO、Kotlin 和 Ruby 的官方支持。另外，第三方有提供對 JavaScript 和 PHP 等等語言的支持。\n\n<!--more-->\n\n## 開始使用 protobuf\n\n（1）下載編譯器並設置環境變量。\n\n```bash\n# protoc\nPB_REL=\"https://github.com/protocolbuffers/protobuf/releases\"\ncurl -LO $PB_REL/download/v3.15.8/protoc-3.15.8-osx-x86_64.zip\nunzip protoc-3.15.8-osx-x86_64.zip -d ~/go/bin/protoc-3.15.8\ncp ~/go/bin/protoc-3.15.8/bin/protoc ~/go/bin\n\n# protoc-gen-go 和 protoc-gen-go-grpc\ngo get google.golang.org/protobuf/cmd/protoc-gen-go \\\n   google.golang.org/grpc/cmd/protoc-gen-go-grpc\nexport PATH=\"$PATH:$(go env GOPATH)/bin\"\n```\n\n（2）選擇使用 proto2 還是 proto3，不同的版本有不同的語法，且不兼容。相對而言，proto3 的語法更簡單。\n\n（3）根據語法編寫 proto 文件。\n\n```protobuf\nsyntax = \"proto3\";\n\noption go_package = \"/pb\";\n\noption java_package = \"com.example.m.pb\";\noption java_outer_classname = \"AnimalProto\";\n\npackage pb;\n\nmessage Animal{\n  // reserved 1 to 10;\n  // reserved \"id\";\n  int64 id = 1;\n  string name = 2;\n}\n```\n\n（4）生成需要的語言代碼\n\n```bash\nprotoc --go_out=.  animal.proto\n```\n\n生成後的文件 animal.pb.go 如下：\n\n```go\n// Code generated by protoc-gen-go. DO NOT EDIT.\n// versions:\n// \tprotoc-gen-go v1.27.1\n// \tprotoc        v3.15.8\n// source: animal.proto\n\npackage pb\n\nimport (\n\tprotoreflect \"google.golang.org/protobuf/reflect/protoreflect\"\n\tprotoimpl \"google.golang.org/protobuf/runtime/protoimpl\"\n\treflect \"reflect\"\n\tsync \"sync\"\n)\n\nconst (\n\t// Verify that this generated code is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)\n\t// Verify that runtime/protoimpl is sufficiently up-to-date.\n\t_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)\n)\n\ntype Animal struct {\n\tstate         protoimpl.MessageState\n\tsizeCache     protoimpl.SizeCache\n\tunknownFields protoimpl.UnknownFields\n\n\tId   int64  `protobuf:\"varint,1,opt,name=id,proto3\" json:\"id,omitempty\"`\n\tName string `protobuf:\"bytes,2,opt,name=name,proto3\" json:\"name,omitempty\"`\n}\n\n...\n```\n\n## JSON 和 protobuf 的編碼大不同\n\n我們舉一個例子來說明會比較直觀。\n\n![柯基犬](protobuf-intro/w644.jpeg)\n\n這是一隻柯基犬，它叫 Dokky，編號 12。我們可以將這些信息結構化成對象如下：\n\n```go\ntype Animal struct{\n    Id      int64   // 12\n    Name    string  // \"Dokky\"\n}\n```\n\n編寫程序分別對該 Animal 進行 JSON 和 protobuf 序列化：\n\n\n```go\nfunc marshal() {\n\tdokky := pb.Animal{\n\t\tId:   12,\n\t\tName: \"Dokky\",\n\t}\n\n\tpbs, _ := proto.Marshal(&dokky)\n\tprintBytes(pbs)\n\n\tjbs, _ := json.Marshal(&dokky)\n\tprintBytes(jbs)\n}\n\nfunc printBytes(bs []byte) {\n\tprintln(len(bs), hex.EncodeToString(bs))\n}\n```\n\n\n結果：\n\n```\n9 080c1205446f6b6b79\n24 7b226964223a31322c226e616d65223a22446f6b6b79227d\n```\n\n**（1）JSON 序列化**\n\n```json\n{\n    \"id\": 12,\n    \"name\": \"Dokky\"\n}\n```\n\n二進制形式（Unicode編碼）：\n\n```\n7b\n    22 6964 22 3a 3132 2c\n    22 6e616d65 22 3a 22 446f6b6b79 22\n7d\n```\n\n共佔用 24 個字節。\n\n**（2）protobuf 序列化**\n\n```\n086c 1205 446fb6b79\n```\n\n共佔用 9 個字節。\n\n通過輸出的結果簡單對比兩種序列化方式可見，protobuf\n\n1. 不編碼變量名；\n2. 沒有額外的 `{}[],:\"\"` 等字符；\n3. 對整型不使用文本編碼。\n\n要具體解讀這串序列，我們還得先來了解下 protobuf 的編碼方式。\n\n### Varint 編碼\n\nVarint 即 Variable int，可變長整型編碼，是 protobuf 中最主要的編碼方式。其採用小端二進制編碼，即 LSB`（Least Significant Bit，最低有效位）`置於低地址。每個字節的首位即 MSB`（Most Significant Bit，最高有效位）`用來標識下個字節是否需要讀取， 1 表示需要，0 反之。\n\n以數字 12 為例（爲簡便起見，假定類型爲 int16）：\n\n```·\n      二進制序列：0000 0000 0000 1100\n從末尾開始7位一組： 000 1100\n        添加MSB：0000 1100\n    十六進制表示：0C\n```\n\n再以數字 255 為例（爲簡便起見，假定類型爲 int16）：\n\n```\n      二進制序列：0000 0000 1111 1110\n從末尾開始7位一組： 111 1110  000 0001\n        添加MSB：1111 1110 0000 0001\n    十六進制表示：FE01\n```\n\n### protobuf 編碼規則\n\n一般來說，在protobuf 中每個字段拆分成四個部分進行編碼，依次是：\n\n![protobuf 字段結構](protobuf-intro/protobuf-field-structure.jpeg)\n\n1. number：字段序號；\n2. type：字段類型，佔用 3 個比特位，與 number 一起構成字段標識 tag，佔用一個或多個字節，採用 Varint 編碼；其取值含義見下表；\n3. length（可選）：字段長度，當 type 爲 2 時有值；\n4. value：字段值，爲零值的字段不會進行編碼。\n\n| Type     | Meaning                      | Used for                                                 |\n| -------- | ---------------------------- | -------------------------------------------------------- |\n| 0（000） | Varint（可變長整型）         | int32、int64、uint32、uint64、sint32、sint64、bool、enum |\n| 1（001） | 64-bit（固定64位）           | fixed64、sfixed64、double                                |\n| 2（010） | Length-delimited（指定長度） | string、bytes、embedded message、packed repeated fields  |\n| 5（101） | 32-bit（固定32位）           | fixed32、sfixed32、float                                 |\n\n### 解讀序列 086c 1205 446fb6b79\n\n```js\n08 => 00001 000 => number: 1, type: 0\n0C => value: 12\n```\n\n序號爲 1 的字段，類型爲 Varint，值爲 12。\n\n```js\n12 => 00010 010 => number: 2, type: 2\n\n05 => length: 5\n\n446fb6b79 => value: Dokky\n```\n\n序號爲 2 的字段，類型爲 Length-delimited，值爲 Dokky。\n\n### ZigZag 編碼\n\n前面我們討論了非負數的 Varint 編碼，現在我們來看看負數。其實對於負數，並不建議使用 int32 或 int64 等類型，而應使用 sint32 或 sint64，即帶符號的整型。為什麼呢？下面我們對 -1 分別指定 int 32 和 sint32 類型進行編碼：\n\n**（1）int32(-1)**\n\n使用 int32 或 int64 類型時，進行 Varint 編碼，負數總是佔用 10 個字節。因此 int32(-1) 編碼爲：\n\n```\n      二進制序列：11111111  11111111  11111111  11111111\n                11111111  11111111  11111111  11111111\n從尾部開始7位一組： 1111111   1111111   1111111   1111111\n                 1111111   1111111   1111111   1111111  1111111 0000001\n        添加MSB：11111111  11111111  11111111  11111111\n                11111111  11111111  11111111  11111111  11111111 00000001\n    十六進制表示：FF FF FF FF\n                FF FF FF FF FF 01\n```\n\n**（2）sint32(-1)**\n\n當使用 sint32 或 sint64 時，會先進行 ZigZag 編碼再進行 Varint 編碼。ZigZag 就是將負數放到整數前面，交替進行編碼，呈“Z” 或 “之” 字形，故有此稱。\n\n對 sint32， 數字 n 的 ZigZag 編碼爲：(n << 1) ^ (n >> 31)\n\n對 sint64， 數字 n 的 ZigZag 編碼爲：(n << 1) ^ (n >> 63)\n\n因此 sint32(-1) 編碼爲：\n\n```\n      二進制序列： 11111111  11111111  11111111  11111111\n        n << 1： 11111111  11111111  11111111  11111110\n       n >> 31： 11111111  11111111  11111111  11111111\n           異或： 00000000  00000000  00000000   00000001\n從尾部開始7位一組：   0000001\n        添加MSB： 00000001\n    十六進制表示： 01\n```\n\n可見，int32(-1) 佔用 10 個字節，而 sint32(-1)  佔用 1 個字節。在值可能爲負數的情況下，應使用帶符號整型，可以大大減少負數的編碼量。\n\n## proto3 語法\n\n```protobuf\n// 指定使用的語言版本\nsyntax = \"proto3\";\n\n// 指定生成文件的 Go 包路徑，使用 '/' 分隔\noption go_package = \"/pb\";\n\n// 指定生成文件的 Java 包路徑，使用 '.' 分隔\noption  java_package = \"com.example.m.pb\";\n// 定義生成文件的 Java 類名\noption java_outer_classname = \"AnimalProto\";\n\n// 指定包名\npackage pb;\n\n// 定義一個名為 Animal 的消息\nmessage Animal{\n  // 定義一個名為 id 的 int64 字段\n  int64 id = 1;\n  // 定義一個名為 name 的 string 字段\n  string name = 2;\n  // 保留第3～5的字段序號\n  reserved 3 to 5;\n  // 保留字段名 kind\n  reserved \"kind\";\n  // 使用 enum 類型\n  Vision vision = 6;\n\n  // 以下字段的值只允許是 HumanDifference 或 OtherAnimalDifference\n  // 設置其中一個值將會清除另一個的值\n  oneof difference{\n    // 使用自定義的結構類型\n    HumanDifference human = 8;\n    OtherAnimalDifference other = 9;\n  }\n}\n\n// 定義一個枚舉類型，按風格要求第一個值須設置為未指定\nenum Vision{\n  VISION_UNSPECSIFIED = 0;\n  VISION_GREAT = 1;\n  VISION_BURRED = 2;\n  VISION_BLIND = 3;\n}\n\nmessage HumanDifference{\n  // 定義一個名為 lang 的 string 數組\n  repeated string langs = 1;\n}\n\nmessage OtherAnimalDifference{\n  // 字段名採用全小寫下划線連接\n  repeated string natural_enemies = 1;\n}\n```\n\n注意：\n\n1. 建议将变量序号 1～15 的给最常用的字段用，并保留扩展；\n2. message 可以导入；\n3. 字段有默认零值，零值不会被序列化；\n4. 字段序號一旦指定，一般不改動，否則會向後不兼容。\n5. 當值為 1～128（2^7） 時使用 int32 類型僅用 1 個字節，當值為 129～2^14 時僅用 2 個字節；\n6. 對大於 2^28 的數，需要用到 5 個字節及以上的空間，這時候使用 fixed32 或 fixed64 更為划算。\n\nproto3 定義了以下的標量類型`（Scalar Type, hold one value at a time）`：\n\n| Scalar Type | Meaning                             | Go Type | Java/Kotlin Type |\n| ----------- | ----------------------------------- | ------- | ---------------- |\n| double      | 雙精度浮點型                        | float64 | double           |\n| float       | 浮點型                              | float   | float            |\n| int32       | 使用Varint編碼的32位整型            | int32   | int              |\n| int64       | 使用Varint編碼的64位整型            | int64   | long             |\n| uint32      | 使用Varint編碼的無符號32位整型      | uint32  | long             |\n| uint64      | 使用Varint編碼的無符號64位整型      | uint64  | long             |\n| sint32      | 使用Varint編碼的有符號32位整型      | int32   | int              |\n| sint64      | 使用Varint編碼的有符號64位整型      | int64   | long             |\n| fixed32     | 固定32位的整型                      | uint32  | int              |\n| fixed64     | 固定64位的整型                      | uint64  | long             |\n| sfixed32    | 固定長度的有符號32位整型            | int32   | int              |\n| sfixed64    | 固定長度的有符號64位整型            | int64   | long             |\n| bool        | 布爾型                              | bool    | boolean          |\n| string      | 採用UTF-8或者7位ASCII碼編碼的字符串 | string  | String           |\n| bytes       | 字節序列                            | []byte  | ByteString       |\n\n### proto 風格\n\n1. 文件名、字段名建議使用全小寫字母加下划線`（lower_snake_case）`；\n2. 每行長度限定在 80 個字符；\n3. 使用 2 個空格作為縮緊；\n4. 字符串使用雙引號包裹；\n5. repeated 類型的字段名使用複數形式；\n6. enum 類型第一個枚舉值建議以 UNSPECIFIED 為後綴標明為「未指定值」，值為 0；\n7. RPC 服務名及方法名採用大駝峰。\n\n## 不適用 protobuf 的情況\n\n1. 目前官方僅支持 C++、C#、Dart、Go、Java、Kotlin、Python 和 Ruby，其它語言有的有第三方支持，需慎重考慮；\n2. 傳輸超過 1MB 的 message 時建議另擇策略，protobuf 並非爲大數據集而設計；\n3. 當枚舉值的零值在應用中有特殊含義時，不應使用 protobuf 中的 enum，因 protobuf 中的 enum 默認零值只應該是未指定的意思；\n4. 需要使用到 protobuf 中未定義或不完善的類型時。\n\n## 問答\n\n### 為什麼 protobuf 叫 protobuf？\n\nProtocol 即協議，指的是商定的消息協議或者說消息格式，它存放在 proto 文件中。\n\n而 Buffers 呢？\n\n在早期的實現中並沒有編譯器自動生成類，而是有一個名為 ProtocolBuffer 的類實現了一個 Buffer，用戶通過 AddValue(tag, value) 方法添加 tag/value 對（以原始字節方式存儲）到 Buffer中，然後再讀取出來。這個 tag 其實是用來標示字段序號和類型，value 則是編碼後的字段值。\n\n這個 Buffer 在新的版本中已經不在，但名稱保留下來了。\n\n### protobuf 是否可以在 HTTP 中使用？\n\ngRPC 基於 HTTP2 二進制協議，比 HTTP 文本協議傳輸數據量小；而且長連接，減少建立連接的消耗。protobuf 是一種二進制的數據交換格式，序列化後傳輸的數據量很小，可以說 protobuf + gRPC 結合很登對。\n\n通常 JSON + HTTP 在上層應用中很流行，JSON 是一種文本型的數據交換格式，易讀，簡單地將對象轉為 JSON 字符串，然後再以其二進制形式傳輸即可。\n\n但其實 protobuf 是可以在 HTTP 協議中運用的，使用 Content-Type 為 application/x-protobuf，將使用 proto 序列化後的二進制流傳輸到客戶端，客戶端再使用 proto 的反序列化方法解析即可。\n\n### 示例：HTTP over protobuf\n\n#### Go 服務端\n\nserver.go\n\n```go\npackage main\n\nimport (\n\t\"encoding/hex\"\n\n\t\"example.com/m/pb\"\n\t\"github.com/gin-gonic/gin\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc main() {\n\ts := gin.Default()\n\ts.GET(\"/whoami\", func(c *gin.Context) {\n\t\tanimal := pb.Animal{\n\t\t\tId:   12,\n\t\t\tName: \"Dokky\",\n\t\t}\n\t\tbs, _ := proto.Marshal(&animal)\n\t\tprintln(hex.EncodeToString(bs))\n\t\tc.Data(200, \"application/x-protobuf\", bs)\n\t})\n\ts.Run()\n}\n```\n\nserver_test.go\n\n```go\npackage main\n\nimport (\n\t\"encoding/hex\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"testing\"\n\t\"example.com/m/pb\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc TestWhoami(t *testing.T) {\n\trequest, err := http.NewRequest(\"GET\", \"http://localhost:8080/whoami\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\trequest.Header.Add(\"Content-Type\", \"application/x-protobuf\")\n\tresponse, err := http.DefaultClient.Do(request)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tbs, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tt.Log(hex.EncodeToString(bs))\n\twhami := &pb.Animal{}\n\tproto.Unmarshal(bs, whami)\n\tt.Log(whami)\n}\n```\n\n運行命令：\n\n```bash\n# 運行服務端\ngo run server.go\n# 運行測試程序\ngo test -test.v server_test.go\n# 或直接通過 curl 訪問\ncurl --header \"Content-Type: application/x-protobuf\" localhost:8080/whoami\n```\n\n#### Java 服務端\n\nServer.java\n\n```java\npackage com.example.m;\n\nimport com.example.m.pb.AnimalProto;\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpHandler;\nimport com.sun.net.httpserver.HttpServer;\nimport org.apache.commons.codec.binary.Hex;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.util.List;\n\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        HttpServer server = HttpServer.create(new InetSocketAddress(\"localhost\", 8080), 0);\n        server.createContext(\"/whoami\", new WhoamiHandler());\n        server.start();\n    }\n\n    static class WhoamiHandler implements HttpHandler{\n        @Override\n        public void handle(HttpExchange exchange) throws IOException {\n            List<String> contentTypes = exchange.getRequestHeaders().get(\"Content-Type\");\n            if (contentTypes==null || (contentTypes.size()>0 && !contentTypes.get(0).equals(\"application/x-protobuf\"))){\n                exchange.sendResponseHeaders(404,0);\n                exchange.close();\n                return;\n            }\n\n            OutputStream outputStream = exchange.getResponseBody();\n            AnimalProto.Animal animal  = AnimalProto.Animal.newBuilder().setId(12).setName(\"Dokky\").build();\n            byte[] bs = animal.toByteArray();\n            System.out.println(Hex.encodeHexString(bs));\n            exchange.sendResponseHeaders(200, bs.length);\n            outputStream.write(bs);\n            outputStream.flush();\n            outputStream.close();\n            exchange.close();\n        }\n    }\n}\n```\n\nServerTest.java\n\n```java\npackage com.example.m;\n\nimport com.example.m.pb.AnimalProto;\nimport org.apache.commons.codec.binary.Hex;\nimport org.apache.hc.client5.http.classic.methods.HttpGet;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpClient;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;\nimport org.apache.hc.client5.http.impl.classic.HttpClients;\nimport org.apache.hc.core5.http.io.entity.EntityUtils;\nimport org.junit.jupiter.api.Test;\nimport sun.misc.IOUtils;\n\nimport java.io.IOException;\n\nclass ServerTest {\n\n    @Test\n    public  void testServer() throws IOException {\n        CloseableHttpClient httpClient = HttpClients.createDefault();\n        HttpGet httpGet = new HttpGet(\"http://localhost:8080/whoami\");\n        httpGet.setHeader(\"Content-Type\",\"application/x-protobuf\");\n        CloseableHttpResponse response = httpClient.execute(httpGet);\n        byte[] bs = IOUtils.readAllBytes(response.getEntity().getContent());\n        System.out.printf(\"%d, %s\\n\",response.getCode(), Hex.encodeHexString(bs));\n        AnimalProto.Animal animal = AnimalProto.Animal.parseFrom(bs);\n        System.out.printf(\"%d, %s\\n\", animal.getId(),animal.getName());\n        EntityUtils.consume(response.getEntity());\n        httpClient.close();\n    }\n}\n```\n\n## 閱讀更多\n\n1. [protobuf 官方文檔](https://developers.google.cn/protocol-buffers?hl=zh-cn)\n2. [protobuf 代碼倉庫](https://github.com/protocolbuffers/protobuf)\n\n\n\n","slug":"it/common/protobuf-intro","published":1,"updated":"2021-12-04T13:02:03.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfo002z1n9kbg9g7flo","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>Protocol Buffers<code>（簡稱 protobuf）</code>，是 Google 推出的一種數據交換格式，採用 Varint 和 ZigZag 等二進制編碼，數據壓縮效果顯著，可用來傳輸數據或持久化數據。</p>\n<h2 id=\"JSON-是什麼？\"><a href=\"#JSON-是什麼？\" class=\"headerlink\" title=\"JSON 是什麼？\"></a>JSON 是什麼？</h2><p>JSON 全稱爲 JavaScript Object Notation<code>（JavaScript對象標記）</code>，即 JS對象的字符串表示。其採用文本編碼，是現今最通用的數據交換格式。2001年3月，State Software公司的聯合創始人設計了此種格式，並隨後進行了標準化。現在有 ECMA-404（2013年）和 RFC-8259（2017年）兩種標準。</p>\n<h2 id=\"protobuf-是什麼？\"><a href=\"#protobuf-是什麼？\" class=\"headerlink\" title=\"protobuf 是什麼？\"></a>protobuf 是什麼？</h2><p>protobuf 全稱爲 Protocol Buffers<code>（“協議緩衝”）</code>，是一種數據壓縮性能優秀的數據存儲和交換格式。其採用二進制編碼，通常跟 gRPC 一起使用。</p>\n<p>2001年 Google公司內部誕生了proto1版本，並隨後在2008年以BSD協議開源了proto2，2016年釋出proto3正式版。</p>\n<p>對於 proto2，官方推出了針對 C++、Java、C# 和 Python 語言的 protobuf編譯器 protoc；而在 proto3 中，增加了對 Dart、GO、Kotlin 和 Ruby 的官方支持。另外，第三方有提供對 JavaScript 和 PHP 等等語言的支持。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"開始使用-protobuf\"><a href=\"#開始使用-protobuf\" class=\"headerlink\" title=\"開始使用 protobuf\"></a>開始使用 protobuf</h2><p>（1）下載編譯器並設置環境變量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># protoc</span></span><br><span class=\"line\">PB_REL=<span class=\"string\">&quot;https://github.com/protocolbuffers/protobuf/releases&quot;</span></span><br><span class=\"line\">curl -LO <span class=\"variable\">$PB_REL</span>/download/v3.15.8/protoc-3.15.8-osx-x86_64.zip</span><br><span class=\"line\">unzip protoc-3.15.8-osx-x86_64.zip -d ~/go/bin/protoc-3.15.8</span><br><span class=\"line\">cp ~/go/bin/protoc-3.15.8/bin/protoc ~/go/bin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># protoc-gen-go 和 protoc-gen-go-grpc</span></span><br><span class=\"line\">go get google.golang.org/protobuf/cmd/protoc-gen-go \\</span><br><span class=\"line\">   google.golang.org/grpc/cmd/protoc-gen-go-grpc</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">&quot;<span class=\"variable\">$PATH</span>:<span class=\"subst\">$(go env GOPATH)</span>/bin&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）選擇使用 proto2 還是 proto3，不同的版本有不同的語法，且不兼容。相對而言，proto3 的語法更簡單。</p>\n<p>（3）根據語法編寫 proto 文件。</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> go_package = <span class=\"string\">&quot;/pb&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> java_package = <span class=\"string\">&quot;com.example.m.pb&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;AnimalProto&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> pb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// reserved 1 to 10;</span></span><br><span class=\"line\">  <span class=\"comment\">// reserved &quot;id&quot;;</span></span><br><span class=\"line\">  <span class=\"built_in\">int64</span> id = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）生成需要的語言代碼</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">protoc --go_out=.  animal.proto</span><br></pre></td></tr></table></figure>\n\n<p>生成後的文件 animal.pb.go 如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Code generated by protoc-gen-go. DO NOT EDIT.</span></span><br><span class=\"line\"><span class=\"comment\">// versions:</span></span><br><span class=\"line\"><span class=\"comment\">// \tprotoc-gen-go v1.27.1</span></span><br><span class=\"line\"><span class=\"comment\">// \tprotoc        v3.15.8</span></span><br><span class=\"line\"><span class=\"comment\">// source: animal.proto</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> pb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  protoreflect <span class=\"string\">&quot;google.golang.org/protobuf/reflect/protoreflect&quot;</span></span><br><span class=\"line\">  protoimpl <span class=\"string\">&quot;google.golang.org/protobuf/runtime/protoimpl&quot;</span></span><br><span class=\"line\">  reflect <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">  sync <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  <span class=\"comment\">// Verify that this generated code is sufficiently up-to-date.</span></span><br><span class=\"line\">  _ = protoimpl.EnforceVersion(<span class=\"number\">20</span> - protoimpl.MinVersion)</span><br><span class=\"line\">  <span class=\"comment\">// Verify that runtime/protoimpl is sufficiently up-to-date.</span></span><br><span class=\"line\">  _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - <span class=\"number\">20</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  state         protoimpl.MessageState</span><br><span class=\"line\">  sizeCache     protoimpl.SizeCache</span><br><span class=\"line\">  unknownFields protoimpl.UnknownFields</span><br><span class=\"line\"></span><br><span class=\"line\">  Id   <span class=\"keyword\">int64</span>  <span class=\"string\">`protobuf:&quot;varint,1,opt,name=id,proto3&quot; json:&quot;id,omitempty&quot;`</span></span><br><span class=\"line\">  Name <span class=\"keyword\">string</span> <span class=\"string\">`protobuf:&quot;bytes,2,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JSON-和-protobuf-的編碼大不同\"><a href=\"#JSON-和-protobuf-的編碼大不同\" class=\"headerlink\" title=\"JSON 和 protobuf 的編碼大不同\"></a>JSON 和 protobuf 的編碼大不同</h2><p>我們舉一個例子來說明會比較直觀。</p>\n<p><img src=\"/it/common/protobuf-intro/w644.jpeg\" alt=\"柯基犬\"></p>\n<p>這是一隻柯基犬，它叫 Dokky，編號 12。我們可以將這些信息結構化成對象如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Id      <span class=\"keyword\">int64</span>   <span class=\"comment\">// 12</span></span><br><span class=\"line\">    Name    <span class=\"keyword\">string</span>  <span class=\"comment\">// &quot;Dokky&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>編寫程序分別對該 Animal 進行 JSON 和 protobuf 序列化：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">marshal</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  dokky := pb.Animal&#123;</span><br><span class=\"line\">    Id:   <span class=\"number\">12</span>,</span><br><span class=\"line\">    Name: <span class=\"string\">&quot;Dokky&quot;</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pbs, _ := proto.Marshal(&amp;dokky)</span><br><span class=\"line\">  printBytes(pbs)</span><br><span class=\"line\"></span><br><span class=\"line\">  jbs, _ := json.Marshal(&amp;dokky)</span><br><span class=\"line\">  printBytes(jbs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printBytes</span><span class=\"params\">(bs []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"built_in\">len</span>(bs), hex.EncodeToString(bs))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>結果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">9 080c1205446f6b6b79</span><br><span class=\"line\">24 7b226964223a31322c226e616d65223a22446f6b6b79227d</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）JSON 序列化</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">12</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Dokky&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二進制形式（Unicode編碼）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">7b</span><br><span class=\"line\">    22 6964 22 3a 3132 2c</span><br><span class=\"line\">    22 6e616d65 22 3a 22 446f6b6b79 22</span><br><span class=\"line\">7d</span><br></pre></td></tr></table></figure>\n\n<p>共佔用 24 個字節。</p>\n<p><strong>（2）protobuf 序列化</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">086c 1205 446fb6b79</span><br></pre></td></tr></table></figure>\n\n<p>共佔用 9 個字節。</p>\n<p>通過輸出的結果簡單對比兩種序列化方式可見，protobuf</p>\n<ol>\n<li>不編碼變量名；</li>\n<li>沒有額外的 <code>&#123;&#125;[],:&quot;&quot;</code> 等字符；</li>\n<li>對整型不使用文本編碼。</li>\n</ol>\n<p>要具體解讀這串序列，我們還得先來了解下 protobuf 的編碼方式。</p>\n<h3 id=\"Varint-編碼\"><a href=\"#Varint-編碼\" class=\"headerlink\" title=\"Varint 編碼\"></a>Varint 編碼</h3><p>Varint 即 Variable int，可變長整型編碼，是 protobuf 中最主要的編碼方式。其採用小端二進制編碼，即 LSB<code>（Least Significant Bit，最低有效位）</code>置於低地址。每個字節的首位即 MSB<code>（Most Significant Bit，最高有效位）</code>用來標識下個字節是否需要讀取， 1 表示需要，0 反之。</p>\n<p>以數字 12 為例（爲簡便起見，假定類型爲 int16）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      二進制序列：0000 0000 0000 1100</span><br><span class=\"line\">從末尾開始7位一組： 000 1100</span><br><span class=\"line\">        添加MSB：0000 1100</span><br><span class=\"line\">    十六進制表示：0C</span><br></pre></td></tr></table></figure>\n\n<p>再以數字 255 為例（爲簡便起見，假定類型爲 int16）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      二進制序列：0000 0000 1111 1110</span><br><span class=\"line\">從末尾開始7位一組： 111 1110  000 0001</span><br><span class=\"line\">        添加MSB：1111 1110 0000 0001</span><br><span class=\"line\">    十六進制表示：FE01</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"protobuf-編碼規則\"><a href=\"#protobuf-編碼規則\" class=\"headerlink\" title=\"protobuf 編碼規則\"></a>protobuf 編碼規則</h3><p>一般來說，在protobuf 中每個字段拆分成四個部分進行編碼，依次是：</p>\n<p><img src=\"/it/common/protobuf-intro/protobuf-field-structure.jpeg\" alt=\"protobuf 字段結構\"></p>\n<ol>\n<li>number：字段序號；</li>\n<li>type：字段類型，佔用 3 個比特位，與 number 一起構成字段標識 tag，佔用一個或多個字節，採用 Varint 編碼；其取值含義見下表；</li>\n<li>length（可選）：字段長度，當 type 爲 2 時有值；</li>\n<li>value：字段值，爲零值的字段不會進行編碼。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Meaning</th>\n<th>Used for</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0（000）</td>\n<td>Varint（可變長整型）</td>\n<td>int32、int64、uint32、uint64、sint32、sint64、bool、enum</td>\n</tr>\n<tr>\n<td>1（001）</td>\n<td>64-bit（固定64位）</td>\n<td>fixed64、sfixed64、double</td>\n</tr>\n<tr>\n<td>2（010）</td>\n<td>Length-delimited（指定長度）</td>\n<td>string、bytes、embedded message、packed repeated fields</td>\n</tr>\n<tr>\n<td>5（101）</td>\n<td>32-bit（固定32位）</td>\n<td>fixed32、sfixed32、float</td>\n</tr>\n</tbody></table>\n<h3 id=\"解讀序列-086c-1205-446fb6b79\"><a href=\"#解讀序列-086c-1205-446fb6b79\" class=\"headerlink\" title=\"解讀序列 086c 1205 446fb6b79\"></a>解讀序列 086c 1205 446fb6b79</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">08</span> =&gt; <span class=\"number\">00001</span> <span class=\"number\">000</span> =&gt; number: <span class=\"number\">1</span>, <span class=\"attr\">type</span>: <span class=\"number\">0</span></span><br><span class=\"line\">0C =&gt; value: <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n\n<p>序號爲 1 的字段，類型爲 Varint，值爲 12。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">12</span> =&gt; <span class=\"number\">00010</span> <span class=\"number\">010</span> =&gt; number: <span class=\"number\">2</span>, <span class=\"attr\">type</span>: <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">05</span> =&gt; length: <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">446fb6b79 =&gt; value: Dokky</span><br></pre></td></tr></table></figure>\n\n<p>序號爲 2 的字段，類型爲 Length-delimited，值爲 Dokky。</p>\n<h3 id=\"ZigZag-編碼\"><a href=\"#ZigZag-編碼\" class=\"headerlink\" title=\"ZigZag 編碼\"></a>ZigZag 編碼</h3><p>前面我們討論了非負數的 Varint 編碼，現在我們來看看負數。其實對於負數，並不建議使用 int32 或 int64 等類型，而應使用 sint32 或 sint64，即帶符號的整型。為什麼呢？下面我們對 -1 分別指定 int 32 和 sint32 類型進行編碼：</p>\n<p><strong>（1）int32(-1)</strong></p>\n<p>使用 int32 或 int64 類型時，進行 Varint 編碼，負數總是佔用 10 個字節。因此 int32(-1) 編碼爲：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      二進制序列：11111111  11111111  11111111  11111111</span><br><span class=\"line\">                11111111  11111111  11111111  11111111</span><br><span class=\"line\">從尾部開始7位一組： 1111111   1111111   1111111   1111111</span><br><span class=\"line\">                 1111111   1111111   1111111   1111111  1111111 0000001</span><br><span class=\"line\">        添加MSB：11111111  11111111  11111111  11111111</span><br><span class=\"line\">                11111111  11111111  11111111  11111111  11111111 00000001</span><br><span class=\"line\">    十六進制表示：FF FF FF FF</span><br><span class=\"line\">                FF FF FF FF FF 01</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）sint32(-1)</strong></p>\n<p>當使用 sint32 或 sint64 時，會先進行 ZigZag 編碼再進行 Varint 編碼。ZigZag 就是將負數放到整數前面，交替進行編碼，呈“Z” 或 “之” 字形，故有此稱。</p>\n<p>對 sint32， 數字 n 的 ZigZag 編碼爲：(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</p>\n<p>對 sint64， 數字 n 的 ZigZag 編碼爲：(n &lt;&lt; 1) ^ (n &gt;&gt; 63)</p>\n<p>因此 sint32(-1) 編碼爲：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      二進制序列： 11111111  11111111  11111111  11111111</span><br><span class=\"line\">        n &lt;&lt; 1： 11111111  11111111  11111111  11111110</span><br><span class=\"line\">       n &gt;&gt; 31： 11111111  11111111  11111111  11111111</span><br><span class=\"line\">           異或： 00000000  00000000  00000000   00000001</span><br><span class=\"line\">從尾部開始7位一組：   0000001</span><br><span class=\"line\">        添加MSB： 00000001</span><br><span class=\"line\">    十六進制表示： 01</span><br></pre></td></tr></table></figure>\n\n<p>可見，int32(-1) 佔用 10 個字節，而 sint32(-1)  佔用 1 個字節。在值可能爲負數的情況下，應使用帶符號整型，可以大大減少負數的編碼量。</p>\n<h2 id=\"proto3-語法\"><a href=\"#proto3-語法\" class=\"headerlink\" title=\"proto3 語法\"></a>proto3 語法</h2><figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定使用的語言版本</span></span><br><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定生成文件的 Go 包路徑，使用 &#x27;/&#x27; 分隔</span></span><br><span class=\"line\"><span class=\"keyword\">option</span> go_package = <span class=\"string\">&quot;/pb&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定生成文件的 Java 包路徑，使用 &#x27;.&#x27; 分隔</span></span><br><span class=\"line\"><span class=\"keyword\">option</span>  java_package = <span class=\"string\">&quot;com.example.m.pb&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 定義生成文件的 Java 類名</span></span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;AnimalProto&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定包名</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> pb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定義一個名為 Animal 的消息</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定義一個名為 id 的 int64 字段</span></span><br><span class=\"line\">  <span class=\"built_in\">int64</span> id = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 定義一個名為 name 的 string 字段</span></span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 保留第3～5的字段序號</span></span><br><span class=\"line\">  reserved <span class=\"number\">3</span> to <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 保留字段名 kind</span></span><br><span class=\"line\">  reserved <span class=\"string\">&quot;kind&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 使用 enum 類型</span></span><br><span class=\"line\">  Vision vision = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 以下字段的值只允許是 HumanDifference 或 OtherAnimalDifference</span></span><br><span class=\"line\">  <span class=\"comment\">// 設置其中一個值將會清除另一個的值</span></span><br><span class=\"line\">  <span class=\"keyword\">oneof</span> difference&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用自定義的結構類型</span></span><br><span class=\"line\">    HumanDifference human = <span class=\"number\">8</span>;</span><br><span class=\"line\">    OtherAnimalDifference other = <span class=\"number\">9</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定義一個枚舉類型，按風格要求第一個值須設置為未指定</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Vision</span></span>&#123;</span><br><span class=\"line\">  VISION_UNSPECSIFIED = <span class=\"number\">0</span>;</span><br><span class=\"line\">  VISION_GREAT = <span class=\"number\">1</span>;</span><br><span class=\"line\">  VISION_BURRED = <span class=\"number\">2</span>;</span><br><span class=\"line\">  VISION_BLIND = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">HumanDifference</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定義一個名為 lang 的 string 數組</span></span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> <span class=\"built_in\">string</span> langs = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">OtherAnimalDifference</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 字段名採用全小寫下划線連接</span></span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> <span class=\"built_in\">string</span> natural_enemies = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ol>\n<li>建议将变量序号 1～15 的给最常用的字段用，并保留扩展；</li>\n<li>message 可以导入；</li>\n<li>字段有默认零值，零值不会被序列化；</li>\n<li>字段序號一旦指定，一般不改動，否則會向後不兼容。</li>\n<li>當值為 1～128（2^7） 時使用 int32 類型僅用 1 個字節，當值為 129～2^14 時僅用 2 個字節；</li>\n<li>對大於 2^28 的數，需要用到 5 個字節及以上的空間，這時候使用 fixed32 或 fixed64 更為划算。</li>\n</ol>\n<p>proto3 定義了以下的標量類型<code>（Scalar Type, hold one value at a time）</code>：</p>\n<table>\n<thead>\n<tr>\n<th>Scalar Type</th>\n<th>Meaning</th>\n<th>Go Type</th>\n<th>Java/Kotlin Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>double</td>\n<td>雙精度浮點型</td>\n<td>float64</td>\n<td>double</td>\n</tr>\n<tr>\n<td>float</td>\n<td>浮點型</td>\n<td>float</td>\n<td>float</td>\n</tr>\n<tr>\n<td>int32</td>\n<td>使用Varint編碼的32位整型</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>int64</td>\n<td>使用Varint編碼的64位整型</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>uint32</td>\n<td>使用Varint編碼的無符號32位整型</td>\n<td>uint32</td>\n<td>long</td>\n</tr>\n<tr>\n<td>uint64</td>\n<td>使用Varint編碼的無符號64位整型</td>\n<td>uint64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>sint32</td>\n<td>使用Varint編碼的有符號32位整型</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>sint64</td>\n<td>使用Varint編碼的有符號64位整型</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>fixed32</td>\n<td>固定32位的整型</td>\n<td>uint32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>fixed64</td>\n<td>固定64位的整型</td>\n<td>uint64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>sfixed32</td>\n<td>固定長度的有符號32位整型</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>sfixed64</td>\n<td>固定長度的有符號64位整型</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>布爾型</td>\n<td>bool</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>string</td>\n<td>採用UTF-8或者7位ASCII碼編碼的字符串</td>\n<td>string</td>\n<td>String</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>字節序列</td>\n<td>[]byte</td>\n<td>ByteString</td>\n</tr>\n</tbody></table>\n<h3 id=\"proto-風格\"><a href=\"#proto-風格\" class=\"headerlink\" title=\"proto 風格\"></a>proto 風格</h3><ol>\n<li>文件名、字段名建議使用全小寫字母加下划線<code>（lower_snake_case）</code>；</li>\n<li>每行長度限定在 80 個字符；</li>\n<li>使用 2 個空格作為縮緊；</li>\n<li>字符串使用雙引號包裹；</li>\n<li>repeated 類型的字段名使用複數形式；</li>\n<li>enum 類型第一個枚舉值建議以 UNSPECIFIED 為後綴標明為「未指定值」，值為 0；</li>\n<li>RPC 服務名及方法名採用大駝峰。</li>\n</ol>\n<h2 id=\"不適用-protobuf-的情況\"><a href=\"#不適用-protobuf-的情況\" class=\"headerlink\" title=\"不適用 protobuf 的情況\"></a>不適用 protobuf 的情況</h2><ol>\n<li>目前官方僅支持 C++、C#、Dart、Go、Java、Kotlin、Python 和 Ruby，其它語言有的有第三方支持，需慎重考慮；</li>\n<li>傳輸超過 1MB 的 message 時建議另擇策略，protobuf 並非爲大數據集而設計；</li>\n<li>當枚舉值的零值在應用中有特殊含義時，不應使用 protobuf 中的 enum，因 protobuf 中的 enum 默認零值只應該是未指定的意思；</li>\n<li>需要使用到 protobuf 中未定義或不完善的類型時。</li>\n</ol>\n<h2 id=\"問答\"><a href=\"#問答\" class=\"headerlink\" title=\"問答\"></a>問答</h2><h3 id=\"為什麼-protobuf-叫-protobuf？\"><a href=\"#為什麼-protobuf-叫-protobuf？\" class=\"headerlink\" title=\"為什麼 protobuf 叫 protobuf？\"></a>為什麼 protobuf 叫 protobuf？</h3><p>Protocol 即協議，指的是商定的消息協議或者說消息格式，它存放在 proto 文件中。</p>\n<p>而 Buffers 呢？</p>\n<p>在早期的實現中並沒有編譯器自動生成類，而是有一個名為 ProtocolBuffer 的類實現了一個 Buffer，用戶通過 AddValue(tag, value) 方法添加 tag/value 對（以原始字節方式存儲）到 Buffer中，然後再讀取出來。這個 tag 其實是用來標示字段序號和類型，value 則是編碼後的字段值。</p>\n<p>這個 Buffer 在新的版本中已經不在，但名稱保留下來了。</p>\n<h3 id=\"protobuf-是否可以在-HTTP-中使用？\"><a href=\"#protobuf-是否可以在-HTTP-中使用？\" class=\"headerlink\" title=\"protobuf 是否可以在 HTTP 中使用？\"></a>protobuf 是否可以在 HTTP 中使用？</h3><p>gRPC 基於 HTTP2 二進制協議，比 HTTP 文本協議傳輸數據量小；而且長連接，減少建立連接的消耗。protobuf 是一種二進制的數據交換格式，序列化後傳輸的數據量很小，可以說 protobuf + gRPC 結合很登對。</p>\n<p>通常 JSON + HTTP 在上層應用中很流行，JSON 是一種文本型的數據交換格式，易讀，簡單地將對象轉為 JSON 字符串，然後再以其二進制形式傳輸即可。</p>\n<p>但其實 protobuf 是可以在 HTTP 協議中運用的，使用 Content-Type 為 application/x-protobuf，將使用 proto 序列化後的二進制流傳輸到客戶端，客戶端再使用 proto 的反序列化方法解析即可。</p>\n<h3 id=\"示例：HTTP-over-protobuf\"><a href=\"#示例：HTTP-over-protobuf\" class=\"headerlink\" title=\"示例：HTTP over protobuf\"></a>示例：HTTP over protobuf</h3><h4 id=\"Go-服務端\"><a href=\"#Go-服務端\" class=\"headerlink\" title=\"Go 服務端\"></a>Go 服務端</h4><p>server.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;encoding/hex&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&quot;example.com/m/pb&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;google.golang.org/protobuf/proto&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  s := gin.Default()</span><br><span class=\"line\">  s.GET(<span class=\"string\">&quot;/whoami&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    animal := pb.Animal&#123;</span><br><span class=\"line\">      Id:   <span class=\"number\">12</span>,</span><br><span class=\"line\">      Name: <span class=\"string\">&quot;Dokky&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bs, _ := proto.Marshal(&amp;animal)</span><br><span class=\"line\">    <span class=\"built_in\">println</span>(hex.EncodeToString(bs))</span><br><span class=\"line\">    c.Data(<span class=\"number\">200</span>, <span class=\"string\">&quot;application/x-protobuf&quot;</span>, bs)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  s.Run()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>server_test.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;encoding/hex&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;example.com/m/pb&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;google.golang.org/protobuf/proto&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestWhoami</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">  request, err := http.NewRequest(<span class=\"string\">&quot;GET&quot;</span>, <span class=\"string\">&quot;http://localhost:8080/whoami&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    t.Error(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  request.Header.Add(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/x-protobuf&quot;</span>)</span><br><span class=\"line\">  response, err := http.DefaultClient.Do(request)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    t.Error(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  bs, err := ioutil.ReadAll(response.Body)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    t.Error(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  t.Log(hex.EncodeToString(bs))</span><br><span class=\"line\">  whami := &amp;pb.Animal&#123;&#125;</span><br><span class=\"line\">  proto.Unmarshal(bs, whami)</span><br><span class=\"line\">  t.Log(whami)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>運行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 運行服務端</span></span><br><span class=\"line\">go run server.go</span><br><span class=\"line\"><span class=\"comment\"># 運行測試程序</span></span><br><span class=\"line\">go <span class=\"built_in\">test</span> -test.v server_test.go</span><br><span class=\"line\"><span class=\"comment\"># 或直接通過 curl 訪問</span></span><br><span class=\"line\">curl --header <span class=\"string\">&quot;Content-Type: application/x-protobuf&quot;</span> localhost:8080/whoami</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java-服務端\"><a href=\"#Java-服務端\" class=\"headerlink\" title=\"Java 服務端\"></a>Java 服務端</h4><p>Server.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.m.pb.AnimalProto;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.net.httpserver.HttpExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.net.httpserver.HttpHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.net.httpserver.HttpServer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.OutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        HttpServer server = HttpServer.create(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">        server.createContext(<span class=\"string\">&quot;/whoami&quot;</span>, <span class=\"keyword\">new</span> WhoamiHandler());</span><br><span class=\"line\">        server.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhoamiHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">HttpHandler</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(HttpExchange exchange)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">            List&lt;String&gt; contentTypes = exchange.getRequestHeaders().get(<span class=\"string\">&quot;Content-Type&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (contentTypes==<span class=\"keyword\">null</span> || (contentTypes.size()&gt;<span class=\"number\">0</span> &amp;&amp; !contentTypes.get(<span class=\"number\">0</span>).equals(<span class=\"string\">&quot;application/x-protobuf&quot;</span>)))&#123;</span><br><span class=\"line\">                exchange.sendResponseHeaders(<span class=\"number\">404</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">                exchange.close();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            OutputStream outputStream = exchange.getResponseBody();</span><br><span class=\"line\">            AnimalProto.Animal animal  = AnimalProto.Animal.newBuilder().setId(<span class=\"number\">12</span>).setName(<span class=\"string\">&quot;Dokky&quot;</span>).build();</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bs = animal.toByteArray();</span><br><span class=\"line\">            System.out.println(Hex.encodeHexString(bs));</span><br><span class=\"line\">            exchange.sendResponseHeaders(<span class=\"number\">200</span>, bs.length);</span><br><span class=\"line\">            outputStream.write(bs);</span><br><span class=\"line\">            outputStream.flush();</span><br><span class=\"line\">            outputStream.close();</span><br><span class=\"line\">            exchange.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ServerTest.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.m.pb.AnimalProto;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hc.client5.http.classic.methods.HttpGet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hc.client5.http.impl.classic.CloseableHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hc.client5.http.impl.classic.HttpClients;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hc.core5.http.io.entity.EntityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.jupiter.api.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> sun.misc.IOUtils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">testServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class=\"line\">        HttpGet httpGet = <span class=\"keyword\">new</span> HttpGet(<span class=\"string\">&quot;http://localhost:8080/whoami&quot;</span>);</span><br><span class=\"line\">        httpGet.setHeader(<span class=\"string\">&quot;Content-Type&quot;</span>,<span class=\"string\">&quot;application/x-protobuf&quot;</span>);</span><br><span class=\"line\">        CloseableHttpResponse response = httpClient.execute(httpGet);</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] bs = IOUtils.readAllBytes(response.getEntity().getContent());</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%d, %s\\n&quot;</span>,response.getCode(), Hex.encodeHexString(bs));</span><br><span class=\"line\">        AnimalProto.Animal animal = AnimalProto.Animal.parseFrom(bs);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%d, %s\\n&quot;</span>, animal.getId(),animal.getName());</span><br><span class=\"line\">        EntityUtils.consume(response.getEntity());</span><br><span class=\"line\">        httpClient.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"閱讀更多\"><a href=\"#閱讀更多\" class=\"headerlink\" title=\"閱讀更多\"></a>閱讀更多</h2><ol>\n<li><a href=\"https://developers.google.cn/protocol-buffers?hl=zh-cn\">protobuf 官方文檔</a></li>\n<li><a href=\"https://github.com/protocolbuffers/protobuf\">protobuf 代碼倉庫</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Protocol Buffers<code>（簡稱 protobuf）</code>，是 Google 推出的一種數據交換格式，採用 Varint 和 ZigZag 等二進制編碼，數據壓縮效果顯著，可用來傳輸數據或持久化數據。</p>\n<h2 id=\"JSON-是什麼？\"><a href=\"#JSON-是什麼？\" class=\"headerlink\" title=\"JSON 是什麼？\"></a>JSON 是什麼？</h2><p>JSON 全稱爲 JavaScript Object Notation<code>（JavaScript對象標記）</code>，即 JS對象的字符串表示。其採用文本編碼，是現今最通用的數據交換格式。2001年3月，State Software公司的聯合創始人設計了此種格式，並隨後進行了標準化。現在有 ECMA-404（2013年）和 RFC-8259（2017年）兩種標準。</p>\n<h2 id=\"protobuf-是什麼？\"><a href=\"#protobuf-是什麼？\" class=\"headerlink\" title=\"protobuf 是什麼？\"></a>protobuf 是什麼？</h2><p>protobuf 全稱爲 Protocol Buffers<code>（“協議緩衝”）</code>，是一種數據壓縮性能優秀的數據存儲和交換格式。其採用二進制編碼，通常跟 gRPC 一起使用。</p>\n<p>2001年 Google公司內部誕生了proto1版本，並隨後在2008年以BSD協議開源了proto2，2016年釋出proto3正式版。</p>\n<p>對於 proto2，官方推出了針對 C++、Java、C# 和 Python 語言的 protobuf編譯器 protoc；而在 proto3 中，增加了對 Dart、GO、Kotlin 和 Ruby 的官方支持。另外，第三方有提供對 JavaScript 和 PHP 等等語言的支持。</p>","more":"<h2 id=\"開始使用-protobuf\"><a href=\"#開始使用-protobuf\" class=\"headerlink\" title=\"開始使用 protobuf\"></a>開始使用 protobuf</h2><p>（1）下載編譯器並設置環境變量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># protoc</span></span><br><span class=\"line\">PB_REL=<span class=\"string\">&quot;https://github.com/protocolbuffers/protobuf/releases&quot;</span></span><br><span class=\"line\">curl -LO <span class=\"variable\">$PB_REL</span>/download/v3.15.8/protoc-3.15.8-osx-x86_64.zip</span><br><span class=\"line\">unzip protoc-3.15.8-osx-x86_64.zip -d ~/go/bin/protoc-3.15.8</span><br><span class=\"line\">cp ~/go/bin/protoc-3.15.8/bin/protoc ~/go/bin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># protoc-gen-go 和 protoc-gen-go-grpc</span></span><br><span class=\"line\">go get google.golang.org/protobuf/cmd/protoc-gen-go \\</span><br><span class=\"line\">   google.golang.org/grpc/cmd/protoc-gen-go-grpc</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">&quot;<span class=\"variable\">$PATH</span>:<span class=\"subst\">$(go env GOPATH)</span>/bin&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）選擇使用 proto2 還是 proto3，不同的版本有不同的語法，且不兼容。相對而言，proto3 的語法更簡單。</p>\n<p>（3）根據語法編寫 proto 文件。</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> go_package = <span class=\"string\">&quot;/pb&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> java_package = <span class=\"string\">&quot;com.example.m.pb&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;AnimalProto&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> pb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// reserved 1 to 10;</span></span><br><span class=\"line\">  <span class=\"comment\">// reserved &quot;id&quot;;</span></span><br><span class=\"line\">  <span class=\"built_in\">int64</span> id = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）生成需要的語言代碼</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">protoc --go_out=.  animal.proto</span><br></pre></td></tr></table></figure>\n\n<p>生成後的文件 animal.pb.go 如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Code generated by protoc-gen-go. DO NOT EDIT.</span></span><br><span class=\"line\"><span class=\"comment\">// versions:</span></span><br><span class=\"line\"><span class=\"comment\">// \tprotoc-gen-go v1.27.1</span></span><br><span class=\"line\"><span class=\"comment\">// \tprotoc        v3.15.8</span></span><br><span class=\"line\"><span class=\"comment\">// source: animal.proto</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> pb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  protoreflect <span class=\"string\">&quot;google.golang.org/protobuf/reflect/protoreflect&quot;</span></span><br><span class=\"line\">  protoimpl <span class=\"string\">&quot;google.golang.org/protobuf/runtime/protoimpl&quot;</span></span><br><span class=\"line\">  reflect <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">  sync <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  <span class=\"comment\">// Verify that this generated code is sufficiently up-to-date.</span></span><br><span class=\"line\">  _ = protoimpl.EnforceVersion(<span class=\"number\">20</span> - protoimpl.MinVersion)</span><br><span class=\"line\">  <span class=\"comment\">// Verify that runtime/protoimpl is sufficiently up-to-date.</span></span><br><span class=\"line\">  _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - <span class=\"number\">20</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  state         protoimpl.MessageState</span><br><span class=\"line\">  sizeCache     protoimpl.SizeCache</span><br><span class=\"line\">  unknownFields protoimpl.UnknownFields</span><br><span class=\"line\"></span><br><span class=\"line\">  Id   <span class=\"keyword\">int64</span>  <span class=\"string\">`protobuf:&quot;varint,1,opt,name=id,proto3&quot; json:&quot;id,omitempty&quot;`</span></span><br><span class=\"line\">  Name <span class=\"keyword\">string</span> <span class=\"string\">`protobuf:&quot;bytes,2,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JSON-和-protobuf-的編碼大不同\"><a href=\"#JSON-和-protobuf-的編碼大不同\" class=\"headerlink\" title=\"JSON 和 protobuf 的編碼大不同\"></a>JSON 和 protobuf 的編碼大不同</h2><p>我們舉一個例子來說明會比較直觀。</p>\n<p><img src=\"/it/common/protobuf-intro/w644.jpeg\" alt=\"柯基犬\"></p>\n<p>這是一隻柯基犬，它叫 Dokky，編號 12。我們可以將這些信息結構化成對象如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Id      <span class=\"keyword\">int64</span>   <span class=\"comment\">// 12</span></span><br><span class=\"line\">    Name    <span class=\"keyword\">string</span>  <span class=\"comment\">// &quot;Dokky&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>編寫程序分別對該 Animal 進行 JSON 和 protobuf 序列化：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">marshal</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  dokky := pb.Animal&#123;</span><br><span class=\"line\">    Id:   <span class=\"number\">12</span>,</span><br><span class=\"line\">    Name: <span class=\"string\">&quot;Dokky&quot;</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pbs, _ := proto.Marshal(&amp;dokky)</span><br><span class=\"line\">  printBytes(pbs)</span><br><span class=\"line\"></span><br><span class=\"line\">  jbs, _ := json.Marshal(&amp;dokky)</span><br><span class=\"line\">  printBytes(jbs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printBytes</span><span class=\"params\">(bs []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"built_in\">len</span>(bs), hex.EncodeToString(bs))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>結果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">9 080c1205446f6b6b79</span><br><span class=\"line\">24 7b226964223a31322c226e616d65223a22446f6b6b79227d</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）JSON 序列化</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">12</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Dokky&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二進制形式（Unicode編碼）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">7b</span><br><span class=\"line\">    22 6964 22 3a 3132 2c</span><br><span class=\"line\">    22 6e616d65 22 3a 22 446f6b6b79 22</span><br><span class=\"line\">7d</span><br></pre></td></tr></table></figure>\n\n<p>共佔用 24 個字節。</p>\n<p><strong>（2）protobuf 序列化</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">086c 1205 446fb6b79</span><br></pre></td></tr></table></figure>\n\n<p>共佔用 9 個字節。</p>\n<p>通過輸出的結果簡單對比兩種序列化方式可見，protobuf</p>\n<ol>\n<li>不編碼變量名；</li>\n<li>沒有額外的 <code>&#123;&#125;[],:&quot;&quot;</code> 等字符；</li>\n<li>對整型不使用文本編碼。</li>\n</ol>\n<p>要具體解讀這串序列，我們還得先來了解下 protobuf 的編碼方式。</p>\n<h3 id=\"Varint-編碼\"><a href=\"#Varint-編碼\" class=\"headerlink\" title=\"Varint 編碼\"></a>Varint 編碼</h3><p>Varint 即 Variable int，可變長整型編碼，是 protobuf 中最主要的編碼方式。其採用小端二進制編碼，即 LSB<code>（Least Significant Bit，最低有效位）</code>置於低地址。每個字節的首位即 MSB<code>（Most Significant Bit，最高有效位）</code>用來標識下個字節是否需要讀取， 1 表示需要，0 反之。</p>\n<p>以數字 12 為例（爲簡便起見，假定類型爲 int16）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      二進制序列：0000 0000 0000 1100</span><br><span class=\"line\">從末尾開始7位一組： 000 1100</span><br><span class=\"line\">        添加MSB：0000 1100</span><br><span class=\"line\">    十六進制表示：0C</span><br></pre></td></tr></table></figure>\n\n<p>再以數字 255 為例（爲簡便起見，假定類型爲 int16）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      二進制序列：0000 0000 1111 1110</span><br><span class=\"line\">從末尾開始7位一組： 111 1110  000 0001</span><br><span class=\"line\">        添加MSB：1111 1110 0000 0001</span><br><span class=\"line\">    十六進制表示：FE01</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"protobuf-編碼規則\"><a href=\"#protobuf-編碼規則\" class=\"headerlink\" title=\"protobuf 編碼規則\"></a>protobuf 編碼規則</h3><p>一般來說，在protobuf 中每個字段拆分成四個部分進行編碼，依次是：</p>\n<p><img src=\"/it/common/protobuf-intro/protobuf-field-structure.jpeg\" alt=\"protobuf 字段結構\"></p>\n<ol>\n<li>number：字段序號；</li>\n<li>type：字段類型，佔用 3 個比特位，與 number 一起構成字段標識 tag，佔用一個或多個字節，採用 Varint 編碼；其取值含義見下表；</li>\n<li>length（可選）：字段長度，當 type 爲 2 時有值；</li>\n<li>value：字段值，爲零值的字段不會進行編碼。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Meaning</th>\n<th>Used for</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0（000）</td>\n<td>Varint（可變長整型）</td>\n<td>int32、int64、uint32、uint64、sint32、sint64、bool、enum</td>\n</tr>\n<tr>\n<td>1（001）</td>\n<td>64-bit（固定64位）</td>\n<td>fixed64、sfixed64、double</td>\n</tr>\n<tr>\n<td>2（010）</td>\n<td>Length-delimited（指定長度）</td>\n<td>string、bytes、embedded message、packed repeated fields</td>\n</tr>\n<tr>\n<td>5（101）</td>\n<td>32-bit（固定32位）</td>\n<td>fixed32、sfixed32、float</td>\n</tr>\n</tbody></table>\n<h3 id=\"解讀序列-086c-1205-446fb6b79\"><a href=\"#解讀序列-086c-1205-446fb6b79\" class=\"headerlink\" title=\"解讀序列 086c 1205 446fb6b79\"></a>解讀序列 086c 1205 446fb6b79</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">08</span> =&gt; <span class=\"number\">00001</span> <span class=\"number\">000</span> =&gt; number: <span class=\"number\">1</span>, <span class=\"attr\">type</span>: <span class=\"number\">0</span></span><br><span class=\"line\">0C =&gt; value: <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n\n<p>序號爲 1 的字段，類型爲 Varint，值爲 12。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">12</span> =&gt; <span class=\"number\">00010</span> <span class=\"number\">010</span> =&gt; number: <span class=\"number\">2</span>, <span class=\"attr\">type</span>: <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">05</span> =&gt; length: <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">446fb6b79 =&gt; value: Dokky</span><br></pre></td></tr></table></figure>\n\n<p>序號爲 2 的字段，類型爲 Length-delimited，值爲 Dokky。</p>\n<h3 id=\"ZigZag-編碼\"><a href=\"#ZigZag-編碼\" class=\"headerlink\" title=\"ZigZag 編碼\"></a>ZigZag 編碼</h3><p>前面我們討論了非負數的 Varint 編碼，現在我們來看看負數。其實對於負數，並不建議使用 int32 或 int64 等類型，而應使用 sint32 或 sint64，即帶符號的整型。為什麼呢？下面我們對 -1 分別指定 int 32 和 sint32 類型進行編碼：</p>\n<p><strong>（1）int32(-1)</strong></p>\n<p>使用 int32 或 int64 類型時，進行 Varint 編碼，負數總是佔用 10 個字節。因此 int32(-1) 編碼爲：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      二進制序列：11111111  11111111  11111111  11111111</span><br><span class=\"line\">                11111111  11111111  11111111  11111111</span><br><span class=\"line\">從尾部開始7位一組： 1111111   1111111   1111111   1111111</span><br><span class=\"line\">                 1111111   1111111   1111111   1111111  1111111 0000001</span><br><span class=\"line\">        添加MSB：11111111  11111111  11111111  11111111</span><br><span class=\"line\">                11111111  11111111  11111111  11111111  11111111 00000001</span><br><span class=\"line\">    十六進制表示：FF FF FF FF</span><br><span class=\"line\">                FF FF FF FF FF 01</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）sint32(-1)</strong></p>\n<p>當使用 sint32 或 sint64 時，會先進行 ZigZag 編碼再進行 Varint 編碼。ZigZag 就是將負數放到整數前面，交替進行編碼，呈“Z” 或 “之” 字形，故有此稱。</p>\n<p>對 sint32， 數字 n 的 ZigZag 編碼爲：(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</p>\n<p>對 sint64， 數字 n 的 ZigZag 編碼爲：(n &lt;&lt; 1) ^ (n &gt;&gt; 63)</p>\n<p>因此 sint32(-1) 編碼爲：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      二進制序列： 11111111  11111111  11111111  11111111</span><br><span class=\"line\">        n &lt;&lt; 1： 11111111  11111111  11111111  11111110</span><br><span class=\"line\">       n &gt;&gt; 31： 11111111  11111111  11111111  11111111</span><br><span class=\"line\">           異或： 00000000  00000000  00000000   00000001</span><br><span class=\"line\">從尾部開始7位一組：   0000001</span><br><span class=\"line\">        添加MSB： 00000001</span><br><span class=\"line\">    十六進制表示： 01</span><br></pre></td></tr></table></figure>\n\n<p>可見，int32(-1) 佔用 10 個字節，而 sint32(-1)  佔用 1 個字節。在值可能爲負數的情況下，應使用帶符號整型，可以大大減少負數的編碼量。</p>\n<h2 id=\"proto3-語法\"><a href=\"#proto3-語法\" class=\"headerlink\" title=\"proto3 語法\"></a>proto3 語法</h2><figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定使用的語言版本</span></span><br><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定生成文件的 Go 包路徑，使用 &#x27;/&#x27; 分隔</span></span><br><span class=\"line\"><span class=\"keyword\">option</span> go_package = <span class=\"string\">&quot;/pb&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定生成文件的 Java 包路徑，使用 &#x27;.&#x27; 分隔</span></span><br><span class=\"line\"><span class=\"keyword\">option</span>  java_package = <span class=\"string\">&quot;com.example.m.pb&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 定義生成文件的 Java 類名</span></span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;AnimalProto&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定包名</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> pb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定義一個名為 Animal 的消息</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定義一個名為 id 的 int64 字段</span></span><br><span class=\"line\">  <span class=\"built_in\">int64</span> id = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 定義一個名為 name 的 string 字段</span></span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 保留第3～5的字段序號</span></span><br><span class=\"line\">  reserved <span class=\"number\">3</span> to <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 保留字段名 kind</span></span><br><span class=\"line\">  reserved <span class=\"string\">&quot;kind&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 使用 enum 類型</span></span><br><span class=\"line\">  Vision vision = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 以下字段的值只允許是 HumanDifference 或 OtherAnimalDifference</span></span><br><span class=\"line\">  <span class=\"comment\">// 設置其中一個值將會清除另一個的值</span></span><br><span class=\"line\">  <span class=\"keyword\">oneof</span> difference&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用自定義的結構類型</span></span><br><span class=\"line\">    HumanDifference human = <span class=\"number\">8</span>;</span><br><span class=\"line\">    OtherAnimalDifference other = <span class=\"number\">9</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定義一個枚舉類型，按風格要求第一個值須設置為未指定</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Vision</span></span>&#123;</span><br><span class=\"line\">  VISION_UNSPECSIFIED = <span class=\"number\">0</span>;</span><br><span class=\"line\">  VISION_GREAT = <span class=\"number\">1</span>;</span><br><span class=\"line\">  VISION_BURRED = <span class=\"number\">2</span>;</span><br><span class=\"line\">  VISION_BLIND = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">HumanDifference</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定義一個名為 lang 的 string 數組</span></span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> <span class=\"built_in\">string</span> langs = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">OtherAnimalDifference</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 字段名採用全小寫下划線連接</span></span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> <span class=\"built_in\">string</span> natural_enemies = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ol>\n<li>建议将变量序号 1～15 的给最常用的字段用，并保留扩展；</li>\n<li>message 可以导入；</li>\n<li>字段有默认零值，零值不会被序列化；</li>\n<li>字段序號一旦指定，一般不改動，否則會向後不兼容。</li>\n<li>當值為 1～128（2^7） 時使用 int32 類型僅用 1 個字節，當值為 129～2^14 時僅用 2 個字節；</li>\n<li>對大於 2^28 的數，需要用到 5 個字節及以上的空間，這時候使用 fixed32 或 fixed64 更為划算。</li>\n</ol>\n<p>proto3 定義了以下的標量類型<code>（Scalar Type, hold one value at a time）</code>：</p>\n<table>\n<thead>\n<tr>\n<th>Scalar Type</th>\n<th>Meaning</th>\n<th>Go Type</th>\n<th>Java/Kotlin Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>double</td>\n<td>雙精度浮點型</td>\n<td>float64</td>\n<td>double</td>\n</tr>\n<tr>\n<td>float</td>\n<td>浮點型</td>\n<td>float</td>\n<td>float</td>\n</tr>\n<tr>\n<td>int32</td>\n<td>使用Varint編碼的32位整型</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>int64</td>\n<td>使用Varint編碼的64位整型</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>uint32</td>\n<td>使用Varint編碼的無符號32位整型</td>\n<td>uint32</td>\n<td>long</td>\n</tr>\n<tr>\n<td>uint64</td>\n<td>使用Varint編碼的無符號64位整型</td>\n<td>uint64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>sint32</td>\n<td>使用Varint編碼的有符號32位整型</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>sint64</td>\n<td>使用Varint編碼的有符號64位整型</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>fixed32</td>\n<td>固定32位的整型</td>\n<td>uint32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>fixed64</td>\n<td>固定64位的整型</td>\n<td>uint64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>sfixed32</td>\n<td>固定長度的有符號32位整型</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>sfixed64</td>\n<td>固定長度的有符號64位整型</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>布爾型</td>\n<td>bool</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>string</td>\n<td>採用UTF-8或者7位ASCII碼編碼的字符串</td>\n<td>string</td>\n<td>String</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>字節序列</td>\n<td>[]byte</td>\n<td>ByteString</td>\n</tr>\n</tbody></table>\n<h3 id=\"proto-風格\"><a href=\"#proto-風格\" class=\"headerlink\" title=\"proto 風格\"></a>proto 風格</h3><ol>\n<li>文件名、字段名建議使用全小寫字母加下划線<code>（lower_snake_case）</code>；</li>\n<li>每行長度限定在 80 個字符；</li>\n<li>使用 2 個空格作為縮緊；</li>\n<li>字符串使用雙引號包裹；</li>\n<li>repeated 類型的字段名使用複數形式；</li>\n<li>enum 類型第一個枚舉值建議以 UNSPECIFIED 為後綴標明為「未指定值」，值為 0；</li>\n<li>RPC 服務名及方法名採用大駝峰。</li>\n</ol>\n<h2 id=\"不適用-protobuf-的情況\"><a href=\"#不適用-protobuf-的情況\" class=\"headerlink\" title=\"不適用 protobuf 的情況\"></a>不適用 protobuf 的情況</h2><ol>\n<li>目前官方僅支持 C++、C#、Dart、Go、Java、Kotlin、Python 和 Ruby，其它語言有的有第三方支持，需慎重考慮；</li>\n<li>傳輸超過 1MB 的 message 時建議另擇策略，protobuf 並非爲大數據集而設計；</li>\n<li>當枚舉值的零值在應用中有特殊含義時，不應使用 protobuf 中的 enum，因 protobuf 中的 enum 默認零值只應該是未指定的意思；</li>\n<li>需要使用到 protobuf 中未定義或不完善的類型時。</li>\n</ol>\n<h2 id=\"問答\"><a href=\"#問答\" class=\"headerlink\" title=\"問答\"></a>問答</h2><h3 id=\"為什麼-protobuf-叫-protobuf？\"><a href=\"#為什麼-protobuf-叫-protobuf？\" class=\"headerlink\" title=\"為什麼 protobuf 叫 protobuf？\"></a>為什麼 protobuf 叫 protobuf？</h3><p>Protocol 即協議，指的是商定的消息協議或者說消息格式，它存放在 proto 文件中。</p>\n<p>而 Buffers 呢？</p>\n<p>在早期的實現中並沒有編譯器自動生成類，而是有一個名為 ProtocolBuffer 的類實現了一個 Buffer，用戶通過 AddValue(tag, value) 方法添加 tag/value 對（以原始字節方式存儲）到 Buffer中，然後再讀取出來。這個 tag 其實是用來標示字段序號和類型，value 則是編碼後的字段值。</p>\n<p>這個 Buffer 在新的版本中已經不在，但名稱保留下來了。</p>\n<h3 id=\"protobuf-是否可以在-HTTP-中使用？\"><a href=\"#protobuf-是否可以在-HTTP-中使用？\" class=\"headerlink\" title=\"protobuf 是否可以在 HTTP 中使用？\"></a>protobuf 是否可以在 HTTP 中使用？</h3><p>gRPC 基於 HTTP2 二進制協議，比 HTTP 文本協議傳輸數據量小；而且長連接，減少建立連接的消耗。protobuf 是一種二進制的數據交換格式，序列化後傳輸的數據量很小，可以說 protobuf + gRPC 結合很登對。</p>\n<p>通常 JSON + HTTP 在上層應用中很流行，JSON 是一種文本型的數據交換格式，易讀，簡單地將對象轉為 JSON 字符串，然後再以其二進制形式傳輸即可。</p>\n<p>但其實 protobuf 是可以在 HTTP 協議中運用的，使用 Content-Type 為 application/x-protobuf，將使用 proto 序列化後的二進制流傳輸到客戶端，客戶端再使用 proto 的反序列化方法解析即可。</p>\n<h3 id=\"示例：HTTP-over-protobuf\"><a href=\"#示例：HTTP-over-protobuf\" class=\"headerlink\" title=\"示例：HTTP over protobuf\"></a>示例：HTTP over protobuf</h3><h4 id=\"Go-服務端\"><a href=\"#Go-服務端\" class=\"headerlink\" title=\"Go 服務端\"></a>Go 服務端</h4><p>server.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;encoding/hex&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&quot;example.com/m/pb&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;google.golang.org/protobuf/proto&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  s := gin.Default()</span><br><span class=\"line\">  s.GET(<span class=\"string\">&quot;/whoami&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    animal := pb.Animal&#123;</span><br><span class=\"line\">      Id:   <span class=\"number\">12</span>,</span><br><span class=\"line\">      Name: <span class=\"string\">&quot;Dokky&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bs, _ := proto.Marshal(&amp;animal)</span><br><span class=\"line\">    <span class=\"built_in\">println</span>(hex.EncodeToString(bs))</span><br><span class=\"line\">    c.Data(<span class=\"number\">200</span>, <span class=\"string\">&quot;application/x-protobuf&quot;</span>, bs)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  s.Run()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>server_test.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;encoding/hex&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;example.com/m/pb&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;google.golang.org/protobuf/proto&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestWhoami</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">  request, err := http.NewRequest(<span class=\"string\">&quot;GET&quot;</span>, <span class=\"string\">&quot;http://localhost:8080/whoami&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    t.Error(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  request.Header.Add(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/x-protobuf&quot;</span>)</span><br><span class=\"line\">  response, err := http.DefaultClient.Do(request)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    t.Error(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  bs, err := ioutil.ReadAll(response.Body)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    t.Error(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  t.Log(hex.EncodeToString(bs))</span><br><span class=\"line\">  whami := &amp;pb.Animal&#123;&#125;</span><br><span class=\"line\">  proto.Unmarshal(bs, whami)</span><br><span class=\"line\">  t.Log(whami)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>運行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 運行服務端</span></span><br><span class=\"line\">go run server.go</span><br><span class=\"line\"><span class=\"comment\"># 運行測試程序</span></span><br><span class=\"line\">go <span class=\"built_in\">test</span> -test.v server_test.go</span><br><span class=\"line\"><span class=\"comment\"># 或直接通過 curl 訪問</span></span><br><span class=\"line\">curl --header <span class=\"string\">&quot;Content-Type: application/x-protobuf&quot;</span> localhost:8080/whoami</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Java-服務端\"><a href=\"#Java-服務端\" class=\"headerlink\" title=\"Java 服務端\"></a>Java 服務端</h4><p>Server.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.m.pb.AnimalProto;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.net.httpserver.HttpExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.net.httpserver.HttpHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.net.httpserver.HttpServer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.OutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        HttpServer server = HttpServer.create(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">        server.createContext(<span class=\"string\">&quot;/whoami&quot;</span>, <span class=\"keyword\">new</span> WhoamiHandler());</span><br><span class=\"line\">        server.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WhoamiHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">HttpHandler</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(HttpExchange exchange)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">            List&lt;String&gt; contentTypes = exchange.getRequestHeaders().get(<span class=\"string\">&quot;Content-Type&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (contentTypes==<span class=\"keyword\">null</span> || (contentTypes.size()&gt;<span class=\"number\">0</span> &amp;&amp; !contentTypes.get(<span class=\"number\">0</span>).equals(<span class=\"string\">&quot;application/x-protobuf&quot;</span>)))&#123;</span><br><span class=\"line\">                exchange.sendResponseHeaders(<span class=\"number\">404</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">                exchange.close();</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            OutputStream outputStream = exchange.getResponseBody();</span><br><span class=\"line\">            AnimalProto.Animal animal  = AnimalProto.Animal.newBuilder().setId(<span class=\"number\">12</span>).setName(<span class=\"string\">&quot;Dokky&quot;</span>).build();</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bs = animal.toByteArray();</span><br><span class=\"line\">            System.out.println(Hex.encodeHexString(bs));</span><br><span class=\"line\">            exchange.sendResponseHeaders(<span class=\"number\">200</span>, bs.length);</span><br><span class=\"line\">            outputStream.write(bs);</span><br><span class=\"line\">            outputStream.flush();</span><br><span class=\"line\">            outputStream.close();</span><br><span class=\"line\">            exchange.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ServerTest.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.m.pb.AnimalProto;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hc.client5.http.classic.methods.HttpGet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hc.client5.http.impl.classic.CloseableHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hc.client5.http.impl.classic.HttpClients;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.hc.core5.http.io.entity.EntityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.jupiter.api.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> sun.misc.IOUtils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">testServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class=\"line\">        HttpGet httpGet = <span class=\"keyword\">new</span> HttpGet(<span class=\"string\">&quot;http://localhost:8080/whoami&quot;</span>);</span><br><span class=\"line\">        httpGet.setHeader(<span class=\"string\">&quot;Content-Type&quot;</span>,<span class=\"string\">&quot;application/x-protobuf&quot;</span>);</span><br><span class=\"line\">        CloseableHttpResponse response = httpClient.execute(httpGet);</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] bs = IOUtils.readAllBytes(response.getEntity().getContent());</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%d, %s\\n&quot;</span>,response.getCode(), Hex.encodeHexString(bs));</span><br><span class=\"line\">        AnimalProto.Animal animal = AnimalProto.Animal.parseFrom(bs);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;%d, %s\\n&quot;</span>, animal.getId(),animal.getName());</span><br><span class=\"line\">        EntityUtils.consume(response.getEntity());</span><br><span class=\"line\">        httpClient.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"閱讀更多\"><a href=\"#閱讀更多\" class=\"headerlink\" title=\"閱讀更多\"></a>閱讀更多</h2><ol>\n<li><a href=\"https://developers.google.cn/protocol-buffers?hl=zh-cn\">protobuf 官方文檔</a></li>\n<li><a href=\"https://github.com/protocolbuffers/protobuf\">protobuf 代碼倉庫</a></li>\n</ol>"},{"title":"Java 集合","p":"it/java/java-collection.md","date":"2020-11-08T04:23:00.000Z","_content":"\nJava 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。\n\nList 有一實現 `ArrayList`，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數。\n\nSet 有一實現 `HashSet`，其底層實現是 `HashMap` ，其檢查重複的機制有賴於 `hashCode` 和 `equals` 方法。\n\nMap 有一實現 `HashMap` ，JDK 1.8 之後其底層實現是：**數組 + 鏈表 + 紅黑二叉樹**。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 `hash & (length-1)` 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。\n\n總結下 HashMap 中解決哈希衝突的方式：\n\n1. 使用鏈表 — 拉鍊法；\n2. 使用紅黑二叉樹；\n3. 擴容底層數組；\n4. 強制數組容量爲 2 之幂次；\n5. 將元素的 hash 值的高位分散到低位等等。\n\n`ArrayList`、`HashSet`、`HashMap` 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 `CopyOnWriteArrayList` 、`ConcurrentHashMap` （`HashSet` 用`ConcurrentHashMap` 的 keySet 可得 Set 視圖）。`CopyOnWriteArrayList` 會在寫時加鎖並複製集合進行操作；`ConcurrentHashMap` 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。\n\n<!-- more -->\n\n## 概覽\n\n集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。\n\n![](java-collection/Untitled.png)\n\n### List、Set、Map 三者之區別\n\n1. List：存儲的元素有序、可重複。\n2. Set：存儲的元素無序、不可重複。\n3. Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。\n\n### List、Set、Map 三者之底層數據結構\n\n1. List\n    - ArrayList：Object 數組\n    - Vector：Object 數組\n    - LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）\n2. Set\n    - HashSet（無序、唯一）：基於 HashMap\n    - LinkedHashSet：基於 LinkedHashMap\n    - TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）\n3. Map\n    - HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）\n    - LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表\n    - Hashtable：數組 + 鏈表\n    - TreeMap：紅黑樹（自平衡的排序二叉樹）\n\n### Iterator 迭代器\n\n迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，`hasNext()` 和 `next()` 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 `ConcurrentModificationException` 了。\n\n爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 `modCount` 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 `expectedModCount` 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 `modCount` 和 `expectedModCount`，兩者相等，不會拋出異常。\n\n```java\nMap<Integer, String> map = new HashMap();\nmap.put(1, \"Java\");\nmap.put(2, \"Python\");\nmap.put(2, \"Go\");\nIterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<Integer, String> entry = iterator.next();\n  System.out.println(entry.getKey() + entry.getValue());\n}\n```\n\n### 有哪些集合是線程不安全的？怎麼解決？\n\n常用的 `ArrayList`、`LinkedList`、`HashMap`、`HashSet`、`TreeSet`、`TreeMap`、`PriorityQueue` 都不是線程安全的。解決方法就是用 `java.util.concurrent` 包提供的線程安全的集合來代替：\n\n1. `ConcurrentHashMap` 代替 `HashMap`；\n2. `CopyOnWriteArrayList` 代替 `ArrayList`；\n3. `ConcurrentLinkedQueue` 代替 `LinkedList` ；\n4. `BlockingQueue` 接口下的 `PriorityBlockingQueue`、`LinkedBlockingQueue` 等阻塞隊列代替 `PriorityQueue`  等；\n5. `ConcurrentSkipListMap`  代替 `TreeMap` ，實現多線程下保證按 Key 的順序存儲元素。\n\n### `length`、`length()`、`size()` 三者用途\n\n1. `length`：用於數組。\n2. `length()`：用於字符串。\n3. `size()`：用於集合。\n\n### Collections 工具類的使用\n\n- 排序\n\n    ```java\n    //反轉\n    void reverse(List list)\n    //隨機排序\n    void shuffle(List list)\n    //按自然排序的升序排序\n    void sort(List list)\n    //定制排序，由Comparator控制排序邏輯\n    void sort(List list, Comparator c)\n    //交換兩個索引位置的元素\n    void swap(List list, int i , int j)\n    //旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面\n    void rotate(List list, int distance)\n    ```\n\n- 查找替換統計\n\n    ```java\n    //對List進行二分查找，返回索引，注意List必須是有序的\n    int binarySearch(List list, Object key)\n    //根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)\n    int max(Collection coll)\n    //根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)\n    int max(Collection coll, Comparator c)\n    //用指定的元素代替指定list中的所有元素\n    void fill(List list, Object obj)\n    //用新元素替換舊元素\n    boolean replaceAll(List list, Object oldVal, Object newVal) \n    //統計元素出現次數\n    int frequency(Collection c, Object o)\n    //統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)\n    int indexOfSubList(List list, List target)\n    ```\n\n## List\n\n### 比較 ArrayList 與 LinkedList\n\n共同點：\n\n1. 都實現了 List 接口；\n2. 都是不同步的，不保證線程安全。\n\n不同點：\n\n1. **底層數據結構不同**。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。\n2. **插入和刪除的時間複雜度不同**。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。\n3. **對快速隨機訪問的支持不同**。ArrayList 支持快速隨機訪問；LinkedList 不支持。\n4. **對空間的利用不同**。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。\n- 比較雙向鏈表與雙向循環鏈表\n\n    ![](java-collection/Untitled%201.png)\n\n    ![](java-collection/Untitled%202.png)\n\n### ArrayList 擴容機制\n\nArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。\n\n其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是**等到首次添加元素時才開始初始化**一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，**容量會擴充到原來的 1.5 倍**（`newCapacity = oldCapacity + oldCapacity >> 2`），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。\n\n### 快速隨機訪問 RandomAccess\n\nRandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。\n\n```java\npublic interface RandomAccess {\n}\n```\n\n### `System.arraycopy()` 與 `Arrays.copyOf()` 方法\n\n1. `System.arraycopy()` 方法用於源數組到目標數組之間的數據拷貝；\n2. `Arrays.copyOf()` 方法用於給源數組擴容，底層調用`System.arraycopy()` 。\n\n### CopyOnWriteArrayList 的特點\n\n1. 寫時會加鎖並複製整個集合；\n2. 讀時可能讀到舊數據。\n\n### **如何移除列表中的元素**\n\n首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 `ConcurrentModificationException` （並發修改異常）。\n\n可以採用 `iterator` 或者 `Collection.removeIf()` 方法移除列表元素。\n\n```java\nString[] arrs = {\"a\", \"b\", \"c\"};\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n\n// 採用 iterator\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    if (\"a\".equals(iterator.next())) {\n        iterator.remove();\n        break;\n    }\n}\n\n// 採用 removeIf 方法，\"a\"::equals 等價於 x -> \"a\".equals(x)\nlist.removeIf(\"a\"::equals); \n\nSystem.out.println(list);\n```\n\n### **正確使用 Arrays.asList**\n\n如果非要在 `foreach` 循環中刪除元素，還可以使用 `CopyOnWriteArrayList`，此集合是 `fail-safe` 的。`CopyOnWriteArrayList` 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。\n\nArrays 工具類有一個靜態方法 `asList(T... a)`，能將**對象**數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 `add`/`remove`/`clear` 並不可用，調用會拋出 `UnsupportedOperationException`。\n\nArrays 類中關於 `asList` 方法的代碼如下：\n\n```java\npublic static <T> List<T> asList(T... a) {\n\t\t// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList\n    return new ArrayList<>(a);\n}\n```\n\n爲什麼 `asList` 方法傳入的必須是對象數組呢？\n\n你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。\n\n傳入基本類型的數組會怎樣呢？請看下面代碼：\n\n```java\nint[] ints = {1, 3, 4};\n// 此時的泛型是 int[] 對象，而非 int\nList<int[]> list = Arrays.asList(ints);\n// list 的大小爲 1，就是 ints 這個數組對象\nSystem.out.println(list.size());\n```\n\n### **把數組轉爲 `java.util.ArrayList`**\n\n那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？\n\n```java\n// 1) 使用 ArrayList 的帶參構造方法\nList<String> list = new ArrayList<>(Arrays.asList(arrs));\n\n// 2) 使用 Java 8 的 Stream API\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n// boxed 方法可以把基本類型轉成包裝類型\nList<Integer> intList = Arrays.stream(ints).boxed().collect(Collectors.toList());\n\n// 3) 使用 Guava 包的 API\nImmutableList<String[]> list = ImmutableList.of(arrs);\nImmutableList<String> list1 = ImmutableList.copyOf(arrs);\nArrayList<String> list2 = Lists.newArrayList(arrs);\n\n// 4) 使用 Java 9 的 API\nList<String> list = List.of(arrs);\n```\n\n### **將 List 轉爲數組**\n\n使用 List 的 `toArray` 方法可以將 List 轉爲數組，代碼如下：\n\n```java\n// new String[0] 僅僅爲了告知類型返回數組的類型\nString[] strings = list.toArray(new String[0]);\n```\n\n## Set\n\n### 無序性和不可重複性的含義\n\n無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。\n\n不可重複性是指添加的元素按 equals 方法判斷結果爲 false。\n\n### 比較 HashSet、LinkedHashSet 和 TreeSet\n\n共同點：\n\n1. 都實現了 Set 接口；\n2. 元素不可重複；\n3. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據接口不同**。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。\n2. **有序性不同**。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。\n\n### 自定義排序的實現\n\n自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。\n\n### HashSet 如何檢查重複\n\nHashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n## Map\n\n### 比較 HashMap 與 TreeMap\n\n共同點：\n\n1. 都繼承自 AbstractMap，間接實現了 Map 接口；\n2. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據結構不同**。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。\n2. **HashMap 無搜索和排序的能力**。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。\n\n### HashMap 底層實現\n\nJDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：\n\n```java\ntransient Node<K,V>[] table;\n```\n\nNode 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。\n\n![](java-collection/Untitled%203.png)\n\n該數組默認大小是 `1 << 4 = 16` 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過**拉鍊法**解決。當 Map 中包含的元素數量大於等於 `threshold = loadFactor * capacity` （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。\n\nJDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，**當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。**\n\n![](java-collection/Untitled%204.png)\n\n**（1）散列算法**\n\n首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。\n\n```java\n// JDK 1.7\nstatic int hash(int h) {\n  // This function ensures that hashCodes that differ only by\n  // constant multiples at each bit position have a bounded\n  // number of collisions (approximately 8 at default load factor).\n  h ^= (h >>> 20) ^ (h >>> 12);\n  return h ^ (h >>> 7) ^ (h >>> 4);\n}\n// JDK 1.8\nstatic final int hash(Object key) {\n  int h;\n  return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n**（2）插入算法**\n\n如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 `hash % length` 等價於 `h & (length-1)`。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 `hash % length` = 0000 0010 = `h & (length-1)`。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。\n\n```java\n/**\n* Returns index for hash code h.\n*/\nstatic int indexFor(int h, int length) {\n  return h & (length-1);\n}\n```\n\n**（3）拉鍊法**\n\n將衝突的值加到鏈表中。\n\n**（4）保證數組長度爲 2 之幂次的方法**\n\n- 方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。\n\n    ```java\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n    ```\n\n- 方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。\n\n    ```java\n    // HashMap.java\n    static final int tableSizeFor(int cap) {\n      int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\n      return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n\n    // Integer.java\n    // 取得整數二進制表示前面的零位數量\n    public static int numberOfLeadingZeros(int i) {\n      // HD, Count leading 0's\n      if (i <= 0)\n          return i == 0 ? 32 : 0;\n      int n = 31;\n      if (i >= 1 << 16) { n -= 16; i >>>= 16; }\n      if (i >= 1 <<  8) { n -=  8; i >>>=  8; }\n      if (i >= 1 <<  4) { n -=  4; i >>>=  4; }\n      if (i >= 1 <<  2) { n -=  2; i >>>=  2; }\n      return n - (i >>> 1);\n    }\n    ```\n\n- 方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。\n\n    ```java\n    int n = (int) Math.pow(2, (int) Math.ceil(Math.log(cap) / Math.log(2)));\n    ```\n\n### 遍歷 HashMap 的幾種方式\n\nHashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 `iterator.remove`方法刪除元素或者用 stream 的 `filter` 過濾不需要的數據再進行循環。參見 [https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow](https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow)\n\n```java\nMap<String, String> map = new HashMap<>();\nmap.put(\"lang\", \"java\");\nmap.put(\"sys\", \"linux\");\n// iterator\nIterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<String, String> entry = iterator.next();\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// for，增強 for 循環，使用了迭代器\nfor (Map.Entry<String, String> entry : map.entrySet()) {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// lambda\nmap.forEach((key, value) -> {\n  System.out.println(key + \":\" + value);\n});\n// stream\nmap.entrySet().parallelStream().forEach((entry) -> {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n});\n```\n\n### ConcurrentHashMap 線程安全的原因\n\n我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？\n\nJDK 1.7 時，採用**分段鎖**，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。\n\n![](java-collection/Untitled%205.png)\n\nJDK 1.8 開始取消了分段鎖，採用 **CAS（樂觀鎖） 和 synchronized（悲觀鎖）** 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。\n\n![](java-collection/Untitled%206.png)","source":"_posts/it/java/java-collection.md","raw":"---\ntitle: Java 集合\np: it/java/java-collection.md\ndate: 2020-11-08 12:23:00\ntags:\n- Java\n---\n\nJava 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。\n\nList 有一實現 `ArrayList`，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數。\n\nSet 有一實現 `HashSet`，其底層實現是 `HashMap` ，其檢查重複的機制有賴於 `hashCode` 和 `equals` 方法。\n\nMap 有一實現 `HashMap` ，JDK 1.8 之後其底層實現是：**數組 + 鏈表 + 紅黑二叉樹**。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 `hash & (length-1)` 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。\n\n總結下 HashMap 中解決哈希衝突的方式：\n\n1. 使用鏈表 — 拉鍊法；\n2. 使用紅黑二叉樹；\n3. 擴容底層數組；\n4. 強制數組容量爲 2 之幂次；\n5. 將元素的 hash 值的高位分散到低位等等。\n\n`ArrayList`、`HashSet`、`HashMap` 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 `CopyOnWriteArrayList` 、`ConcurrentHashMap` （`HashSet` 用`ConcurrentHashMap` 的 keySet 可得 Set 視圖）。`CopyOnWriteArrayList` 會在寫時加鎖並複製集合進行操作；`ConcurrentHashMap` 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。\n\n<!-- more -->\n\n## 概覽\n\n集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。\n\n![](java-collection/Untitled.png)\n\n### List、Set、Map 三者之區別\n\n1. List：存儲的元素有序、可重複。\n2. Set：存儲的元素無序、不可重複。\n3. Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。\n\n### List、Set、Map 三者之底層數據結構\n\n1. List\n    - ArrayList：Object 數組\n    - Vector：Object 數組\n    - LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）\n2. Set\n    - HashSet（無序、唯一）：基於 HashMap\n    - LinkedHashSet：基於 LinkedHashMap\n    - TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）\n3. Map\n    - HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）\n    - LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表\n    - Hashtable：數組 + 鏈表\n    - TreeMap：紅黑樹（自平衡的排序二叉樹）\n\n### Iterator 迭代器\n\n迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，`hasNext()` 和 `next()` 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 `ConcurrentModificationException` 了。\n\n爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 `modCount` 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 `expectedModCount` 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 `modCount` 和 `expectedModCount`，兩者相等，不會拋出異常。\n\n```java\nMap<Integer, String> map = new HashMap();\nmap.put(1, \"Java\");\nmap.put(2, \"Python\");\nmap.put(2, \"Go\");\nIterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<Integer, String> entry = iterator.next();\n  System.out.println(entry.getKey() + entry.getValue());\n}\n```\n\n### 有哪些集合是線程不安全的？怎麼解決？\n\n常用的 `ArrayList`、`LinkedList`、`HashMap`、`HashSet`、`TreeSet`、`TreeMap`、`PriorityQueue` 都不是線程安全的。解決方法就是用 `java.util.concurrent` 包提供的線程安全的集合來代替：\n\n1. `ConcurrentHashMap` 代替 `HashMap`；\n2. `CopyOnWriteArrayList` 代替 `ArrayList`；\n3. `ConcurrentLinkedQueue` 代替 `LinkedList` ；\n4. `BlockingQueue` 接口下的 `PriorityBlockingQueue`、`LinkedBlockingQueue` 等阻塞隊列代替 `PriorityQueue`  等；\n5. `ConcurrentSkipListMap`  代替 `TreeMap` ，實現多線程下保證按 Key 的順序存儲元素。\n\n### `length`、`length()`、`size()` 三者用途\n\n1. `length`：用於數組。\n2. `length()`：用於字符串。\n3. `size()`：用於集合。\n\n### Collections 工具類的使用\n\n- 排序\n\n    ```java\n    //反轉\n    void reverse(List list)\n    //隨機排序\n    void shuffle(List list)\n    //按自然排序的升序排序\n    void sort(List list)\n    //定制排序，由Comparator控制排序邏輯\n    void sort(List list, Comparator c)\n    //交換兩個索引位置的元素\n    void swap(List list, int i , int j)\n    //旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面\n    void rotate(List list, int distance)\n    ```\n\n- 查找替換統計\n\n    ```java\n    //對List進行二分查找，返回索引，注意List必須是有序的\n    int binarySearch(List list, Object key)\n    //根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)\n    int max(Collection coll)\n    //根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)\n    int max(Collection coll, Comparator c)\n    //用指定的元素代替指定list中的所有元素\n    void fill(List list, Object obj)\n    //用新元素替換舊元素\n    boolean replaceAll(List list, Object oldVal, Object newVal) \n    //統計元素出現次數\n    int frequency(Collection c, Object o)\n    //統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)\n    int indexOfSubList(List list, List target)\n    ```\n\n## List\n\n### 比較 ArrayList 與 LinkedList\n\n共同點：\n\n1. 都實現了 List 接口；\n2. 都是不同步的，不保證線程安全。\n\n不同點：\n\n1. **底層數據結構不同**。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。\n2. **插入和刪除的時間複雜度不同**。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。\n3. **對快速隨機訪問的支持不同**。ArrayList 支持快速隨機訪問；LinkedList 不支持。\n4. **對空間的利用不同**。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。\n- 比較雙向鏈表與雙向循環鏈表\n\n    ![](java-collection/Untitled%201.png)\n\n    ![](java-collection/Untitled%202.png)\n\n### ArrayList 擴容機制\n\nArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。\n\n其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是**等到首次添加元素時才開始初始化**一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，**容量會擴充到原來的 1.5 倍**（`newCapacity = oldCapacity + oldCapacity >> 2`），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。\n\n### 快速隨機訪問 RandomAccess\n\nRandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。\n\n```java\npublic interface RandomAccess {\n}\n```\n\n### `System.arraycopy()` 與 `Arrays.copyOf()` 方法\n\n1. `System.arraycopy()` 方法用於源數組到目標數組之間的數據拷貝；\n2. `Arrays.copyOf()` 方法用於給源數組擴容，底層調用`System.arraycopy()` 。\n\n### CopyOnWriteArrayList 的特點\n\n1. 寫時會加鎖並複製整個集合；\n2. 讀時可能讀到舊數據。\n\n### **如何移除列表中的元素**\n\n首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 `ConcurrentModificationException` （並發修改異常）。\n\n可以採用 `iterator` 或者 `Collection.removeIf()` 方法移除列表元素。\n\n```java\nString[] arrs = {\"a\", \"b\", \"c\"};\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n\n// 採用 iterator\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    if (\"a\".equals(iterator.next())) {\n        iterator.remove();\n        break;\n    }\n}\n\n// 採用 removeIf 方法，\"a\"::equals 等價於 x -> \"a\".equals(x)\nlist.removeIf(\"a\"::equals); \n\nSystem.out.println(list);\n```\n\n### **正確使用 Arrays.asList**\n\n如果非要在 `foreach` 循環中刪除元素，還可以使用 `CopyOnWriteArrayList`，此集合是 `fail-safe` 的。`CopyOnWriteArrayList` 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。\n\nArrays 工具類有一個靜態方法 `asList(T... a)`，能將**對象**數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 `add`/`remove`/`clear` 並不可用，調用會拋出 `UnsupportedOperationException`。\n\nArrays 類中關於 `asList` 方法的代碼如下：\n\n```java\npublic static <T> List<T> asList(T... a) {\n\t\t// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList\n    return new ArrayList<>(a);\n}\n```\n\n爲什麼 `asList` 方法傳入的必須是對象數組呢？\n\n你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。\n\n傳入基本類型的數組會怎樣呢？請看下面代碼：\n\n```java\nint[] ints = {1, 3, 4};\n// 此時的泛型是 int[] 對象，而非 int\nList<int[]> list = Arrays.asList(ints);\n// list 的大小爲 1，就是 ints 這個數組對象\nSystem.out.println(list.size());\n```\n\n### **把數組轉爲 `java.util.ArrayList`**\n\n那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？\n\n```java\n// 1) 使用 ArrayList 的帶參構造方法\nList<String> list = new ArrayList<>(Arrays.asList(arrs));\n\n// 2) 使用 Java 8 的 Stream API\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n// boxed 方法可以把基本類型轉成包裝類型\nList<Integer> intList = Arrays.stream(ints).boxed().collect(Collectors.toList());\n\n// 3) 使用 Guava 包的 API\nImmutableList<String[]> list = ImmutableList.of(arrs);\nImmutableList<String> list1 = ImmutableList.copyOf(arrs);\nArrayList<String> list2 = Lists.newArrayList(arrs);\n\n// 4) 使用 Java 9 的 API\nList<String> list = List.of(arrs);\n```\n\n### **將 List 轉爲數組**\n\n使用 List 的 `toArray` 方法可以將 List 轉爲數組，代碼如下：\n\n```java\n// new String[0] 僅僅爲了告知類型返回數組的類型\nString[] strings = list.toArray(new String[0]);\n```\n\n## Set\n\n### 無序性和不可重複性的含義\n\n無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。\n\n不可重複性是指添加的元素按 equals 方法判斷結果爲 false。\n\n### 比較 HashSet、LinkedHashSet 和 TreeSet\n\n共同點：\n\n1. 都實現了 Set 接口；\n2. 元素不可重複；\n3. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據接口不同**。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。\n2. **有序性不同**。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。\n\n### 自定義排序的實現\n\n自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。\n\n### HashSet 如何檢查重複\n\nHashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n## Map\n\n### 比較 HashMap 與 TreeMap\n\n共同點：\n\n1. 都繼承自 AbstractMap，間接實現了 Map 接口；\n2. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據結構不同**。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。\n2. **HashMap 無搜索和排序的能力**。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。\n\n### HashMap 底層實現\n\nJDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：\n\n```java\ntransient Node<K,V>[] table;\n```\n\nNode 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。\n\n![](java-collection/Untitled%203.png)\n\n該數組默認大小是 `1 << 4 = 16` 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過**拉鍊法**解決。當 Map 中包含的元素數量大於等於 `threshold = loadFactor * capacity` （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。\n\nJDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，**當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。**\n\n![](java-collection/Untitled%204.png)\n\n**（1）散列算法**\n\n首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。\n\n```java\n// JDK 1.7\nstatic int hash(int h) {\n  // This function ensures that hashCodes that differ only by\n  // constant multiples at each bit position have a bounded\n  // number of collisions (approximately 8 at default load factor).\n  h ^= (h >>> 20) ^ (h >>> 12);\n  return h ^ (h >>> 7) ^ (h >>> 4);\n}\n// JDK 1.8\nstatic final int hash(Object key) {\n  int h;\n  return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n**（2）插入算法**\n\n如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 `hash % length` 等價於 `h & (length-1)`。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 `hash % length` = 0000 0010 = `h & (length-1)`。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。\n\n```java\n/**\n* Returns index for hash code h.\n*/\nstatic int indexFor(int h, int length) {\n  return h & (length-1);\n}\n```\n\n**（3）拉鍊法**\n\n將衝突的值加到鏈表中。\n\n**（4）保證數組長度爲 2 之幂次的方法**\n\n- 方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。\n\n    ```java\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n    ```\n\n- 方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。\n\n    ```java\n    // HashMap.java\n    static final int tableSizeFor(int cap) {\n      int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\n      return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n\n    // Integer.java\n    // 取得整數二進制表示前面的零位數量\n    public static int numberOfLeadingZeros(int i) {\n      // HD, Count leading 0's\n      if (i <= 0)\n          return i == 0 ? 32 : 0;\n      int n = 31;\n      if (i >= 1 << 16) { n -= 16; i >>>= 16; }\n      if (i >= 1 <<  8) { n -=  8; i >>>=  8; }\n      if (i >= 1 <<  4) { n -=  4; i >>>=  4; }\n      if (i >= 1 <<  2) { n -=  2; i >>>=  2; }\n      return n - (i >>> 1);\n    }\n    ```\n\n- 方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。\n\n    ```java\n    int n = (int) Math.pow(2, (int) Math.ceil(Math.log(cap) / Math.log(2)));\n    ```\n\n### 遍歷 HashMap 的幾種方式\n\nHashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 `iterator.remove`方法刪除元素或者用 stream 的 `filter` 過濾不需要的數據再進行循環。參見 [https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow](https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow)\n\n```java\nMap<String, String> map = new HashMap<>();\nmap.put(\"lang\", \"java\");\nmap.put(\"sys\", \"linux\");\n// iterator\nIterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<String, String> entry = iterator.next();\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// for，增強 for 循環，使用了迭代器\nfor (Map.Entry<String, String> entry : map.entrySet()) {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// lambda\nmap.forEach((key, value) -> {\n  System.out.println(key + \":\" + value);\n});\n// stream\nmap.entrySet().parallelStream().forEach((entry) -> {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n});\n```\n\n### ConcurrentHashMap 線程安全的原因\n\n我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？\n\nJDK 1.7 時，採用**分段鎖**，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。\n\n![](java-collection/Untitled%205.png)\n\nJDK 1.8 開始取消了分段鎖，採用 **CAS（樂觀鎖） 和 synchronized（悲觀鎖）** 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。\n\n![](java-collection/Untitled%206.png)","slug":"it/java/java-collection","published":1,"updated":"2021-09-13T14:16:38.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfp00311n9k4xupefeb","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>Java 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。</p>\n<p>List 有一實現 <code>ArrayList</code>，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數。</p>\n<p>Set 有一實現 <code>HashSet</code>，其底層實現是 <code>HashMap</code> ，其檢查重複的機制有賴於 <code>hashCode</code> 和 <code>equals</code> 方法。</p>\n<p>Map 有一實現 <code>HashMap</code> ，JDK 1.8 之後其底層實現是：<strong>數組 + 鏈表 + 紅黑二叉樹</strong>。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 <code>hash &amp; (length-1)</code> 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。</p>\n<p>總結下 HashMap 中解決哈希衝突的方式：</p>\n<ol>\n<li>使用鏈表 — 拉鍊法；</li>\n<li>使用紅黑二叉樹；</li>\n<li>擴容底層數組；</li>\n<li>強制數組容量爲 2 之幂次；</li>\n<li>將元素的 hash 值的高位分散到低位等等。</li>\n</ol>\n<p><code>ArrayList</code>、<code>HashSet</code>、<code>HashMap</code> 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 <code>CopyOnWriteArrayList</code> 、<code>ConcurrentHashMap</code> （<code>HashSet</code> 用<code>ConcurrentHashMap</code> 的 keySet 可得 Set 視圖）。<code>CopyOnWriteArrayList</code> 會在寫時加鎖並複製集合進行操作；<code>ConcurrentHashMap</code> 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"概覽\"><a href=\"#概覽\" class=\"headerlink\" title=\"概覽\"></a>概覽</h2><p>集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。</p>\n<p><img src=\"/it/java/java-collection/Untitled.png\" alt></p>\n<h3 id=\"List、Set、Map-三者之區別\"><a href=\"#List、Set、Map-三者之區別\" class=\"headerlink\" title=\"List、Set、Map 三者之區別\"></a>List、Set、Map 三者之區別</h3><ol>\n<li>List：存儲的元素有序、可重複。</li>\n<li>Set：存儲的元素無序、不可重複。</li>\n<li>Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。</li>\n</ol>\n<h3 id=\"List、Set、Map-三者之底層數據結構\"><a href=\"#List、Set、Map-三者之底層數據結構\" class=\"headerlink\" title=\"List、Set、Map 三者之底層數據結構\"></a>List、Set、Map 三者之底層數據結構</h3><ol>\n<li>List<ul>\n<li>ArrayList：Object 數組</li>\n<li>Vector：Object 數組</li>\n<li>LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）</li>\n</ul>\n</li>\n<li>Set<ul>\n<li>HashSet（無序、唯一）：基於 HashMap</li>\n<li>LinkedHashSet：基於 LinkedHashMap</li>\n<li>TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n<li>Map<ul>\n<li>HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）</li>\n<li>LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表</li>\n<li>Hashtable：數組 + 鏈表</li>\n<li>TreeMap：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Iterator-迭代器\"><a href=\"#Iterator-迭代器\" class=\"headerlink\" title=\"Iterator 迭代器\"></a>Iterator 迭代器</h3><p>迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，<code>hasNext()</code> 和 <code>next()</code> 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 <code>ConcurrentModificationException</code> 了。</p>\n<p>爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 <code>modCount</code> 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 <code>expectedModCount</code> 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 <code>modCount</code> 和 <code>expectedModCount</code>，兩者相等，不會拋出異常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">&quot;Java&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Python&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Go&quot;</span>);</span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有哪些集合是線程不安全的？怎麼解決？\"><a href=\"#有哪些集合是線程不安全的？怎麼解決？\" class=\"headerlink\" title=\"有哪些集合是線程不安全的？怎麼解決？\"></a>有哪些集合是線程不安全的？怎麼解決？</h3><p>常用的 <code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>HashSet</code>、<code>TreeSet</code>、<code>TreeMap</code>、<code>PriorityQueue</code> 都不是線程安全的。解決方法就是用 <code>java.util.concurrent</code> 包提供的線程安全的集合來代替：</p>\n<ol>\n<li><code>ConcurrentHashMap</code> 代替 <code>HashMap</code>；</li>\n<li><code>CopyOnWriteArrayList</code> 代替 <code>ArrayList</code>；</li>\n<li><code>ConcurrentLinkedQueue</code> 代替 <code>LinkedList</code> ；</li>\n<li><code>BlockingQueue</code> 接口下的 <code>PriorityBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等阻塞隊列代替 <code>PriorityQueue</code>  等；</li>\n<li><code>ConcurrentSkipListMap</code>  代替 <code>TreeMap</code> ，實現多線程下保證按 Key 的順序存儲元素。</li>\n</ol>\n<h3 id=\"length、length-、size-三者用途\"><a href=\"#length、length-、size-三者用途\" class=\"headerlink\" title=\"length、length()、size() 三者用途\"></a><code>length</code>、<code>length()</code>、<code>size()</code> 三者用途</h3><ol>\n<li><code>length</code>：用於數組。</li>\n<li><code>length()</code>：用於字符串。</li>\n<li><code>size()</code>：用於集合。</li>\n</ol>\n<h3 id=\"Collections-工具類的使用\"><a href=\"#Collections-工具類的使用\" class=\"headerlink\" title=\"Collections 工具類的使用\"></a>Collections 工具類的使用</h3><ul>\n<li><p>排序</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//反轉</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//隨機排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shuffle</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//按自然排序的升序排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//定制排序，由Comparator控制排序邏輯</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//交換兩個索引位置的元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> i , <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> distance)</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查找替換統計</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//對List進行二分查找，返回索引，注意List必須是有序的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(List list, Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fill</span><span class=\"params\">(List list, Object obj)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用新元素替換舊元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">replaceAll</span><span class=\"params\">(List list, Object oldVal, Object newVal)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計元素出現次數</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">frequency</span><span class=\"params\">(Collection c, Object o)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">indexOfSubList</span><span class=\"params\">(List list, List target)</span></span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"比較-ArrayList-與-LinkedList\"><a href=\"#比較-ArrayList-與-LinkedList\" class=\"headerlink\" title=\"比較 ArrayList 與 LinkedList\"></a>比較 ArrayList 與 LinkedList</h3><p>共同點：</p>\n<ol>\n<li>都實現了 List 接口；</li>\n<li>都是不同步的，不保證線程安全。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。</li>\n<li><strong>插入和刪除的時間複雜度不同</strong>。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。</li>\n<li><strong>對快速隨機訪問的支持不同</strong>。ArrayList 支持快速隨機訪問；LinkedList 不支持。</li>\n<li><strong>對空間的利用不同</strong>。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。</li>\n</ol>\n<ul>\n<li><p>比較雙向鏈表與雙向循環鏈表</p>\n<p>  <img src=\"/it/java/java-collection/Untitled%201.png\" alt></p>\n<p>  <img src=\"/it/java/java-collection/Untitled%202.png\" alt></p>\n</li>\n</ul>\n<h3 id=\"ArrayList-擴容機制\"><a href=\"#ArrayList-擴容機制\" class=\"headerlink\" title=\"ArrayList 擴容機制\"></a>ArrayList 擴容機制</h3><p>ArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。</p>\n<p>其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是<strong>等到首次添加元素時才開始初始化</strong>一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，<strong>容量會擴充到原來的 1.5 倍</strong>（<code>newCapacity = oldCapacity + oldCapacity &gt;&gt; 2</code>），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。</p>\n<h3 id=\"快速隨機訪問-RandomAccess\"><a href=\"#快速隨機訪問-RandomAccess\" class=\"headerlink\" title=\"快速隨機訪問 RandomAccess\"></a>快速隨機訪問 RandomAccess</h3><p>RandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RandomAccess</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"System-arraycopy-與-Arrays-copyOf-方法\"><a href=\"#System-arraycopy-與-Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy() 與 Arrays.copyOf() 方法\"></a><code>System.arraycopy()</code> 與 <code>Arrays.copyOf()</code> 方法</h3><ol>\n<li><code>System.arraycopy()</code> 方法用於源數組到目標數組之間的數據拷貝；</li>\n<li><code>Arrays.copyOf()</code> 方法用於給源數組擴容，底層調用<code>System.arraycopy()</code> 。</li>\n</ol>\n<h3 id=\"CopyOnWriteArrayList-的特點\"><a href=\"#CopyOnWriteArrayList-的特點\" class=\"headerlink\" title=\"CopyOnWriteArrayList 的特點\"></a>CopyOnWriteArrayList 的特點</h3><ol>\n<li>寫時會加鎖並複製整個集合；</li>\n<li>讀時可能讀到舊數據。</li>\n</ol>\n<h3 id=\"如何移除列表中的元素\"><a href=\"#如何移除列表中的元素\" class=\"headerlink\" title=\"如何移除列表中的元素\"></a><strong>如何移除列表中的元素</strong></h3><p>首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 <code>ConcurrentModificationException</code> （並發修改異常）。</p>\n<p>可以採用 <code>iterator</code> 或者 <code>Collection.removeIf()</code> 方法移除列表元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String[] arrs = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>&#125;;</span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 iterator</span></span><br><span class=\"line\">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;a&quot;</span>.equals(iterator.next())) &#123;</span><br><span class=\"line\">        iterator.remove();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 removeIf 方法，&quot;a&quot;::equals 等價於 x -&gt; &quot;a&quot;.equals(x)</span></span><br><span class=\"line\">list.removeIf(<span class=\"string\">&quot;a&quot;</span>::equals); </span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正確使用-Arrays-asList\"><a href=\"#正確使用-Arrays-asList\" class=\"headerlink\" title=\"正確使用 Arrays.asList\"></a><strong>正確使用 Arrays.asList</strong></h3><p>如果非要在 <code>foreach</code> 循環中刪除元素，還可以使用 <code>CopyOnWriteArrayList</code>，此集合是 <code>fail-safe</code> 的。<code>CopyOnWriteArrayList</code> 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。</p>\n<p>Arrays 工具類有一個靜態方法 <code>asList(T... a)</code>，能將<strong>對象</strong>數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 <code>add</code>/<code>remove</code>/<code>clear</code> 並不可用，調用會拋出 <code>UnsupportedOperationException</code>。</p>\n<p>Arrays 類中關於 <code>asList</code> 方法的代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>爲什麼 <code>asList</code> 方法傳入的必須是對象數組呢？</p>\n<p>你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。</p>\n<p>傳入基本類型的數組會怎樣呢？請看下面代碼：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] ints = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 此時的泛型是 int[] 對象，而非 int</span></span><br><span class=\"line\">List&lt;<span class=\"keyword\">int</span>[]&gt; list = Arrays.asList(ints);</span><br><span class=\"line\"><span class=\"comment\">// list 的大小爲 1，就是 ints 這個數組對象</span></span><br><span class=\"line\">System.out.println(list.size());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"把數組轉爲-java-util-ArrayList\"><a href=\"#把數組轉爲-java-util-ArrayList\" class=\"headerlink\" title=\"把數組轉爲 java.util.ArrayList\"></a><strong>把數組轉爲 <code>java.util.ArrayList</code></strong></h3><p>那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1) 使用 ArrayList 的帶參構造方法</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(arrs));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2) 使用 Java 8 的 Stream API</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"><span class=\"comment\">// boxed 方法可以把基本類型轉成包裝類型</span></span><br><span class=\"line\">List&lt;Integer&gt; intList = Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3) 使用 Guava 包的 API</span></span><br><span class=\"line\">ImmutableList&lt;String[]&gt; list = ImmutableList.of(arrs);</span><br><span class=\"line\">ImmutableList&lt;String&gt; list1 = ImmutableList.copyOf(arrs);</span><br><span class=\"line\">ArrayList&lt;String&gt; list2 = Lists.newArrayList(arrs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4) 使用 Java 9 的 API</span></span><br><span class=\"line\">List&lt;String&gt; list = List.of(arrs);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"將-List-轉爲數組\"><a href=\"#將-List-轉爲數組\" class=\"headerlink\" title=\"將 List 轉爲數組\"></a><strong>將 List 轉爲數組</strong></h3><p>使用 List 的 <code>toArray</code> 方法可以將 List 轉爲數組，代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new String[0] 僅僅爲了告知類型返回數組的類型</span></span><br><span class=\"line\">String[] strings = list.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"無序性和不可重複性的含義\"><a href=\"#無序性和不可重複性的含義\" class=\"headerlink\" title=\"無序性和不可重複性的含義\"></a>無序性和不可重複性的含義</h3><p>無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。</p>\n<p>不可重複性是指添加的元素按 equals 方法判斷結果爲 false。</p>\n<h3 id=\"比較-HashSet、LinkedHashSet-和-TreeSet\"><a href=\"#比較-HashSet、LinkedHashSet-和-TreeSet\" class=\"headerlink\" title=\"比較 HashSet、LinkedHashSet 和 TreeSet\"></a>比較 HashSet、LinkedHashSet 和 TreeSet</h3><p>共同點：</p>\n<ol>\n<li>都實現了 Set 接口；</li>\n<li>元素不可重複；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據接口不同</strong>。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。</li>\n<li><strong>有序性不同</strong>。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。</li>\n</ol>\n<h3 id=\"自定義排序的實現\"><a href=\"#自定義排序的實現\" class=\"headerlink\" title=\"自定義排序的實現\"></a>自定義排序的實現</h3><p>自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。</p>\n<h3 id=\"HashSet-如何檢查重複\"><a href=\"#HashSet-如何檢查重複\" class=\"headerlink\" title=\"HashSet 如何檢查重複\"></a>HashSet 如何檢查重複</h3><p>HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"比較-HashMap-與-TreeMap\"><a href=\"#比較-HashMap-與-TreeMap\" class=\"headerlink\" title=\"比較 HashMap 與 TreeMap\"></a>比較 HashMap 與 TreeMap</h3><p>共同點：</p>\n<ol>\n<li>都繼承自 AbstractMap，間接實現了 Map 接口；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。</li>\n<li><strong>HashMap 無搜索和排序的能力</strong>。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。</li>\n</ol>\n<h3 id=\"HashMap-底層實現\"><a href=\"#HashMap-底層實現\" class=\"headerlink\" title=\"HashMap 底層實現\"></a>HashMap 底層實現</h3><p>JDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n\n<p>Node 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。</p>\n<p><img src=\"/it/java/java-collection/Untitled%203.png\" alt></p>\n<p>該數組默認大小是 <code>1 &lt;&lt; 4 = 16</code> 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過<strong>拉鍊法</strong>解決。當 Map 中包含的元素數量大於等於 <code>threshold = loadFactor * capacity</code> （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。</p>\n<p>JDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，<strong>當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。</strong></p>\n<p><img src=\"/it/java/java-collection/Untitled%204.png\" alt></p>\n<p><strong>（1）散列算法</strong></p>\n<p>首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK 1.7</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></span><br><span class=\"line\">  <span class=\"comment\">// constant multiples at each bit position have a bounded</span></span><br><span class=\"line\">  <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></span><br><span class=\"line\">  h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// JDK 1.8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）插入算法</strong></p>\n<p>如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 <code>hash % length</code> 等價於 <code>h &amp; (length-1)</code>。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 <code>hash % length</code> = 0000 0010 = <code>h &amp; (length-1)</code>。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Returns index for hash code h.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）拉鍊法</strong></p>\n<p>將衝突的值加到鏈表中。</p>\n<p><strong>（4）保證數組長度爲 2 之幂次的方法</strong></p>\n<ul>\n<li><p>方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HashMap.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = -<span class=\"number\">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Integer.java</span></span><br><span class=\"line\"><span class=\"comment\">// 取得整數二進制表示前面的零位數量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">numberOfLeadingZeros</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// HD, Count leading 0&#x27;s</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i == <span class=\"number\">0</span> ? <span class=\"number\">32</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>) &#123; n -= <span class=\"number\">16</span>; i &gt;&gt;&gt;= <span class=\"number\">16</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">8</span>) &#123; n -=  <span class=\"number\">8</span>; i &gt;&gt;&gt;=  <span class=\"number\">8</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">4</span>) &#123; n -=  <span class=\"number\">4</span>; i &gt;&gt;&gt;=  <span class=\"number\">4</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">2</span>) &#123; n -=  <span class=\"number\">2</span>; i &gt;&gt;&gt;=  <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - (i &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = (<span class=\"keyword\">int</span>) Math.pow(<span class=\"number\">2</span>, (<span class=\"keyword\">int</span>) Math.ceil(Math.log(cap) / Math.log(<span class=\"number\">2</span>)));</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"遍歷-HashMap-的幾種方式\"><a href=\"#遍歷-HashMap-的幾種方式\" class=\"headerlink\" title=\"遍歷 HashMap 的幾種方式\"></a>遍歷 HashMap 的幾種方式</h3><p>HashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 <code>iterator.remove</code>方法刪除元素或者用 stream 的 <code>filter</code> 過濾不需要的數據再進行循環。參見 <a href=\"https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow\">https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;lang&quot;</span>, <span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;sys&quot;</span>, <span class=\"string\">&quot;linux&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// iterator</span></span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// for，增強 for 循環，使用了迭代器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lambda</span></span><br><span class=\"line\">map.forEach((key, value) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// stream</span></span><br><span class=\"line\">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ConcurrentHashMap-線程安全的原因\"><a href=\"#ConcurrentHashMap-線程安全的原因\" class=\"headerlink\" title=\"ConcurrentHashMap 線程安全的原因\"></a>ConcurrentHashMap 線程安全的原因</h3><p>我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？</p>\n<p>JDK 1.7 時，採用<strong>分段鎖</strong>，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。</p>\n<p><img src=\"/it/java/java-collection/Untitled%205.png\" alt></p>\n<p>JDK 1.8 開始取消了分段鎖，採用 <strong>CAS（樂觀鎖） 和 synchronized（悲觀鎖）</strong> 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。</p>\n<p><img src=\"/it/java/java-collection/Untitled%206.png\" alt></p>\n","site":{"data":{}},"excerpt":"<p>Java 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。</p>\n<p>List 有一實現 <code>ArrayList</code>，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數。</p>\n<p>Set 有一實現 <code>HashSet</code>，其底層實現是 <code>HashMap</code> ，其檢查重複的機制有賴於 <code>hashCode</code> 和 <code>equals</code> 方法。</p>\n<p>Map 有一實現 <code>HashMap</code> ，JDK 1.8 之後其底層實現是：<strong>數組 + 鏈表 + 紅黑二叉樹</strong>。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 <code>hash &amp; (length-1)</code> 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。</p>\n<p>總結下 HashMap 中解決哈希衝突的方式：</p>\n<ol>\n<li>使用鏈表 — 拉鍊法；</li>\n<li>使用紅黑二叉樹；</li>\n<li>擴容底層數組；</li>\n<li>強制數組容量爲 2 之幂次；</li>\n<li>將元素的 hash 值的高位分散到低位等等。</li>\n</ol>\n<p><code>ArrayList</code>、<code>HashSet</code>、<code>HashMap</code> 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 <code>CopyOnWriteArrayList</code> 、<code>ConcurrentHashMap</code> （<code>HashSet</code> 用<code>ConcurrentHashMap</code> 的 keySet 可得 Set 視圖）。<code>CopyOnWriteArrayList</code> 會在寫時加鎖並複製集合進行操作；<code>ConcurrentHashMap</code> 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。</p>","more":"<h2 id=\"概覽\"><a href=\"#概覽\" class=\"headerlink\" title=\"概覽\"></a>概覽</h2><p>集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。</p>\n<p><img src=\"/it/java/java-collection/Untitled.png\" alt></p>\n<h3 id=\"List、Set、Map-三者之區別\"><a href=\"#List、Set、Map-三者之區別\" class=\"headerlink\" title=\"List、Set、Map 三者之區別\"></a>List、Set、Map 三者之區別</h3><ol>\n<li>List：存儲的元素有序、可重複。</li>\n<li>Set：存儲的元素無序、不可重複。</li>\n<li>Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。</li>\n</ol>\n<h3 id=\"List、Set、Map-三者之底層數據結構\"><a href=\"#List、Set、Map-三者之底層數據結構\" class=\"headerlink\" title=\"List、Set、Map 三者之底層數據結構\"></a>List、Set、Map 三者之底層數據結構</h3><ol>\n<li>List<ul>\n<li>ArrayList：Object 數組</li>\n<li>Vector：Object 數組</li>\n<li>LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）</li>\n</ul>\n</li>\n<li>Set<ul>\n<li>HashSet（無序、唯一）：基於 HashMap</li>\n<li>LinkedHashSet：基於 LinkedHashMap</li>\n<li>TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n<li>Map<ul>\n<li>HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）</li>\n<li>LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表</li>\n<li>Hashtable：數組 + 鏈表</li>\n<li>TreeMap：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Iterator-迭代器\"><a href=\"#Iterator-迭代器\" class=\"headerlink\" title=\"Iterator 迭代器\"></a>Iterator 迭代器</h3><p>迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，<code>hasNext()</code> 和 <code>next()</code> 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 <code>ConcurrentModificationException</code> 了。</p>\n<p>爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 <code>modCount</code> 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 <code>expectedModCount</code> 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 <code>modCount</code> 和 <code>expectedModCount</code>，兩者相等，不會拋出異常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">&quot;Java&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Python&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Go&quot;</span>);</span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有哪些集合是線程不安全的？怎麼解決？\"><a href=\"#有哪些集合是線程不安全的？怎麼解決？\" class=\"headerlink\" title=\"有哪些集合是線程不安全的？怎麼解決？\"></a>有哪些集合是線程不安全的？怎麼解決？</h3><p>常用的 <code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>HashSet</code>、<code>TreeSet</code>、<code>TreeMap</code>、<code>PriorityQueue</code> 都不是線程安全的。解決方法就是用 <code>java.util.concurrent</code> 包提供的線程安全的集合來代替：</p>\n<ol>\n<li><code>ConcurrentHashMap</code> 代替 <code>HashMap</code>；</li>\n<li><code>CopyOnWriteArrayList</code> 代替 <code>ArrayList</code>；</li>\n<li><code>ConcurrentLinkedQueue</code> 代替 <code>LinkedList</code> ；</li>\n<li><code>BlockingQueue</code> 接口下的 <code>PriorityBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等阻塞隊列代替 <code>PriorityQueue</code>  等；</li>\n<li><code>ConcurrentSkipListMap</code>  代替 <code>TreeMap</code> ，實現多線程下保證按 Key 的順序存儲元素。</li>\n</ol>\n<h3 id=\"length、length-、size-三者用途\"><a href=\"#length、length-、size-三者用途\" class=\"headerlink\" title=\"length、length()、size() 三者用途\"></a><code>length</code>、<code>length()</code>、<code>size()</code> 三者用途</h3><ol>\n<li><code>length</code>：用於數組。</li>\n<li><code>length()</code>：用於字符串。</li>\n<li><code>size()</code>：用於集合。</li>\n</ol>\n<h3 id=\"Collections-工具類的使用\"><a href=\"#Collections-工具類的使用\" class=\"headerlink\" title=\"Collections 工具類的使用\"></a>Collections 工具類的使用</h3><ul>\n<li><p>排序</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//反轉</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//隨機排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shuffle</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//按自然排序的升序排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//定制排序，由Comparator控制排序邏輯</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//交換兩個索引位置的元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> i , <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> distance)</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查找替換統計</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//對List進行二分查找，返回索引，注意List必須是有序的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(List list, Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fill</span><span class=\"params\">(List list, Object obj)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用新元素替換舊元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">replaceAll</span><span class=\"params\">(List list, Object oldVal, Object newVal)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計元素出現次數</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">frequency</span><span class=\"params\">(Collection c, Object o)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">indexOfSubList</span><span class=\"params\">(List list, List target)</span></span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"比較-ArrayList-與-LinkedList\"><a href=\"#比較-ArrayList-與-LinkedList\" class=\"headerlink\" title=\"比較 ArrayList 與 LinkedList\"></a>比較 ArrayList 與 LinkedList</h3><p>共同點：</p>\n<ol>\n<li>都實現了 List 接口；</li>\n<li>都是不同步的，不保證線程安全。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。</li>\n<li><strong>插入和刪除的時間複雜度不同</strong>。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。</li>\n<li><strong>對快速隨機訪問的支持不同</strong>。ArrayList 支持快速隨機訪問；LinkedList 不支持。</li>\n<li><strong>對空間的利用不同</strong>。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。</li>\n</ol>\n<ul>\n<li><p>比較雙向鏈表與雙向循環鏈表</p>\n<p>  <img src=\"/it/java/java-collection/Untitled%201.png\" alt></p>\n<p>  <img src=\"/it/java/java-collection/Untitled%202.png\" alt></p>\n</li>\n</ul>\n<h3 id=\"ArrayList-擴容機制\"><a href=\"#ArrayList-擴容機制\" class=\"headerlink\" title=\"ArrayList 擴容機制\"></a>ArrayList 擴容機制</h3><p>ArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。</p>\n<p>其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是<strong>等到首次添加元素時才開始初始化</strong>一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，<strong>容量會擴充到原來的 1.5 倍</strong>（<code>newCapacity = oldCapacity + oldCapacity &gt;&gt; 2</code>），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。</p>\n<h3 id=\"快速隨機訪問-RandomAccess\"><a href=\"#快速隨機訪問-RandomAccess\" class=\"headerlink\" title=\"快速隨機訪問 RandomAccess\"></a>快速隨機訪問 RandomAccess</h3><p>RandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RandomAccess</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"System-arraycopy-與-Arrays-copyOf-方法\"><a href=\"#System-arraycopy-與-Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy() 與 Arrays.copyOf() 方法\"></a><code>System.arraycopy()</code> 與 <code>Arrays.copyOf()</code> 方法</h3><ol>\n<li><code>System.arraycopy()</code> 方法用於源數組到目標數組之間的數據拷貝；</li>\n<li><code>Arrays.copyOf()</code> 方法用於給源數組擴容，底層調用<code>System.arraycopy()</code> 。</li>\n</ol>\n<h3 id=\"CopyOnWriteArrayList-的特點\"><a href=\"#CopyOnWriteArrayList-的特點\" class=\"headerlink\" title=\"CopyOnWriteArrayList 的特點\"></a>CopyOnWriteArrayList 的特點</h3><ol>\n<li>寫時會加鎖並複製整個集合；</li>\n<li>讀時可能讀到舊數據。</li>\n</ol>\n<h3 id=\"如何移除列表中的元素\"><a href=\"#如何移除列表中的元素\" class=\"headerlink\" title=\"如何移除列表中的元素\"></a><strong>如何移除列表中的元素</strong></h3><p>首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 <code>ConcurrentModificationException</code> （並發修改異常）。</p>\n<p>可以採用 <code>iterator</code> 或者 <code>Collection.removeIf()</code> 方法移除列表元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String[] arrs = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>&#125;;</span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 iterator</span></span><br><span class=\"line\">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;a&quot;</span>.equals(iterator.next())) &#123;</span><br><span class=\"line\">        iterator.remove();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 removeIf 方法，&quot;a&quot;::equals 等價於 x -&gt; &quot;a&quot;.equals(x)</span></span><br><span class=\"line\">list.removeIf(<span class=\"string\">&quot;a&quot;</span>::equals); </span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正確使用-Arrays-asList\"><a href=\"#正確使用-Arrays-asList\" class=\"headerlink\" title=\"正確使用 Arrays.asList\"></a><strong>正確使用 Arrays.asList</strong></h3><p>如果非要在 <code>foreach</code> 循環中刪除元素，還可以使用 <code>CopyOnWriteArrayList</code>，此集合是 <code>fail-safe</code> 的。<code>CopyOnWriteArrayList</code> 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。</p>\n<p>Arrays 工具類有一個靜態方法 <code>asList(T... a)</code>，能將<strong>對象</strong>數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 <code>add</code>/<code>remove</code>/<code>clear</code> 並不可用，調用會拋出 <code>UnsupportedOperationException</code>。</p>\n<p>Arrays 類中關於 <code>asList</code> 方法的代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>爲什麼 <code>asList</code> 方法傳入的必須是對象數組呢？</p>\n<p>你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。</p>\n<p>傳入基本類型的數組會怎樣呢？請看下面代碼：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] ints = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 此時的泛型是 int[] 對象，而非 int</span></span><br><span class=\"line\">List&lt;<span class=\"keyword\">int</span>[]&gt; list = Arrays.asList(ints);</span><br><span class=\"line\"><span class=\"comment\">// list 的大小爲 1，就是 ints 這個數組對象</span></span><br><span class=\"line\">System.out.println(list.size());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"把數組轉爲-java-util-ArrayList\"><a href=\"#把數組轉爲-java-util-ArrayList\" class=\"headerlink\" title=\"把數組轉爲 java.util.ArrayList\"></a><strong>把數組轉爲 <code>java.util.ArrayList</code></strong></h3><p>那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1) 使用 ArrayList 的帶參構造方法</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(arrs));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2) 使用 Java 8 的 Stream API</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"><span class=\"comment\">// boxed 方法可以把基本類型轉成包裝類型</span></span><br><span class=\"line\">List&lt;Integer&gt; intList = Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3) 使用 Guava 包的 API</span></span><br><span class=\"line\">ImmutableList&lt;String[]&gt; list = ImmutableList.of(arrs);</span><br><span class=\"line\">ImmutableList&lt;String&gt; list1 = ImmutableList.copyOf(arrs);</span><br><span class=\"line\">ArrayList&lt;String&gt; list2 = Lists.newArrayList(arrs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4) 使用 Java 9 的 API</span></span><br><span class=\"line\">List&lt;String&gt; list = List.of(arrs);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"將-List-轉爲數組\"><a href=\"#將-List-轉爲數組\" class=\"headerlink\" title=\"將 List 轉爲數組\"></a><strong>將 List 轉爲數組</strong></h3><p>使用 List 的 <code>toArray</code> 方法可以將 List 轉爲數組，代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new String[0] 僅僅爲了告知類型返回數組的類型</span></span><br><span class=\"line\">String[] strings = list.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"無序性和不可重複性的含義\"><a href=\"#無序性和不可重複性的含義\" class=\"headerlink\" title=\"無序性和不可重複性的含義\"></a>無序性和不可重複性的含義</h3><p>無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。</p>\n<p>不可重複性是指添加的元素按 equals 方法判斷結果爲 false。</p>\n<h3 id=\"比較-HashSet、LinkedHashSet-和-TreeSet\"><a href=\"#比較-HashSet、LinkedHashSet-和-TreeSet\" class=\"headerlink\" title=\"比較 HashSet、LinkedHashSet 和 TreeSet\"></a>比較 HashSet、LinkedHashSet 和 TreeSet</h3><p>共同點：</p>\n<ol>\n<li>都實現了 Set 接口；</li>\n<li>元素不可重複；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據接口不同</strong>。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。</li>\n<li><strong>有序性不同</strong>。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。</li>\n</ol>\n<h3 id=\"自定義排序的實現\"><a href=\"#自定義排序的實現\" class=\"headerlink\" title=\"自定義排序的實現\"></a>自定義排序的實現</h3><p>自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。</p>\n<h3 id=\"HashSet-如何檢查重複\"><a href=\"#HashSet-如何檢查重複\" class=\"headerlink\" title=\"HashSet 如何檢查重複\"></a>HashSet 如何檢查重複</h3><p>HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"比較-HashMap-與-TreeMap\"><a href=\"#比較-HashMap-與-TreeMap\" class=\"headerlink\" title=\"比較 HashMap 與 TreeMap\"></a>比較 HashMap 與 TreeMap</h3><p>共同點：</p>\n<ol>\n<li>都繼承自 AbstractMap，間接實現了 Map 接口；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。</li>\n<li><strong>HashMap 無搜索和排序的能力</strong>。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。</li>\n</ol>\n<h3 id=\"HashMap-底層實現\"><a href=\"#HashMap-底層實現\" class=\"headerlink\" title=\"HashMap 底層實現\"></a>HashMap 底層實現</h3><p>JDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n\n<p>Node 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。</p>\n<p><img src=\"/it/java/java-collection/Untitled%203.png\" alt></p>\n<p>該數組默認大小是 <code>1 &lt;&lt; 4 = 16</code> 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過<strong>拉鍊法</strong>解決。當 Map 中包含的元素數量大於等於 <code>threshold = loadFactor * capacity</code> （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。</p>\n<p>JDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，<strong>當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。</strong></p>\n<p><img src=\"/it/java/java-collection/Untitled%204.png\" alt></p>\n<p><strong>（1）散列算法</strong></p>\n<p>首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK 1.7</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></span><br><span class=\"line\">  <span class=\"comment\">// constant multiples at each bit position have a bounded</span></span><br><span class=\"line\">  <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></span><br><span class=\"line\">  h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// JDK 1.8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）插入算法</strong></p>\n<p>如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 <code>hash % length</code> 等價於 <code>h &amp; (length-1)</code>。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 <code>hash % length</code> = 0000 0010 = <code>h &amp; (length-1)</code>。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Returns index for hash code h.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）拉鍊法</strong></p>\n<p>將衝突的值加到鏈表中。</p>\n<p><strong>（4）保證數組長度爲 2 之幂次的方法</strong></p>\n<ul>\n<li><p>方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HashMap.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = -<span class=\"number\">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Integer.java</span></span><br><span class=\"line\"><span class=\"comment\">// 取得整數二進制表示前面的零位數量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">numberOfLeadingZeros</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// HD, Count leading 0&#x27;s</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i == <span class=\"number\">0</span> ? <span class=\"number\">32</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>) &#123; n -= <span class=\"number\">16</span>; i &gt;&gt;&gt;= <span class=\"number\">16</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">8</span>) &#123; n -=  <span class=\"number\">8</span>; i &gt;&gt;&gt;=  <span class=\"number\">8</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">4</span>) &#123; n -=  <span class=\"number\">4</span>; i &gt;&gt;&gt;=  <span class=\"number\">4</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">2</span>) &#123; n -=  <span class=\"number\">2</span>; i &gt;&gt;&gt;=  <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - (i &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = (<span class=\"keyword\">int</span>) Math.pow(<span class=\"number\">2</span>, (<span class=\"keyword\">int</span>) Math.ceil(Math.log(cap) / Math.log(<span class=\"number\">2</span>)));</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"遍歷-HashMap-的幾種方式\"><a href=\"#遍歷-HashMap-的幾種方式\" class=\"headerlink\" title=\"遍歷 HashMap 的幾種方式\"></a>遍歷 HashMap 的幾種方式</h3><p>HashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 <code>iterator.remove</code>方法刪除元素或者用 stream 的 <code>filter</code> 過濾不需要的數據再進行循環。參見 <a href=\"https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow\">https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;lang&quot;</span>, <span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;sys&quot;</span>, <span class=\"string\">&quot;linux&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// iterator</span></span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// for，增強 for 循環，使用了迭代器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lambda</span></span><br><span class=\"line\">map.forEach((key, value) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// stream</span></span><br><span class=\"line\">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ConcurrentHashMap-線程安全的原因\"><a href=\"#ConcurrentHashMap-線程安全的原因\" class=\"headerlink\" title=\"ConcurrentHashMap 線程安全的原因\"></a>ConcurrentHashMap 線程安全的原因</h3><p>我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？</p>\n<p>JDK 1.7 時，採用<strong>分段鎖</strong>，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。</p>\n<p><img src=\"/it/java/java-collection/Untitled%205.png\" alt></p>\n<p>JDK 1.8 開始取消了分段鎖，採用 <strong>CAS（樂觀鎖） 和 synchronized（悲觀鎖）</strong> 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。</p>\n<p><img src=\"/it/java/java-collection/Untitled%206.png\" alt></p>"},{"title":"JVM","p":"it/java/java-jvm.md","date":"2020-11-18T03:37:00.000Z","_content":"\nJVM(Java Virtual Machine)，即 Java 虛擬機，是操作系統上的一個程序，用於編譯、運行Java程序，使得 Java程序可以跨平台。關於 JVM 我們著重在內存區域、類的加載、對象的創建和內存管理四個部分。\n\n內存區域分爲堆、方法區、程序計數器、虛擬機棧和本地方法棧。其中堆和方法區是線程共享的，程序計數器、虛擬機棧和本地方法棧則是線程私有的。堆是一大塊內存，幾乎所有的對象實例都在這裡分配；方法區在JVM 規範中是堆的一部分，不同的 JVM 可以有不同的實現，就 HotSpot VM 而言，在 JDK1.8 之前使用永久代實現方法區，在JDK1.8及之後使用直接內存上的元空間實現；程序計數器存放下一條指令的地址；虛擬機棧的每一個棧幀保存著方法的局部變量表、操作數棧、動態連接和方法返回地址；本地方法棧類似虛擬機棧，不過是調用 native 方法，在 HotSpot VM中虛擬機棧和本地方法棧合而爲一。\n\n類的生命週期分爲加載、連接、初始化、使用和卸載四個過程，其中：\n\n1. 加載：將 .class 文件以二進制字節流方式讀入虛擬機，並在方法區給靜態變量分配空間，在堆中生成 Class 對象作爲訪問靜態變量的入口。\n2. 連接：分爲驗證、準備和解析三個階段，驗證階段驗證字節碼文件的合規性，準備階段將類變量賦予初始零值，解析階段將常量池中的符號引用轉爲直接引用。\n3. 初始化：執行 `<clinit>` 方法。\n\n對象的創建過程依次是類加載檢查、分配內存、初始化零值、設置對象頭和執行`<init>` 方法。\n\n1. 類加載檢查：檢查類是否加載完畢。\n2. 分配內存：對象實例一般會分配在堆中，根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。JDK1.7之後啟用逃逸分析可以將未逃逸的對象分配到棧中。\n3. 初始化零值：給對象的成員變量設置初始的零值。\n4. 設置對象頭：對象頭包括所屬的類、對象哈希碼、GC分代年齡和鎖信息。\n5. 執行 `<init>` 方法。\n\nJava 是自動內存管理的，內存的分配和回收由JVM進行控制。通常使用分代內存管理，分新生代、老年代和永久代(JDK1.8及之後無永久代)，新對象優先在新生代 Eden 區分配，大對象直接分配到老年代，持續存活的對象也會被轉移到老年代。\n\n內存回收涉及垃圾的判定、垃圾收集算法和垃圾收集器。\n\n判定垃圾通常有引用計數法和可達性分析算法。\n\n垃圾收集(GC)通常分部分收集(Partial GC)和整堆收集(Full GC)，部分收集分新生代收集(Minor GC / Young GC)、老年代收集(Major GC / Old GC)和混合收集(Mixed GC)\n\n垃圾收集算法通常有標記-清除算法、複製算法、標記-整理算法和分代收集算法。\n\n垃圾收集器中 ParNew 最早採用並行收集，CMS 最早採用並發收集。JDK1.8 中默認使用 Parallel Scavenge(新生代) + Parallel Old(老年代) 收集器，JDK9之後默認使用 G1 收集器。\n\n<!-- more -->\n\n## 內存區域\n\n內存區域可以分爲：\n\n1. 線程共享：堆、方法區（邏輯上屬於堆）、直接內存(非運行時內存)\n2. 線程私有：程序計數器、虛擬機棧和本地方法棧\n\n### 堆(Heap)\n\n堆是進程中最大的一塊內存，用於存放對象實例，**幾乎所有**的對象實例都在堆中分配。\n\nJDK 1.7 開始默認開啟了逃逸分析，如果方法中的對象引用沒有逃逸出去（對象沒有 return 或被外面使用），那麼對象可以直接在棧上分配內存，而不是堆。\n\n一般來說，Java 中的堆根據對象實例的存活時長分爲**新生代、老年代和永久代，以便於更好地回收和分配內存**。\n\n![](java-jvm/Untitled.png)\n\n- Young Generation(新生代)\n    - Eden(伊甸園)：一般情況下，新創建的對象實例默認分配到此區域。\n    - Survivor(幸存者)：包含 from 和 to 兩個區，Survivor區的對象實例來自 Eden和另一個 Survivor區，默認情況下對象**至多**在新生代中來回複製**15次**(可通過參數`-XX:MaxTenuringThreshold`設置)後才會進入 Old Generation。\n- Old Generation(老年代)\n- Permanent Generation(永久代)：在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；JDK1.7 時字符串常量池從方法區(HotSpot永久代)移到了堆中；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\n### 方法區(Method Area)\n\n根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放已被虛擬機加載的類信息、常量、靜態變量、即時編譯器編譯後的代碼等數據的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(text segmemt/code segment)，通常只讀。\n\n在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\nUNIX 中的進程將內存劃分成三個部分：\n1. text segment,文本區，例如代碼\n2. data segment，數據區，例如變量\n3. stack segment，棧區域\n\n### 直接內存(Direct Memory)\n\n直接內存不是JVM 規範中定義的內存區域，不受Java堆的限制。\n\n1. JDK1.4 加入的 NIO，引入一種基於通道(Channel)和緩存區(Buffer)的 I/O 方式，可以直接使用 native 函數分配堆外內存。\n2. JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\n### 程序計數器(Program Counter)\n\n程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。\n\n因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。\n\n### 棧(Stack)\n\n棧有兩種：\n\n1. **虛擬機棧**：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態連接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。\n\n    所謂操作數棧就是一個供常量或變量寫入寫出的棧，出棧的方向可以是局部變量表或者直接返回給調用者。\n    所謂動態連接就是在運行時將方法的符號引用轉爲直接引用的過程。\n\n2. **本地方法棧**：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。\n\n爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。\n\n## 類的加載\n\n### 類的生命週期\n\n![](java-jvm/Untitled%201.png)\n\n**（1）加載**\n\n1. 將 .class 文件轉爲**二進制字節流**裝載進**類加載器**(ClassLoader)；\n2. 將其中代表的**靜態**存儲結構轉換爲**方法區**中的**運行時數據結構**；\n3. 在**內存**中生成一個 **Class 對象**，作爲方法區中數據的訪問入口。\n\n**（2）連接**\n\n連接階段分爲驗證、準備和解析三個步驟。該階段和加載階段不是順序執行的，存在交叉，即加載未完成時連接就開始了。\n\n1. 驗證：進行文件格式驗證、元數據驗證、字節碼驗證和符號引用驗證。\n2. 準備：爲**類變量**（靜態變量）分配內存並設置初始值（默認的零值，除非有 final 字段才會設置爲最終的初始值）。\n3. 解析：將常量池內的符號引用替換爲直接引用。\n\n**符號引用**：描述目標的一組符號（字面量），包括類、接口、字段、類方法、接口方法、方法類型、方法句柄和調用限定符。\n**直接引用**：直接指向目標的指針、相對偏移量或一個間接定位到目標的句柄。\n\n**（3）初始化**\n\n初始化階段是執行初始化方法 `<clinit>` 方法的過程。初始化的時機有：\n\n1. 直接 new 一個類會觸發類的初始化。\n2. 對類進行反射調用會自動初始化。\n3. 父類會在子類初始化時自動初始化。\n4. 主類（包含main方法）會隨虛擬機啟動自動初始化。\n5. Java 8 中的默認接口方法會在其實現類初始化時自動初始化。\n6. ...\n\n**（4）卸載**\n\n卸載就是該類的 Class 對象被 GC（垃圾回收）。卸載類需要滿足：\n\n1. 該類的所有實例對象都被 GC。\n2. 該類 Class 對象沒有其他任何地方被引用。\n3. 該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。\n\n### 類加載器(ClassLoader)\n\n自帶的類加載器有以下三種，分別加載不同路徑下的類：\n\n1. **BootstrapClassLoader(啟動類加載器)**：最頂層的加載類，負責加載 `%JAVA_HOME%/lib`目錄下的類或者或被 `-Xbootclasspath`參數指定的路徑中的所有類。\n2. **ExtensionClassLoader(擴展類加載器)**：繼承自`java.lang.ClassLoader`，負責加載 `%JRE_HOME%/lib/ext` 目錄下的類，或系統變量 `java.ext.dirs` 所指定的路徑下的類。\n3. **AppClassLoader(應用程序類加載器)**：繼承自`java.lang.ClassLoader`，記載當前應用 classpath 下的類。\n\nJVM 採用**雙親委派模型(parent-delegation model)**協調類加載器加載類。所謂雙親委派模型就是當一個類要加載時會委託其父類加載器進行加載，如果父類加載器已經加載過會直接返回；如果一直沒有父類加載器處理，會最終委託到頂層類加載器 **BootstrapClassLoader**；當所有**父系類加載器**都無法處理時才會自行加載。\n\n爲何要這樣麻煩，不一開始就自己加載類呢？**避免類被重複加載，避免 Java 核心類被修改**。注意：同一個類文件被不同的類加載器加載之後會生成不同的類。\n\n## 對象的創建\n\n### 對象的創建過程\n\n![](java-jvm/Untitled%202.png)\n\n在 HotSpot 虛擬機中，一個 Java 對象的創建經歷以下幾個步驟：\n\n1. **類加載檢查**。請看「類的加載」部分。\n2. **分配內存**。在堆中分配一塊內存空間供對象使用。有兩種分配方式：\n    - 指針碰撞：當內存規整時，使用和未使用的內存中間會有一個分界指針，只要指針朝未使用內存方法移動即可分配內存。\n    - 空閒列表：當內存不規整時，虛擬機會維護一個內存的可用列表，分配時會確定一塊大小合適的內存並更新可用列表。\n3. **初始化零值**。保證對象實例字段可以不用賦予初始值就可以使用。\n4. **設置對象頭**。對象的元數據，包括所屬的類、對象哈希碼、GC分代年齡以及鎖信息。\n5. **執行 `<init>` 方法**。代碼視角的對象初始化。\n\n比較`<clinit>` 和 `<init>`方法：\n1. `<clinit>` 方法：class init 類構造器，按順序執行父類靜態變量初始化、父類靜態語句塊、子類靜態變量初始化、子類靜態語句塊。\n2. `<init>` 方法：實例構造器，按順序執行父類變量初始化、父類語句塊、父類構造函數、子類變量初始化、子類語句塊、子類構造函數。\n\n### 對象的內存佈局\n\n在 Hotspot 虛擬機中，Java對象在內存中由以下部分組成：\n\n1. 對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。\n2. 實例數據（instance data）：對象的有效信息。\n3. 對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。\n\n### 對象的訪問\n\nJava 程序通過棧上的 reference 類型數據來操作訪問堆上的實例對象。具體來說有以下兩種實現方式：\n\n1. 句柄(handle)：操作對象的中間媒介，通過句柄獲取具體對象實例的指針，進而從實例池中獲取想要訪問的對象。\n\n    ![](java-jvm/Untitled%203.png)\n\n2. 直接指針(direct pointer)：reference 存儲對象地址，直接指向對象實例。HotSpot 虛擬機採用這種方式訪問對象，相對與句柄的方式，節約了一次定位對象的時間。\n\n    ![](java-jvm/Untitled%204.png)\n\n## 內存管理\n\nJava 是自動進行內存管理的，不同於 C/C++ 需要手動進行內存分配和回收。\n\n### 內存分配\n\n1. 對象優先在新生代 Eden 區分配。\n2. 大對象直接進入老年代。\n避免大對象**分配擔保機制**帶來的複製而降低效率。\n分配擔保機制：當進行 Minor GC 時，如果 Survivor 區空間不夠用，會直接將新生代的對象提前轉移到老年代中。\n3. 長期存活的對象將進入老年代。\n每個對象都有一個對象年齡計數器，超齡的對象一般會進入老年代。\n4. 根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。\n\n### 垃圾判定\n\n1. 引用計數法\n給對象添加一個引用計數器，當有一個地方引用了該對象，計數器就加 1，引用失效則減 1。若計數爲 0 則判定該對象是垃圾。這種算法有個大缺陷就是無法解決循環引用問題：當對象 A 和對象B除了互相引用外別無引用時，A 和B的計數都不爲0不會判定爲垃圾，但顯然 A、B是垃圾啊。\n2. 可達性分析算法\n以根集合 GC Roots 爲起點向下搜索形成引用鏈，當一個對象到 GC Roots沒有引用鏈時判定其爲垃圾。\n\n    ![](java-jvm/Untitled%205.png)\n\n    可作爲 GC Roots 的對象有:\n\n    - 虛擬機棧(棧幀中的本地變量表)中引用的對象\n    - 本地方法棧(Native 方法)中引用的對象\n    - 方法區中類靜態屬性引用的對象\n    - 方法區中常量引用的對象\n3. 廢棄常量的判定\n沒有對象引用的常量就是廢棄常量。\n4. 廢棄類的判定\n\n    廢棄類需要滿足：\n\n    - 該類的所有實例對象都被 GC。\n    - 該類 Class 對象沒有其他任何地方被引用。\n    - 該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。\n\n### 垃圾收集算法\n\n垃圾收集(Garbage Collection, GC)，指對判定爲垃圾的內存區域進行收集的過程。針對 HotSpot VM，GC 可分爲：\n\n1. 部分收集 (Partial GC)：\n    - 新生代收集（Minor GC / Young GC）：只對新生代進行垃圾收集，Eden 區和 From 區的數據會進入 To 區，然後 From 和To會互換角色。\n    - 老年代收集（Major GC / Old GC）：只對老年代進行垃圾收集。需要注意的是 Major GC 在有的語境中也用於指代整堆收集。\n    - 混合收集（Mixed GC）：對整個新生代和部分老年代進行垃圾收集。\n2. 整堆收集 (Full GC)：收集整個 Java 堆和方法區。\n\n常見的垃圾收集算法有：\n\n1. 標記-清除算法\n分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一清除垃圾。缺點是造成內存碎片化。\n\n    ![](java-jvm/Untitled%206.png)\n\n2. 複製算法\n將內存分爲大小相同的兩塊，每次只使用其中的一塊。當一塊使用完後，將存活的對象複製到另一塊去，再把使用完的空間一次清理掉，避免了標記-清除算法的內存碎片化問題。\n\n    ![](java-jvm/Untitled%207.png)\n\n3. 標記-整理算法(Mark-Compact)\n分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一將存活對象向一端移動，然後清理掉端邊界之外的內存。\n\n    ![](java-jvm/Untitled%208.png)\n\n4. 分代收集算法\n便於根據各個年代的特點選擇合適的垃圾收集算法：\n* 新生代(From Survivor 和 To Survivor)：複製算法\n* 老年代：標記-清除 或 標記-整理算法\n\n### 垃圾收集器\n\n1. 新生代收集器\n    1. Serial\n    單線程，採用複製算法，串行，收集垃圾時會暫停其他所有的工作線程。\n    2. ParNew (Parallel New)\n    Serial 的多線程版本，採用複製算法，**並行—多條垃圾收集線程並行工作，仍然會暫停其他所有的工作線程(Stop the World)**。\n    3. Parallel Scavenge\n    直譯過來就是「並行清理垃圾」，也採用複製算法，這是 JDK1.8 默認的收集器。該算法關注**吞吐量，即CPU中運行用戶代碼的時間與總消耗時間的比值**。\n2. 老年代收集器\n    1. Serial Old\n    Serial 的老年代版本，採用標記-整理算法。CMS 的後備方案。\n    2. Parallel Old\n    Parallel Scavenge 的老年代版本，採用標記-整理算法。\n    3. CMS (Concurrent Mark Sweep)\n    直譯過來就是「並發標記清除」，HotSpot 虛擬機第一款真正意義上的並發收集器，JDK1.5時發佈，採用標記-清除算法，**並發—用戶線程與垃圾收集線程同時執行（但不一定是並行的，可能會交替執行），用戶程序在繼續運行**。該算法關注**用戶線程的停頓時間**，綽號**并发低停顿收集器**（Concurrent Low Pause Collector）。缺點有三：\n        - 對 ****CPU 資源敏感；\n        - 無法處理浮動垃圾；\n        - 使用的「標記-清除」算法會導致內存碎片化。\n3. G1 (Garbage-First)\n\n    面向服務端應用的垃圾收集器，JDK1.7時發佈。特點是：並發與並行、分代收集、空間整合(標記-整理)和可預測的停頓。G1 收集器在後台維護了一個優先列表，每次根據允許的收集時間，優先選擇回收價值最大的區域。\n\n4. ZGC (The Z Garbage Collector)\n\n    JDK 11時發佈，適用於大內存低延遲服務的內存管理和回收。\n\n使用以下命令可以查看JDK使用的垃圾收集器：\n\n```bash\njava -XX:+PrintCommandLineFlags\njava -XX:+PrintGCDetails\njava -Xlog:gc # 較新版本可用\n```\n\n不同 JDK 版本默認使用的垃圾收集器：\n\n- 1.8，Parallel Scavenge(新生代) + Parallel Old(老年代)\n\n    注意：PS 是「Parallel Scavenge」的簡寫，ParOld 是「Parallel Old」的簡寫。\n\n    ```bash\n    $ java -version\n    java version \"1.8.0_191\"\n    Java(TM) SE Runtime Environment (build 1.8.0_191-b12)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)\n\n    $ java -XX:+PrintCommandLineFlags\n    -XX:InitialHeapSize=266390080 -XX:MaxHeapSize=4262241280 -XX:+PrintCommandLineFlags \n    -XX:+UseCompressedClassPointers -XX:+UseCompressedOops \n    -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC\n\n    $ java -XX:+PrintGCDetails -version\n    Heap\n     \tPSYoungGen      total 76288K, used 2621K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)\n      \t\t\t\t\teden space 65536K, 4% used [0x000000076b500000,0x000000076b78f748,0x000000076f500000)\n      \t\t\t\t\tfrom space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)\n      \t\t\t\t\tto   space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)\n    \tParOldGen       total 175104K, used 0K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)\n      \t\t\t\t\tobject space 175104K, 0% used [0x00000006c1e00000,0x00000006c1e00000,0x00000006cc900000)\n     \tMetaspace       used 2291K, capacity 4480K, committed 4480K, reserved 1056768K\n      \t\t\t\t\tclass space    used 254K, capacity 384K, committed 384K, reserved 1048576K\n    ```\n\n- 9、11、15，G1\n\n    ```bash\n    $ java -version\n    java version \"15.0.1\" 2020-10-20\n    Java(TM) SE Runtime Environment (build 15.0.1+9-18)\n    Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18, mixed mode, sharing)\n\n    $ java -XX:+PrintCommandLineFlags\n    -XX:ConcGCThreads=1 -XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC\n\n    $ java -Xlog:gc\n    [0.006s][info][gc] Using G1\n    ```","source":"_posts/it/java/java-jvm.md","raw":"---\ntitle: JVM\np: it/java/java-jvm.md\ndate: 2020-11-18 11:37:00\ntags:\n- Java\n---\n\nJVM(Java Virtual Machine)，即 Java 虛擬機，是操作系統上的一個程序，用於編譯、運行Java程序，使得 Java程序可以跨平台。關於 JVM 我們著重在內存區域、類的加載、對象的創建和內存管理四個部分。\n\n內存區域分爲堆、方法區、程序計數器、虛擬機棧和本地方法棧。其中堆和方法區是線程共享的，程序計數器、虛擬機棧和本地方法棧則是線程私有的。堆是一大塊內存，幾乎所有的對象實例都在這裡分配；方法區在JVM 規範中是堆的一部分，不同的 JVM 可以有不同的實現，就 HotSpot VM 而言，在 JDK1.8 之前使用永久代實現方法區，在JDK1.8及之後使用直接內存上的元空間實現；程序計數器存放下一條指令的地址；虛擬機棧的每一個棧幀保存著方法的局部變量表、操作數棧、動態連接和方法返回地址；本地方法棧類似虛擬機棧，不過是調用 native 方法，在 HotSpot VM中虛擬機棧和本地方法棧合而爲一。\n\n類的生命週期分爲加載、連接、初始化、使用和卸載四個過程，其中：\n\n1. 加載：將 .class 文件以二進制字節流方式讀入虛擬機，並在方法區給靜態變量分配空間，在堆中生成 Class 對象作爲訪問靜態變量的入口。\n2. 連接：分爲驗證、準備和解析三個階段，驗證階段驗證字節碼文件的合規性，準備階段將類變量賦予初始零值，解析階段將常量池中的符號引用轉爲直接引用。\n3. 初始化：執行 `<clinit>` 方法。\n\n對象的創建過程依次是類加載檢查、分配內存、初始化零值、設置對象頭和執行`<init>` 方法。\n\n1. 類加載檢查：檢查類是否加載完畢。\n2. 分配內存：對象實例一般會分配在堆中，根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。JDK1.7之後啟用逃逸分析可以將未逃逸的對象分配到棧中。\n3. 初始化零值：給對象的成員變量設置初始的零值。\n4. 設置對象頭：對象頭包括所屬的類、對象哈希碼、GC分代年齡和鎖信息。\n5. 執行 `<init>` 方法。\n\nJava 是自動內存管理的，內存的分配和回收由JVM進行控制。通常使用分代內存管理，分新生代、老年代和永久代(JDK1.8及之後無永久代)，新對象優先在新生代 Eden 區分配，大對象直接分配到老年代，持續存活的對象也會被轉移到老年代。\n\n內存回收涉及垃圾的判定、垃圾收集算法和垃圾收集器。\n\n判定垃圾通常有引用計數法和可達性分析算法。\n\n垃圾收集(GC)通常分部分收集(Partial GC)和整堆收集(Full GC)，部分收集分新生代收集(Minor GC / Young GC)、老年代收集(Major GC / Old GC)和混合收集(Mixed GC)\n\n垃圾收集算法通常有標記-清除算法、複製算法、標記-整理算法和分代收集算法。\n\n垃圾收集器中 ParNew 最早採用並行收集，CMS 最早採用並發收集。JDK1.8 中默認使用 Parallel Scavenge(新生代) + Parallel Old(老年代) 收集器，JDK9之後默認使用 G1 收集器。\n\n<!-- more -->\n\n## 內存區域\n\n內存區域可以分爲：\n\n1. 線程共享：堆、方法區（邏輯上屬於堆）、直接內存(非運行時內存)\n2. 線程私有：程序計數器、虛擬機棧和本地方法棧\n\n### 堆(Heap)\n\n堆是進程中最大的一塊內存，用於存放對象實例，**幾乎所有**的對象實例都在堆中分配。\n\nJDK 1.7 開始默認開啟了逃逸分析，如果方法中的對象引用沒有逃逸出去（對象沒有 return 或被外面使用），那麼對象可以直接在棧上分配內存，而不是堆。\n\n一般來說，Java 中的堆根據對象實例的存活時長分爲**新生代、老年代和永久代，以便於更好地回收和分配內存**。\n\n![](java-jvm/Untitled.png)\n\n- Young Generation(新生代)\n    - Eden(伊甸園)：一般情況下，新創建的對象實例默認分配到此區域。\n    - Survivor(幸存者)：包含 from 和 to 兩個區，Survivor區的對象實例來自 Eden和另一個 Survivor區，默認情況下對象**至多**在新生代中來回複製**15次**(可通過參數`-XX:MaxTenuringThreshold`設置)後才會進入 Old Generation。\n- Old Generation(老年代)\n- Permanent Generation(永久代)：在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；JDK1.7 時字符串常量池從方法區(HotSpot永久代)移到了堆中；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\n### 方法區(Method Area)\n\n根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放已被虛擬機加載的類信息、常量、靜態變量、即時編譯器編譯後的代碼等數據的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(text segmemt/code segment)，通常只讀。\n\n在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\nUNIX 中的進程將內存劃分成三個部分：\n1. text segment,文本區，例如代碼\n2. data segment，數據區，例如變量\n3. stack segment，棧區域\n\n### 直接內存(Direct Memory)\n\n直接內存不是JVM 規範中定義的內存區域，不受Java堆的限制。\n\n1. JDK1.4 加入的 NIO，引入一種基於通道(Channel)和緩存區(Buffer)的 I/O 方式，可以直接使用 native 函數分配堆外內存。\n2. JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\n### 程序計數器(Program Counter)\n\n程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。\n\n因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。\n\n### 棧(Stack)\n\n棧有兩種：\n\n1. **虛擬機棧**：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態連接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。\n\n    所謂操作數棧就是一個供常量或變量寫入寫出的棧，出棧的方向可以是局部變量表或者直接返回給調用者。\n    所謂動態連接就是在運行時將方法的符號引用轉爲直接引用的過程。\n\n2. **本地方法棧**：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。\n\n爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。\n\n## 類的加載\n\n### 類的生命週期\n\n![](java-jvm/Untitled%201.png)\n\n**（1）加載**\n\n1. 將 .class 文件轉爲**二進制字節流**裝載進**類加載器**(ClassLoader)；\n2. 將其中代表的**靜態**存儲結構轉換爲**方法區**中的**運行時數據結構**；\n3. 在**內存**中生成一個 **Class 對象**，作爲方法區中數據的訪問入口。\n\n**（2）連接**\n\n連接階段分爲驗證、準備和解析三個步驟。該階段和加載階段不是順序執行的，存在交叉，即加載未完成時連接就開始了。\n\n1. 驗證：進行文件格式驗證、元數據驗證、字節碼驗證和符號引用驗證。\n2. 準備：爲**類變量**（靜態變量）分配內存並設置初始值（默認的零值，除非有 final 字段才會設置爲最終的初始值）。\n3. 解析：將常量池內的符號引用替換爲直接引用。\n\n**符號引用**：描述目標的一組符號（字面量），包括類、接口、字段、類方法、接口方法、方法類型、方法句柄和調用限定符。\n**直接引用**：直接指向目標的指針、相對偏移量或一個間接定位到目標的句柄。\n\n**（3）初始化**\n\n初始化階段是執行初始化方法 `<clinit>` 方法的過程。初始化的時機有：\n\n1. 直接 new 一個類會觸發類的初始化。\n2. 對類進行反射調用會自動初始化。\n3. 父類會在子類初始化時自動初始化。\n4. 主類（包含main方法）會隨虛擬機啟動自動初始化。\n5. Java 8 中的默認接口方法會在其實現類初始化時自動初始化。\n6. ...\n\n**（4）卸載**\n\n卸載就是該類的 Class 對象被 GC（垃圾回收）。卸載類需要滿足：\n\n1. 該類的所有實例對象都被 GC。\n2. 該類 Class 對象沒有其他任何地方被引用。\n3. 該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。\n\n### 類加載器(ClassLoader)\n\n自帶的類加載器有以下三種，分別加載不同路徑下的類：\n\n1. **BootstrapClassLoader(啟動類加載器)**：最頂層的加載類，負責加載 `%JAVA_HOME%/lib`目錄下的類或者或被 `-Xbootclasspath`參數指定的路徑中的所有類。\n2. **ExtensionClassLoader(擴展類加載器)**：繼承自`java.lang.ClassLoader`，負責加載 `%JRE_HOME%/lib/ext` 目錄下的類，或系統變量 `java.ext.dirs` 所指定的路徑下的類。\n3. **AppClassLoader(應用程序類加載器)**：繼承自`java.lang.ClassLoader`，記載當前應用 classpath 下的類。\n\nJVM 採用**雙親委派模型(parent-delegation model)**協調類加載器加載類。所謂雙親委派模型就是當一個類要加載時會委託其父類加載器進行加載，如果父類加載器已經加載過會直接返回；如果一直沒有父類加載器處理，會最終委託到頂層類加載器 **BootstrapClassLoader**；當所有**父系類加載器**都無法處理時才會自行加載。\n\n爲何要這樣麻煩，不一開始就自己加載類呢？**避免類被重複加載，避免 Java 核心類被修改**。注意：同一個類文件被不同的類加載器加載之後會生成不同的類。\n\n## 對象的創建\n\n### 對象的創建過程\n\n![](java-jvm/Untitled%202.png)\n\n在 HotSpot 虛擬機中，一個 Java 對象的創建經歷以下幾個步驟：\n\n1. **類加載檢查**。請看「類的加載」部分。\n2. **分配內存**。在堆中分配一塊內存空間供對象使用。有兩種分配方式：\n    - 指針碰撞：當內存規整時，使用和未使用的內存中間會有一個分界指針，只要指針朝未使用內存方法移動即可分配內存。\n    - 空閒列表：當內存不規整時，虛擬機會維護一個內存的可用列表，分配時會確定一塊大小合適的內存並更新可用列表。\n3. **初始化零值**。保證對象實例字段可以不用賦予初始值就可以使用。\n4. **設置對象頭**。對象的元數據，包括所屬的類、對象哈希碼、GC分代年齡以及鎖信息。\n5. **執行 `<init>` 方法**。代碼視角的對象初始化。\n\n比較`<clinit>` 和 `<init>`方法：\n1. `<clinit>` 方法：class init 類構造器，按順序執行父類靜態變量初始化、父類靜態語句塊、子類靜態變量初始化、子類靜態語句塊。\n2. `<init>` 方法：實例構造器，按順序執行父類變量初始化、父類語句塊、父類構造函數、子類變量初始化、子類語句塊、子類構造函數。\n\n### 對象的內存佈局\n\n在 Hotspot 虛擬機中，Java對象在內存中由以下部分組成：\n\n1. 對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。\n2. 實例數據（instance data）：對象的有效信息。\n3. 對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。\n\n### 對象的訪問\n\nJava 程序通過棧上的 reference 類型數據來操作訪問堆上的實例對象。具體來說有以下兩種實現方式：\n\n1. 句柄(handle)：操作對象的中間媒介，通過句柄獲取具體對象實例的指針，進而從實例池中獲取想要訪問的對象。\n\n    ![](java-jvm/Untitled%203.png)\n\n2. 直接指針(direct pointer)：reference 存儲對象地址，直接指向對象實例。HotSpot 虛擬機採用這種方式訪問對象，相對與句柄的方式，節約了一次定位對象的時間。\n\n    ![](java-jvm/Untitled%204.png)\n\n## 內存管理\n\nJava 是自動進行內存管理的，不同於 C/C++ 需要手動進行內存分配和回收。\n\n### 內存分配\n\n1. 對象優先在新生代 Eden 區分配。\n2. 大對象直接進入老年代。\n避免大對象**分配擔保機制**帶來的複製而降低效率。\n分配擔保機制：當進行 Minor GC 時，如果 Survivor 區空間不夠用，會直接將新生代的對象提前轉移到老年代中。\n3. 長期存活的對象將進入老年代。\n每個對象都有一個對象年齡計數器，超齡的對象一般會進入老年代。\n4. 根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。\n\n### 垃圾判定\n\n1. 引用計數法\n給對象添加一個引用計數器，當有一個地方引用了該對象，計數器就加 1，引用失效則減 1。若計數爲 0 則判定該對象是垃圾。這種算法有個大缺陷就是無法解決循環引用問題：當對象 A 和對象B除了互相引用外別無引用時，A 和B的計數都不爲0不會判定爲垃圾，但顯然 A、B是垃圾啊。\n2. 可達性分析算法\n以根集合 GC Roots 爲起點向下搜索形成引用鏈，當一個對象到 GC Roots沒有引用鏈時判定其爲垃圾。\n\n    ![](java-jvm/Untitled%205.png)\n\n    可作爲 GC Roots 的對象有:\n\n    - 虛擬機棧(棧幀中的本地變量表)中引用的對象\n    - 本地方法棧(Native 方法)中引用的對象\n    - 方法區中類靜態屬性引用的對象\n    - 方法區中常量引用的對象\n3. 廢棄常量的判定\n沒有對象引用的常量就是廢棄常量。\n4. 廢棄類的判定\n\n    廢棄類需要滿足：\n\n    - 該類的所有實例對象都被 GC。\n    - 該類 Class 對象沒有其他任何地方被引用。\n    - 該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。\n\n### 垃圾收集算法\n\n垃圾收集(Garbage Collection, GC)，指對判定爲垃圾的內存區域進行收集的過程。針對 HotSpot VM，GC 可分爲：\n\n1. 部分收集 (Partial GC)：\n    - 新生代收集（Minor GC / Young GC）：只對新生代進行垃圾收集，Eden 區和 From 區的數據會進入 To 區，然後 From 和To會互換角色。\n    - 老年代收集（Major GC / Old GC）：只對老年代進行垃圾收集。需要注意的是 Major GC 在有的語境中也用於指代整堆收集。\n    - 混合收集（Mixed GC）：對整個新生代和部分老年代進行垃圾收集。\n2. 整堆收集 (Full GC)：收集整個 Java 堆和方法區。\n\n常見的垃圾收集算法有：\n\n1. 標記-清除算法\n分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一清除垃圾。缺點是造成內存碎片化。\n\n    ![](java-jvm/Untitled%206.png)\n\n2. 複製算法\n將內存分爲大小相同的兩塊，每次只使用其中的一塊。當一塊使用完後，將存活的對象複製到另一塊去，再把使用完的空間一次清理掉，避免了標記-清除算法的內存碎片化問題。\n\n    ![](java-jvm/Untitled%207.png)\n\n3. 標記-整理算法(Mark-Compact)\n分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一將存活對象向一端移動，然後清理掉端邊界之外的內存。\n\n    ![](java-jvm/Untitled%208.png)\n\n4. 分代收集算法\n便於根據各個年代的特點選擇合適的垃圾收集算法：\n* 新生代(From Survivor 和 To Survivor)：複製算法\n* 老年代：標記-清除 或 標記-整理算法\n\n### 垃圾收集器\n\n1. 新生代收集器\n    1. Serial\n    單線程，採用複製算法，串行，收集垃圾時會暫停其他所有的工作線程。\n    2. ParNew (Parallel New)\n    Serial 的多線程版本，採用複製算法，**並行—多條垃圾收集線程並行工作，仍然會暫停其他所有的工作線程(Stop the World)**。\n    3. Parallel Scavenge\n    直譯過來就是「並行清理垃圾」，也採用複製算法，這是 JDK1.8 默認的收集器。該算法關注**吞吐量，即CPU中運行用戶代碼的時間與總消耗時間的比值**。\n2. 老年代收集器\n    1. Serial Old\n    Serial 的老年代版本，採用標記-整理算法。CMS 的後備方案。\n    2. Parallel Old\n    Parallel Scavenge 的老年代版本，採用標記-整理算法。\n    3. CMS (Concurrent Mark Sweep)\n    直譯過來就是「並發標記清除」，HotSpot 虛擬機第一款真正意義上的並發收集器，JDK1.5時發佈，採用標記-清除算法，**並發—用戶線程與垃圾收集線程同時執行（但不一定是並行的，可能會交替執行），用戶程序在繼續運行**。該算法關注**用戶線程的停頓時間**，綽號**并发低停顿收集器**（Concurrent Low Pause Collector）。缺點有三：\n        - 對 ****CPU 資源敏感；\n        - 無法處理浮動垃圾；\n        - 使用的「標記-清除」算法會導致內存碎片化。\n3. G1 (Garbage-First)\n\n    面向服務端應用的垃圾收集器，JDK1.7時發佈。特點是：並發與並行、分代收集、空間整合(標記-整理)和可預測的停頓。G1 收集器在後台維護了一個優先列表，每次根據允許的收集時間，優先選擇回收價值最大的區域。\n\n4. ZGC (The Z Garbage Collector)\n\n    JDK 11時發佈，適用於大內存低延遲服務的內存管理和回收。\n\n使用以下命令可以查看JDK使用的垃圾收集器：\n\n```bash\njava -XX:+PrintCommandLineFlags\njava -XX:+PrintGCDetails\njava -Xlog:gc # 較新版本可用\n```\n\n不同 JDK 版本默認使用的垃圾收集器：\n\n- 1.8，Parallel Scavenge(新生代) + Parallel Old(老年代)\n\n    注意：PS 是「Parallel Scavenge」的簡寫，ParOld 是「Parallel Old」的簡寫。\n\n    ```bash\n    $ java -version\n    java version \"1.8.0_191\"\n    Java(TM) SE Runtime Environment (build 1.8.0_191-b12)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)\n\n    $ java -XX:+PrintCommandLineFlags\n    -XX:InitialHeapSize=266390080 -XX:MaxHeapSize=4262241280 -XX:+PrintCommandLineFlags \n    -XX:+UseCompressedClassPointers -XX:+UseCompressedOops \n    -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC\n\n    $ java -XX:+PrintGCDetails -version\n    Heap\n     \tPSYoungGen      total 76288K, used 2621K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)\n      \t\t\t\t\teden space 65536K, 4% used [0x000000076b500000,0x000000076b78f748,0x000000076f500000)\n      \t\t\t\t\tfrom space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)\n      \t\t\t\t\tto   space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)\n    \tParOldGen       total 175104K, used 0K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)\n      \t\t\t\t\tobject space 175104K, 0% used [0x00000006c1e00000,0x00000006c1e00000,0x00000006cc900000)\n     \tMetaspace       used 2291K, capacity 4480K, committed 4480K, reserved 1056768K\n      \t\t\t\t\tclass space    used 254K, capacity 384K, committed 384K, reserved 1048576K\n    ```\n\n- 9、11、15，G1\n\n    ```bash\n    $ java -version\n    java version \"15.0.1\" 2020-10-20\n    Java(TM) SE Runtime Environment (build 15.0.1+9-18)\n    Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18, mixed mode, sharing)\n\n    $ java -XX:+PrintCommandLineFlags\n    -XX:ConcGCThreads=1 -XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC\n\n    $ java -Xlog:gc\n    [0.006s][info][gc] Using G1\n    ```","slug":"it/java/java-jvm","published":1,"updated":"2021-09-13T14:15:36.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfq00341n9kg6j17eu9","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>JVM(Java Virtual Machine)，即 Java 虛擬機，是操作系統上的一個程序，用於編譯、運行Java程序，使得 Java程序可以跨平台。關於 JVM 我們著重在內存區域、類的加載、對象的創建和內存管理四個部分。</p>\n<p>內存區域分爲堆、方法區、程序計數器、虛擬機棧和本地方法棧。其中堆和方法區是線程共享的，程序計數器、虛擬機棧和本地方法棧則是線程私有的。堆是一大塊內存，幾乎所有的對象實例都在這裡分配；方法區在JVM 規範中是堆的一部分，不同的 JVM 可以有不同的實現，就 HotSpot VM 而言，在 JDK1.8 之前使用永久代實現方法區，在JDK1.8及之後使用直接內存上的元空間實現；程序計數器存放下一條指令的地址；虛擬機棧的每一個棧幀保存著方法的局部變量表、操作數棧、動態連接和方法返回地址；本地方法棧類似虛擬機棧，不過是調用 native 方法，在 HotSpot VM中虛擬機棧和本地方法棧合而爲一。</p>\n<p>類的生命週期分爲加載、連接、初始化、使用和卸載四個過程，其中：</p>\n<ol>\n<li>加載：將 .class 文件以二進制字節流方式讀入虛擬機，並在方法區給靜態變量分配空間，在堆中生成 Class 對象作爲訪問靜態變量的入口。</li>\n<li>連接：分爲驗證、準備和解析三個階段，驗證階段驗證字節碼文件的合規性，準備階段將類變量賦予初始零值，解析階段將常量池中的符號引用轉爲直接引用。</li>\n<li>初始化：執行 <code>&lt;clinit&gt;</code> 方法。</li>\n</ol>\n<p>對象的創建過程依次是類加載檢查、分配內存、初始化零值、設置對象頭和執行<code>&lt;init&gt;</code> 方法。</p>\n<ol>\n<li>類加載檢查：檢查類是否加載完畢。</li>\n<li>分配內存：對象實例一般會分配在堆中，根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。JDK1.7之後啟用逃逸分析可以將未逃逸的對象分配到棧中。</li>\n<li>初始化零值：給對象的成員變量設置初始的零值。</li>\n<li>設置對象頭：對象頭包括所屬的類、對象哈希碼、GC分代年齡和鎖信息。</li>\n<li>執行 <code>&lt;init&gt;</code> 方法。</li>\n</ol>\n<p>Java 是自動內存管理的，內存的分配和回收由JVM進行控制。通常使用分代內存管理，分新生代、老年代和永久代(JDK1.8及之後無永久代)，新對象優先在新生代 Eden 區分配，大對象直接分配到老年代，持續存活的對象也會被轉移到老年代。</p>\n<p>內存回收涉及垃圾的判定、垃圾收集算法和垃圾收集器。</p>\n<p>判定垃圾通常有引用計數法和可達性分析算法。</p>\n<p>垃圾收集(GC)通常分部分收集(Partial GC)和整堆收集(Full GC)，部分收集分新生代收集(Minor GC / Young GC)、老年代收集(Major GC / Old GC)和混合收集(Mixed GC)</p>\n<p>垃圾收集算法通常有標記-清除算法、複製算法、標記-整理算法和分代收集算法。</p>\n<p>垃圾收集器中 ParNew 最早採用並行收集，CMS 最早採用並發收集。JDK1.8 中默認使用 Parallel Scavenge(新生代) + Parallel Old(老年代) 收集器，JDK9之後默認使用 G1 收集器。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"內存區域\"><a href=\"#內存區域\" class=\"headerlink\" title=\"內存區域\"></a>內存區域</h2><p>內存區域可以分爲：</p>\n<ol>\n<li>線程共享：堆、方法區（邏輯上屬於堆）、直接內存(非運行時內存)</li>\n<li>線程私有：程序計數器、虛擬機棧和本地方法棧</li>\n</ol>\n<h3 id=\"堆-Heap\"><a href=\"#堆-Heap\" class=\"headerlink\" title=\"堆(Heap)\"></a>堆(Heap)</h3><p>堆是進程中最大的一塊內存，用於存放對象實例，<strong>幾乎所有</strong>的對象實例都在堆中分配。</p>\n<p>JDK 1.7 開始默認開啟了逃逸分析，如果方法中的對象引用沒有逃逸出去（對象沒有 return 或被外面使用），那麼對象可以直接在棧上分配內存，而不是堆。</p>\n<p>一般來說，Java 中的堆根據對象實例的存活時長分爲<strong>新生代、老年代和永久代，以便於更好地回收和分配內存</strong>。</p>\n<p><img src=\"/it/java/java-jvm/Untitled.png\" alt></p>\n<ul>\n<li>Young Generation(新生代)<ul>\n<li>Eden(伊甸園)：一般情況下，新創建的對象實例默認分配到此區域。</li>\n<li>Survivor(幸存者)：包含 from 和 to 兩個區，Survivor區的對象實例來自 Eden和另一個 Survivor區，默認情況下對象<strong>至多</strong>在新生代中來回複製<strong>15次</strong>(可通過參數<code>-XX:MaxTenuringThreshold</code>設置)後才會進入 Old Generation。</li>\n</ul>\n</li>\n<li>Old Generation(老年代)</li>\n<li>Permanent Generation(永久代)：在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；JDK1.7 時字符串常量池從方法區(HotSpot永久代)移到了堆中；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</li>\n</ul>\n<h3 id=\"方法區-Method-Area\"><a href=\"#方法區-Method-Area\" class=\"headerlink\" title=\"方法區(Method Area)\"></a>方法區(Method Area)</h3><p>根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放已被虛擬機加載的類信息、常量、靜態變量、即時編譯器編譯後的代碼等數據的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(text segmemt/code segment)，通常只讀。</p>\n<p>在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</p>\n<p>UNIX 中的進程將內存劃分成三個部分：</p>\n<ol>\n<li>text segment,文本區，例如代碼</li>\n<li>data segment，數據區，例如變量</li>\n<li>stack segment，棧區域</li>\n</ol>\n<h3 id=\"直接內存-Direct-Memory\"><a href=\"#直接內存-Direct-Memory\" class=\"headerlink\" title=\"直接內存(Direct Memory)\"></a>直接內存(Direct Memory)</h3><p>直接內存不是JVM 規範中定義的內存區域，不受Java堆的限制。</p>\n<ol>\n<li>JDK1.4 加入的 NIO，引入一種基於通道(Channel)和緩存區(Buffer)的 I/O 方式，可以直接使用 native 函數分配堆外內存。</li>\n<li>JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</li>\n</ol>\n<h3 id=\"程序計數器-Program-Counter\"><a href=\"#程序計數器-Program-Counter\" class=\"headerlink\" title=\"程序計數器(Program Counter)\"></a>程序計數器(Program Counter)</h3><p>程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。</p>\n<p>因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。</p>\n<h3 id=\"棧-Stack\"><a href=\"#棧-Stack\" class=\"headerlink\" title=\"棧(Stack)\"></a>棧(Stack)</h3><p>棧有兩種：</p>\n<ol>\n<li><p><strong>虛擬機棧</strong>：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態連接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。</p>\n<p> 所謂操作數棧就是一個供常量或變量寫入寫出的棧，出棧的方向可以是局部變量表或者直接返回給調用者。<br> 所謂動態連接就是在運行時將方法的符號引用轉爲直接引用的過程。</p>\n</li>\n<li><p><strong>本地方法棧</strong>：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。</p>\n</li>\n</ol>\n<p>爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。</p>\n<h2 id=\"類的加載\"><a href=\"#類的加載\" class=\"headerlink\" title=\"類的加載\"></a>類的加載</h2><h3 id=\"類的生命週期\"><a href=\"#類的生命週期\" class=\"headerlink\" title=\"類的生命週期\"></a>類的生命週期</h3><p><img src=\"/it/java/java-jvm/Untitled%201.png\" alt></p>\n<p><strong>（1）加載</strong></p>\n<ol>\n<li>將 .class 文件轉爲<strong>二進制字節流</strong>裝載進<strong>類加載器</strong>(ClassLoader)；</li>\n<li>將其中代表的<strong>靜態</strong>存儲結構轉換爲<strong>方法區</strong>中的<strong>運行時數據結構</strong>；</li>\n<li>在<strong>內存</strong>中生成一個 <strong>Class 對象</strong>，作爲方法區中數據的訪問入口。</li>\n</ol>\n<p><strong>（2）連接</strong></p>\n<p>連接階段分爲驗證、準備和解析三個步驟。該階段和加載階段不是順序執行的，存在交叉，即加載未完成時連接就開始了。</p>\n<ol>\n<li>驗證：進行文件格式驗證、元數據驗證、字節碼驗證和符號引用驗證。</li>\n<li>準備：爲<strong>類變量</strong>（靜態變量）分配內存並設置初始值（默認的零值，除非有 final 字段才會設置爲最終的初始值）。</li>\n<li>解析：將常量池內的符號引用替換爲直接引用。</li>\n</ol>\n<p><strong>符號引用</strong>：描述目標的一組符號（字面量），包括類、接口、字段、類方法、接口方法、方法類型、方法句柄和調用限定符。<br><strong>直接引用</strong>：直接指向目標的指針、相對偏移量或一個間接定位到目標的句柄。</p>\n<p><strong>（3）初始化</strong></p>\n<p>初始化階段是執行初始化方法 <code>&lt;clinit&gt;</code> 方法的過程。初始化的時機有：</p>\n<ol>\n<li>直接 new 一個類會觸發類的初始化。</li>\n<li>對類進行反射調用會自動初始化。</li>\n<li>父類會在子類初始化時自動初始化。</li>\n<li>主類（包含main方法）會隨虛擬機啟動自動初始化。</li>\n<li>Java 8 中的默認接口方法會在其實現類初始化時自動初始化。</li>\n<li>…</li>\n</ol>\n<p><strong>（4）卸載</strong></p>\n<p>卸載就是該類的 Class 對象被 GC（垃圾回收）。卸載類需要滿足：</p>\n<ol>\n<li>該類的所有實例對象都被 GC。</li>\n<li>該類 Class 對象沒有其他任何地方被引用。</li>\n<li>該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。</li>\n</ol>\n<h3 id=\"類加載器-ClassLoader\"><a href=\"#類加載器-ClassLoader\" class=\"headerlink\" title=\"類加載器(ClassLoader)\"></a>類加載器(ClassLoader)</h3><p>自帶的類加載器有以下三種，分別加載不同路徑下的類：</p>\n<ol>\n<li><strong>BootstrapClassLoader(啟動類加載器)</strong>：最頂層的加載類，負責加載 <code>%JAVA_HOME%/lib</code>目錄下的類或者或被 <code>-Xbootclasspath</code>參數指定的路徑中的所有類。</li>\n<li><strong>ExtensionClassLoader(擴展類加載器)</strong>：繼承自<code>java.lang.ClassLoader</code>，負責加載 <code>%JRE_HOME%/lib/ext</code> 目錄下的類，或系統變量 <code>java.ext.dirs</code> 所指定的路徑下的類。</li>\n<li><strong>AppClassLoader(應用程序類加載器)</strong>：繼承自<code>java.lang.ClassLoader</code>，記載當前應用 classpath 下的類。</li>\n</ol>\n<p>JVM 採用<strong>雙親委派模型(parent-delegation model)</strong>協調類加載器加載類。所謂雙親委派模型就是當一個類要加載時會委託其父類加載器進行加載，如果父類加載器已經加載過會直接返回；如果一直沒有父類加載器處理，會最終委託到頂層類加載器 <strong>BootstrapClassLoader</strong>；當所有<strong>父系類加載器</strong>都無法處理時才會自行加載。</p>\n<p>爲何要這樣麻煩，不一開始就自己加載類呢？<strong>避免類被重複加載，避免 Java 核心類被修改</strong>。注意：同一個類文件被不同的類加載器加載之後會生成不同的類。</p>\n<h2 id=\"對象的創建\"><a href=\"#對象的創建\" class=\"headerlink\" title=\"對象的創建\"></a>對象的創建</h2><h3 id=\"對象的創建過程\"><a href=\"#對象的創建過程\" class=\"headerlink\" title=\"對象的創建過程\"></a>對象的創建過程</h3><p><img src=\"/it/java/java-jvm/Untitled%202.png\" alt></p>\n<p>在 HotSpot 虛擬機中，一個 Java 對象的創建經歷以下幾個步驟：</p>\n<ol>\n<li><strong>類加載檢查</strong>。請看「類的加載」部分。</li>\n<li><strong>分配內存</strong>。在堆中分配一塊內存空間供對象使用。有兩種分配方式：<ul>\n<li>指針碰撞：當內存規整時，使用和未使用的內存中間會有一個分界指針，只要指針朝未使用內存方法移動即可分配內存。</li>\n<li>空閒列表：當內存不規整時，虛擬機會維護一個內存的可用列表，分配時會確定一塊大小合適的內存並更新可用列表。</li>\n</ul>\n</li>\n<li><strong>初始化零值</strong>。保證對象實例字段可以不用賦予初始值就可以使用。</li>\n<li><strong>設置對象頭</strong>。對象的元數據，包括所屬的類、對象哈希碼、GC分代年齡以及鎖信息。</li>\n<li><strong>執行 <code>&lt;init&gt;</code> 方法</strong>。代碼視角的對象初始化。</li>\n</ol>\n<p>比較<code>&lt;clinit&gt;</code> 和 <code>&lt;init&gt;</code>方法：</p>\n<ol>\n<li><code>&lt;clinit&gt;</code> 方法：class init 類構造器，按順序執行父類靜態變量初始化、父類靜態語句塊、子類靜態變量初始化、子類靜態語句塊。</li>\n<li><code>&lt;init&gt;</code> 方法：實例構造器，按順序執行父類變量初始化、父類語句塊、父類構造函數、子類變量初始化、子類語句塊、子類構造函數。</li>\n</ol>\n<h3 id=\"對象的內存佈局\"><a href=\"#對象的內存佈局\" class=\"headerlink\" title=\"對象的內存佈局\"></a>對象的內存佈局</h3><p>在 Hotspot 虛擬機中，Java對象在內存中由以下部分組成：</p>\n<ol>\n<li>對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。</li>\n<li>實例數據（instance data）：對象的有效信息。</li>\n<li>對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。</li>\n</ol>\n<h3 id=\"對象的訪問\"><a href=\"#對象的訪問\" class=\"headerlink\" title=\"對象的訪問\"></a>對象的訪問</h3><p>Java 程序通過棧上的 reference 類型數據來操作訪問堆上的實例對象。具體來說有以下兩種實現方式：</p>\n<ol>\n<li><p>句柄(handle)：操作對象的中間媒介，通過句柄獲取具體對象實例的指針，進而從實例池中獲取想要訪問的對象。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%203.png\" alt></p>\n</li>\n<li><p>直接指針(direct pointer)：reference 存儲對象地址，直接指向對象實例。HotSpot 虛擬機採用這種方式訪問對象，相對與句柄的方式，節約了一次定位對象的時間。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%204.png\" alt></p>\n</li>\n</ol>\n<h2 id=\"內存管理\"><a href=\"#內存管理\" class=\"headerlink\" title=\"內存管理\"></a>內存管理</h2><p>Java 是自動進行內存管理的，不同於 C/C++ 需要手動進行內存分配和回收。</p>\n<h3 id=\"內存分配\"><a href=\"#內存分配\" class=\"headerlink\" title=\"內存分配\"></a>內存分配</h3><ol>\n<li>對象優先在新生代 Eden 區分配。</li>\n<li>大對象直接進入老年代。<br>避免大對象<strong>分配擔保機制</strong>帶來的複製而降低效率。<br>分配擔保機制：當進行 Minor GC 時，如果 Survivor 區空間不夠用，會直接將新生代的對象提前轉移到老年代中。</li>\n<li>長期存活的對象將進入老年代。<br>每個對象都有一個對象年齡計數器，超齡的對象一般會進入老年代。</li>\n<li>根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。</li>\n</ol>\n<h3 id=\"垃圾判定\"><a href=\"#垃圾判定\" class=\"headerlink\" title=\"垃圾判定\"></a>垃圾判定</h3><ol>\n<li><p>引用計數法<br>給對象添加一個引用計數器，當有一個地方引用了該對象，計數器就加 1，引用失效則減 1。若計數爲 0 則判定該對象是垃圾。這種算法有個大缺陷就是無法解決循環引用問題：當對象 A 和對象B除了互相引用外別無引用時，A 和B的計數都不爲0不會判定爲垃圾，但顯然 A、B是垃圾啊。</p>\n</li>\n<li><p>可達性分析算法<br>以根集合 GC Roots 爲起點向下搜索形成引用鏈，當一個對象到 GC Roots沒有引用鏈時判定其爲垃圾。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%205.png\" alt></p>\n<p> 可作爲 GC Roots 的對象有:</p>\n<ul>\n<li>虛擬機棧(棧幀中的本地變量表)中引用的對象</li>\n<li>本地方法棧(Native 方法)中引用的對象</li>\n<li>方法區中類靜態屬性引用的對象</li>\n<li>方法區中常量引用的對象</li>\n</ul>\n</li>\n<li><p>廢棄常量的判定<br>沒有對象引用的常量就是廢棄常量。</p>\n</li>\n<li><p>廢棄類的判定</p>\n<p> 廢棄類需要滿足：</p>\n<ul>\n<li>該類的所有實例對象都被 GC。</li>\n<li>該類 Class 對象沒有其他任何地方被引用。</li>\n<li>該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><p>垃圾收集(Garbage Collection, GC)，指對判定爲垃圾的內存區域進行收集的過程。針對 HotSpot VM，GC 可分爲：</p>\n<ol>\n<li>部分收集 (Partial GC)：<ul>\n<li>新生代收集（Minor GC / Young GC）：只對新生代進行垃圾收集，Eden 區和 From 區的數據會進入 To 區，然後 From 和To會互換角色。</li>\n<li>老年代收集（Major GC / Old GC）：只對老年代進行垃圾收集。需要注意的是 Major GC 在有的語境中也用於指代整堆收集。</li>\n<li>混合收集（Mixed GC）：對整個新生代和部分老年代進行垃圾收集。</li>\n</ul>\n</li>\n<li>整堆收集 (Full GC)：收集整個 Java 堆和方法區。</li>\n</ol>\n<p>常見的垃圾收集算法有：</p>\n<ol>\n<li><p>標記-清除算法<br>分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一清除垃圾。缺點是造成內存碎片化。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%206.png\" alt></p>\n</li>\n<li><p>複製算法<br>將內存分爲大小相同的兩塊，每次只使用其中的一塊。當一塊使用完後，將存活的對象複製到另一塊去，再把使用完的空間一次清理掉，避免了標記-清除算法的內存碎片化問題。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%207.png\" alt></p>\n</li>\n<li><p>標記-整理算法(Mark-Compact)<br>分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一將存活對象向一端移動，然後清理掉端邊界之外的內存。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%208.png\" alt></p>\n</li>\n<li><p>分代收集算法<br>便於根據各個年代的特點選擇合適的垃圾收集算法：</p>\n</li>\n</ol>\n<ul>\n<li>新生代(From Survivor 和 To Survivor)：複製算法</li>\n<li>老年代：標記-清除 或 標記-整理算法</li>\n</ul>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><ol>\n<li><p>新生代收集器</p>\n<ol>\n<li>Serial<br>單線程，採用複製算法，串行，收集垃圾時會暫停其他所有的工作線程。</li>\n<li>ParNew (Parallel New)<br>Serial 的多線程版本，採用複製算法，<strong>並行—多條垃圾收集線程並行工作，仍然會暫停其他所有的工作線程(Stop the World)</strong>。</li>\n<li>Parallel Scavenge<br>直譯過來就是「並行清理垃圾」，也採用複製算法，這是 JDK1.8 默認的收集器。該算法關注<strong>吞吐量，即CPU中運行用戶代碼的時間與總消耗時間的比值</strong>。</li>\n</ol>\n</li>\n<li><p>老年代收集器</p>\n<ol>\n<li>Serial Old<br>Serial 的老年代版本，採用標記-整理算法。CMS 的後備方案。</li>\n<li>Parallel Old<br>Parallel Scavenge 的老年代版本，採用標記-整理算法。</li>\n<li>CMS (Concurrent Mark Sweep)<br>直譯過來就是「並發標記清除」，HotSpot 虛擬機第一款真正意義上的並發收集器，JDK1.5時發佈，採用標記-清除算法，<strong>並發—用戶線程與垃圾收集線程同時執行（但不一定是並行的，可能會交替執行），用戶程序在繼續運行</strong>。該算法關注<strong>用戶線程的停頓時間</strong>，綽號<strong>并发低停顿收集器</strong>（Concurrent Low Pause Collector）。缺點有三：<ul>\n<li>對 ****CPU 資源敏感；</li>\n<li>無法處理浮動垃圾；</li>\n<li>使用的「標記-清除」算法會導致內存碎片化。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>G1 (Garbage-First)</p>\n<p> 面向服務端應用的垃圾收集器，JDK1.7時發佈。特點是：並發與並行、分代收集、空間整合(標記-整理)和可預測的停頓。G1 收集器在後台維護了一個優先列表，每次根據允許的收集時間，優先選擇回收價值最大的區域。</p>\n</li>\n<li><p>ZGC (The Z Garbage Collector)</p>\n<p> JDK 11時發佈，適用於大內存低延遲服務的內存管理和回收。</p>\n</li>\n</ol>\n<p>使用以下命令可以查看JDK使用的垃圾收集器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">java -XX:+PrintGCDetails</span><br><span class=\"line\">java -Xlog:gc <span class=\"comment\"># 較新版本可用</span></span><br></pre></td></tr></table></figure>\n\n<p>不同 JDK 版本默認使用的垃圾收集器：</p>\n<ul>\n<li><p>1.8，Parallel Scavenge(新生代) + Parallel Old(老年代)</p>\n<p>  注意：PS 是「Parallel Scavenge」的簡寫，ParOld 是「Parallel Old」的簡寫。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br><span class=\"line\">java version <span class=\"string\">&quot;1.8.0_191&quot;</span></span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 1.8.0_191-b12)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">-XX:InitialHeapSize=266390080 -XX:MaxHeapSize=4262241280 -XX:+PrintCommandLineFlags </span><br><span class=\"line\">-XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class=\"line\">-XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintGCDetails -version</span><br><span class=\"line\">Heap</span><br><span class=\"line\"> \tPSYoungGen      total 76288K, used 2621K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)</span><br><span class=\"line\">  \t\t\t\t\teden space 65536K, 4% used [0x000000076b500000,0x000000076b78f748,0x000000076f500000)</span><br><span class=\"line\">  \t\t\t\t\tfrom space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)</span><br><span class=\"line\">  \t\t\t\t\tto   space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)</span><br><span class=\"line\">  ParOldGen       total 175104K, used 0K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)</span><br><span class=\"line\">  \t\t\t\t\tobject space 175104K, 0% used [0x00000006c1e00000,0x00000006c1e00000,0x00000006cc900000)</span><br><span class=\"line\"> \tMetaspace       used 2291K, capacity 4480K, committed 4480K, reserved 1056768K</span><br><span class=\"line\">  \t\t\t\t\tclass space    used 254K, capacity 384K, committed 384K, reserved 1048576K</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>9、11、15，G1</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br><span class=\"line\">java version <span class=\"string\">&quot;15.0.1&quot;</span> 2020-10-20</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 15.0.1+9-18)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18, mixed mode, sharing)</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">-XX:ConcGCThreads=1 -XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -Xlog:gc</span><br><span class=\"line\">[0.006s][info][gc] Using G1</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>JVM(Java Virtual Machine)，即 Java 虛擬機，是操作系統上的一個程序，用於編譯、運行Java程序，使得 Java程序可以跨平台。關於 JVM 我們著重在內存區域、類的加載、對象的創建和內存管理四個部分。</p>\n<p>內存區域分爲堆、方法區、程序計數器、虛擬機棧和本地方法棧。其中堆和方法區是線程共享的，程序計數器、虛擬機棧和本地方法棧則是線程私有的。堆是一大塊內存，幾乎所有的對象實例都在這裡分配；方法區在JVM 規範中是堆的一部分，不同的 JVM 可以有不同的實現，就 HotSpot VM 而言，在 JDK1.8 之前使用永久代實現方法區，在JDK1.8及之後使用直接內存上的元空間實現；程序計數器存放下一條指令的地址；虛擬機棧的每一個棧幀保存著方法的局部變量表、操作數棧、動態連接和方法返回地址；本地方法棧類似虛擬機棧，不過是調用 native 方法，在 HotSpot VM中虛擬機棧和本地方法棧合而爲一。</p>\n<p>類的生命週期分爲加載、連接、初始化、使用和卸載四個過程，其中：</p>\n<ol>\n<li>加載：將 .class 文件以二進制字節流方式讀入虛擬機，並在方法區給靜態變量分配空間，在堆中生成 Class 對象作爲訪問靜態變量的入口。</li>\n<li>連接：分爲驗證、準備和解析三個階段，驗證階段驗證字節碼文件的合規性，準備階段將類變量賦予初始零值，解析階段將常量池中的符號引用轉爲直接引用。</li>\n<li>初始化：執行 <code>&lt;clinit&gt;</code> 方法。</li>\n</ol>\n<p>對象的創建過程依次是類加載檢查、分配內存、初始化零值、設置對象頭和執行<code>&lt;init&gt;</code> 方法。</p>\n<ol>\n<li>類加載檢查：檢查類是否加載完畢。</li>\n<li>分配內存：對象實例一般會分配在堆中，根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。JDK1.7之後啟用逃逸分析可以將未逃逸的對象分配到棧中。</li>\n<li>初始化零值：給對象的成員變量設置初始的零值。</li>\n<li>設置對象頭：對象頭包括所屬的類、對象哈希碼、GC分代年齡和鎖信息。</li>\n<li>執行 <code>&lt;init&gt;</code> 方法。</li>\n</ol>\n<p>Java 是自動內存管理的，內存的分配和回收由JVM進行控制。通常使用分代內存管理，分新生代、老年代和永久代(JDK1.8及之後無永久代)，新對象優先在新生代 Eden 區分配，大對象直接分配到老年代，持續存活的對象也會被轉移到老年代。</p>\n<p>內存回收涉及垃圾的判定、垃圾收集算法和垃圾收集器。</p>\n<p>判定垃圾通常有引用計數法和可達性分析算法。</p>\n<p>垃圾收集(GC)通常分部分收集(Partial GC)和整堆收集(Full GC)，部分收集分新生代收集(Minor GC / Young GC)、老年代收集(Major GC / Old GC)和混合收集(Mixed GC)</p>\n<p>垃圾收集算法通常有標記-清除算法、複製算法、標記-整理算法和分代收集算法。</p>\n<p>垃圾收集器中 ParNew 最早採用並行收集，CMS 最早採用並發收集。JDK1.8 中默認使用 Parallel Scavenge(新生代) + Parallel Old(老年代) 收集器，JDK9之後默認使用 G1 收集器。</p>","more":"<h2 id=\"內存區域\"><a href=\"#內存區域\" class=\"headerlink\" title=\"內存區域\"></a>內存區域</h2><p>內存區域可以分爲：</p>\n<ol>\n<li>線程共享：堆、方法區（邏輯上屬於堆）、直接內存(非運行時內存)</li>\n<li>線程私有：程序計數器、虛擬機棧和本地方法棧</li>\n</ol>\n<h3 id=\"堆-Heap\"><a href=\"#堆-Heap\" class=\"headerlink\" title=\"堆(Heap)\"></a>堆(Heap)</h3><p>堆是進程中最大的一塊內存，用於存放對象實例，<strong>幾乎所有</strong>的對象實例都在堆中分配。</p>\n<p>JDK 1.7 開始默認開啟了逃逸分析，如果方法中的對象引用沒有逃逸出去（對象沒有 return 或被外面使用），那麼對象可以直接在棧上分配內存，而不是堆。</p>\n<p>一般來說，Java 中的堆根據對象實例的存活時長分爲<strong>新生代、老年代和永久代，以便於更好地回收和分配內存</strong>。</p>\n<p><img src=\"/it/java/java-jvm/Untitled.png\" alt></p>\n<ul>\n<li>Young Generation(新生代)<ul>\n<li>Eden(伊甸園)：一般情況下，新創建的對象實例默認分配到此區域。</li>\n<li>Survivor(幸存者)：包含 from 和 to 兩個區，Survivor區的對象實例來自 Eden和另一個 Survivor區，默認情況下對象<strong>至多</strong>在新生代中來回複製<strong>15次</strong>(可通過參數<code>-XX:MaxTenuringThreshold</code>設置)後才會進入 Old Generation。</li>\n</ul>\n</li>\n<li>Old Generation(老年代)</li>\n<li>Permanent Generation(永久代)：在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；JDK1.7 時字符串常量池從方法區(HotSpot永久代)移到了堆中；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</li>\n</ul>\n<h3 id=\"方法區-Method-Area\"><a href=\"#方法區-Method-Area\" class=\"headerlink\" title=\"方法區(Method Area)\"></a>方法區(Method Area)</h3><p>根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放已被虛擬機加載的類信息、常量、靜態變量、即時編譯器編譯後的代碼等數據的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(text segmemt/code segment)，通常只讀。</p>\n<p>在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</p>\n<p>UNIX 中的進程將內存劃分成三個部分：</p>\n<ol>\n<li>text segment,文本區，例如代碼</li>\n<li>data segment，數據區，例如變量</li>\n<li>stack segment，棧區域</li>\n</ol>\n<h3 id=\"直接內存-Direct-Memory\"><a href=\"#直接內存-Direct-Memory\" class=\"headerlink\" title=\"直接內存(Direct Memory)\"></a>直接內存(Direct Memory)</h3><p>直接內存不是JVM 規範中定義的內存區域，不受Java堆的限制。</p>\n<ol>\n<li>JDK1.4 加入的 NIO，引入一種基於通道(Channel)和緩存區(Buffer)的 I/O 方式，可以直接使用 native 函數分配堆外內存。</li>\n<li>JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</li>\n</ol>\n<h3 id=\"程序計數器-Program-Counter\"><a href=\"#程序計數器-Program-Counter\" class=\"headerlink\" title=\"程序計數器(Program Counter)\"></a>程序計數器(Program Counter)</h3><p>程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。</p>\n<p>因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。</p>\n<h3 id=\"棧-Stack\"><a href=\"#棧-Stack\" class=\"headerlink\" title=\"棧(Stack)\"></a>棧(Stack)</h3><p>棧有兩種：</p>\n<ol>\n<li><p><strong>虛擬機棧</strong>：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態連接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。</p>\n<p> 所謂操作數棧就是一個供常量或變量寫入寫出的棧，出棧的方向可以是局部變量表或者直接返回給調用者。<br> 所謂動態連接就是在運行時將方法的符號引用轉爲直接引用的過程。</p>\n</li>\n<li><p><strong>本地方法棧</strong>：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。</p>\n</li>\n</ol>\n<p>爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。</p>\n<h2 id=\"類的加載\"><a href=\"#類的加載\" class=\"headerlink\" title=\"類的加載\"></a>類的加載</h2><h3 id=\"類的生命週期\"><a href=\"#類的生命週期\" class=\"headerlink\" title=\"類的生命週期\"></a>類的生命週期</h3><p><img src=\"/it/java/java-jvm/Untitled%201.png\" alt></p>\n<p><strong>（1）加載</strong></p>\n<ol>\n<li>將 .class 文件轉爲<strong>二進制字節流</strong>裝載進<strong>類加載器</strong>(ClassLoader)；</li>\n<li>將其中代表的<strong>靜態</strong>存儲結構轉換爲<strong>方法區</strong>中的<strong>運行時數據結構</strong>；</li>\n<li>在<strong>內存</strong>中生成一個 <strong>Class 對象</strong>，作爲方法區中數據的訪問入口。</li>\n</ol>\n<p><strong>（2）連接</strong></p>\n<p>連接階段分爲驗證、準備和解析三個步驟。該階段和加載階段不是順序執行的，存在交叉，即加載未完成時連接就開始了。</p>\n<ol>\n<li>驗證：進行文件格式驗證、元數據驗證、字節碼驗證和符號引用驗證。</li>\n<li>準備：爲<strong>類變量</strong>（靜態變量）分配內存並設置初始值（默認的零值，除非有 final 字段才會設置爲最終的初始值）。</li>\n<li>解析：將常量池內的符號引用替換爲直接引用。</li>\n</ol>\n<p><strong>符號引用</strong>：描述目標的一組符號（字面量），包括類、接口、字段、類方法、接口方法、方法類型、方法句柄和調用限定符。<br><strong>直接引用</strong>：直接指向目標的指針、相對偏移量或一個間接定位到目標的句柄。</p>\n<p><strong>（3）初始化</strong></p>\n<p>初始化階段是執行初始化方法 <code>&lt;clinit&gt;</code> 方法的過程。初始化的時機有：</p>\n<ol>\n<li>直接 new 一個類會觸發類的初始化。</li>\n<li>對類進行反射調用會自動初始化。</li>\n<li>父類會在子類初始化時自動初始化。</li>\n<li>主類（包含main方法）會隨虛擬機啟動自動初始化。</li>\n<li>Java 8 中的默認接口方法會在其實現類初始化時自動初始化。</li>\n<li>…</li>\n</ol>\n<p><strong>（4）卸載</strong></p>\n<p>卸載就是該類的 Class 對象被 GC（垃圾回收）。卸載類需要滿足：</p>\n<ol>\n<li>該類的所有實例對象都被 GC。</li>\n<li>該類 Class 對象沒有其他任何地方被引用。</li>\n<li>該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。</li>\n</ol>\n<h3 id=\"類加載器-ClassLoader\"><a href=\"#類加載器-ClassLoader\" class=\"headerlink\" title=\"類加載器(ClassLoader)\"></a>類加載器(ClassLoader)</h3><p>自帶的類加載器有以下三種，分別加載不同路徑下的類：</p>\n<ol>\n<li><strong>BootstrapClassLoader(啟動類加載器)</strong>：最頂層的加載類，負責加載 <code>%JAVA_HOME%/lib</code>目錄下的類或者或被 <code>-Xbootclasspath</code>參數指定的路徑中的所有類。</li>\n<li><strong>ExtensionClassLoader(擴展類加載器)</strong>：繼承自<code>java.lang.ClassLoader</code>，負責加載 <code>%JRE_HOME%/lib/ext</code> 目錄下的類，或系統變量 <code>java.ext.dirs</code> 所指定的路徑下的類。</li>\n<li><strong>AppClassLoader(應用程序類加載器)</strong>：繼承自<code>java.lang.ClassLoader</code>，記載當前應用 classpath 下的類。</li>\n</ol>\n<p>JVM 採用<strong>雙親委派模型(parent-delegation model)</strong>協調類加載器加載類。所謂雙親委派模型就是當一個類要加載時會委託其父類加載器進行加載，如果父類加載器已經加載過會直接返回；如果一直沒有父類加載器處理，會最終委託到頂層類加載器 <strong>BootstrapClassLoader</strong>；當所有<strong>父系類加載器</strong>都無法處理時才會自行加載。</p>\n<p>爲何要這樣麻煩，不一開始就自己加載類呢？<strong>避免類被重複加載，避免 Java 核心類被修改</strong>。注意：同一個類文件被不同的類加載器加載之後會生成不同的類。</p>\n<h2 id=\"對象的創建\"><a href=\"#對象的創建\" class=\"headerlink\" title=\"對象的創建\"></a>對象的創建</h2><h3 id=\"對象的創建過程\"><a href=\"#對象的創建過程\" class=\"headerlink\" title=\"對象的創建過程\"></a>對象的創建過程</h3><p><img src=\"/it/java/java-jvm/Untitled%202.png\" alt></p>\n<p>在 HotSpot 虛擬機中，一個 Java 對象的創建經歷以下幾個步驟：</p>\n<ol>\n<li><strong>類加載檢查</strong>。請看「類的加載」部分。</li>\n<li><strong>分配內存</strong>。在堆中分配一塊內存空間供對象使用。有兩種分配方式：<ul>\n<li>指針碰撞：當內存規整時，使用和未使用的內存中間會有一個分界指針，只要指針朝未使用內存方法移動即可分配內存。</li>\n<li>空閒列表：當內存不規整時，虛擬機會維護一個內存的可用列表，分配時會確定一塊大小合適的內存並更新可用列表。</li>\n</ul>\n</li>\n<li><strong>初始化零值</strong>。保證對象實例字段可以不用賦予初始值就可以使用。</li>\n<li><strong>設置對象頭</strong>。對象的元數據，包括所屬的類、對象哈希碼、GC分代年齡以及鎖信息。</li>\n<li><strong>執行 <code>&lt;init&gt;</code> 方法</strong>。代碼視角的對象初始化。</li>\n</ol>\n<p>比較<code>&lt;clinit&gt;</code> 和 <code>&lt;init&gt;</code>方法：</p>\n<ol>\n<li><code>&lt;clinit&gt;</code> 方法：class init 類構造器，按順序執行父類靜態變量初始化、父類靜態語句塊、子類靜態變量初始化、子類靜態語句塊。</li>\n<li><code>&lt;init&gt;</code> 方法：實例構造器，按順序執行父類變量初始化、父類語句塊、父類構造函數、子類變量初始化、子類語句塊、子類構造函數。</li>\n</ol>\n<h3 id=\"對象的內存佈局\"><a href=\"#對象的內存佈局\" class=\"headerlink\" title=\"對象的內存佈局\"></a>對象的內存佈局</h3><p>在 Hotspot 虛擬機中，Java對象在內存中由以下部分組成：</p>\n<ol>\n<li>對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。</li>\n<li>實例數據（instance data）：對象的有效信息。</li>\n<li>對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。</li>\n</ol>\n<h3 id=\"對象的訪問\"><a href=\"#對象的訪問\" class=\"headerlink\" title=\"對象的訪問\"></a>對象的訪問</h3><p>Java 程序通過棧上的 reference 類型數據來操作訪問堆上的實例對象。具體來說有以下兩種實現方式：</p>\n<ol>\n<li><p>句柄(handle)：操作對象的中間媒介，通過句柄獲取具體對象實例的指針，進而從實例池中獲取想要訪問的對象。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%203.png\" alt></p>\n</li>\n<li><p>直接指針(direct pointer)：reference 存儲對象地址，直接指向對象實例。HotSpot 虛擬機採用這種方式訪問對象，相對與句柄的方式，節約了一次定位對象的時間。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%204.png\" alt></p>\n</li>\n</ol>\n<h2 id=\"內存管理\"><a href=\"#內存管理\" class=\"headerlink\" title=\"內存管理\"></a>內存管理</h2><p>Java 是自動進行內存管理的，不同於 C/C++ 需要手動進行內存分配和回收。</p>\n<h3 id=\"內存分配\"><a href=\"#內存分配\" class=\"headerlink\" title=\"內存分配\"></a>內存分配</h3><ol>\n<li>對象優先在新生代 Eden 區分配。</li>\n<li>大對象直接進入老年代。<br>避免大對象<strong>分配擔保機制</strong>帶來的複製而降低效率。<br>分配擔保機制：當進行 Minor GC 時，如果 Survivor 區空間不夠用，會直接將新生代的對象提前轉移到老年代中。</li>\n<li>長期存活的對象將進入老年代。<br>每個對象都有一個對象年齡計數器，超齡的對象一般會進入老年代。</li>\n<li>根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。</li>\n</ol>\n<h3 id=\"垃圾判定\"><a href=\"#垃圾判定\" class=\"headerlink\" title=\"垃圾判定\"></a>垃圾判定</h3><ol>\n<li><p>引用計數法<br>給對象添加一個引用計數器，當有一個地方引用了該對象，計數器就加 1，引用失效則減 1。若計數爲 0 則判定該對象是垃圾。這種算法有個大缺陷就是無法解決循環引用問題：當對象 A 和對象B除了互相引用外別無引用時，A 和B的計數都不爲0不會判定爲垃圾，但顯然 A、B是垃圾啊。</p>\n</li>\n<li><p>可達性分析算法<br>以根集合 GC Roots 爲起點向下搜索形成引用鏈，當一個對象到 GC Roots沒有引用鏈時判定其爲垃圾。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%205.png\" alt></p>\n<p> 可作爲 GC Roots 的對象有:</p>\n<ul>\n<li>虛擬機棧(棧幀中的本地變量表)中引用的對象</li>\n<li>本地方法棧(Native 方法)中引用的對象</li>\n<li>方法區中類靜態屬性引用的對象</li>\n<li>方法區中常量引用的對象</li>\n</ul>\n</li>\n<li><p>廢棄常量的判定<br>沒有對象引用的常量就是廢棄常量。</p>\n</li>\n<li><p>廢棄類的判定</p>\n<p> 廢棄類需要滿足：</p>\n<ul>\n<li>該類的所有實例對象都被 GC。</li>\n<li>該類 Class 對象沒有其他任何地方被引用。</li>\n<li>該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><p>垃圾收集(Garbage Collection, GC)，指對判定爲垃圾的內存區域進行收集的過程。針對 HotSpot VM，GC 可分爲：</p>\n<ol>\n<li>部分收集 (Partial GC)：<ul>\n<li>新生代收集（Minor GC / Young GC）：只對新生代進行垃圾收集，Eden 區和 From 區的數據會進入 To 區，然後 From 和To會互換角色。</li>\n<li>老年代收集（Major GC / Old GC）：只對老年代進行垃圾收集。需要注意的是 Major GC 在有的語境中也用於指代整堆收集。</li>\n<li>混合收集（Mixed GC）：對整個新生代和部分老年代進行垃圾收集。</li>\n</ul>\n</li>\n<li>整堆收集 (Full GC)：收集整個 Java 堆和方法區。</li>\n</ol>\n<p>常見的垃圾收集算法有：</p>\n<ol>\n<li><p>標記-清除算法<br>分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一清除垃圾。缺點是造成內存碎片化。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%206.png\" alt></p>\n</li>\n<li><p>複製算法<br>將內存分爲大小相同的兩塊，每次只使用其中的一塊。當一塊使用完後，將存活的對象複製到另一塊去，再把使用完的空間一次清理掉，避免了標記-清除算法的內存碎片化問題。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%207.png\" alt></p>\n</li>\n<li><p>標記-整理算法(Mark-Compact)<br>分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一將存活對象向一端移動，然後清理掉端邊界之外的內存。</p>\n<p> <img src=\"/it/java/java-jvm/Untitled%208.png\" alt></p>\n</li>\n<li><p>分代收集算法<br>便於根據各個年代的特點選擇合適的垃圾收集算法：</p>\n</li>\n</ol>\n<ul>\n<li>新生代(From Survivor 和 To Survivor)：複製算法</li>\n<li>老年代：標記-清除 或 標記-整理算法</li>\n</ul>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><ol>\n<li><p>新生代收集器</p>\n<ol>\n<li>Serial<br>單線程，採用複製算法，串行，收集垃圾時會暫停其他所有的工作線程。</li>\n<li>ParNew (Parallel New)<br>Serial 的多線程版本，採用複製算法，<strong>並行—多條垃圾收集線程並行工作，仍然會暫停其他所有的工作線程(Stop the World)</strong>。</li>\n<li>Parallel Scavenge<br>直譯過來就是「並行清理垃圾」，也採用複製算法，這是 JDK1.8 默認的收集器。該算法關注<strong>吞吐量，即CPU中運行用戶代碼的時間與總消耗時間的比值</strong>。</li>\n</ol>\n</li>\n<li><p>老年代收集器</p>\n<ol>\n<li>Serial Old<br>Serial 的老年代版本，採用標記-整理算法。CMS 的後備方案。</li>\n<li>Parallel Old<br>Parallel Scavenge 的老年代版本，採用標記-整理算法。</li>\n<li>CMS (Concurrent Mark Sweep)<br>直譯過來就是「並發標記清除」，HotSpot 虛擬機第一款真正意義上的並發收集器，JDK1.5時發佈，採用標記-清除算法，<strong>並發—用戶線程與垃圾收集線程同時執行（但不一定是並行的，可能會交替執行），用戶程序在繼續運行</strong>。該算法關注<strong>用戶線程的停頓時間</strong>，綽號<strong>并发低停顿收集器</strong>（Concurrent Low Pause Collector）。缺點有三：<ul>\n<li>對 ****CPU 資源敏感；</li>\n<li>無法處理浮動垃圾；</li>\n<li>使用的「標記-清除」算法會導致內存碎片化。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>G1 (Garbage-First)</p>\n<p> 面向服務端應用的垃圾收集器，JDK1.7時發佈。特點是：並發與並行、分代收集、空間整合(標記-整理)和可預測的停頓。G1 收集器在後台維護了一個優先列表，每次根據允許的收集時間，優先選擇回收價值最大的區域。</p>\n</li>\n<li><p>ZGC (The Z Garbage Collector)</p>\n<p> JDK 11時發佈，適用於大內存低延遲服務的內存管理和回收。</p>\n</li>\n</ol>\n<p>使用以下命令可以查看JDK使用的垃圾收集器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">java -XX:+PrintGCDetails</span><br><span class=\"line\">java -Xlog:gc <span class=\"comment\"># 較新版本可用</span></span><br></pre></td></tr></table></figure>\n\n<p>不同 JDK 版本默認使用的垃圾收集器：</p>\n<ul>\n<li><p>1.8，Parallel Scavenge(新生代) + Parallel Old(老年代)</p>\n<p>  注意：PS 是「Parallel Scavenge」的簡寫，ParOld 是「Parallel Old」的簡寫。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br><span class=\"line\">java version <span class=\"string\">&quot;1.8.0_191&quot;</span></span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 1.8.0_191-b12)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">-XX:InitialHeapSize=266390080 -XX:MaxHeapSize=4262241280 -XX:+PrintCommandLineFlags </span><br><span class=\"line\">-XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class=\"line\">-XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintGCDetails -version</span><br><span class=\"line\">Heap</span><br><span class=\"line\"> \tPSYoungGen      total 76288K, used 2621K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)</span><br><span class=\"line\">  \t\t\t\t\teden space 65536K, 4% used [0x000000076b500000,0x000000076b78f748,0x000000076f500000)</span><br><span class=\"line\">  \t\t\t\t\tfrom space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)</span><br><span class=\"line\">  \t\t\t\t\tto   space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)</span><br><span class=\"line\">  ParOldGen       total 175104K, used 0K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)</span><br><span class=\"line\">  \t\t\t\t\tobject space 175104K, 0% used [0x00000006c1e00000,0x00000006c1e00000,0x00000006cc900000)</span><br><span class=\"line\"> \tMetaspace       used 2291K, capacity 4480K, committed 4480K, reserved 1056768K</span><br><span class=\"line\">  \t\t\t\t\tclass space    used 254K, capacity 384K, committed 384K, reserved 1048576K</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>9、11、15，G1</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br><span class=\"line\">java version <span class=\"string\">&quot;15.0.1&quot;</span> 2020-10-20</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 15.0.1+9-18)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18, mixed mode, sharing)</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">-XX:ConcGCThreads=1 -XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -Xlog:gc</span><br><span class=\"line\">[0.006s][info][gc] Using G1</span><br></pre></td></tr></table></figure></li>\n</ul>"},{"title":"Go 基礎","p":"it/go/go-basic.md","date":"2020-11-24T03:39:00.000Z","_content":"\nGo 又稱 Golang，是 Google 公司 2009 年發佈的一款開源編程語言，以簡潔而高效的代碼著稱。Go 目前使用 GOPATH 或 Go modules 管理項目中的第三方依賴，且不支持循環依賴。\n\nGo 的基本數據類型有 16 種(不包含別名)，可謂豐富。要注意的是 string 也是基本數據類型，表示一個 UTF-8 字符串，底層是 byte 數組。單個字符使用一個 int32 的別名 rune 表示，其值爲 Unicode 字符碼點。\n\nGo 的變量使用 var 關鍵字聲明，也可以使用短變量聲明；常量則是使用 const 關鍵字聲明。\n\nGo 有 if 條件語句、for 循環語句、switch 選擇語句和 defer 延遲執行語句。Go 的 for 語句兼具其他語言的 while 語句；switch 語句每個 case 條件都支持運算，且默認自動 break；defer 語句可以立即計算參數值，然後在函數 return 前執行。\n\nGo 的可見性跟標識符的首字母是否大寫相關，大寫則是導出的，包外可見；小寫則是非導出的，包外不可見。\n\nGo 有指針，要注意 `&` 是生成指向操作數的指針，而 `*` 是獲取指針指向的底層值。\n\nGo 將一些字段組合成一個結構體(struct) 。結構體支持隱式間接調用，即 p.X 等價於 (*p).X（p 爲結構體指針）。\n\nGo 支持數組，更重要的是支持一種名爲切片(slice) 的動態數組。切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量。\n\nGo 支持映射(map)。\n\nGo 支持函數(function)的命名返回值、多值返回、作爲值傳遞和閉包。還有一種稱爲方法(method)的特殊函數，其帶有接收者參數，接收者可以是值接收者也可以是指針接收者，指針接收者可以更改接收者的值。\n\nGo 支持將一些方法簽名組成接口(interface)。接口的實現是隱式的，不需要「implements」。一個結構體作爲接收者定義了接口中的所有方法，那麼該結構體就是實現了該接口。因爲隱式的緣故，建議接口方法盡可能少，以便管理。接口是值，可以傳遞。底層值是 nil 的接口，其方法可以被調用；接口本身爲 nil ，則意味著其不保存值也不保存具體類型；空接口(interface{})是包含零個函數的接口，不是爲 nil 接口。\n\nGo 的異常處理很簡單，只有 Error，沒有 throws。\n\nGo 支持 Go 程，一種 Go運行時管理的輕量級線程。Go 程之間可以通過信道(channel) 通信，通過 Mutex 或 RWMutex 共享互斥變量，通過 WaitGroup 等待執行完成。 \n\nGo 中的信道還支持通過 for-range 循環讀取數據，當信道關閉時該循環自動退出。記住，只有發送方可以關閉信道，接收方不能。信道還支持 select 語句，其會**阻塞到某一分支可以執行爲止**，如沒有分支可以執行且設定了default 語句，會一直執行 default 語句。\n\n<!-- more -->\n\n以下內容多來自[《Go 指南》](https://tour.go-zh.org/)，內容有所改動。\n\n## 歷史\n\nGo 又稱 Golang，是 Google 公司開發的一款靜態強類型、編譯型、並發型，並具有垃圾回收功能的編程語言。\n\n1. 2007.9.21 罗伯特·格瑞史莫(Robert Griesemer)、罗勃·派克(Rob Pike)和肯·汤普逊(Ken Thompson) 開始設計 Go。\n2. 2009.11 Google 發佈 Go 語言。\n3. 2012.3 Go 1.0 發佈。\n4. 2018.8 Go 1.11 發佈，預支持 modules 進行依賴管理。\n\n## 入門\n\n### 安裝\n\n按照[官方教程](https://golang.org/doc/install)安裝即可。\n\n### Hello World\n\n直接在系統 Home 目錄，新建一一個 hello.go 文件，寫入代碼如下：\n\n```go\npackage main //程序從 main 包的 main 函數開始運行\nimport \"fmt\" //導入 fmt 包\n\nfunc main() { //main函數\n    fmt.Println(\"Hello, World!\") //打印日誌\n}\n```\n\n然後執行 `go run hello.go` 即可。\n\n### GOPATH\n\n當項目未啟用 Go modules 時，Go 使用 `GOPATH` 環境變量解析 import 語句。`GOPATH` 的值默認爲 `$HOME/go` ， `GOPATH` 目錄結構如下：\n\n```go\nGOPATH=/home/user/go\n\nsrc/\n    foo/\n        bar/               (go code in package bar)\n            x.go\n        quux/              (go code in package main)\n            y.go\nbin/\n    quux                   (installed command)\npkg/\n    linux_amd64/\n        foo/\n            bar.a          (installed package object)\n```\n\n- src：存放依賴的源代碼\n- bin：存放安裝的命令\n- pkg：存法安裝的包對象\n\n啟用 Go modules 後雖然不通過 `GOPATH` 解析 import 語句，但下載的源代碼和安裝的命令都會存在`GOPATH`目錄下。\n\n### Vendor\n\nVendor 就是使用本地依賴包的模式，Go 1.5 作爲實驗特性，Go 1.6 正式支持，Go 1.14 正式終結。命名爲 vender(小商販) 是一種比喻，並將 GOPATH 隱喻爲有固定地址的商舖。啟用 Vendor 模式很簡單，在項目中創建一個名爲 vendor 的文件夾然後拷貝依賴的源代碼進入其中即可。比如有如下的項目使用了 Vendor：\n\n```go\n$GOPATH\n|\tsrc/\n|\t|\tgithub.com/constabulary/example-gsftp/\n|\t|\t|\tcmd/\n|\t|\t|\t|\tgsftp/\n|\t|\t|\t|\t|\tmain.go\n|\t|\t|\tvendor/\n|\t|\t|\t|\tgithub.com/pkg/sftp/\n|\t|\t|\t|\tgolang.org/x/crypto/ssh/\n|\t|\t|\t|\t|\tagent/\n```\n\n在文件 `github.com/constabulary/example-gsftp/cmd/gsftp/main.go` 中應這樣 import 依賴（不需要加入 vendor 前綴）：\n\n```go\nimport (\n\t...\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/agent\"\n\t\"github.com/pkg/sftp\"\n)\n```\n\n這種方式顯然會帶來代碼膨脹，特別是N個庫同時用 Vendor 模式依賴一個通用庫時，那麼該通用庫的代碼將會出現N次。\n\n### Go modules\n\nGo 官方推出的依賴管理系統，在 Go 1.11 和 1.12中已經有初步支持，但默認關閉；從 1.13 開始默認啟用，1.14 開始可用於生產。\n\n**（1）使用 Go modules**\n\n使用 Go modules 很簡單，只需要在項目根路徑(不可以在 `$GOPATH/src` 裏面)執行 `go mod init example.com/m` 即可初始化一個名爲 `example.com/m` 的模塊，之後會在項目根路徑生成一個名爲 `go.mod` 的依賴文件，其內容結構如下：\n\n```go\nmodule example.com/hello //模塊名\n\ngo 1.12 //使用的 Go 版本\n\nrequire rsc.io/quote v1.5.2 //依賴項\n```\n\n此外，Go modules 還生成和維護著一個名爲 `go.sum` 的文件，該文件包含了期望的指定模塊版本的內容的加密哈希。\n\n爲保證依賴的一致性，需要同時將 `go.mod` 和 `go.sum` 加入版本管理。\n\n**（2）更新依賴**\n\n更新小版本很簡單，一個 `go get` 命令就完了。更新大版本比更新小版本複雜，因爲大版本通常會帶來 API 的變化，Go 要求更改大版本號後，模塊名也要加上版本號。例如原本是 `rsc.io/quote` 的依賴，升級到 v3 後依賴要改成 `rsc.io/quote/v3` ，因此代碼中的 import 語句要改成 `rsc.io/quote/v3` ，然後清理掉舊版本的依賴，有點麻煩。\n\n```bash\n# 列出當前項目的模塊和依賴項\ngo list -m all\n# 直接更新到最新的小版本\ngo get rsc.io/sampler\n# 列出所有小版本\ngo list -m -versions rsc.io/sampler\n# 更新到指定版本\ngo get rsc.io/sampler@v1.3.1\n\n# 查看模塊的所有版本\ngo list -m rsc.io/q...\n# 清除未使用的依賴\ngo mod tidy\n```\n\n### 循環依賴\n\nGo 不支持循環依賴，Go設計者Rob Pike認爲如果出現兩個包循環依賴，那麼是你的設計問題。\n\n筆者就出現過一次循環依賴，場景是：封裝了一個打印日誌的庫A和一個解析配置的庫B，庫A需要通過庫B配置，庫B需要用庫A打印日誌。最後選擇在庫B使用原始的日誌打印。\n\n## 語法\n\n### 數據類型\n\n**（1）基本類型**\n\n```go\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的別名\n    // 表示一個 Unicode 碼點\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\n其中 int, uint 和 uintptr 在 32 位系統上通常為 32 位寬，在 64 位系統上則為 64 位寬。\n\nstring 表示一個 UTF-8 類型的字符串，底層是一個字節數組。\n\nrune 表示一個 Unicode 碼點，是 int32 的別名。讀取 string 中的每個字符，只需要將 string 轉爲 rune 數組即可\n\nJava 中的 char 類型，每個字符對應一個 Unicode 碼點，可以表示BMP範圍內（即[U+0000, U+FFFF]之間）的Unicode字符。String 是 UTF-8 類型。\n\n**（2）零值**\n\n没有明确初始值的变量声明会被赋予它们的 **零值**。\n\n零值是：\n\n- 数值类型为 `0`，\n- 布尔类型为 `false`，\n- 字符串为 `\"\"`（空字符串）。\n\n**（3）類型轉換**\n\n數值之間可以通過表達式 T(v) 將值 v 轉換為類型 T，如：\n\n```go\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n**（4）类型推导**\n\n在聲明一個變量而不指定其類型時（即使用不帶類型的 := 語法或 var = 表達式語法），變量的類型由右值推導得出。\n\n```go\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n```\n\n### 變量\n\n**（1）聲明語句**\n\n```go\n// var 開頭，逗號(,)分割變量名，最後寫數據類型 \nvar c, python, java bool\n```\n\n**（2）賦值語句**\n\n```go\nvar c, python, java = true,false,\"no\"\n```\n\n或直接使用**短變量聲明**，注意短變量聲明只能在函數內使用，因爲函數外的每個語句要求必須以關鍵字開始。\n\n```go\nc, python, java := true,false,\"no\"\n```\n\n### 常量\n\n常量聲明使用 const 關鍵字。常量可以是字符、字符串、布尔值或数值。常量不能用 `:=` 语法声明。\n\n```go\nconst Pi = 3.14\n```\n\n`iota` 可以用來創建順序遞增的常量。\n\n```go\nconst (\n\tLow = iota //0\n\tMedium     //1\n\tHigh       //2\n)\n```\n\n### 風格\n\n1. 每行程序結束後不需要撰寫分號（;）。\n2. 大括號（{）不能夠換行放置。\n3. if判斷式和for循環不需要以小括號包覆起來。\n4. 使用 tab 做排版\n\n### 流程控制\n\n**（1）if-else**\n\n不需要小括號，可以使用簡短語句。\n\n```go\n_,ok := sendMsg();\nif ok {\n  // do something\n}else{\n  // do other thing\n}\n// 等價於以下簡短語句\nif _,ok := sendMsg(); ok {\n  // do something\n}else{\n  // do other thing\n}\n```\n\n**（2）for**\n\nGo 中的 for 語句，還包含了其他語言的 while 的功能。特別的不用括號包裹。\n\n```go\n// 功能：遍歷 10 次\nfor i:=0;i<10;i++{\n}\n// 功能：類似於其他語言 while 的功能\nvar i = 0\nfor i<10{\n}\n// 功能：無限循環，類似於其他語言中的 while(true)\nfor{\n}\n// 功能：for range 循環，返回當前元素的下標及副本\n// 可通過 _ 忽略其中的某個值\npow := []int{1, 2, 4, 8}\nfor i, v := range pow {\n\tfmt.Printf(\"%d,%d\\n\", i, v)\n}\nfor _,v := range pow {\n\tfmt.Printf(\"%d\\n\", v)\n}\nfor i := range pow {\n\tfmt.Printf(\"%d\\n\", i)\n}\n```\n\n**（3）switch**\n\nGo 中的 switch 語句是自動 break 的。如果不想要break，需要在 case 後面協商 fallthrough。\n\nGo 中的 switch 的 case 無需為常量，且取值不必為整數。\n\n```go\n// 功能：選擇顏色\nswitch color {\n    case Red:\n    // do something\n    case Green:\n    // do something\n    default:\n    // do something\n}\n// 功能：替代 if-then-else，更整齊\nresult := request()\nswitch {\n    case result > 0:\n    case result <0:\n    default:\n}\n// 或者\nswitch result := request(); {\n    case result > 0:\n    case result <0:\n    default:\n}\n```\n\n**（4）defer**\n\ndefer 語句會將函數推遲到外層函數返回之後執行。\n\n推遲調用的函數其參數會立即求值，但直到外層函數返回前該函數都不會被調用。\n\n推遲的函數調用會被壓入一個棧中。當外層函數返回時，被推遲的函數會按照後進先出的順序調用。\n\n```go\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n```\n\ndefer 並不是免費的。defer 底層會調用 `runtime.deferproc` 去設置要延遲調用的函數，調用 `runtime.deferreturn` 會依次執行先前延遲調用的函數。參考：https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32\n\n### 可見性\n\n- 導出：大寫字母開頭的標識符，包外可訪問。\n- 未導出：非大寫字母開頭的標識符，包外不可訪問。\n\n### 指針\n\nGo 擁有指針。指針保存了值的內存地址。\n\n- 類型 `*T` 是指向 `T` 類型值的指針。其零值為 `nil`。\n- `&` 操作符會**生成一個指向其操作數的指針**。（注意：把`&` 理解爲取地址符號是錯誤的）\n- `*` 操作符**表示指針指向的底層值**。（注意：把`*` 理解爲取值符號是錯誤的）\n\n```go\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := &i         // 指向 i\n\tfmt.Println(*p) // 通過指針讀取 i 的值\n\t*p = 21         // 通過指針設置 i 的值\n\tfmt.Println(i)  // 查看 i 的值\n\n\tp = &j         // 重定向到 j\n\t*p = *p / 37   // 通過指針對 j 進行除法運算\n\tfmt.Println(j) // 查看 j 的值\n}\n```\n\n### 結構體\n\n一個結構體（struct）就是一組字段（field）。外界使用點號來訪問結構體字段。\n\n結構體字段可以通過結構體指針來訪問。如果我們有一個指向結構體的指針 p，那麼可以通過 `(*p).X` 來訪問其字段 X。不過這麼寫太囉嗦了，所以語言也允許我們使用**隱式間接引用**，直接寫 `p.X` 就可以。\n\n```go\ntype Vertex struct {\n\tX, Y int\n}\n\nfunc main() {\n  v := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n  \n  p := &v\n\tp.X = 1e9\n\tfmt.Println(v)\n\n\tv2 = Vertex{X: 1}  // Y:0 被隱式地賦予\n\tv3 = Vertex{}      // X:0 Y:0\n\tp  = &Vertex{1, 2} // 創建一個 *Vertex 類型的結構體（指針）\n}\n```\n\n### 數組\n\n類型 [n]T 表示擁有 n 個 T 類型的值的數組。\n\n表达式\n\n```go\nvar a [10]int\n```\n\n會將變量 `a` 聲明為擁有 10 個整數的數組。\n\n### 切片\n\n**（1）定義**\n\n類型 []T 表示一個元素類型為 T 的切片。T 可以是任何類型，包括切片本身。\n\n切片通過兩個下標來界定，即一個上界和一個下界，二者以冒號分隔：\n\n```go\na[low : high]\n```\n\n它會選擇一個半開區間，包括第一個元素，但排除最後一個元素。\n\n切片下界的默認值爲 0，上界則是其底層數組的長度。\n\n對於數組 `var a [10]int` 來說，以下切片是等價的：\n\n```go\na[0:10]\na[:10]\na[0:]\na[:]\n```\n\n**（2）切片的本質**\n\n一個切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量，其結構如下：\n\n![](go-basic/Untitled.png)\n\n![](go-basic/Untitled%201.png)\n\n切片的長度就是它所包含的元素個數。\n切片的容量是從它的第一個元素開始數，到其底層數組元素末尾的個數。\n切片 s 的長度和容量可通過表達式 `len(s)` 和 `cap(s)` 來獲取。\n\n更改切片的元素會修改其底層數組中對應的元素。與它共享底層數組的切片都會觀測到這些修改。\n\n```go\nfunc main() {\n\tnames := [4]string{\n\t\t\"John\",\n\t\t\"Paul\",\n\t\t\"George\",\n\t\t\"Ringo\",\n\t}\n\tfmt.Println(names)\n\n\ta := names[0:2]\n\tb := names[1:3]\n\tfmt.Println(a, b)\n\n\tb[0] = \"XXX\"\n\tfmt.Println(a, b)\n\tfmt.Println(names)\n}\n```\n\n注意：切片的零值爲 nil，其長度和容量爲 0 且沒有底層數組。\n\n**（3）通過 make 創建切片**\n\n```go\na := make([]int, 5)  // len(a)=5\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n```\n\n**（4）通過 append 追加元素**\n\n```go\nfunc append(s []T, vs ...T) []T\n```\n\n`append` 的第一個參數 `s` 是一個元素類型為 `T` 的切片，其餘類型為 `T`的值將會追加到該切片的末尾。\n\n`append` 的結果是一個包含原切片所有元素加上新添加元素的切片。\n\n當 `s` 的底層數組太小，不足以容納所有給定的值時，它就會分配一個更大的數組。返回的切片會指向這個新分配的數組。\n\n當引用一個原始數組時，GC不會釋放該數組的空間，即使只用到其中一小部分數據。因此函數返回切片的時候要特別注意，最好拷貝需要數據到新的切片再返回。\n\n```go\n// 使用 copy 函數\nfunc CopyDigits(filename string) []byte {\n    b, _ := ioutil.ReadFile(filename)\n    b = digitRegexp.Find(b)\n    c := make([]byte, len(b))\n    copy(c, b)\n    return c\n}\n// 或使用 append 函數\nfunc CopyDigits(filename string) []byte {\n    b, _ := ioutil.ReadFile(filename)\n    b = digitRegexp.Find(b)\n    var c []byte\n    return append(c, b...)\n}\n```\n\n### 映射\n\n映射將鍵映射到值。\n\n映射的零值為 `nil` 。`nil` 映射既沒有鍵，也不能添加鍵。\n\n`make` 函數會返回給定類型的映射，並將其初始化備用。\n\n```go\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": {40.68433, -74.39967},\n\t\"Google\":    {37.42202, -122.08408},\n}\n```\n\n 常用操作：\n\n1. 插入或修改元素：`m[key] = elem`\n2. 獲取元素：`elem = m[key]`\n3. 通過雙賦值檢測某個鍵是否存在：`elem, ok := m[key]`\n4. 刪除元素：`delete(m, key)`\n\n### 函數(function)\n\n**（1）概述**\n\n函數可以沒有參數或接受多個參數。當連續兩個或多個函數的已命名形參類型相同時，除最後一個類型以外，其它都可以省略。\n\n```go\nfunc add(x, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n```\n\n**（2）命名返回值**\n\nGo 的返回值可被命名，它們會被視作**定義在函數頂部的變量**。返回值的名稱應當具有一定的意義，它可以作為文檔使用。沒有參數的 `return` 語句返回已命名的返回值。也就是 `直接` 返回。直接返回語句應當僅用在下面這樣的短函數中。在長的函數中它們會影響代碼的可讀性。\n\n```go\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(split(17))\n}\n```\n\n**（3）多值返回**\n\n函數可以返回任意數量的返回值。\n\n```go\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n```\n\n**（4）函數值**\n\n函數也是值，可以作爲函數的參數或返回值。\n\n```go\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\nfmt.Println(compute(math.Pow))\n```\n\n**（5）閉包(closure)**\n\n閉包是指一個函數引用了其函數體之外的變量，該函數可以訪問並賦予其引用的變量的值。換句話說就是該函數跟函數體之外的變量綑綁在一起了。每次調用閉包中的函數可以改變閉包中變量的值。例如斐波那契閉包：\n\n```go\nfunc fibonacci() func() int {\n\tx,y := 0,1\n\treturn func() int {\n\t\tres := x\n\t\tx,y = y,x+y\n\t\treturn res\n\t}\n}\n\nfunc main() {\n\tf := fibonacci()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(f())\n\t}\n}\n```\n\n### 方法(method)\n\n方法就是一類帶特殊的**接收者參數**的函數。方法接收者在它自己的參數列表內，**位於 func 關鍵字和方法名之間**。\n\n```go\ntype Vertex struct {\n\tX, Y float64\n}\n// 這就是方法\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n```\n\n值得注意的是：接收者的類型定義和方法聲明必須在同一包內；不能爲內建類型聲明方法。\n\n接收者除了是**值接收者**外，還支持**指針接收者**，使用 `*T` (不能是 `*int` 之類的) 的文法即可。指針接收者可以修改接收者指向的值。如下：\n\n```go\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(10) // 此時 Go 會解釋爲 (&v).Scale(10)，這就是指針重定向\n\tfmt.Println(v.Abs())\n}\n```\n\n使用指針接收者的好處：\n\n1. 方法能夠修改其接收者指向的值。\n2. 避免在每次調用方法時複製該值。該值佔用的空間越大，則越顯得高效。\n\n注意：一個結構體採用值接收者的方式實現了接口的方法，則隱含著採用指針接收者的方式實現了接口的方法。（接收者是指針類型的方法，很可能在方法中會對接收者的屬性進行更改操作，從而影響接收者；而對於接收者是值類型的方法，在方法中不會對接收者本身產生影響）\n\n### 接口\n\n**（1）定義**\n\n接口類型是**由一組方法簽名定義的集合**。接口類型的變量可以保存**任何**實現了這些方法的值。\n\n**（2）隱式實現**\n\n類型通過實現一個接口的所有方法來實現該接口。既然無需專門顯式聲明，也就沒有「implements」關鍵字。\n\n```go\ntype Animal interface {\n\teat()\n}\n\ntype John struct{}\n\nfunc (j *John) eat() {\n\tfmt.Println(\"eat...\")\n}\n\ntype Person interface {\n\teat()\n\ttalk()\n}\n\nfunc (j *John) talk() {\n\tfmt.Println(\"talk...\")\n}\n\nfunc main() {\n\tvar a Animal = &John{}\n\ta.eat()\n\tvar b Person = &John{}\n\tb.eat()\n\tb.talk()\n}\n```\n\n**（4）接口值**\n\n接口也是值，可以作爲函數的參數或返回值。在內部，接口值可以看做包含值和具體類型的元組：`(value, type)` 。接口值保存了一個具體底層類型的具體值。接口值調用方法時會執行其底層類型的同名方法。\n\n```go\n// Animal、John 見上面的代碼\nj := John{}\ndescribe(j)\n\nfunc describe(i Animal){\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n**（5）底層值爲 nil 的接口值**\n\n即便接口內的具體值為 nil，方法仍然會被 nil 接收者調用。\n\n```go\n// 改造上面的代碼\nfunc (j *John) talk() {\n\tif j == nil {\n\t\tfmt.Println(\"j is <nil>\")\n\t\treturn\n\t}\n\tfmt.Println(\"talk...\")\n}\n\nfunc main() {\n\tvar x Person\n\tvar y John\n\tx = &y\n\tdescribe(x)\n\tx.talk() // 正常調用\n}\n```\n\n判斷接口的底層值是否爲 nil 的方法：\n\n```go\n// 接上\nprintln( x == nil || reflect.ValueOf(x).IsNil())\n```\n\n**（6）nil 接口值**\n\nnil 接口值既不保存值也不保存具體類型。\n\n為 nil 接口調用方法會產生運行時錯誤，因為接口的元組內並未包含能夠指明該調用哪個 **具體** 方法的類型。\n\n```go\ntype I interface {\n\tM()\n}\n\nfunc main() {\n\tvar i I\n\tdescribe(i)\n\ti.M() // 此處拋出 panic: runtime error: invalid memory address or nil pointer dereference\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i) // (<nil>, <nil>)\n}\n```\n\n**（7）空接口**\n\n指定了**零個方法**的接口值被稱為空接口，即 `interface{}` 。空接口可保存任何類型的值。（因為每個類型都至少實現了零個方法。）空接口被用來處理未知類型的值。例如，`fmt.Print` 可接受類型為 `interface{}` 的任意數量的參數。\n\n```go\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42 // 保存 int值\n\tdescribe(i)\n\n\ti = \"hello\" // 保存 string值\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n**（8）類型斷言**\n\n類型斷言提供了訪問**接口值底層具體值**的方式。\n\n```go\n// 判斷接口i的底層值類型是否爲T，如是返回其底層值和true，否則返回T類型的零值和false\nt, ok := i.(T)\n```\n\n```go\nvar i interface{} = \"hello\"\ns, ok := i.(string)\nfmt.Println(s, ok)\nf, ok := i.(int)\nfmt.Println(f, ok)\n// 支持類型選擇\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n\tcase string:\n\t\tfmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n\tdefault:\n\t\tfmt.Printf(\"I don't know about type %T!\\n\", v)\n\t}\n}\n```\n\n### 異常處理\n\nGo 程序使用 `error` 值來表示錯誤狀態。\n\n```go\ntype error interface {\n    Error() string\n}\n```\n\n通常函數會返回一個 `error` 值，調用的它的代碼應當判斷這個錯誤是否等於 `nil` 來進行錯誤處理。`error` 為 nil 時表示成功；非 nil 的 `error` 表示失敗。\n\n```go\nif i, err := strconv.Atoi(\"42\"); err == nil {\n    fmt.Println(\"Converted integer:\", i)\n}\n```\n\n### Go 程(goroutine)\n\n**（1）定義**\n\n**Go 程（goroutine）是由 Go 運行時管理的輕量級線程**。\n\n```go\n// x,y,z 的求值發生在當前 Go 程中，f 的執行則是在新的 Go 程中\ngo f(x, y, z)\n```\n\n（**2）信道**\n\n**信道是帶有類型的管道**，你可以通過它用**信道操作符** `<-` (箭頭就是數據流的方向)來發送或者接收值。\n\n默認情況下，發送和接收操作在另一端準備好之前都會阻塞。這使得 Go 程可以在沒有顯式的鎖或競態變量的情況下進行同步。\n\n```go\n// 創建信道\nch := make(chan int)\n// 將 v 發送至信道 ch。\nch <- v\n// 從 ch 接收值並賦予 v。\nv := <-ch\n```\n\n**信道可以是帶緩衝，**將緩衝長度作為第二個參數提供給 `make` 來初始化一個帶緩衝的信道。\n\n```go\nch := make(chan int, 100)\n```\n\n**僅當信道的緩衝區填滿後，向其發送數據時才會阻塞。當緩衝區為空時，接受方會阻塞。**\n\n**（3）range 和 close**\n\n有且僅有發送者可以通過 close 方法關閉一個信道。接收者讀取值的時候可以通過 `v, ok := <-ch`  的 ok 值判斷是否信道關閉了。更簡單的是使用 for-range 不斷從信道接收值，直到信道關閉，循環自動退出。\n\n```go\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n```\n\n**（4）select**\n\nselect 語句使一個 Go 程可以等待多個通信操作。select 會阻塞到某個分支可以繼續執行為止，這時就會執行該分支。當多個分支都準備好時會隨機選擇一個執行。當 select 中的其它分支都沒有準備好時，default 分支就會執行。\n\n```go\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n    default:\n      // 當 c 和 quit 阻塞時會執行到此處\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci(c, quit)\n}\n```\n\n- 練習：等價二叉查找樹\n\n    函數 tree.New(k) 用於構造一個隨機結構的已排序二叉查找樹，它保存了值 k, 2k, 3k, ..., 10k。\n\n    Walk 步進 tree t 將所有的值從 tree 發送到 channel ch。\n\n    用 Walk 實現 Same 函數來檢測 t1 和 t2 是否存儲了相同的值。\n\n    ```go\n    package main\n\n    import \"golang.org/x/tour/tree\"\n\n    func Walk(t *tree.Tree, ch chan int){\n    \tif t.Left != nil{\n    \t\tWalk(t.Left, ch)\n    \t}\n    \tch <- t.Value\n    \tif t.Right != nil{\n    \t\tWalk(t.Right, ch)\n    \t}\n    }\n\n    // Same 检测树 t1 和 t2 是否含有相同的值。\n    func Same(t1, t2 *tree.Tree) bool{\n    \tch1,ch2 := make(chan int),make(chan int)\n    \tgo func(){\n    \t\tWalk(t1, ch1)\n    \t\tclose(ch1)\n    \t}()\n    \tgo func(){\n    \t\tWalk(t2, ch2)\n    \t\tclose(ch2)\n    \t}()\n    \tfor i := range ch1{\n    \t\tif i != <-ch2 {\n    \t\t\treturn false\n    \t\t}\n    \t}\n    \treturn true\n    }\n\n    func main() {\n    \tprintln(Same(tree.New(1),tree.New(1)))\n    }\n    ```\n\n**（5）sync.Mutex**\n\n互斥鎖可以保證每次只有一個 Go 程訪問一個共享變量。\n\nGo 標準庫中的 **Mutex** 就是一個互斥鎖，可以創建為其他結構體的字段；零值為解鎖狀態。Mutex類型的鎖和線程無關，可以由不同的線程加鎖和解鎖。在代碼前調用 Lock 方法，並在代碼後調用 Unlock 方法來保證一段代碼互斥執行。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\nfunc (c *SafeCounter) Increase(key string) {\n\tc.mux.Lock()\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\")\n\t}\n\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n}\n```\n\n爲了提升讀寫性能，常用 **RWMutex** 代替 **Mutex。**RWMutex是讀寫互斥鎖。該鎖可以被同時多個讀取者持有或唯一個寫入者持有。RWMutex可以創建為其他結構體的字段；零值為解鎖狀態。RWMutex類型的鎖也和線程無關，可以由不同的線程加讀取鎖/寫入和解讀取鎖/寫入鎖。\n\n下面的代碼效果不明顯，因爲讀的次數不多。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.RWMutex\n}\n\nfunc (c *SafeCounter) Increase(key string) {\n\tc.mux.Lock()\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.RLock()\n\tdefer c.mux.RUnlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tnow := time.Now()\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\")\n\t}\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n\tprint(time.Now().Sub(now))\n}\n```\n\n**（6）WaitGroup**\n\nWaitGroup 可以等待一組 Go 程結束。通過調用 Add 方法設定要等待的 Go 程數量。然後各個 Go 程通過調用 Done 方法結束等待。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.RWMutex\n}\n\nfunc (c *SafeCounter) Increase(key string, wg *sync.WaitGroup) {\n\tc.mux.Lock()\n\tc.v[key]++\n\twg.Done()\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.RLock()\n\tdefer c.mux.RUnlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\twg.Add(1000)\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\", &wg)\n\t}\n\twg.Wait()\n\tfmt.Println(c.Value(\"somekey\"))\n}\n```","source":"_posts/it/go/go-basic.md","raw":"---\ntitle: Go 基礎\np: it/go/go-basic.md\ndate: 2020-11-24 11:39:00\ntags:\n- Go\n---\n\nGo 又稱 Golang，是 Google 公司 2009 年發佈的一款開源編程語言，以簡潔而高效的代碼著稱。Go 目前使用 GOPATH 或 Go modules 管理項目中的第三方依賴，且不支持循環依賴。\n\nGo 的基本數據類型有 16 種(不包含別名)，可謂豐富。要注意的是 string 也是基本數據類型，表示一個 UTF-8 字符串，底層是 byte 數組。單個字符使用一個 int32 的別名 rune 表示，其值爲 Unicode 字符碼點。\n\nGo 的變量使用 var 關鍵字聲明，也可以使用短變量聲明；常量則是使用 const 關鍵字聲明。\n\nGo 有 if 條件語句、for 循環語句、switch 選擇語句和 defer 延遲執行語句。Go 的 for 語句兼具其他語言的 while 語句；switch 語句每個 case 條件都支持運算，且默認自動 break；defer 語句可以立即計算參數值，然後在函數 return 前執行。\n\nGo 的可見性跟標識符的首字母是否大寫相關，大寫則是導出的，包外可見；小寫則是非導出的，包外不可見。\n\nGo 有指針，要注意 `&` 是生成指向操作數的指針，而 `*` 是獲取指針指向的底層值。\n\nGo 將一些字段組合成一個結構體(struct) 。結構體支持隱式間接調用，即 p.X 等價於 (*p).X（p 爲結構體指針）。\n\nGo 支持數組，更重要的是支持一種名爲切片(slice) 的動態數組。切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量。\n\nGo 支持映射(map)。\n\nGo 支持函數(function)的命名返回值、多值返回、作爲值傳遞和閉包。還有一種稱爲方法(method)的特殊函數，其帶有接收者參數，接收者可以是值接收者也可以是指針接收者，指針接收者可以更改接收者的值。\n\nGo 支持將一些方法簽名組成接口(interface)。接口的實現是隱式的，不需要「implements」。一個結構體作爲接收者定義了接口中的所有方法，那麼該結構體就是實現了該接口。因爲隱式的緣故，建議接口方法盡可能少，以便管理。接口是值，可以傳遞。底層值是 nil 的接口，其方法可以被調用；接口本身爲 nil ，則意味著其不保存值也不保存具體類型；空接口(interface{})是包含零個函數的接口，不是爲 nil 接口。\n\nGo 的異常處理很簡單，只有 Error，沒有 throws。\n\nGo 支持 Go 程，一種 Go運行時管理的輕量級線程。Go 程之間可以通過信道(channel) 通信，通過 Mutex 或 RWMutex 共享互斥變量，通過 WaitGroup 等待執行完成。 \n\nGo 中的信道還支持通過 for-range 循環讀取數據，當信道關閉時該循環自動退出。記住，只有發送方可以關閉信道，接收方不能。信道還支持 select 語句，其會**阻塞到某一分支可以執行爲止**，如沒有分支可以執行且設定了default 語句，會一直執行 default 語句。\n\n<!-- more -->\n\n以下內容多來自[《Go 指南》](https://tour.go-zh.org/)，內容有所改動。\n\n## 歷史\n\nGo 又稱 Golang，是 Google 公司開發的一款靜態強類型、編譯型、並發型，並具有垃圾回收功能的編程語言。\n\n1. 2007.9.21 罗伯特·格瑞史莫(Robert Griesemer)、罗勃·派克(Rob Pike)和肯·汤普逊(Ken Thompson) 開始設計 Go。\n2. 2009.11 Google 發佈 Go 語言。\n3. 2012.3 Go 1.0 發佈。\n4. 2018.8 Go 1.11 發佈，預支持 modules 進行依賴管理。\n\n## 入門\n\n### 安裝\n\n按照[官方教程](https://golang.org/doc/install)安裝即可。\n\n### Hello World\n\n直接在系統 Home 目錄，新建一一個 hello.go 文件，寫入代碼如下：\n\n```go\npackage main //程序從 main 包的 main 函數開始運行\nimport \"fmt\" //導入 fmt 包\n\nfunc main() { //main函數\n    fmt.Println(\"Hello, World!\") //打印日誌\n}\n```\n\n然後執行 `go run hello.go` 即可。\n\n### GOPATH\n\n當項目未啟用 Go modules 時，Go 使用 `GOPATH` 環境變量解析 import 語句。`GOPATH` 的值默認爲 `$HOME/go` ， `GOPATH` 目錄結構如下：\n\n```go\nGOPATH=/home/user/go\n\nsrc/\n    foo/\n        bar/               (go code in package bar)\n            x.go\n        quux/              (go code in package main)\n            y.go\nbin/\n    quux                   (installed command)\npkg/\n    linux_amd64/\n        foo/\n            bar.a          (installed package object)\n```\n\n- src：存放依賴的源代碼\n- bin：存放安裝的命令\n- pkg：存法安裝的包對象\n\n啟用 Go modules 後雖然不通過 `GOPATH` 解析 import 語句，但下載的源代碼和安裝的命令都會存在`GOPATH`目錄下。\n\n### Vendor\n\nVendor 就是使用本地依賴包的模式，Go 1.5 作爲實驗特性，Go 1.6 正式支持，Go 1.14 正式終結。命名爲 vender(小商販) 是一種比喻，並將 GOPATH 隱喻爲有固定地址的商舖。啟用 Vendor 模式很簡單，在項目中創建一個名爲 vendor 的文件夾然後拷貝依賴的源代碼進入其中即可。比如有如下的項目使用了 Vendor：\n\n```go\n$GOPATH\n|\tsrc/\n|\t|\tgithub.com/constabulary/example-gsftp/\n|\t|\t|\tcmd/\n|\t|\t|\t|\tgsftp/\n|\t|\t|\t|\t|\tmain.go\n|\t|\t|\tvendor/\n|\t|\t|\t|\tgithub.com/pkg/sftp/\n|\t|\t|\t|\tgolang.org/x/crypto/ssh/\n|\t|\t|\t|\t|\tagent/\n```\n\n在文件 `github.com/constabulary/example-gsftp/cmd/gsftp/main.go` 中應這樣 import 依賴（不需要加入 vendor 前綴）：\n\n```go\nimport (\n\t...\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/agent\"\n\t\"github.com/pkg/sftp\"\n)\n```\n\n這種方式顯然會帶來代碼膨脹，特別是N個庫同時用 Vendor 模式依賴一個通用庫時，那麼該通用庫的代碼將會出現N次。\n\n### Go modules\n\nGo 官方推出的依賴管理系統，在 Go 1.11 和 1.12中已經有初步支持，但默認關閉；從 1.13 開始默認啟用，1.14 開始可用於生產。\n\n**（1）使用 Go modules**\n\n使用 Go modules 很簡單，只需要在項目根路徑(不可以在 `$GOPATH/src` 裏面)執行 `go mod init example.com/m` 即可初始化一個名爲 `example.com/m` 的模塊，之後會在項目根路徑生成一個名爲 `go.mod` 的依賴文件，其內容結構如下：\n\n```go\nmodule example.com/hello //模塊名\n\ngo 1.12 //使用的 Go 版本\n\nrequire rsc.io/quote v1.5.2 //依賴項\n```\n\n此外，Go modules 還生成和維護著一個名爲 `go.sum` 的文件，該文件包含了期望的指定模塊版本的內容的加密哈希。\n\n爲保證依賴的一致性，需要同時將 `go.mod` 和 `go.sum` 加入版本管理。\n\n**（2）更新依賴**\n\n更新小版本很簡單，一個 `go get` 命令就完了。更新大版本比更新小版本複雜，因爲大版本通常會帶來 API 的變化，Go 要求更改大版本號後，模塊名也要加上版本號。例如原本是 `rsc.io/quote` 的依賴，升級到 v3 後依賴要改成 `rsc.io/quote/v3` ，因此代碼中的 import 語句要改成 `rsc.io/quote/v3` ，然後清理掉舊版本的依賴，有點麻煩。\n\n```bash\n# 列出當前項目的模塊和依賴項\ngo list -m all\n# 直接更新到最新的小版本\ngo get rsc.io/sampler\n# 列出所有小版本\ngo list -m -versions rsc.io/sampler\n# 更新到指定版本\ngo get rsc.io/sampler@v1.3.1\n\n# 查看模塊的所有版本\ngo list -m rsc.io/q...\n# 清除未使用的依賴\ngo mod tidy\n```\n\n### 循環依賴\n\nGo 不支持循環依賴，Go設計者Rob Pike認爲如果出現兩個包循環依賴，那麼是你的設計問題。\n\n筆者就出現過一次循環依賴，場景是：封裝了一個打印日誌的庫A和一個解析配置的庫B，庫A需要通過庫B配置，庫B需要用庫A打印日誌。最後選擇在庫B使用原始的日誌打印。\n\n## 語法\n\n### 數據類型\n\n**（1）基本類型**\n\n```go\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的別名\n    // 表示一個 Unicode 碼點\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\n其中 int, uint 和 uintptr 在 32 位系統上通常為 32 位寬，在 64 位系統上則為 64 位寬。\n\nstring 表示一個 UTF-8 類型的字符串，底層是一個字節數組。\n\nrune 表示一個 Unicode 碼點，是 int32 的別名。讀取 string 中的每個字符，只需要將 string 轉爲 rune 數組即可\n\nJava 中的 char 類型，每個字符對應一個 Unicode 碼點，可以表示BMP範圍內（即[U+0000, U+FFFF]之間）的Unicode字符。String 是 UTF-8 類型。\n\n**（2）零值**\n\n没有明确初始值的变量声明会被赋予它们的 **零值**。\n\n零值是：\n\n- 数值类型为 `0`，\n- 布尔类型为 `false`，\n- 字符串为 `\"\"`（空字符串）。\n\n**（3）類型轉換**\n\n數值之間可以通過表達式 T(v) 將值 v 轉換為類型 T，如：\n\n```go\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n**（4）类型推导**\n\n在聲明一個變量而不指定其類型時（即使用不帶類型的 := 語法或 var = 表達式語法），變量的類型由右值推導得出。\n\n```go\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n```\n\n### 變量\n\n**（1）聲明語句**\n\n```go\n// var 開頭，逗號(,)分割變量名，最後寫數據類型 \nvar c, python, java bool\n```\n\n**（2）賦值語句**\n\n```go\nvar c, python, java = true,false,\"no\"\n```\n\n或直接使用**短變量聲明**，注意短變量聲明只能在函數內使用，因爲函數外的每個語句要求必須以關鍵字開始。\n\n```go\nc, python, java := true,false,\"no\"\n```\n\n### 常量\n\n常量聲明使用 const 關鍵字。常量可以是字符、字符串、布尔值或数值。常量不能用 `:=` 语法声明。\n\n```go\nconst Pi = 3.14\n```\n\n`iota` 可以用來創建順序遞增的常量。\n\n```go\nconst (\n\tLow = iota //0\n\tMedium     //1\n\tHigh       //2\n)\n```\n\n### 風格\n\n1. 每行程序結束後不需要撰寫分號（;）。\n2. 大括號（{）不能夠換行放置。\n3. if判斷式和for循環不需要以小括號包覆起來。\n4. 使用 tab 做排版\n\n### 流程控制\n\n**（1）if-else**\n\n不需要小括號，可以使用簡短語句。\n\n```go\n_,ok := sendMsg();\nif ok {\n  // do something\n}else{\n  // do other thing\n}\n// 等價於以下簡短語句\nif _,ok := sendMsg(); ok {\n  // do something\n}else{\n  // do other thing\n}\n```\n\n**（2）for**\n\nGo 中的 for 語句，還包含了其他語言的 while 的功能。特別的不用括號包裹。\n\n```go\n// 功能：遍歷 10 次\nfor i:=0;i<10;i++{\n}\n// 功能：類似於其他語言 while 的功能\nvar i = 0\nfor i<10{\n}\n// 功能：無限循環，類似於其他語言中的 while(true)\nfor{\n}\n// 功能：for range 循環，返回當前元素的下標及副本\n// 可通過 _ 忽略其中的某個值\npow := []int{1, 2, 4, 8}\nfor i, v := range pow {\n\tfmt.Printf(\"%d,%d\\n\", i, v)\n}\nfor _,v := range pow {\n\tfmt.Printf(\"%d\\n\", v)\n}\nfor i := range pow {\n\tfmt.Printf(\"%d\\n\", i)\n}\n```\n\n**（3）switch**\n\nGo 中的 switch 語句是自動 break 的。如果不想要break，需要在 case 後面協商 fallthrough。\n\nGo 中的 switch 的 case 無需為常量，且取值不必為整數。\n\n```go\n// 功能：選擇顏色\nswitch color {\n    case Red:\n    // do something\n    case Green:\n    // do something\n    default:\n    // do something\n}\n// 功能：替代 if-then-else，更整齊\nresult := request()\nswitch {\n    case result > 0:\n    case result <0:\n    default:\n}\n// 或者\nswitch result := request(); {\n    case result > 0:\n    case result <0:\n    default:\n}\n```\n\n**（4）defer**\n\ndefer 語句會將函數推遲到外層函數返回之後執行。\n\n推遲調用的函數其參數會立即求值，但直到外層函數返回前該函數都不會被調用。\n\n推遲的函數調用會被壓入一個棧中。當外層函數返回時，被推遲的函數會按照後進先出的順序調用。\n\n```go\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n```\n\ndefer 並不是免費的。defer 底層會調用 `runtime.deferproc` 去設置要延遲調用的函數，調用 `runtime.deferreturn` 會依次執行先前延遲調用的函數。參考：https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32\n\n### 可見性\n\n- 導出：大寫字母開頭的標識符，包外可訪問。\n- 未導出：非大寫字母開頭的標識符，包外不可訪問。\n\n### 指針\n\nGo 擁有指針。指針保存了值的內存地址。\n\n- 類型 `*T` 是指向 `T` 類型值的指針。其零值為 `nil`。\n- `&` 操作符會**生成一個指向其操作數的指針**。（注意：把`&` 理解爲取地址符號是錯誤的）\n- `*` 操作符**表示指針指向的底層值**。（注意：把`*` 理解爲取值符號是錯誤的）\n\n```go\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := &i         // 指向 i\n\tfmt.Println(*p) // 通過指針讀取 i 的值\n\t*p = 21         // 通過指針設置 i 的值\n\tfmt.Println(i)  // 查看 i 的值\n\n\tp = &j         // 重定向到 j\n\t*p = *p / 37   // 通過指針對 j 進行除法運算\n\tfmt.Println(j) // 查看 j 的值\n}\n```\n\n### 結構體\n\n一個結構體（struct）就是一組字段（field）。外界使用點號來訪問結構體字段。\n\n結構體字段可以通過結構體指針來訪問。如果我們有一個指向結構體的指針 p，那麼可以通過 `(*p).X` 來訪問其字段 X。不過這麼寫太囉嗦了，所以語言也允許我們使用**隱式間接引用**，直接寫 `p.X` 就可以。\n\n```go\ntype Vertex struct {\n\tX, Y int\n}\n\nfunc main() {\n  v := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n  \n  p := &v\n\tp.X = 1e9\n\tfmt.Println(v)\n\n\tv2 = Vertex{X: 1}  // Y:0 被隱式地賦予\n\tv3 = Vertex{}      // X:0 Y:0\n\tp  = &Vertex{1, 2} // 創建一個 *Vertex 類型的結構體（指針）\n}\n```\n\n### 數組\n\n類型 [n]T 表示擁有 n 個 T 類型的值的數組。\n\n表达式\n\n```go\nvar a [10]int\n```\n\n會將變量 `a` 聲明為擁有 10 個整數的數組。\n\n### 切片\n\n**（1）定義**\n\n類型 []T 表示一個元素類型為 T 的切片。T 可以是任何類型，包括切片本身。\n\n切片通過兩個下標來界定，即一個上界和一個下界，二者以冒號分隔：\n\n```go\na[low : high]\n```\n\n它會選擇一個半開區間，包括第一個元素，但排除最後一個元素。\n\n切片下界的默認值爲 0，上界則是其底層數組的長度。\n\n對於數組 `var a [10]int` 來說，以下切片是等價的：\n\n```go\na[0:10]\na[:10]\na[0:]\na[:]\n```\n\n**（2）切片的本質**\n\n一個切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量，其結構如下：\n\n![](go-basic/Untitled.png)\n\n![](go-basic/Untitled%201.png)\n\n切片的長度就是它所包含的元素個數。\n切片的容量是從它的第一個元素開始數，到其底層數組元素末尾的個數。\n切片 s 的長度和容量可通過表達式 `len(s)` 和 `cap(s)` 來獲取。\n\n更改切片的元素會修改其底層數組中對應的元素。與它共享底層數組的切片都會觀測到這些修改。\n\n```go\nfunc main() {\n\tnames := [4]string{\n\t\t\"John\",\n\t\t\"Paul\",\n\t\t\"George\",\n\t\t\"Ringo\",\n\t}\n\tfmt.Println(names)\n\n\ta := names[0:2]\n\tb := names[1:3]\n\tfmt.Println(a, b)\n\n\tb[0] = \"XXX\"\n\tfmt.Println(a, b)\n\tfmt.Println(names)\n}\n```\n\n注意：切片的零值爲 nil，其長度和容量爲 0 且沒有底層數組。\n\n**（3）通過 make 創建切片**\n\n```go\na := make([]int, 5)  // len(a)=5\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n```\n\n**（4）通過 append 追加元素**\n\n```go\nfunc append(s []T, vs ...T) []T\n```\n\n`append` 的第一個參數 `s` 是一個元素類型為 `T` 的切片，其餘類型為 `T`的值將會追加到該切片的末尾。\n\n`append` 的結果是一個包含原切片所有元素加上新添加元素的切片。\n\n當 `s` 的底層數組太小，不足以容納所有給定的值時，它就會分配一個更大的數組。返回的切片會指向這個新分配的數組。\n\n當引用一個原始數組時，GC不會釋放該數組的空間，即使只用到其中一小部分數據。因此函數返回切片的時候要特別注意，最好拷貝需要數據到新的切片再返回。\n\n```go\n// 使用 copy 函數\nfunc CopyDigits(filename string) []byte {\n    b, _ := ioutil.ReadFile(filename)\n    b = digitRegexp.Find(b)\n    c := make([]byte, len(b))\n    copy(c, b)\n    return c\n}\n// 或使用 append 函數\nfunc CopyDigits(filename string) []byte {\n    b, _ := ioutil.ReadFile(filename)\n    b = digitRegexp.Find(b)\n    var c []byte\n    return append(c, b...)\n}\n```\n\n### 映射\n\n映射將鍵映射到值。\n\n映射的零值為 `nil` 。`nil` 映射既沒有鍵，也不能添加鍵。\n\n`make` 函數會返回給定類型的映射，並將其初始化備用。\n\n```go\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": {40.68433, -74.39967},\n\t\"Google\":    {37.42202, -122.08408},\n}\n```\n\n 常用操作：\n\n1. 插入或修改元素：`m[key] = elem`\n2. 獲取元素：`elem = m[key]`\n3. 通過雙賦值檢測某個鍵是否存在：`elem, ok := m[key]`\n4. 刪除元素：`delete(m, key)`\n\n### 函數(function)\n\n**（1）概述**\n\n函數可以沒有參數或接受多個參數。當連續兩個或多個函數的已命名形參類型相同時，除最後一個類型以外，其它都可以省略。\n\n```go\nfunc add(x, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n```\n\n**（2）命名返回值**\n\nGo 的返回值可被命名，它們會被視作**定義在函數頂部的變量**。返回值的名稱應當具有一定的意義，它可以作為文檔使用。沒有參數的 `return` 語句返回已命名的返回值。也就是 `直接` 返回。直接返回語句應當僅用在下面這樣的短函數中。在長的函數中它們會影響代碼的可讀性。\n\n```go\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(split(17))\n}\n```\n\n**（3）多值返回**\n\n函數可以返回任意數量的返回值。\n\n```go\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n```\n\n**（4）函數值**\n\n函數也是值，可以作爲函數的參數或返回值。\n\n```go\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\nfmt.Println(compute(math.Pow))\n```\n\n**（5）閉包(closure)**\n\n閉包是指一個函數引用了其函數體之外的變量，該函數可以訪問並賦予其引用的變量的值。換句話說就是該函數跟函數體之外的變量綑綁在一起了。每次調用閉包中的函數可以改變閉包中變量的值。例如斐波那契閉包：\n\n```go\nfunc fibonacci() func() int {\n\tx,y := 0,1\n\treturn func() int {\n\t\tres := x\n\t\tx,y = y,x+y\n\t\treturn res\n\t}\n}\n\nfunc main() {\n\tf := fibonacci()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(f())\n\t}\n}\n```\n\n### 方法(method)\n\n方法就是一類帶特殊的**接收者參數**的函數。方法接收者在它自己的參數列表內，**位於 func 關鍵字和方法名之間**。\n\n```go\ntype Vertex struct {\n\tX, Y float64\n}\n// 這就是方法\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n```\n\n值得注意的是：接收者的類型定義和方法聲明必須在同一包內；不能爲內建類型聲明方法。\n\n接收者除了是**值接收者**外，還支持**指針接收者**，使用 `*T` (不能是 `*int` 之類的) 的文法即可。指針接收者可以修改接收者指向的值。如下：\n\n```go\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(10) // 此時 Go 會解釋爲 (&v).Scale(10)，這就是指針重定向\n\tfmt.Println(v.Abs())\n}\n```\n\n使用指針接收者的好處：\n\n1. 方法能夠修改其接收者指向的值。\n2. 避免在每次調用方法時複製該值。該值佔用的空間越大，則越顯得高效。\n\n注意：一個結構體採用值接收者的方式實現了接口的方法，則隱含著採用指針接收者的方式實現了接口的方法。（接收者是指針類型的方法，很可能在方法中會對接收者的屬性進行更改操作，從而影響接收者；而對於接收者是值類型的方法，在方法中不會對接收者本身產生影響）\n\n### 接口\n\n**（1）定義**\n\n接口類型是**由一組方法簽名定義的集合**。接口類型的變量可以保存**任何**實現了這些方法的值。\n\n**（2）隱式實現**\n\n類型通過實現一個接口的所有方法來實現該接口。既然無需專門顯式聲明，也就沒有「implements」關鍵字。\n\n```go\ntype Animal interface {\n\teat()\n}\n\ntype John struct{}\n\nfunc (j *John) eat() {\n\tfmt.Println(\"eat...\")\n}\n\ntype Person interface {\n\teat()\n\ttalk()\n}\n\nfunc (j *John) talk() {\n\tfmt.Println(\"talk...\")\n}\n\nfunc main() {\n\tvar a Animal = &John{}\n\ta.eat()\n\tvar b Person = &John{}\n\tb.eat()\n\tb.talk()\n}\n```\n\n**（4）接口值**\n\n接口也是值，可以作爲函數的參數或返回值。在內部，接口值可以看做包含值和具體類型的元組：`(value, type)` 。接口值保存了一個具體底層類型的具體值。接口值調用方法時會執行其底層類型的同名方法。\n\n```go\n// Animal、John 見上面的代碼\nj := John{}\ndescribe(j)\n\nfunc describe(i Animal){\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n**（5）底層值爲 nil 的接口值**\n\n即便接口內的具體值為 nil，方法仍然會被 nil 接收者調用。\n\n```go\n// 改造上面的代碼\nfunc (j *John) talk() {\n\tif j == nil {\n\t\tfmt.Println(\"j is <nil>\")\n\t\treturn\n\t}\n\tfmt.Println(\"talk...\")\n}\n\nfunc main() {\n\tvar x Person\n\tvar y John\n\tx = &y\n\tdescribe(x)\n\tx.talk() // 正常調用\n}\n```\n\n判斷接口的底層值是否爲 nil 的方法：\n\n```go\n// 接上\nprintln( x == nil || reflect.ValueOf(x).IsNil())\n```\n\n**（6）nil 接口值**\n\nnil 接口值既不保存值也不保存具體類型。\n\n為 nil 接口調用方法會產生運行時錯誤，因為接口的元組內並未包含能夠指明該調用哪個 **具體** 方法的類型。\n\n```go\ntype I interface {\n\tM()\n}\n\nfunc main() {\n\tvar i I\n\tdescribe(i)\n\ti.M() // 此處拋出 panic: runtime error: invalid memory address or nil pointer dereference\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i) // (<nil>, <nil>)\n}\n```\n\n**（7）空接口**\n\n指定了**零個方法**的接口值被稱為空接口，即 `interface{}` 。空接口可保存任何類型的值。（因為每個類型都至少實現了零個方法。）空接口被用來處理未知類型的值。例如，`fmt.Print` 可接受類型為 `interface{}` 的任意數量的參數。\n\n```go\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42 // 保存 int值\n\tdescribe(i)\n\n\ti = \"hello\" // 保存 string值\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n**（8）類型斷言**\n\n類型斷言提供了訪問**接口值底層具體值**的方式。\n\n```go\n// 判斷接口i的底層值類型是否爲T，如是返回其底層值和true，否則返回T類型的零值和false\nt, ok := i.(T)\n```\n\n```go\nvar i interface{} = \"hello\"\ns, ok := i.(string)\nfmt.Println(s, ok)\nf, ok := i.(int)\nfmt.Println(f, ok)\n// 支持類型選擇\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n\tcase string:\n\t\tfmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n\tdefault:\n\t\tfmt.Printf(\"I don't know about type %T!\\n\", v)\n\t}\n}\n```\n\n### 異常處理\n\nGo 程序使用 `error` 值來表示錯誤狀態。\n\n```go\ntype error interface {\n    Error() string\n}\n```\n\n通常函數會返回一個 `error` 值，調用的它的代碼應當判斷這個錯誤是否等於 `nil` 來進行錯誤處理。`error` 為 nil 時表示成功；非 nil 的 `error` 表示失敗。\n\n```go\nif i, err := strconv.Atoi(\"42\"); err == nil {\n    fmt.Println(\"Converted integer:\", i)\n}\n```\n\n### Go 程(goroutine)\n\n**（1）定義**\n\n**Go 程（goroutine）是由 Go 運行時管理的輕量級線程**。\n\n```go\n// x,y,z 的求值發生在當前 Go 程中，f 的執行則是在新的 Go 程中\ngo f(x, y, z)\n```\n\n（**2）信道**\n\n**信道是帶有類型的管道**，你可以通過它用**信道操作符** `<-` (箭頭就是數據流的方向)來發送或者接收值。\n\n默認情況下，發送和接收操作在另一端準備好之前都會阻塞。這使得 Go 程可以在沒有顯式的鎖或競態變量的情況下進行同步。\n\n```go\n// 創建信道\nch := make(chan int)\n// 將 v 發送至信道 ch。\nch <- v\n// 從 ch 接收值並賦予 v。\nv := <-ch\n```\n\n**信道可以是帶緩衝，**將緩衝長度作為第二個參數提供給 `make` 來初始化一個帶緩衝的信道。\n\n```go\nch := make(chan int, 100)\n```\n\n**僅當信道的緩衝區填滿後，向其發送數據時才會阻塞。當緩衝區為空時，接受方會阻塞。**\n\n**（3）range 和 close**\n\n有且僅有發送者可以通過 close 方法關閉一個信道。接收者讀取值的時候可以通過 `v, ok := <-ch`  的 ok 值判斷是否信道關閉了。更簡單的是使用 for-range 不斷從信道接收值，直到信道關閉，循環自動退出。\n\n```go\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n```\n\n**（4）select**\n\nselect 語句使一個 Go 程可以等待多個通信操作。select 會阻塞到某個分支可以繼續執行為止，這時就會執行該分支。當多個分支都準備好時會隨機選擇一個執行。當 select 中的其它分支都沒有準備好時，default 分支就會執行。\n\n```go\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n    default:\n      // 當 c 和 quit 阻塞時會執行到此處\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci(c, quit)\n}\n```\n\n- 練習：等價二叉查找樹\n\n    函數 tree.New(k) 用於構造一個隨機結構的已排序二叉查找樹，它保存了值 k, 2k, 3k, ..., 10k。\n\n    Walk 步進 tree t 將所有的值從 tree 發送到 channel ch。\n\n    用 Walk 實現 Same 函數來檢測 t1 和 t2 是否存儲了相同的值。\n\n    ```go\n    package main\n\n    import \"golang.org/x/tour/tree\"\n\n    func Walk(t *tree.Tree, ch chan int){\n    \tif t.Left != nil{\n    \t\tWalk(t.Left, ch)\n    \t}\n    \tch <- t.Value\n    \tif t.Right != nil{\n    \t\tWalk(t.Right, ch)\n    \t}\n    }\n\n    // Same 检测树 t1 和 t2 是否含有相同的值。\n    func Same(t1, t2 *tree.Tree) bool{\n    \tch1,ch2 := make(chan int),make(chan int)\n    \tgo func(){\n    \t\tWalk(t1, ch1)\n    \t\tclose(ch1)\n    \t}()\n    \tgo func(){\n    \t\tWalk(t2, ch2)\n    \t\tclose(ch2)\n    \t}()\n    \tfor i := range ch1{\n    \t\tif i != <-ch2 {\n    \t\t\treturn false\n    \t\t}\n    \t}\n    \treturn true\n    }\n\n    func main() {\n    \tprintln(Same(tree.New(1),tree.New(1)))\n    }\n    ```\n\n**（5）sync.Mutex**\n\n互斥鎖可以保證每次只有一個 Go 程訪問一個共享變量。\n\nGo 標準庫中的 **Mutex** 就是一個互斥鎖，可以創建為其他結構體的字段；零值為解鎖狀態。Mutex類型的鎖和線程無關，可以由不同的線程加鎖和解鎖。在代碼前調用 Lock 方法，並在代碼後調用 Unlock 方法來保證一段代碼互斥執行。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\nfunc (c *SafeCounter) Increase(key string) {\n\tc.mux.Lock()\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\")\n\t}\n\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n}\n```\n\n爲了提升讀寫性能，常用 **RWMutex** 代替 **Mutex。**RWMutex是讀寫互斥鎖。該鎖可以被同時多個讀取者持有或唯一個寫入者持有。RWMutex可以創建為其他結構體的字段；零值為解鎖狀態。RWMutex類型的鎖也和線程無關，可以由不同的線程加讀取鎖/寫入和解讀取鎖/寫入鎖。\n\n下面的代碼效果不明顯，因爲讀的次數不多。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.RWMutex\n}\n\nfunc (c *SafeCounter) Increase(key string) {\n\tc.mux.Lock()\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.RLock()\n\tdefer c.mux.RUnlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tnow := time.Now()\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\")\n\t}\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n\tprint(time.Now().Sub(now))\n}\n```\n\n**（6）WaitGroup**\n\nWaitGroup 可以等待一組 Go 程結束。通過調用 Add 方法設定要等待的 Go 程數量。然後各個 Go 程通過調用 Done 方法結束等待。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.RWMutex\n}\n\nfunc (c *SafeCounter) Increase(key string, wg *sync.WaitGroup) {\n\tc.mux.Lock()\n\tc.v[key]++\n\twg.Done()\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.RLock()\n\tdefer c.mux.RUnlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\twg.Add(1000)\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\", &wg)\n\t}\n\twg.Wait()\n\tfmt.Println(c.Value(\"somekey\"))\n}\n```","slug":"it/go/go-basic","published":1,"updated":"2021-09-13T14:14:33.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfr00361n9k3dktbace","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>Go 又稱 Golang，是 Google 公司 2009 年發佈的一款開源編程語言，以簡潔而高效的代碼著稱。Go 目前使用 GOPATH 或 Go modules 管理項目中的第三方依賴，且不支持循環依賴。</p>\n<p>Go 的基本數據類型有 16 種(不包含別名)，可謂豐富。要注意的是 string 也是基本數據類型，表示一個 UTF-8 字符串，底層是 byte 數組。單個字符使用一個 int32 的別名 rune 表示，其值爲 Unicode 字符碼點。</p>\n<p>Go 的變量使用 var 關鍵字聲明，也可以使用短變量聲明；常量則是使用 const 關鍵字聲明。</p>\n<p>Go 有 if 條件語句、for 循環語句、switch 選擇語句和 defer 延遲執行語句。Go 的 for 語句兼具其他語言的 while 語句；switch 語句每個 case 條件都支持運算，且默認自動 break；defer 語句可以立即計算參數值，然後在函數 return 前執行。</p>\n<p>Go 的可見性跟標識符的首字母是否大寫相關，大寫則是導出的，包外可見；小寫則是非導出的，包外不可見。</p>\n<p>Go 有指針，要注意 <code>&amp;</code> 是生成指向操作數的指針，而 <code>*</code> 是獲取指針指向的底層值。</p>\n<p>Go 將一些字段組合成一個結構體(struct) 。結構體支持隱式間接調用，即 p.X 等價於 (*p).X（p 爲結構體指針）。</p>\n<p>Go 支持數組，更重要的是支持一種名爲切片(slice) 的動態數組。切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量。</p>\n<p>Go 支持映射(map)。</p>\n<p>Go 支持函數(function)的命名返回值、多值返回、作爲值傳遞和閉包。還有一種稱爲方法(method)的特殊函數，其帶有接收者參數，接收者可以是值接收者也可以是指針接收者，指針接收者可以更改接收者的值。</p>\n<p>Go 支持將一些方法簽名組成接口(interface)。接口的實現是隱式的，不需要「implements」。一個結構體作爲接收者定義了接口中的所有方法，那麼該結構體就是實現了該接口。因爲隱式的緣故，建議接口方法盡可能少，以便管理。接口是值，可以傳遞。底層值是 nil 的接口，其方法可以被調用；接口本身爲 nil ，則意味著其不保存值也不保存具體類型；空接口(interface{})是包含零個函數的接口，不是爲 nil 接口。</p>\n<p>Go 的異常處理很簡單，只有 Error，沒有 throws。</p>\n<p>Go 支持 Go 程，一種 Go運行時管理的輕量級線程。Go 程之間可以通過信道(channel) 通信，通過 Mutex 或 RWMutex 共享互斥變量，通過 WaitGroup 等待執行完成。 </p>\n<p>Go 中的信道還支持通過 for-range 循環讀取數據，當信道關閉時該循環自動退出。記住，只有發送方可以關閉信道，接收方不能。信道還支持 select 語句，其會<strong>阻塞到某一分支可以執行爲止</strong>，如沒有分支可以執行且設定了default 語句，會一直執行 default 語句。</p>\n<span id=\"more\"></span>\n\n<p>以下內容多來自<a href=\"https://tour.go-zh.org/\">《Go 指南》</a>，內容有所改動。</p>\n<h2 id=\"歷史\"><a href=\"#歷史\" class=\"headerlink\" title=\"歷史\"></a>歷史</h2><p>Go 又稱 Golang，是 Google 公司開發的一款靜態強類型、編譯型、並發型，並具有垃圾回收功能的編程語言。</p>\n<ol>\n<li>2007.9.21 罗伯特·格瑞史莫(Robert Griesemer)、罗勃·派克(Rob Pike)和肯·汤普逊(Ken Thompson) 開始設計 Go。</li>\n<li>2009.11 Google 發佈 Go 語言。</li>\n<li>2012.3 Go 1.0 發佈。</li>\n<li>2018.8 Go 1.11 發佈，預支持 modules 進行依賴管理。</li>\n</ol>\n<h2 id=\"入門\"><a href=\"#入門\" class=\"headerlink\" title=\"入門\"></a>入門</h2><h3 id=\"安裝\"><a href=\"#安裝\" class=\"headerlink\" title=\"安裝\"></a>安裝</h3><p>按照<a href=\"https://golang.org/doc/install\">官方教程</a>安裝即可。</p>\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>直接在系統 Home 目錄，新建一一個 hello.go 文件，寫入代碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main <span class=\"comment\">//程序從 main 包的 main 函數開始運行</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span> <span class=\"comment\">//導入 fmt 包</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//main函數</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Hello, World!&quot;</span>) <span class=\"comment\">//打印日誌</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然後執行 <code>go run hello.go</code> 即可。</p>\n<h3 id=\"GOPATH\"><a href=\"#GOPATH\" class=\"headerlink\" title=\"GOPATH\"></a>GOPATH</h3><p>當項目未啟用 Go modules 時，Go 使用 <code>GOPATH</code> 環境變量解析 import 語句。<code>GOPATH</code> 的值默認爲 <code>$HOME/go</code> ， <code>GOPATH</code> 目錄結構如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">GOPATH=/home/user/<span class=\"keyword\">go</span></span><br><span class=\"line\"></span><br><span class=\"line\">src/</span><br><span class=\"line\">    foo/</span><br><span class=\"line\">        bar/               (<span class=\"keyword\">go</span> code in <span class=\"keyword\">package</span> bar)</span><br><span class=\"line\">            x.<span class=\"keyword\">go</span></span><br><span class=\"line\">        quux/              (<span class=\"keyword\">go</span> code in <span class=\"keyword\">package</span> main)</span><br><span class=\"line\">            y.<span class=\"keyword\">go</span></span><br><span class=\"line\">bin/</span><br><span class=\"line\">    quux                   (installed command)</span><br><span class=\"line\">pkg/</span><br><span class=\"line\">    linux_amd64/</span><br><span class=\"line\">        foo/</span><br><span class=\"line\">            bar.a          (installed <span class=\"keyword\">package</span> object)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>src：存放依賴的源代碼</li>\n<li>bin：存放安裝的命令</li>\n<li>pkg：存法安裝的包對象</li>\n</ul>\n<p>啟用 Go modules 後雖然不通過 <code>GOPATH</code> 解析 import 語句，但下載的源代碼和安裝的命令都會存在<code>GOPATH</code>目錄下。</p>\n<h3 id=\"Vendor\"><a href=\"#Vendor\" class=\"headerlink\" title=\"Vendor\"></a>Vendor</h3><p>Vendor 就是使用本地依賴包的模式，Go 1.5 作爲實驗特性，Go 1.6 正式支持，Go 1.14 正式終結。命名爲 vender(小商販) 是一種比喻，並將 GOPATH 隱喻爲有固定地址的商舖。啟用 Vendor 模式很簡單，在項目中創建一個名爲 vendor 的文件夾然後拷貝依賴的源代碼進入其中即可。比如有如下的項目使用了 Vendor：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">$GOPATH</span><br><span class=\"line\">|\tsrc/</span><br><span class=\"line\">|\t|\tgithub.com/constabulary/example-gsftp/</span><br><span class=\"line\">|\t|\t|\tcmd/</span><br><span class=\"line\">|\t|\t|\t|\tgsftp/</span><br><span class=\"line\">|\t|\t|\t|\t|\tmain.<span class=\"keyword\">go</span></span><br><span class=\"line\">|\t|\t|\tvendor/</span><br><span class=\"line\">|\t|\t|\t|\tgithub.com/pkg/sftp/</span><br><span class=\"line\">|\t|\t|\t|\tgolang.org/x/crypto/ssh/</span><br><span class=\"line\">|\t|\t|\t|\t|\tagent/</span><br></pre></td></tr></table></figure>\n\n<p>在文件 <code>github.com/constabulary/example-gsftp/cmd/gsftp/main.go</code> 中應這樣 import 依賴（不需要加入 vendor 前綴）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"string\">&quot;golang.org/x/crypto/ssh&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;golang.org/x/crypto/ssh/agent&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/pkg/sftp&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>這種方式顯然會帶來代碼膨脹，特別是N個庫同時用 Vendor 模式依賴一個通用庫時，那麼該通用庫的代碼將會出現N次。</p>\n<h3 id=\"Go-modules\"><a href=\"#Go-modules\" class=\"headerlink\" title=\"Go modules\"></a>Go modules</h3><p>Go 官方推出的依賴管理系統，在 Go 1.11 和 1.12中已經有初步支持，但默認關閉；從 1.13 開始默認啟用，1.14 開始可用於生產。</p>\n<p><strong>（1）使用 Go modules</strong></p>\n<p>使用 Go modules 很簡單，只需要在項目根路徑(不可以在 <code>$GOPATH/src</code> 裏面)執行 <code>go mod init example.com/m</code> 即可初始化一個名爲 <code>example.com/m</code> 的模塊，之後會在項目根路徑生成一個名爲 <code>go.mod</code> 的依賴文件，其內容結構如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">module example.com/hello <span class=\"comment\">//模塊名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"number\">1.12</span> <span class=\"comment\">//使用的 Go 版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">require rsc.io/quote v1<span class=\"number\">.5</span><span class=\"number\">.2</span> <span class=\"comment\">//依賴項</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，Go modules 還生成和維護著一個名爲 <code>go.sum</code> 的文件，該文件包含了期望的指定模塊版本的內容的加密哈希。</p>\n<p>爲保證依賴的一致性，需要同時將 <code>go.mod</code> 和 <code>go.sum</code> 加入版本管理。</p>\n<p><strong>（2）更新依賴</strong></p>\n<p>更新小版本很簡單，一個 <code>go get</code> 命令就完了。更新大版本比更新小版本複雜，因爲大版本通常會帶來 API 的變化，Go 要求更改大版本號後，模塊名也要加上版本號。例如原本是 <code>rsc.io/quote</code> 的依賴，升級到 v3 後依賴要改成 <code>rsc.io/quote/v3</code> ，因此代碼中的 import 語句要改成 <code>rsc.io/quote/v3</code> ，然後清理掉舊版本的依賴，有點麻煩。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出當前項目的模塊和依賴項</span></span><br><span class=\"line\">go list -m all</span><br><span class=\"line\"><span class=\"comment\"># 直接更新到最新的小版本</span></span><br><span class=\"line\">go get rsc.io/sampler</span><br><span class=\"line\"><span class=\"comment\"># 列出所有小版本</span></span><br><span class=\"line\">go list -m -versions rsc.io/sampler</span><br><span class=\"line\"><span class=\"comment\"># 更新到指定版本</span></span><br><span class=\"line\">go get rsc.io/sampler@v1.3.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看模塊的所有版本</span></span><br><span class=\"line\">go list -m rsc.io/q...</span><br><span class=\"line\"><span class=\"comment\"># 清除未使用的依賴</span></span><br><span class=\"line\">go mod tidy</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循環依賴\"><a href=\"#循環依賴\" class=\"headerlink\" title=\"循環依賴\"></a>循環依賴</h3><p>Go 不支持循環依賴，Go設計者Rob Pike認爲如果出現兩個包循環依賴，那麼是你的設計問題。</p>\n<p>筆者就出現過一次循環依賴，場景是：封裝了一個打印日誌的庫A和一個解析配置的庫B，庫A需要通過庫B配置，庫B需要用庫A打印日誌。最後選擇在庫B使用原始的日誌打印。</p>\n<h2 id=\"語法\"><a href=\"#語法\" class=\"headerlink\" title=\"語法\"></a>語法</h2><h3 id=\"數據類型\"><a href=\"#數據類型\" class=\"headerlink\" title=\"數據類型\"></a>數據類型</h3><p><strong>（1）基本類型</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>  <span class=\"keyword\">int8</span>  <span class=\"keyword\">int16</span>  <span class=\"keyword\">int32</span>  <span class=\"keyword\">int64</span></span><br><span class=\"line\"><span class=\"keyword\">uint</span> <span class=\"keyword\">uint8</span> <span class=\"keyword\">uint16</span> <span class=\"keyword\">uint32</span> <span class=\"keyword\">uint64</span> <span class=\"keyword\">uintptr</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">byte</span> <span class=\"comment\">// uint8 的别名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">rune</span> <span class=\"comment\">// int32 的別名</span></span><br><span class=\"line\">    <span class=\"comment\">// 表示一個 Unicode 碼點</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">float32</span> <span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">complex64</span> <span class=\"keyword\">complex128</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 int, uint 和 uintptr 在 32 位系統上通常為 32 位寬，在 64 位系統上則為 64 位寬。</p>\n<p>string 表示一個 UTF-8 類型的字符串，底層是一個字節數組。</p>\n<p>rune 表示一個 Unicode 碼點，是 int32 的別名。讀取 string 中的每個字符，只需要將 string 轉爲 rune 數組即可</p>\n<p>Java 中的 char 類型，每個字符對應一個 Unicode 碼點，可以表示BMP範圍內（即[U+0000, U+FFFF]之間）的Unicode字符。String 是 UTF-8 類型。</p>\n<p><strong>（2）零值</strong></p>\n<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>\n<p>零值是：</p>\n<ul>\n<li>数值类型为 <code>0</code>，</li>\n<li>布尔类型为 <code>false</code>，</li>\n<li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li>\n</ul>\n<p><strong>（3）類型轉換</strong></p>\n<p>數值之間可以通過表達式 T(v) 將值 v 轉換為類型 T，如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">42</span></span><br><span class=\"line\">f := <span class=\"keyword\">float64</span>(i)</span><br><span class=\"line\">u := <span class=\"keyword\">uint</span>(f)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）类型推导</strong></p>\n<p>在聲明一個變量而不指定其類型時（即使用不帶類型的 := 語法或 var = 表達式語法），變量的類型由右值推導得出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">42</span>           <span class=\"comment\">// int</span></span><br><span class=\"line\">f := <span class=\"number\">3.142</span>        <span class=\"comment\">// float64</span></span><br><span class=\"line\">g := <span class=\"number\">0.867</span> + <span class=\"number\">0.5i</span> <span class=\"comment\">// complex128</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"變量\"><a href=\"#變量\" class=\"headerlink\" title=\"變量\"></a>變量</h3><p><strong>（1）聲明語句</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 開頭，逗號(,)分割變量名，最後寫數據類型 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c, python, java <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）賦值語句</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c, python, java = <span class=\"literal\">true</span>,<span class=\"literal\">false</span>,<span class=\"string\">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>或直接使用<strong>短變量聲明</strong>，注意短變量聲明只能在函數內使用，因爲函數外的每個語句要求必須以關鍵字開始。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">c, python, java := <span class=\"literal\">true</span>,<span class=\"literal\">false</span>,<span class=\"string\">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量聲明使用 const 關鍵字。常量可以是字符、字符串、布尔值或数值。常量不能用 <code>:=</code> 语法声明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Pi = <span class=\"number\">3.14</span></span><br></pre></td></tr></table></figure>\n\n<p><code>iota</code> 可以用來創建順序遞增的常量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  Low = <span class=\"literal\">iota</span> <span class=\"comment\">//0</span></span><br><span class=\"line\">  Medium     <span class=\"comment\">//1</span></span><br><span class=\"line\">  High       <span class=\"comment\">//2</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"風格\"><a href=\"#風格\" class=\"headerlink\" title=\"風格\"></a>風格</h3><ol>\n<li>每行程序結束後不需要撰寫分號（;）。</li>\n<li>大括號（{）不能夠換行放置。</li>\n<li>if判斷式和for循環不需要以小括號包覆起來。</li>\n<li>使用 tab 做排版</li>\n</ol>\n<h3 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h3><p><strong>（1）if-else</strong></p>\n<p>不需要小括號，可以使用簡短語句。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">_,ok := sendMsg();</span><br><span class=\"line\"><span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do other thing</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等價於以下簡短語句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> _,ok := sendMsg(); ok &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do other thing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）for</strong></p>\n<p>Go 中的 for 語句，還包含了其他語言的 while 的功能。特別的不用括號包裹。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 功能：遍歷 10 次</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：類似於其他語言 while 的功能</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i&lt;<span class=\"number\">10</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：無限循環，類似於其他語言中的 while(true)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：for range 循環，返回當前元素的下標及副本</span></span><br><span class=\"line\"><span class=\"comment\">// 可通過 _ 忽略其中的某個值</span></span><br><span class=\"line\">pow := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d,%d\\n&quot;</span>, i, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> _,v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）switch</strong></p>\n<p>Go 中的 switch 語句是自動 break 的。如果不想要break，需要在 case 後面協商 fallthrough。</p>\n<p>Go 中的 switch 的 case 無需為常量，且取值不必為整數。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 功能：選擇顏色</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> color &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> Red:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Green:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：替代 if-then-else，更整齊</span></span><br><span class=\"line\">result := request()</span><br><span class=\"line\"><span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> result := request(); &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）defer</strong></p>\n<p>defer 語句會將函數推遲到外層函數返回之後執行。</p>\n<p>推遲調用的函數其參數會立即求值，但直到外層函數返回前該函數都不會被調用。</p>\n<p>推遲的函數調用會被壓入一個棧中。當外層函數返回時，被推遲的函數會按照後進先出的順序調用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> fmt.Println(<span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>defer 並不是免費的。defer 底層會調用 <code>runtime.deferproc</code> 去設置要延遲調用的函數，調用 <code>runtime.deferreturn</code> 會依次執行先前延遲調用的函數。參考：<a href=\"https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32\">https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32</a></p>\n<h3 id=\"可見性\"><a href=\"#可見性\" class=\"headerlink\" title=\"可見性\"></a>可見性</h3><ul>\n<li>導出：大寫字母開頭的標識符，包外可訪問。</li>\n<li>未導出：非大寫字母開頭的標識符，包外不可訪問。</li>\n</ul>\n<h3 id=\"指針\"><a href=\"#指針\" class=\"headerlink\" title=\"指針\"></a>指針</h3><p>Go 擁有指針。指針保存了值的內存地址。</p>\n<ul>\n<li>類型 <code>*T</code> 是指向 <code>T</code> 類型值的指針。其零值為 <code>nil</code>。</li>\n<li><code>&amp;</code> 操作符會<strong>生成一個指向其操作數的指針</strong>。（注意：把<code>&amp;</code> 理解爲取地址符號是錯誤的）</li>\n<li><code>*</code> 操作符<strong>表示指針指向的底層值</strong>。（注意：把<code>*</code> 理解爲取值符號是錯誤的）</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  i, j := <span class=\"number\">42</span>, <span class=\"number\">2701</span></span><br><span class=\"line\"></span><br><span class=\"line\">  p := &amp;i         <span class=\"comment\">// 指向 i</span></span><br><span class=\"line\">  fmt.Println(*p) <span class=\"comment\">// 通過指針讀取 i 的值</span></span><br><span class=\"line\">  *p = <span class=\"number\">21</span>         <span class=\"comment\">// 通過指針設置 i 的值</span></span><br><span class=\"line\">  fmt.Println(i)  <span class=\"comment\">// 查看 i 的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  p = &amp;j         <span class=\"comment\">// 重定向到 j</span></span><br><span class=\"line\">  *p = *p / <span class=\"number\">37</span>   <span class=\"comment\">// 通過指針對 j 進行除法運算</span></span><br><span class=\"line\">  fmt.Println(j) <span class=\"comment\">// 查看 j 的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"結構體\"><a href=\"#結構體\" class=\"headerlink\" title=\"結構體\"></a>結構體</h3><p>一個結構體（struct）就是一組字段（field）。外界使用點號來訪問結構體字段。</p>\n<p>結構體字段可以通過結構體指針來訪問。如果我們有一個指向結構體的指針 p，那麼可以通過 <code>(*p).X</code> 來訪問其字段 X。不過這麼寫太囉嗦了，所以語言也允許我們使用<strong>隱式間接引用</strong>，直接寫 <code>p.X</code> 就可以。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">  v.X = <span class=\"number\">4</span></span><br><span class=\"line\">  fmt.Println(v.X)</span><br><span class=\"line\">  </span><br><span class=\"line\">  p := &amp;v</span><br><span class=\"line\">  p.X = <span class=\"number\">1e9</span></span><br><span class=\"line\">  fmt.Println(v)</span><br><span class=\"line\"></span><br><span class=\"line\">  v2 = Vertex&#123;X: <span class=\"number\">1</span>&#125;  <span class=\"comment\">// Y:0 被隱式地賦予</span></span><br><span class=\"line\">  v3 = Vertex&#123;&#125;      <span class=\"comment\">// X:0 Y:0</span></span><br><span class=\"line\">  p  = &amp;Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// 創建一個 *Vertex 類型的結構體（指針）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"數組\"><a href=\"#數組\" class=\"headerlink\" title=\"數組\"></a>數組</h3><p>類型 [n]T 表示擁有 n 個 T 類型的值的數組。</p>\n<p>表达式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">10</span>]<span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure>\n\n<p>會將變量 <code>a</code> 聲明為擁有 10 個整數的數組。</p>\n<h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><p><strong>（1）定義</strong></p>\n<p>類型 []T 表示一個元素類型為 T 的切片。T 可以是任何類型，包括切片本身。</p>\n<p>切片通過兩個下標來界定，即一個上界和一個下界，二者以冒號分隔：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a[low : high]</span><br></pre></td></tr></table></figure>\n\n<p>它會選擇一個半開區間，包括第一個元素，但排除最後一個元素。</p>\n<p>切片下界的默認值爲 0，上界則是其底層數組的長度。</p>\n<p>對於數組 <code>var a [10]int</code> 來說，以下切片是等價的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a[<span class=\"number\">0</span>:<span class=\"number\">10</span>]</span><br><span class=\"line\">a[:<span class=\"number\">10</span>]</span><br><span class=\"line\">a[<span class=\"number\">0</span>:]</span><br><span class=\"line\">a[:]</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）切片的本質</strong></p>\n<p>一個切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量，其結構如下：</p>\n<p><img src=\"/it/go/go-basic/Untitled.png\" alt></p>\n<p><img src=\"/it/go/go-basic/Untitled%201.png\" alt></p>\n<p>切片的長度就是它所包含的元素個數。<br>切片的容量是從它的第一個元素開始數，到其底層數組元素末尾的個數。<br>切片 s 的長度和容量可通過表達式 <code>len(s)</code> 和 <code>cap(s)</code> 來獲取。</p>\n<p>更改切片的元素會修改其底層數組中對應的元素。與它共享底層數組的切片都會觀測到這些修改。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  names := [<span class=\"number\">4</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;John&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Paul&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;George&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Ringo&quot;</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(names)</span><br><span class=\"line\"></span><br><span class=\"line\">  a := names[<span class=\"number\">0</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\">  b := names[<span class=\"number\">1</span>:<span class=\"number\">3</span>]</span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">  b[<span class=\"number\">0</span>] = <span class=\"string\">&quot;XXX&quot;</span></span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\">  fmt.Println(names)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：切片的零值爲 nil，其長度和容量爲 0 且沒有底層數組。</p>\n<p><strong>（3）通過 make 創建切片</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">5</span>)  <span class=\"comment\">// len(a)=5</span></span><br><span class=\"line\">b := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>) <span class=\"comment\">// len(b)=0, cap(b)=5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）通過 append 追加元素</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">append</span><span class=\"params\">(s []T, vs ...T)</span> []<span class=\"title\">T</span></span></span><br></pre></td></tr></table></figure>\n\n<p><code>append</code> 的第一個參數 <code>s</code> 是一個元素類型為 <code>T</code> 的切片，其餘類型為 <code>T</code>的值將會追加到該切片的末尾。</p>\n<p><code>append</code> 的結果是一個包含原切片所有元素加上新添加元素的切片。</p>\n<p>當 <code>s</code> 的底層數組太小，不足以容納所有給定的值時，它就會分配一個更大的數組。返回的切片會指向這個新分配的數組。</p>\n<p>當引用一個原始數組時，GC不會釋放該數組的空間，即使只用到其中一小部分數據。因此函數返回切片的時候要特別注意，最好拷貝需要數據到新的切片再返回。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 copy 函數</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyDigits</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">    b, _ := ioutil.ReadFile(filename)</span><br><span class=\"line\">    b = digitRegexp.Find(b)</span><br><span class=\"line\">    c := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(b))</span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(c, b)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或使用 append 函數</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyDigits</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">    b, _ := ioutil.ReadFile(filename)</span><br><span class=\"line\">    b = digitRegexp.Find(b)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c []<span class=\"keyword\">byte</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">append</span>(c, b...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>映射將鍵映射到值。</p>\n<p>映射的零值為 <code>nil</code> 。<code>nil</code> 映射既沒有鍵，也不能添加鍵。</p>\n<p><code>make</code> 函數會返回給定類型的映射，並將其初始化備用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Lat, Long <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Vertex&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;Bell Labs&quot;</span>: &#123;<span class=\"number\">40.68433</span>, <span class=\"number\">-74.39967</span>&#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;Google&quot;</span>:    &#123;<span class=\"number\">37.42202</span>, <span class=\"number\">-122.08408</span>&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 常用操作：</p>\n<ol>\n<li>插入或修改元素：<code>m[key] = elem</code></li>\n<li>獲取元素：<code>elem = m[key]</code></li>\n<li>通過雙賦值檢測某個鍵是否存在：<code>elem, ok := m[key]</code></li>\n<li>刪除元素：<code>delete(m, key)</code></li>\n</ol>\n<h3 id=\"函數-function\"><a href=\"#函數-function\" class=\"headerlink\" title=\"函數(function)\"></a>函數(function)</h3><p><strong>（1）概述</strong></p>\n<p>函數可以沒有參數或接受多個參數。當連續兩個或多個函數的已命名形參類型相同時，除最後一個類型以外，其它都可以省略。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(add(<span class=\"number\">42</span>, <span class=\"number\">13</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）命名返回值</strong></p>\n<p>Go 的返回值可被命名，它們會被視作<strong>定義在函數頂部的變量</strong>。返回值的名稱應當具有一定的意義，它可以作為文檔使用。沒有參數的 <code>return</code> 語句返回已命名的返回值。也就是 <code>直接</code> 返回。直接返回語句應當僅用在下面這樣的短函數中。在長的函數中它們會影響代碼的可讀性。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">split</span><span class=\"params\">(sum <span class=\"keyword\">int</span>)</span> <span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x = sum * <span class=\"number\">4</span> / <span class=\"number\">9</span></span><br><span class=\"line\">  y = sum - x</span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(split(<span class=\"number\">17</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）多值返回</strong></p>\n<p>函數可以返回任意數量的返回值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  a, b := swap(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）函數值</strong></p>\n<p>函數也是值，可以作爲函數的參數或返回值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compute</span><span class=\"params\">(fn <span class=\"keyword\">func</span>(<span class=\"keyword\">float64</span>, <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span>) <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(compute(math.Pow))</span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）閉包(closure)</strong></p>\n<p>閉包是指一個函數引用了其函數體之外的變量，該函數可以訪問並賦予其引用的變量的值。換句話說就是該函數跟函數體之外的變量綑綁在一起了。每次調用閉包中的函數可以改變閉包中變量的值。例如斐波那契閉包：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  x,y := <span class=\"number\">0</span>,<span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    res := x</span><br><span class=\"line\">    x,y = y,x+y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  f := fibonacci()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    fmt.Println(f())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法-method\"><a href=\"#方法-method\" class=\"headerlink\" title=\"方法(method)\"></a>方法(method)</h3><p>方法就是一類帶特殊的<strong>接收者參數</strong>的函數。方法接收者在它自己的參數列表內，<strong>位於 func 關鍵字和方法名之間</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 這就是方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span> <span class=\"title\">Abs</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">  fmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是：接收者的類型定義和方法聲明必須在同一包內；不能爲內建類型聲明方法。</p>\n<p>接收者除了是<strong>值接收者</strong>外，還支持<strong>指針接收者</strong>，使用 <code>*T</code> (不能是 <code>*int</code> 之類的) 的文法即可。指針接收者可以修改接收者指向的值。如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span> <span class=\"title\">Abs</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span> <span class=\"title\">Scale</span><span class=\"params\">(f <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">  v.X = v.X * f</span><br><span class=\"line\">  v.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">  v.Scale(<span class=\"number\">10</span>) <span class=\"comment\">// 此時 Go 會解釋爲 (&amp;v).Scale(10)，這就是指針重定向</span></span><br><span class=\"line\">  fmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用指針接收者的好處：</p>\n<ol>\n<li>方法能夠修改其接收者指向的值。</li>\n<li>避免在每次調用方法時複製該值。該值佔用的空間越大，則越顯得高效。</li>\n</ol>\n<p>注意：一個結構體採用值接收者的方式實現了接口的方法，則隱含著採用指針接收者的方式實現了接口的方法。（接收者是指針類型的方法，很可能在方法中會對接收者的屬性進行更改操作，從而影響接收者；而對於接收者是值類型的方法，在方法中不會對接收者本身產生影響）</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p><strong>（1）定義</strong></p>\n<p>接口類型是<strong>由一組方法簽名定義的集合</strong>。接口類型的變量可以保存<strong>任何</strong>實現了這些方法的值。</p>\n<p><strong>（2）隱式實現</strong></p>\n<p>類型通過實現一個接口的所有方法來實現該接口。既然無需專門顯式聲明，也就沒有「implements」關鍵字。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  eat()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> John <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;eat...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  eat()</span><br><span class=\"line\">  talk()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">talk</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;talk...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a Animal = &amp;John&#123;&#125;</span><br><span class=\"line\">  a.eat()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b Person = &amp;John&#123;&#125;</span><br><span class=\"line\">  b.eat()</span><br><span class=\"line\">  b.talk()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）接口值</strong></p>\n<p>接口也是值，可以作爲函數的參數或返回值。在內部，接口值可以看做包含值和具體類型的元組：<code>(value, type)</code> 。接口值保存了一個具體底層類型的具體值。接口值調用方法時會執行其底層類型的同名方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Animal、John 見上面的代碼</span></span><br><span class=\"line\">j := John&#123;&#125;</span><br><span class=\"line\">describe(j)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i Animal)</span></span>&#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）底層值爲 nil 的接口值</strong></p>\n<p>即便接口內的具體值為 nil，方法仍然會被 nil 接收者調用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 改造上面的代碼</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">talk</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> j == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;j is &lt;nil&gt;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;talk...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x Person</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y John</span><br><span class=\"line\">  x = &amp;y</span><br><span class=\"line\">  describe(x)</span><br><span class=\"line\">  x.talk() <span class=\"comment\">// 正常調用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判斷接口的底層值是否爲 nil 的方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接上</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>( x == <span class=\"literal\">nil</span> || reflect.ValueOf(x).IsNil())</span><br></pre></td></tr></table></figure>\n\n<p><strong>（6）nil 接口值</strong></p>\n<p>nil 接口值既不保存值也不保存具體類型。</p>\n<p>為 nil 接口調用方法會產生運行時錯誤，因為接口的元組內並未包含能夠指明該調用哪個 <strong>具體</strong> 方法的類型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  M()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i I</span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\">  i.M() <span class=\"comment\">// 此處拋出 panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i I)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i) <span class=\"comment\">// (&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（7）空接口</strong></p>\n<p>指定了<strong>零個方法</strong>的接口值被稱為空接口，即 <code>interface&#123;&#125;</code> 。空接口可保存任何類型的值。（因為每個類型都至少實現了零個方法。）空接口被用來處理未知類型的值。例如，<code>fmt.Print</code> 可接受類型為 <code>interface&#123;&#125;</code> 的任意數量的參數。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">  i = <span class=\"number\">42</span> <span class=\"comment\">// 保存 int值</span></span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">  i = <span class=\"string\">&quot;hello&quot;</span> <span class=\"comment\">// 保存 string值</span></span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（8）類型斷言</strong></p>\n<p>類型斷言提供了訪問<strong>接口值底層具體值</strong>的方式。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判斷接口i的底層值類型是否爲T，如是返回其底層值和true，否則返回T類型的零值和false</span></span><br><span class=\"line\">t, ok := i.(T)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">s, ok := i.(<span class=\"keyword\">string</span>)</span><br><span class=\"line\">fmt.Println(s, ok)</span><br><span class=\"line\">f, ok := i.(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">fmt.Println(f, ok)</span><br><span class=\"line\"><span class=\"comment\">// 支持類型選擇</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">do</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> v := i.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"keyword\">int</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;Twice %v is %v\\n&quot;</span>, v, v*<span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"keyword\">string</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%q is %v bytes long\\n&quot;</span>, v, <span class=\"built_in\">len</span>(v))</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;I don&#x27;t know about type %T!\\n&quot;</span>, v)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"異常處理\"><a href=\"#異常處理\" class=\"headerlink\" title=\"異常處理\"></a>異常處理</h3><p>Go 程序使用 <code>error</code> 值來表示錯誤狀態。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Error() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常函數會返回一個 <code>error</code> 值，調用的它的代碼應當判斷這個錯誤是否等於 <code>nil</code> 來進行錯誤處理。<code>error</code> 為 nil 時表示成功；非 nil 的 <code>error</code> 表示失敗。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> i, err := strconv.Atoi(<span class=\"string\">&quot;42&quot;</span>); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Converted integer:&quot;</span>, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Go-程-goroutine\"><a href=\"#Go-程-goroutine\" class=\"headerlink\" title=\"Go 程(goroutine)\"></a>Go 程(goroutine)</h3><p><strong>（1）定義</strong></p>\n<p><strong>Go 程（goroutine）是由 Go 運行時管理的輕量級線程</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x,y,z 的求值發生在當前 Go 程中，f 的執行則是在新的 Go 程中</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> f(x, y, z)</span><br></pre></td></tr></table></figure>\n\n<p>（<strong>2）信道</strong></p>\n<p><strong>信道是帶有類型的管道</strong>，你可以通過它用<strong>信道操作符</strong> <code>&lt;-</code> (箭頭就是數據流的方向)來發送或者接收值。</p>\n<p>默認情況下，發送和接收操作在另一端準備好之前都會阻塞。這使得 Go 程可以在沒有顯式的鎖或競態變量的情況下進行同步。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 創建信道</span></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">// 將 v 發送至信道 ch。</span></span><br><span class=\"line\">ch &lt;- v</span><br><span class=\"line\"><span class=\"comment\">// 從 ch 接收值並賦予 v。</span></span><br><span class=\"line\">v := &lt;-ch</span><br></pre></td></tr></table></figure>\n\n<p><strong>信道可以是帶緩衝，</strong>將緩衝長度作為第二個參數提供給 <code>make</code> 來初始化一個帶緩衝的信道。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>僅當信道的緩衝區填滿後，向其發送數據時才會阻塞。當緩衝區為空時，接受方會阻塞。</strong></p>\n<p><strong>（3）range 和 close</strong></p>\n<p>有且僅有發送者可以通過 close 方法關閉一個信道。接收者讀取值的時候可以通過 <code>v, ok := &lt;-ch</code>  的 ok 值判斷是否信道關閉了。更簡單的是使用 for-range 不斷從信道接收值，直到信道關閉，循環自動退出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(n <span class=\"keyword\">int</span>, c <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">    c &lt;- x</span><br><span class=\"line\">    x, y = y, x+y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> fibonacci(<span class=\"built_in\">cap</span>(c), c)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> c &#123;</span><br><span class=\"line\">    fmt.Println(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）select</strong></p>\n<p>select 語句使一個 Go 程可以等待多個通信操作。select 會阻塞到某個分支可以繼續執行為止，這時就會執行該分支。當多個分支都準備好時會隨機選擇一個執行。當 select 中的其它分支都沒有準備好時，default 分支就會執行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(c, quit <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> c &lt;- x:</span><br><span class=\"line\">      x, y = y, x+y</span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;-quit:</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">&quot;quit&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 當 c 和 quit 阻塞時會執行到此處</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  quit := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">      fmt.Println(&lt;-c)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    quit &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  fibonacci(c, quit)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>練習：等價二叉查找樹</p>\n<p>  函數 tree.New(k) 用於構造一個隨機結構的已排序二叉查找樹，它保存了值 k, 2k, 3k, …, 10k。</p>\n<p>  Walk 步進 tree t 將所有的值從 tree 發送到 channel ch。</p>\n<p>  用 Walk 實現 Same 函數來檢測 t1 和 t2 是否存儲了相同的值。</p>\n  <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;golang.org/x/tour/tree&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Walk</span><span class=\"params\">(t *tree.Tree, ch <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> t.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    Walk(t.Left, ch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ch &lt;- t.Value</span><br><span class=\"line\">  <span class=\"keyword\">if</span> t.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    Walk(t.Right, ch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Same 检测树 t1 和 t2 是否含有相同的值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Same</span><span class=\"params\">(t1, t2 *tree.Tree)</span> <span class=\"title\">bool</span></span>&#123;</span><br><span class=\"line\">  ch1,ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>),<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Walk(t1, ch1)</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch1)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Walk(t2, ch2)</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch2)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> ch1&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i != &lt;-ch2 &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(Same(tree.New(<span class=\"number\">1</span>),tree.New(<span class=\"number\">1</span>)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（5）sync.Mutex</strong></p>\n<p>互斥鎖可以保證每次只有一個 Go 程訪問一個共享變量。</p>\n<p>Go 標準庫中的 <strong>Mutex</strong> 就是一個互斥鎖，可以創建為其他結構體的字段；零值為解鎖狀態。Mutex類型的鎖和線程無關，可以由不同的線程加鎖和解鎖。在代碼前調用 Lock 方法，並在代碼後調用 Unlock 方法來保證一段代碼互斥執行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.Unlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>爲了提升讀寫性能，常用 <strong>RWMutex</strong> 代替 <strong>Mutex。</strong>RWMutex是讀寫互斥鎖。該鎖可以被同時多個讀取者持有或唯一個寫入者持有。RWMutex可以創建為其他結構體的字段；零值為解鎖狀態。RWMutex類型的鎖也和線程無關，可以由不同的線程加讀取鎖/寫入和解讀取鎖/寫入鎖。</p>\n<p>下面的代碼效果不明顯，因爲讀的次數不多。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.RLock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.RUnlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  now := time.Now()</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(time.Now().Sub(now))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（6）WaitGroup</strong></p>\n<p>WaitGroup 可以等待一組 Go 程結束。通過調用 Add 方法設定要等待的 Go 程數量。然後各個 Go 程通過調用 Done 方法結束等待。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  wg.Done()</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.RLock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.RUnlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1000</span>)</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>, &amp;wg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Go 又稱 Golang，是 Google 公司 2009 年發佈的一款開源編程語言，以簡潔而高效的代碼著稱。Go 目前使用 GOPATH 或 Go modules 管理項目中的第三方依賴，且不支持循環依賴。</p>\n<p>Go 的基本數據類型有 16 種(不包含別名)，可謂豐富。要注意的是 string 也是基本數據類型，表示一個 UTF-8 字符串，底層是 byte 數組。單個字符使用一個 int32 的別名 rune 表示，其值爲 Unicode 字符碼點。</p>\n<p>Go 的變量使用 var 關鍵字聲明，也可以使用短變量聲明；常量則是使用 const 關鍵字聲明。</p>\n<p>Go 有 if 條件語句、for 循環語句、switch 選擇語句和 defer 延遲執行語句。Go 的 for 語句兼具其他語言的 while 語句；switch 語句每個 case 條件都支持運算，且默認自動 break；defer 語句可以立即計算參數值，然後在函數 return 前執行。</p>\n<p>Go 的可見性跟標識符的首字母是否大寫相關，大寫則是導出的，包外可見；小寫則是非導出的，包外不可見。</p>\n<p>Go 有指針，要注意 <code>&amp;</code> 是生成指向操作數的指針，而 <code>*</code> 是獲取指針指向的底層值。</p>\n<p>Go 將一些字段組合成一個結構體(struct) 。結構體支持隱式間接調用，即 p.X 等價於 (*p).X（p 爲結構體指針）。</p>\n<p>Go 支持數組，更重要的是支持一種名爲切片(slice) 的動態數組。切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量。</p>\n<p>Go 支持映射(map)。</p>\n<p>Go 支持函數(function)的命名返回值、多值返回、作爲值傳遞和閉包。還有一種稱爲方法(method)的特殊函數，其帶有接收者參數，接收者可以是值接收者也可以是指針接收者，指針接收者可以更改接收者的值。</p>\n<p>Go 支持將一些方法簽名組成接口(interface)。接口的實現是隱式的，不需要「implements」。一個結構體作爲接收者定義了接口中的所有方法，那麼該結構體就是實現了該接口。因爲隱式的緣故，建議接口方法盡可能少，以便管理。接口是值，可以傳遞。底層值是 nil 的接口，其方法可以被調用；接口本身爲 nil ，則意味著其不保存值也不保存具體類型；空接口(interface{})是包含零個函數的接口，不是爲 nil 接口。</p>\n<p>Go 的異常處理很簡單，只有 Error，沒有 throws。</p>\n<p>Go 支持 Go 程，一種 Go運行時管理的輕量級線程。Go 程之間可以通過信道(channel) 通信，通過 Mutex 或 RWMutex 共享互斥變量，通過 WaitGroup 等待執行完成。 </p>\n<p>Go 中的信道還支持通過 for-range 循環讀取數據，當信道關閉時該循環自動退出。記住，只有發送方可以關閉信道，接收方不能。信道還支持 select 語句，其會<strong>阻塞到某一分支可以執行爲止</strong>，如沒有分支可以執行且設定了default 語句，會一直執行 default 語句。</p>","more":"<p>以下內容多來自<a href=\"https://tour.go-zh.org/\">《Go 指南》</a>，內容有所改動。</p>\n<h2 id=\"歷史\"><a href=\"#歷史\" class=\"headerlink\" title=\"歷史\"></a>歷史</h2><p>Go 又稱 Golang，是 Google 公司開發的一款靜態強類型、編譯型、並發型，並具有垃圾回收功能的編程語言。</p>\n<ol>\n<li>2007.9.21 罗伯特·格瑞史莫(Robert Griesemer)、罗勃·派克(Rob Pike)和肯·汤普逊(Ken Thompson) 開始設計 Go。</li>\n<li>2009.11 Google 發佈 Go 語言。</li>\n<li>2012.3 Go 1.0 發佈。</li>\n<li>2018.8 Go 1.11 發佈，預支持 modules 進行依賴管理。</li>\n</ol>\n<h2 id=\"入門\"><a href=\"#入門\" class=\"headerlink\" title=\"入門\"></a>入門</h2><h3 id=\"安裝\"><a href=\"#安裝\" class=\"headerlink\" title=\"安裝\"></a>安裝</h3><p>按照<a href=\"https://golang.org/doc/install\">官方教程</a>安裝即可。</p>\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>直接在系統 Home 目錄，新建一一個 hello.go 文件，寫入代碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main <span class=\"comment\">//程序從 main 包的 main 函數開始運行</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span> <span class=\"comment\">//導入 fmt 包</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//main函數</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Hello, World!&quot;</span>) <span class=\"comment\">//打印日誌</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然後執行 <code>go run hello.go</code> 即可。</p>\n<h3 id=\"GOPATH\"><a href=\"#GOPATH\" class=\"headerlink\" title=\"GOPATH\"></a>GOPATH</h3><p>當項目未啟用 Go modules 時，Go 使用 <code>GOPATH</code> 環境變量解析 import 語句。<code>GOPATH</code> 的值默認爲 <code>$HOME/go</code> ， <code>GOPATH</code> 目錄結構如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">GOPATH=/home/user/<span class=\"keyword\">go</span></span><br><span class=\"line\"></span><br><span class=\"line\">src/</span><br><span class=\"line\">    foo/</span><br><span class=\"line\">        bar/               (<span class=\"keyword\">go</span> code in <span class=\"keyword\">package</span> bar)</span><br><span class=\"line\">            x.<span class=\"keyword\">go</span></span><br><span class=\"line\">        quux/              (<span class=\"keyword\">go</span> code in <span class=\"keyword\">package</span> main)</span><br><span class=\"line\">            y.<span class=\"keyword\">go</span></span><br><span class=\"line\">bin/</span><br><span class=\"line\">    quux                   (installed command)</span><br><span class=\"line\">pkg/</span><br><span class=\"line\">    linux_amd64/</span><br><span class=\"line\">        foo/</span><br><span class=\"line\">            bar.a          (installed <span class=\"keyword\">package</span> object)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>src：存放依賴的源代碼</li>\n<li>bin：存放安裝的命令</li>\n<li>pkg：存法安裝的包對象</li>\n</ul>\n<p>啟用 Go modules 後雖然不通過 <code>GOPATH</code> 解析 import 語句，但下載的源代碼和安裝的命令都會存在<code>GOPATH</code>目錄下。</p>\n<h3 id=\"Vendor\"><a href=\"#Vendor\" class=\"headerlink\" title=\"Vendor\"></a>Vendor</h3><p>Vendor 就是使用本地依賴包的模式，Go 1.5 作爲實驗特性，Go 1.6 正式支持，Go 1.14 正式終結。命名爲 vender(小商販) 是一種比喻，並將 GOPATH 隱喻爲有固定地址的商舖。啟用 Vendor 模式很簡單，在項目中創建一個名爲 vendor 的文件夾然後拷貝依賴的源代碼進入其中即可。比如有如下的項目使用了 Vendor：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">$GOPATH</span><br><span class=\"line\">|\tsrc/</span><br><span class=\"line\">|\t|\tgithub.com/constabulary/example-gsftp/</span><br><span class=\"line\">|\t|\t|\tcmd/</span><br><span class=\"line\">|\t|\t|\t|\tgsftp/</span><br><span class=\"line\">|\t|\t|\t|\t|\tmain.<span class=\"keyword\">go</span></span><br><span class=\"line\">|\t|\t|\tvendor/</span><br><span class=\"line\">|\t|\t|\t|\tgithub.com/pkg/sftp/</span><br><span class=\"line\">|\t|\t|\t|\tgolang.org/x/crypto/ssh/</span><br><span class=\"line\">|\t|\t|\t|\t|\tagent/</span><br></pre></td></tr></table></figure>\n\n<p>在文件 <code>github.com/constabulary/example-gsftp/cmd/gsftp/main.go</code> 中應這樣 import 依賴（不需要加入 vendor 前綴）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"string\">&quot;golang.org/x/crypto/ssh&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;golang.org/x/crypto/ssh/agent&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/pkg/sftp&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>這種方式顯然會帶來代碼膨脹，特別是N個庫同時用 Vendor 模式依賴一個通用庫時，那麼該通用庫的代碼將會出現N次。</p>\n<h3 id=\"Go-modules\"><a href=\"#Go-modules\" class=\"headerlink\" title=\"Go modules\"></a>Go modules</h3><p>Go 官方推出的依賴管理系統，在 Go 1.11 和 1.12中已經有初步支持，但默認關閉；從 1.13 開始默認啟用，1.14 開始可用於生產。</p>\n<p><strong>（1）使用 Go modules</strong></p>\n<p>使用 Go modules 很簡單，只需要在項目根路徑(不可以在 <code>$GOPATH/src</code> 裏面)執行 <code>go mod init example.com/m</code> 即可初始化一個名爲 <code>example.com/m</code> 的模塊，之後會在項目根路徑生成一個名爲 <code>go.mod</code> 的依賴文件，其內容結構如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">module example.com/hello <span class=\"comment\">//模塊名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"number\">1.12</span> <span class=\"comment\">//使用的 Go 版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">require rsc.io/quote v1<span class=\"number\">.5</span><span class=\"number\">.2</span> <span class=\"comment\">//依賴項</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，Go modules 還生成和維護著一個名爲 <code>go.sum</code> 的文件，該文件包含了期望的指定模塊版本的內容的加密哈希。</p>\n<p>爲保證依賴的一致性，需要同時將 <code>go.mod</code> 和 <code>go.sum</code> 加入版本管理。</p>\n<p><strong>（2）更新依賴</strong></p>\n<p>更新小版本很簡單，一個 <code>go get</code> 命令就完了。更新大版本比更新小版本複雜，因爲大版本通常會帶來 API 的變化，Go 要求更改大版本號後，模塊名也要加上版本號。例如原本是 <code>rsc.io/quote</code> 的依賴，升級到 v3 後依賴要改成 <code>rsc.io/quote/v3</code> ，因此代碼中的 import 語句要改成 <code>rsc.io/quote/v3</code> ，然後清理掉舊版本的依賴，有點麻煩。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出當前項目的模塊和依賴項</span></span><br><span class=\"line\">go list -m all</span><br><span class=\"line\"><span class=\"comment\"># 直接更新到最新的小版本</span></span><br><span class=\"line\">go get rsc.io/sampler</span><br><span class=\"line\"><span class=\"comment\"># 列出所有小版本</span></span><br><span class=\"line\">go list -m -versions rsc.io/sampler</span><br><span class=\"line\"><span class=\"comment\"># 更新到指定版本</span></span><br><span class=\"line\">go get rsc.io/sampler@v1.3.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看模塊的所有版本</span></span><br><span class=\"line\">go list -m rsc.io/q...</span><br><span class=\"line\"><span class=\"comment\"># 清除未使用的依賴</span></span><br><span class=\"line\">go mod tidy</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循環依賴\"><a href=\"#循環依賴\" class=\"headerlink\" title=\"循環依賴\"></a>循環依賴</h3><p>Go 不支持循環依賴，Go設計者Rob Pike認爲如果出現兩個包循環依賴，那麼是你的設計問題。</p>\n<p>筆者就出現過一次循環依賴，場景是：封裝了一個打印日誌的庫A和一個解析配置的庫B，庫A需要通過庫B配置，庫B需要用庫A打印日誌。最後選擇在庫B使用原始的日誌打印。</p>\n<h2 id=\"語法\"><a href=\"#語法\" class=\"headerlink\" title=\"語法\"></a>語法</h2><h3 id=\"數據類型\"><a href=\"#數據類型\" class=\"headerlink\" title=\"數據類型\"></a>數據類型</h3><p><strong>（1）基本類型</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>  <span class=\"keyword\">int8</span>  <span class=\"keyword\">int16</span>  <span class=\"keyword\">int32</span>  <span class=\"keyword\">int64</span></span><br><span class=\"line\"><span class=\"keyword\">uint</span> <span class=\"keyword\">uint8</span> <span class=\"keyword\">uint16</span> <span class=\"keyword\">uint32</span> <span class=\"keyword\">uint64</span> <span class=\"keyword\">uintptr</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">byte</span> <span class=\"comment\">// uint8 的别名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">rune</span> <span class=\"comment\">// int32 的別名</span></span><br><span class=\"line\">    <span class=\"comment\">// 表示一個 Unicode 碼點</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">float32</span> <span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">complex64</span> <span class=\"keyword\">complex128</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 int, uint 和 uintptr 在 32 位系統上通常為 32 位寬，在 64 位系統上則為 64 位寬。</p>\n<p>string 表示一個 UTF-8 類型的字符串，底層是一個字節數組。</p>\n<p>rune 表示一個 Unicode 碼點，是 int32 的別名。讀取 string 中的每個字符，只需要將 string 轉爲 rune 數組即可</p>\n<p>Java 中的 char 類型，每個字符對應一個 Unicode 碼點，可以表示BMP範圍內（即[U+0000, U+FFFF]之間）的Unicode字符。String 是 UTF-8 類型。</p>\n<p><strong>（2）零值</strong></p>\n<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>\n<p>零值是：</p>\n<ul>\n<li>数值类型为 <code>0</code>，</li>\n<li>布尔类型为 <code>false</code>，</li>\n<li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li>\n</ul>\n<p><strong>（3）類型轉換</strong></p>\n<p>數值之間可以通過表達式 T(v) 將值 v 轉換為類型 T，如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">42</span></span><br><span class=\"line\">f := <span class=\"keyword\">float64</span>(i)</span><br><span class=\"line\">u := <span class=\"keyword\">uint</span>(f)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）类型推导</strong></p>\n<p>在聲明一個變量而不指定其類型時（即使用不帶類型的 := 語法或 var = 表達式語法），變量的類型由右值推導得出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">42</span>           <span class=\"comment\">// int</span></span><br><span class=\"line\">f := <span class=\"number\">3.142</span>        <span class=\"comment\">// float64</span></span><br><span class=\"line\">g := <span class=\"number\">0.867</span> + <span class=\"number\">0.5i</span> <span class=\"comment\">// complex128</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"變量\"><a href=\"#變量\" class=\"headerlink\" title=\"變量\"></a>變量</h3><p><strong>（1）聲明語句</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 開頭，逗號(,)分割變量名，最後寫數據類型 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c, python, java <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）賦值語句</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c, python, java = <span class=\"literal\">true</span>,<span class=\"literal\">false</span>,<span class=\"string\">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>或直接使用<strong>短變量聲明</strong>，注意短變量聲明只能在函數內使用，因爲函數外的每個語句要求必須以關鍵字開始。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">c, python, java := <span class=\"literal\">true</span>,<span class=\"literal\">false</span>,<span class=\"string\">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量聲明使用 const 關鍵字。常量可以是字符、字符串、布尔值或数值。常量不能用 <code>:=</code> 语法声明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Pi = <span class=\"number\">3.14</span></span><br></pre></td></tr></table></figure>\n\n<p><code>iota</code> 可以用來創建順序遞增的常量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  Low = <span class=\"literal\">iota</span> <span class=\"comment\">//0</span></span><br><span class=\"line\">  Medium     <span class=\"comment\">//1</span></span><br><span class=\"line\">  High       <span class=\"comment\">//2</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"風格\"><a href=\"#風格\" class=\"headerlink\" title=\"風格\"></a>風格</h3><ol>\n<li>每行程序結束後不需要撰寫分號（;）。</li>\n<li>大括號（{）不能夠換行放置。</li>\n<li>if判斷式和for循環不需要以小括號包覆起來。</li>\n<li>使用 tab 做排版</li>\n</ol>\n<h3 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h3><p><strong>（1）if-else</strong></p>\n<p>不需要小括號，可以使用簡短語句。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">_,ok := sendMsg();</span><br><span class=\"line\"><span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do other thing</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等價於以下簡短語句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> _,ok := sendMsg(); ok &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do other thing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）for</strong></p>\n<p>Go 中的 for 語句，還包含了其他語言的 while 的功能。特別的不用括號包裹。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 功能：遍歷 10 次</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：類似於其他語言 while 的功能</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i&lt;<span class=\"number\">10</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：無限循環，類似於其他語言中的 while(true)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：for range 循環，返回當前元素的下標及副本</span></span><br><span class=\"line\"><span class=\"comment\">// 可通過 _ 忽略其中的某個值</span></span><br><span class=\"line\">pow := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d,%d\\n&quot;</span>, i, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> _,v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）switch</strong></p>\n<p>Go 中的 switch 語句是自動 break 的。如果不想要break，需要在 case 後面協商 fallthrough。</p>\n<p>Go 中的 switch 的 case 無需為常量，且取值不必為整數。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 功能：選擇顏色</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> color &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> Red:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Green:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：替代 if-then-else，更整齊</span></span><br><span class=\"line\">result := request()</span><br><span class=\"line\"><span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> result := request(); &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）defer</strong></p>\n<p>defer 語句會將函數推遲到外層函數返回之後執行。</p>\n<p>推遲調用的函數其參數會立即求值，但直到外層函數返回前該函數都不會被調用。</p>\n<p>推遲的函數調用會被壓入一個棧中。當外層函數返回時，被推遲的函數會按照後進先出的順序調用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> fmt.Println(<span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>defer 並不是免費的。defer 底層會調用 <code>runtime.deferproc</code> 去設置要延遲調用的函數，調用 <code>runtime.deferreturn</code> 會依次執行先前延遲調用的函數。參考：<a href=\"https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32\">https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32</a></p>\n<h3 id=\"可見性\"><a href=\"#可見性\" class=\"headerlink\" title=\"可見性\"></a>可見性</h3><ul>\n<li>導出：大寫字母開頭的標識符，包外可訪問。</li>\n<li>未導出：非大寫字母開頭的標識符，包外不可訪問。</li>\n</ul>\n<h3 id=\"指針\"><a href=\"#指針\" class=\"headerlink\" title=\"指針\"></a>指針</h3><p>Go 擁有指針。指針保存了值的內存地址。</p>\n<ul>\n<li>類型 <code>*T</code> 是指向 <code>T</code> 類型值的指針。其零值為 <code>nil</code>。</li>\n<li><code>&amp;</code> 操作符會<strong>生成一個指向其操作數的指針</strong>。（注意：把<code>&amp;</code> 理解爲取地址符號是錯誤的）</li>\n<li><code>*</code> 操作符<strong>表示指針指向的底層值</strong>。（注意：把<code>*</code> 理解爲取值符號是錯誤的）</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  i, j := <span class=\"number\">42</span>, <span class=\"number\">2701</span></span><br><span class=\"line\"></span><br><span class=\"line\">  p := &amp;i         <span class=\"comment\">// 指向 i</span></span><br><span class=\"line\">  fmt.Println(*p) <span class=\"comment\">// 通過指針讀取 i 的值</span></span><br><span class=\"line\">  *p = <span class=\"number\">21</span>         <span class=\"comment\">// 通過指針設置 i 的值</span></span><br><span class=\"line\">  fmt.Println(i)  <span class=\"comment\">// 查看 i 的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  p = &amp;j         <span class=\"comment\">// 重定向到 j</span></span><br><span class=\"line\">  *p = *p / <span class=\"number\">37</span>   <span class=\"comment\">// 通過指針對 j 進行除法運算</span></span><br><span class=\"line\">  fmt.Println(j) <span class=\"comment\">// 查看 j 的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"結構體\"><a href=\"#結構體\" class=\"headerlink\" title=\"結構體\"></a>結構體</h3><p>一個結構體（struct）就是一組字段（field）。外界使用點號來訪問結構體字段。</p>\n<p>結構體字段可以通過結構體指針來訪問。如果我們有一個指向結構體的指針 p，那麼可以通過 <code>(*p).X</code> 來訪問其字段 X。不過這麼寫太囉嗦了，所以語言也允許我們使用<strong>隱式間接引用</strong>，直接寫 <code>p.X</code> 就可以。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">  v.X = <span class=\"number\">4</span></span><br><span class=\"line\">  fmt.Println(v.X)</span><br><span class=\"line\">  </span><br><span class=\"line\">  p := &amp;v</span><br><span class=\"line\">  p.X = <span class=\"number\">1e9</span></span><br><span class=\"line\">  fmt.Println(v)</span><br><span class=\"line\"></span><br><span class=\"line\">  v2 = Vertex&#123;X: <span class=\"number\">1</span>&#125;  <span class=\"comment\">// Y:0 被隱式地賦予</span></span><br><span class=\"line\">  v3 = Vertex&#123;&#125;      <span class=\"comment\">// X:0 Y:0</span></span><br><span class=\"line\">  p  = &amp;Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// 創建一個 *Vertex 類型的結構體（指針）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"數組\"><a href=\"#數組\" class=\"headerlink\" title=\"數組\"></a>數組</h3><p>類型 [n]T 表示擁有 n 個 T 類型的值的數組。</p>\n<p>表达式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">10</span>]<span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure>\n\n<p>會將變量 <code>a</code> 聲明為擁有 10 個整數的數組。</p>\n<h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><p><strong>（1）定義</strong></p>\n<p>類型 []T 表示一個元素類型為 T 的切片。T 可以是任何類型，包括切片本身。</p>\n<p>切片通過兩個下標來界定，即一個上界和一個下界，二者以冒號分隔：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a[low : high]</span><br></pre></td></tr></table></figure>\n\n<p>它會選擇一個半開區間，包括第一個元素，但排除最後一個元素。</p>\n<p>切片下界的默認值爲 0，上界則是其底層數組的長度。</p>\n<p>對於數組 <code>var a [10]int</code> 來說，以下切片是等價的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a[<span class=\"number\">0</span>:<span class=\"number\">10</span>]</span><br><span class=\"line\">a[:<span class=\"number\">10</span>]</span><br><span class=\"line\">a[<span class=\"number\">0</span>:]</span><br><span class=\"line\">a[:]</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）切片的本質</strong></p>\n<p>一個切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量，其結構如下：</p>\n<p><img src=\"/it/go/go-basic/Untitled.png\" alt></p>\n<p><img src=\"/it/go/go-basic/Untitled%201.png\" alt></p>\n<p>切片的長度就是它所包含的元素個數。<br>切片的容量是從它的第一個元素開始數，到其底層數組元素末尾的個數。<br>切片 s 的長度和容量可通過表達式 <code>len(s)</code> 和 <code>cap(s)</code> 來獲取。</p>\n<p>更改切片的元素會修改其底層數組中對應的元素。與它共享底層數組的切片都會觀測到這些修改。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  names := [<span class=\"number\">4</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;John&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Paul&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;George&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Ringo&quot;</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(names)</span><br><span class=\"line\"></span><br><span class=\"line\">  a := names[<span class=\"number\">0</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\">  b := names[<span class=\"number\">1</span>:<span class=\"number\">3</span>]</span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">  b[<span class=\"number\">0</span>] = <span class=\"string\">&quot;XXX&quot;</span></span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\">  fmt.Println(names)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：切片的零值爲 nil，其長度和容量爲 0 且沒有底層數組。</p>\n<p><strong>（3）通過 make 創建切片</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">5</span>)  <span class=\"comment\">// len(a)=5</span></span><br><span class=\"line\">b := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>) <span class=\"comment\">// len(b)=0, cap(b)=5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）通過 append 追加元素</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">append</span><span class=\"params\">(s []T, vs ...T)</span> []<span class=\"title\">T</span></span></span><br></pre></td></tr></table></figure>\n\n<p><code>append</code> 的第一個參數 <code>s</code> 是一個元素類型為 <code>T</code> 的切片，其餘類型為 <code>T</code>的值將會追加到該切片的末尾。</p>\n<p><code>append</code> 的結果是一個包含原切片所有元素加上新添加元素的切片。</p>\n<p>當 <code>s</code> 的底層數組太小，不足以容納所有給定的值時，它就會分配一個更大的數組。返回的切片會指向這個新分配的數組。</p>\n<p>當引用一個原始數組時，GC不會釋放該數組的空間，即使只用到其中一小部分數據。因此函數返回切片的時候要特別注意，最好拷貝需要數據到新的切片再返回。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 copy 函數</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyDigits</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">    b, _ := ioutil.ReadFile(filename)</span><br><span class=\"line\">    b = digitRegexp.Find(b)</span><br><span class=\"line\">    c := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(b))</span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(c, b)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或使用 append 函數</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyDigits</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">    b, _ := ioutil.ReadFile(filename)</span><br><span class=\"line\">    b = digitRegexp.Find(b)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c []<span class=\"keyword\">byte</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">append</span>(c, b...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>映射將鍵映射到值。</p>\n<p>映射的零值為 <code>nil</code> 。<code>nil</code> 映射既沒有鍵，也不能添加鍵。</p>\n<p><code>make</code> 函數會返回給定類型的映射，並將其初始化備用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Lat, Long <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Vertex&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;Bell Labs&quot;</span>: &#123;<span class=\"number\">40.68433</span>, <span class=\"number\">-74.39967</span>&#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;Google&quot;</span>:    &#123;<span class=\"number\">37.42202</span>, <span class=\"number\">-122.08408</span>&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 常用操作：</p>\n<ol>\n<li>插入或修改元素：<code>m[key] = elem</code></li>\n<li>獲取元素：<code>elem = m[key]</code></li>\n<li>通過雙賦值檢測某個鍵是否存在：<code>elem, ok := m[key]</code></li>\n<li>刪除元素：<code>delete(m, key)</code></li>\n</ol>\n<h3 id=\"函數-function\"><a href=\"#函數-function\" class=\"headerlink\" title=\"函數(function)\"></a>函數(function)</h3><p><strong>（1）概述</strong></p>\n<p>函數可以沒有參數或接受多個參數。當連續兩個或多個函數的已命名形參類型相同時，除最後一個類型以外，其它都可以省略。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(add(<span class=\"number\">42</span>, <span class=\"number\">13</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）命名返回值</strong></p>\n<p>Go 的返回值可被命名，它們會被視作<strong>定義在函數頂部的變量</strong>。返回值的名稱應當具有一定的意義，它可以作為文檔使用。沒有參數的 <code>return</code> 語句返回已命名的返回值。也就是 <code>直接</code> 返回。直接返回語句應當僅用在下面這樣的短函數中。在長的函數中它們會影響代碼的可讀性。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">split</span><span class=\"params\">(sum <span class=\"keyword\">int</span>)</span> <span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x = sum * <span class=\"number\">4</span> / <span class=\"number\">9</span></span><br><span class=\"line\">  y = sum - x</span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(split(<span class=\"number\">17</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）多值返回</strong></p>\n<p>函數可以返回任意數量的返回值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  a, b := swap(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）函數值</strong></p>\n<p>函數也是值，可以作爲函數的參數或返回值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compute</span><span class=\"params\">(fn <span class=\"keyword\">func</span>(<span class=\"keyword\">float64</span>, <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span>) <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(compute(math.Pow))</span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）閉包(closure)</strong></p>\n<p>閉包是指一個函數引用了其函數體之外的變量，該函數可以訪問並賦予其引用的變量的值。換句話說就是該函數跟函數體之外的變量綑綁在一起了。每次調用閉包中的函數可以改變閉包中變量的值。例如斐波那契閉包：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  x,y := <span class=\"number\">0</span>,<span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    res := x</span><br><span class=\"line\">    x,y = y,x+y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  f := fibonacci()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    fmt.Println(f())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法-method\"><a href=\"#方法-method\" class=\"headerlink\" title=\"方法(method)\"></a>方法(method)</h3><p>方法就是一類帶特殊的<strong>接收者參數</strong>的函數。方法接收者在它自己的參數列表內，<strong>位於 func 關鍵字和方法名之間</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 這就是方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span> <span class=\"title\">Abs</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">  fmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是：接收者的類型定義和方法聲明必須在同一包內；不能爲內建類型聲明方法。</p>\n<p>接收者除了是<strong>值接收者</strong>外，還支持<strong>指針接收者</strong>，使用 <code>*T</code> (不能是 <code>*int</code> 之類的) 的文法即可。指針接收者可以修改接收者指向的值。如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span> <span class=\"title\">Abs</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span> <span class=\"title\">Scale</span><span class=\"params\">(f <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">  v.X = v.X * f</span><br><span class=\"line\">  v.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">  v.Scale(<span class=\"number\">10</span>) <span class=\"comment\">// 此時 Go 會解釋爲 (&amp;v).Scale(10)，這就是指針重定向</span></span><br><span class=\"line\">  fmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用指針接收者的好處：</p>\n<ol>\n<li>方法能夠修改其接收者指向的值。</li>\n<li>避免在每次調用方法時複製該值。該值佔用的空間越大，則越顯得高效。</li>\n</ol>\n<p>注意：一個結構體採用值接收者的方式實現了接口的方法，則隱含著採用指針接收者的方式實現了接口的方法。（接收者是指針類型的方法，很可能在方法中會對接收者的屬性進行更改操作，從而影響接收者；而對於接收者是值類型的方法，在方法中不會對接收者本身產生影響）</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p><strong>（1）定義</strong></p>\n<p>接口類型是<strong>由一組方法簽名定義的集合</strong>。接口類型的變量可以保存<strong>任何</strong>實現了這些方法的值。</p>\n<p><strong>（2）隱式實現</strong></p>\n<p>類型通過實現一個接口的所有方法來實現該接口。既然無需專門顯式聲明，也就沒有「implements」關鍵字。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  eat()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> John <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;eat...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  eat()</span><br><span class=\"line\">  talk()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">talk</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;talk...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a Animal = &amp;John&#123;&#125;</span><br><span class=\"line\">  a.eat()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b Person = &amp;John&#123;&#125;</span><br><span class=\"line\">  b.eat()</span><br><span class=\"line\">  b.talk()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）接口值</strong></p>\n<p>接口也是值，可以作爲函數的參數或返回值。在內部，接口值可以看做包含值和具體類型的元組：<code>(value, type)</code> 。接口值保存了一個具體底層類型的具體值。接口值調用方法時會執行其底層類型的同名方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Animal、John 見上面的代碼</span></span><br><span class=\"line\">j := John&#123;&#125;</span><br><span class=\"line\">describe(j)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i Animal)</span></span>&#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）底層值爲 nil 的接口值</strong></p>\n<p>即便接口內的具體值為 nil，方法仍然會被 nil 接收者調用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 改造上面的代碼</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">talk</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> j == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;j is &lt;nil&gt;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;talk...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x Person</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y John</span><br><span class=\"line\">  x = &amp;y</span><br><span class=\"line\">  describe(x)</span><br><span class=\"line\">  x.talk() <span class=\"comment\">// 正常調用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判斷接口的底層值是否爲 nil 的方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接上</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>( x == <span class=\"literal\">nil</span> || reflect.ValueOf(x).IsNil())</span><br></pre></td></tr></table></figure>\n\n<p><strong>（6）nil 接口值</strong></p>\n<p>nil 接口值既不保存值也不保存具體類型。</p>\n<p>為 nil 接口調用方法會產生運行時錯誤，因為接口的元組內並未包含能夠指明該調用哪個 <strong>具體</strong> 方法的類型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  M()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i I</span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\">  i.M() <span class=\"comment\">// 此處拋出 panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i I)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i) <span class=\"comment\">// (&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（7）空接口</strong></p>\n<p>指定了<strong>零個方法</strong>的接口值被稱為空接口，即 <code>interface&#123;&#125;</code> 。空接口可保存任何類型的值。（因為每個類型都至少實現了零個方法。）空接口被用來處理未知類型的值。例如，<code>fmt.Print</code> 可接受類型為 <code>interface&#123;&#125;</code> 的任意數量的參數。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">  i = <span class=\"number\">42</span> <span class=\"comment\">// 保存 int值</span></span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">  i = <span class=\"string\">&quot;hello&quot;</span> <span class=\"comment\">// 保存 string值</span></span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（8）類型斷言</strong></p>\n<p>類型斷言提供了訪問<strong>接口值底層具體值</strong>的方式。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判斷接口i的底層值類型是否爲T，如是返回其底層值和true，否則返回T類型的零值和false</span></span><br><span class=\"line\">t, ok := i.(T)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">s, ok := i.(<span class=\"keyword\">string</span>)</span><br><span class=\"line\">fmt.Println(s, ok)</span><br><span class=\"line\">f, ok := i.(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">fmt.Println(f, ok)</span><br><span class=\"line\"><span class=\"comment\">// 支持類型選擇</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">do</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> v := i.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"keyword\">int</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;Twice %v is %v\\n&quot;</span>, v, v*<span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"keyword\">string</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%q is %v bytes long\\n&quot;</span>, v, <span class=\"built_in\">len</span>(v))</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;I don&#x27;t know about type %T!\\n&quot;</span>, v)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"異常處理\"><a href=\"#異常處理\" class=\"headerlink\" title=\"異常處理\"></a>異常處理</h3><p>Go 程序使用 <code>error</code> 值來表示錯誤狀態。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Error() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常函數會返回一個 <code>error</code> 值，調用的它的代碼應當判斷這個錯誤是否等於 <code>nil</code> 來進行錯誤處理。<code>error</code> 為 nil 時表示成功；非 nil 的 <code>error</code> 表示失敗。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> i, err := strconv.Atoi(<span class=\"string\">&quot;42&quot;</span>); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Converted integer:&quot;</span>, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Go-程-goroutine\"><a href=\"#Go-程-goroutine\" class=\"headerlink\" title=\"Go 程(goroutine)\"></a>Go 程(goroutine)</h3><p><strong>（1）定義</strong></p>\n<p><strong>Go 程（goroutine）是由 Go 運行時管理的輕量級線程</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x,y,z 的求值發生在當前 Go 程中，f 的執行則是在新的 Go 程中</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> f(x, y, z)</span><br></pre></td></tr></table></figure>\n\n<p>（<strong>2）信道</strong></p>\n<p><strong>信道是帶有類型的管道</strong>，你可以通過它用<strong>信道操作符</strong> <code>&lt;-</code> (箭頭就是數據流的方向)來發送或者接收值。</p>\n<p>默認情況下，發送和接收操作在另一端準備好之前都會阻塞。這使得 Go 程可以在沒有顯式的鎖或競態變量的情況下進行同步。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 創建信道</span></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">// 將 v 發送至信道 ch。</span></span><br><span class=\"line\">ch &lt;- v</span><br><span class=\"line\"><span class=\"comment\">// 從 ch 接收值並賦予 v。</span></span><br><span class=\"line\">v := &lt;-ch</span><br></pre></td></tr></table></figure>\n\n<p><strong>信道可以是帶緩衝，</strong>將緩衝長度作為第二個參數提供給 <code>make</code> 來初始化一個帶緩衝的信道。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>僅當信道的緩衝區填滿後，向其發送數據時才會阻塞。當緩衝區為空時，接受方會阻塞。</strong></p>\n<p><strong>（3）range 和 close</strong></p>\n<p>有且僅有發送者可以通過 close 方法關閉一個信道。接收者讀取值的時候可以通過 <code>v, ok := &lt;-ch</code>  的 ok 值判斷是否信道關閉了。更簡單的是使用 for-range 不斷從信道接收值，直到信道關閉，循環自動退出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(n <span class=\"keyword\">int</span>, c <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">    c &lt;- x</span><br><span class=\"line\">    x, y = y, x+y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> fibonacci(<span class=\"built_in\">cap</span>(c), c)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> c &#123;</span><br><span class=\"line\">    fmt.Println(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）select</strong></p>\n<p>select 語句使一個 Go 程可以等待多個通信操作。select 會阻塞到某個分支可以繼續執行為止，這時就會執行該分支。當多個分支都準備好時會隨機選擇一個執行。當 select 中的其它分支都沒有準備好時，default 分支就會執行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(c, quit <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> c &lt;- x:</span><br><span class=\"line\">      x, y = y, x+y</span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;-quit:</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">&quot;quit&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 當 c 和 quit 阻塞時會執行到此處</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  quit := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">      fmt.Println(&lt;-c)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    quit &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  fibonacci(c, quit)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>練習：等價二叉查找樹</p>\n<p>  函數 tree.New(k) 用於構造一個隨機結構的已排序二叉查找樹，它保存了值 k, 2k, 3k, …, 10k。</p>\n<p>  Walk 步進 tree t 將所有的值從 tree 發送到 channel ch。</p>\n<p>  用 Walk 實現 Same 函數來檢測 t1 和 t2 是否存儲了相同的值。</p>\n  <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;golang.org/x/tour/tree&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Walk</span><span class=\"params\">(t *tree.Tree, ch <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> t.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    Walk(t.Left, ch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ch &lt;- t.Value</span><br><span class=\"line\">  <span class=\"keyword\">if</span> t.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    Walk(t.Right, ch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Same 检测树 t1 和 t2 是否含有相同的值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Same</span><span class=\"params\">(t1, t2 *tree.Tree)</span> <span class=\"title\">bool</span></span>&#123;</span><br><span class=\"line\">  ch1,ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>),<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Walk(t1, ch1)</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch1)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Walk(t2, ch2)</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch2)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> ch1&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i != &lt;-ch2 &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(Same(tree.New(<span class=\"number\">1</span>),tree.New(<span class=\"number\">1</span>)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（5）sync.Mutex</strong></p>\n<p>互斥鎖可以保證每次只有一個 Go 程訪問一個共享變量。</p>\n<p>Go 標準庫中的 <strong>Mutex</strong> 就是一個互斥鎖，可以創建為其他結構體的字段；零值為解鎖狀態。Mutex類型的鎖和線程無關，可以由不同的線程加鎖和解鎖。在代碼前調用 Lock 方法，並在代碼後調用 Unlock 方法來保證一段代碼互斥執行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.Unlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>爲了提升讀寫性能，常用 <strong>RWMutex</strong> 代替 <strong>Mutex。</strong>RWMutex是讀寫互斥鎖。該鎖可以被同時多個讀取者持有或唯一個寫入者持有。RWMutex可以創建為其他結構體的字段；零值為解鎖狀態。RWMutex類型的鎖也和線程無關，可以由不同的線程加讀取鎖/寫入和解讀取鎖/寫入鎖。</p>\n<p>下面的代碼效果不明顯，因爲讀的次數不多。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.RLock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.RUnlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  now := time.Now()</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(time.Now().Sub(now))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（6）WaitGroup</strong></p>\n<p>WaitGroup 可以等待一組 Go 程結束。通過調用 Add 方法設定要等待的 Go 程數量。然後各個 Go 程通過調用 Done 方法結束等待。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  wg.Done()</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.RLock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.RUnlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1000</span>)</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>, &amp;wg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java 基礎","p":"it/java/java-basic.md","date":"2020-11-08T04:23:00.000Z","_content":"\nJava 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。\n\n- 它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。\n- 它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。\n- 它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。\n- 它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。\n- 它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。\n- 它提供了豐富的集合類、迭代器及工具類。\n- 它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。\n- 它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。\n- 它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。\n- 另外，目前有兩大項目管理工具，Maven 和 Gradle。\n\n<!-- more -->\n\n## Java 入門（基礎概念與常識）\n\n### 歷史\n\nJava 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 `CA FE BA BE` ，即 cafe babe （咖啡寶貝）。\n\n```java\n$ hexdump Test.class\n0000000 ca fe ba be 00 00 00 3b 00 51 0a 00 02 00 03 07\n```\n\n- 1994 年完成 1.0 版本。\n- 1995 年首次對外發佈，Java 語言誕生。\n- 1996 年JDK 1.0 誕生。\n- 2004 年 SUN 公司發佈 Java SE 5。\n- 2005 年 SUN 公司發佈 Java SE 6。\n- 2006 年 SUN 公司推出 OpenJDK 計劃。\n- 2014年 Oracle 公司發佈 Java SE 8。\n- 2017年 Oracle公司發佈 Java SE 9。\n- 2020 年 Oracle 公司發佈 Java SE 15。\n\n### 安裝與卸載JDK\n\n在 Mac 環境下，從 [Oracle JavaSE 下載地址](https://www.oracle.com/tw/java/technologies/javase-downloads.html) 下載並安裝。安裝完成後執行 `java -version`  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 `/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home` 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。\n\n```bash\nsudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin\nsudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane\n\nls /Library/Java/JavaVirtualMachines/\n输出：jdk-9.0.1.jdk\n\nsudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk\n```\n\n### Hello World\n\n運行以下代碼，將輸出 `Hello World`。\n\n```java\npackage hello;\n\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n```\n\n### Java 語言的特點\n\n1. 面向對象（封裝，繼承，多態）\n2. 平台無關性（ Java 虛擬機實現平台無關性）\n3. 支持多線程\n4. 編譯與解釋並存\n\n編譯：生成字節碼(.class文件)，javac 指令。\n解釋：解釋字節碼成機器碼，java 指令。\n\n### JVM、JDK 和  JRE\n\n1. JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。\n2. JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。\n3. JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。\n\n### Java 與 C++ 對比\n\n1. 皆支持面向對象編程（封裝、繼承和多態）。\n2. Java 不提供指針來直接訪問內存；C++ 提供。\n3. Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。\n4. Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。\n5. Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符`\\0` 來表示結束。\n\n## Java 語法\n\n### 基本類型及其大小\n\nJava 共 8 種數據類型（不包括 void），具體如下表：\n\n![](java_basic/20201202_24328.png)\n\nboolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。\n\nchar 值是一個 16 位的 Unicode 字符，最小值是 '\\u0000' ，最大值是 '\\uffff'，即 0～65535，每個數字對應一個字符。\n\n- 代碼\n\n    ```java\n    char a = '中';\n    System.out.println((int)a);\n    // 輸出 20013\n    System.out.println(Integer.toHexString(a));\n    // 輸出 4e2d\n    System.out.println('\\u4e2d');\n    // 輸出 中\n    ```\n\nbyte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。\n\n- 二進制補碼\n    - 過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。\n    - 原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 [https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm](https://www.ruanyifeng.com/blog/2009/08/twos_complement.html)l\n\nlong 類型的數據後面一定要加上 L，否則會被認為是整型。\n\nchar 類型值使用單引號括起來，String 使用雙引號。\n\nJava 有**自動拆裝箱機制**，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。\n\n### 包裝類型及常量池技術\n\n1. Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。\n2. Character 創建了數值在 [0, 127] 的緩存數據。\n3. Boolean 直接返回 True 和 False。\n4. Float 和 Double 沒有實現常量池技術。\n\n使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。\n\n```java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\nInteger i11 = 333;\nInteger i22 = 333;\nSystem.out.println(i11 == i22);// 输出 false\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n```\n\n《阿里巴巴Java開發手冊》規定：\n\n- 【強制】**所有的 POJO 類屬性必須使用包裝數據類型**。\n- 【強制】RPC 方法的返回值和參數必須使用包裝數據類型。\n- 【推薦】所有的局部變量使用基本數據類型。\n\n### BigDecimal\n\n**（1）使用 BigDecimal 進行浮點數比較和精度取捨**\n\n**（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象**\n\n```java\nfloat a = 1.0f - 0.9f;\nfloat b = 0.9f - 0.8f;\nSystem.out.println(a);\nSystem.out.println(b);\nSystem.out.println(a == b); // false\n\nBigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\nSystem.out.println(a.subtract(b));\nSystem.out.println(b.subtract(c));\nSystem.out.println(a.subtract(b).equals(b.subtract(c))); // true\n\nBigDecimal a = new BigDecimal(\"1.1252312\");\n// 取小數點後 2 位，四捨五入\nBigDecimal scale = a.setScale(2, RoundingMode.HALF_UP);\nSystem.out.println(scale.toString()); // 1.13\n```\n\n### 對象及其大小\n\n基本類型的封裝類型是對象，Java 中的對象由以下部分組成：\n\n1. 對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。\n2. 實例數據（instance data）：對象的有效信息。\n3. 對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。\n\n可使用 `org.openjdk.jol` 工具查看一個對象佔用的字節大小，\n\n- 如下：\n\n    ```java\n    public static void main(String[] args){\n        System.out.println(VM.current().details());\n        System.out.println(ClassLayout.parseClass(Object.class).toPrintable());\n        System.out.println(ClassLayout.parseInstance(Integer.valueOf(1)).toPrintable());\n    }\n    ```\n\n    輸出結果：\n\n    ```bash\n    # Running 64-bit HotSpot VM.\n    # Using compressed oop with 3-bit shift.\n    # Using compressed klass with 3-bit shift.\n    # WARNING | Compressed references base/shifts are guessed by the experiment!\n    # WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.\n    # WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.\n    # Objects are 8 bytes aligned.\n    # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n    # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n\n    java.lang.Object object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0    12        (object header)                           N/A\n         12     4        (loss due to the next object alignment)\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 4 bytes external = 4 bytes total\n\n    java.lang.Integer object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)\n          4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)\n          8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)\n         12     4    int Integer.value                             1\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total\n    ```\n\n結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。\n\n### String、StringBuffer 和 String Builder 的區別\n\nString 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。\n\n```java\npublic final class String {\n\t// Java 9 之前\n\tprivate final char[] value;\n\t// Java 9 之後\n\tprivate final byte[] value;\n}\n```\n\nStringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。\n\n下面從不同角度比較下此三者：\n\n1. 線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。\n2. 性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。\n\n### 注釋\n\n代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。\n\n### 標識符和關鍵字的區別\n\n標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：\n\n1. 訪問控制：private、protected、public\n2. 類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile\n3. 程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default\n4. 錯誤處理：try、catch、throw、throws、finally\n5. 包相關：import、package\n6. 基本類型：boolean、byte、char、double、float、int、short、null、true、false\n7. 變量引用：super、this、void\n8. 保留字：goto、const\n\n### 自增自減運算符\n\n符號在前先加減再賦值，符號在後先賦值後加減。假定 `a = 1; b = a++` 最後 a 值爲 2，b 值爲 1。\n\n### == 和 equals 的區別\n\n1. 基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。\n2. equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。\n3. 整型包裝類都應使用 equals 比較大小。\n4. 浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。\n- 重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？\n\n    hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n    HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。\n\n### 序列化時如果有些字段不想序列化，怎麼辦？\n\n使用 transient 關鍵字修飾不想序列化的字段。\n\n### continue、break 和 return 的區別\n\n1. continue：跳出當前這一次循環，繼續下一次循環。\n2. break：跳出整個循環體，繼續執行循環外的語句。\n3. return：跳出所在的方法，結束方法，可以帶一個返回值。\n\n### 泛型、類型擦除和通配符\n\n**泛型的本質是將類型參數化。**Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲**僞泛型**。下面的例子展示了如何在運行期加入非法類型。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(12);\n//這裡直接添加會報錯\n// list.add(\"a\");\nClass<? extends List> clazz = list.getClass();\nMethod add = clazz.getDeclaredMethod(\"add\", Object.class);\n//但是通過反射添加，是可以的\nadd.invoke(list, \"kl\");\nSystem.out.println(list);\n```\n\n泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。\n\n泛型通配符約定：\n\n1. ？ 表示不確定的 Java 類型，用於泛型方法\n2. T（Type）表示確定的一個 Java 類型\n3. K V（Key Value）分別表示映射中的鍵、值\n4. E（Element）表示集合中的一個元素\n5. <? extends A> 上界通配符，表示 A 類型或其子類\n6. <? super A> 下界通配符，表示 A 類型或其父類\n7. <T extends A> 表示 A 類型或其子類的一種\n8. <T extends A & B> 表示 A 類型且B類型的子類的一種\n9. ~~<T super A>~~ \n\n泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<Apple> 的引用並不能傳遞給 Plate<Fruit>，但可以傳遞給 Plate<? extends Fruit>。\n\n元素爲 <? extends E> 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。\n\n```java\npublic static void main(String[] args) {\n  List<? extends A> list = Arrays.asList(new A(), new B());\n  list.add(new A()); // 報錯\n  list.add(new B()); // 報錯\n  A a = list.get(1);\n  System.out.println(a.toString());\n}\n\nstatic class A {\n}\n\nstatic class B extends A {\n}\n```\n\n元素爲 <? super E> 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。\n\n```java\npublic static void main(String[] args) {\n  List<? super B> list = new ArrayList<>();\n  list.add(new A()); // 報錯\n  list.add(new B());\n  list.add(new C());\n  Object object = list.get(1);\n  System.out.println(object.toString());\n}\n\nstatic class A {\n}\nstatic class B extends A {\n}\nstatic class C extends B{\n}\n```\n\n### 獲取鍵盤輸入數據的常用方法\n\n```java\n// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據\nScanner scanner = new Scanner(System.in);\nString s = scanner.nextLine();\nSystem.out.println(s);\n\n// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\nString s1 = bufferedReader.readLine();\nSystem.out.println(s1);\n```\n\n## 方法（函數）\n\n### 爲什麼 Java 只有值傳遞？\n\n首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：\n\n1. 按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。\n2. 按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。\n\n**Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝**。\n\n```java\npublic static void main(String[] args) {\n  String s1 = \"Hello\";\n  String s2 = \"World\";\n  swap(s1, s2);\n  System.out.printf(\"main s1: %s, s2: %s%n\", s1, s2);\n}\n\nstatic void swap(String s1, String s2) {\n  String tmp = s1;\n  s1 = s2;\n  s2 = tmp;\n  System.out.printf(\"swap s1: %s, s2: %s%n\", s1, s2);\n}\n// 運行結果：\n// swap s1: World, s2: Hello\n// main s1: Hello, s2: World\n```\n\n結論：\n\n1. 一個方法不能修改一個基本類型的實參。\n2. 一個方法可以改變一個對象類型的實參狀態。\n3. 一個方法不能讓對象類型的實參引用一個新對象。\n\n### 深拷貝和淺拷貝有什麼不同？\n\n1. 淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。\n2. 深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。\n\n![](java-basic/Untitled.png)\n\n### 重載和重寫有什麼區別？\n\n1. 重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。\n2. 重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。\n\n## Java 面向對象\n\n### 面向對象和面向過程\n\n1. 面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。\n2. 面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。\n\nJava 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。\n\n### 構造方法\n\n1. 特點：名字跟類名相同，沒有返回值，不可重寫但可重載。\n2. 作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。\n3. 子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。\n\n### 成員變量和局部變量的區別\n\n1. 成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。\n2. 局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。\n\n### 對象實例和對象引用的區別\n\n1. 對象實例：存在於堆內存，一個對象實例可以被多個引用指向。\n2. 對象引用：存在於棧內存，一個引用指向一個對象實例。\n\n### 面向對象的三大特徵\n\n**（1）封裝**\n\n封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。\n\n**（2）繼承**\n\n繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：\n\n1. 子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），**僅僅擁有**。\n2. 子類可以對父類進行擴展，增加新的屬性和方法。\n3. 子類可以重寫父類的方法。\n\n**（3）多態**\n\n多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：\n\n1. 對象類型和引用類型之間具有繼承/實現關係。\n2. 對象類型不可變，引用類型可變。\n3. 方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。\n4. 父類的引用不能調用「只有子類存在但在父類不存在」的方法。\n5. 如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。\n\n### **靜態方法內爲什麼不能調用非靜態成員？**\n\n因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。\n\n### 接口和抽象類的區別\n\n1. 方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。\n2. 變量上：接口只能有 static、final 變量；而抽象類沒有限制。\n3. 繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。\n4. 設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。\n\n## Java 核心技術\n\n### 集合\n\n見 [Java 集合](https://tsunhua.github.io/2020/12/02/it/java/java-collection/) \n\n### 反射機制\n\n**（1）什麼是反射**\n\nJava 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。\n\n**（2）反射的優缺點**\n\n1. 優點：運行時確定類型，動態加載類，提高代碼靈活度。\n2. 缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。\n\n反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。\n\n**（3）反射的應用場景**\n\n反射是框架設計的靈魂。其應用場景有：\n\n1. 模塊化開發；\n2. 動態代理設計模式；\n3. Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；\n4. JDBC 連接數據庫等等。\n\n### 異常\n\n**（1）簡介**\n\nJava 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。**Error 通常是 JVM 錯誤，程序無法處理**；**而 Exception 是程序本身可以處理的異常**。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。\n\n![](java-basic/Untitled%201.png)\n\n**Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）**，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：\n\n- *IOException*\n- *EOFException*\n- *MalFormedURLException*\n- *IntruptedException*\n\n**Unchecked Exception 又名 Runtime Exceptions（運行時異常）**，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：\n\n- *ArithmaticException*\n- *NullPointerException*\n- *IndexOutOfBoundsException*\n- *ClassCastException*\n- *ArrayIndexOutOfBoundsException*\n- *NumberFormatException*\n\n**（2）Throwable 類常用方法**\n\n1. `getMessage`：返回異常的簡要描述\n2. `toString`：返回異常的詳細信息\n3. `getLocalizedMessage`：返回異常的本地化信息（需要子類覆蓋該方法，否則與 `getMessage` 一樣）\n4. `printStackTrace`：在控制台打印 Throwable 对象封装的异常信息\n\n**（3）try-catch-finally**\n\n1. try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。\n2. catch 代碼塊：處理捕獲到的異常。\n3. finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。\n\n```java\npublic static int f(int value) {\n  try {\n      return value * value;\n  } finally {\n      if (value == 2) {\n          return 0;\n      }\n  }\n}\n// f(2) 將返回 0 ，而不是 4.\n```\n\n以下情況，finally 代碼塊不會被執行或只部分執行：\n\n1. finally 代碼塊中有異常，代碼會中異常處中止；\n2. 在 catch 代碼塊或 finally 塊中調用了 `System.exit` 函數退出程序；\n3. 程序所在的線程死亡等等不可預料的系統和硬件問題。\n\n**（4）try-witch-resources**\n\nJava 7 中新增了 ****try-witch-resources 語法糖，適用於實現`java.lang.AutoCloseable` 或者 `java.io.Closeable` 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。\n\n```java\n// try-catch-finally\nScanner scanner = null;\ntry {\n    scanner = new Scanner(new File(\"src/main/resources/test.txt\"));\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (scanner != null) {\n        scanner.close();\n    }\n}\n// try-witch-resources\ntry (Scanner scanner = new Scanner(new File(\"src/main/resources/test.txt\"))) {\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n### 多線程\n\n見 [Java 多線程](https://tsunhua.github.io/2020/12/10/it/java/java-concurrent/) \n\n### 文件與 I/O 流\n\n**（1）Java 中 I/O 流分爲幾種？**\n\n按不同的分類方法有不同的分類：\n\n1. 按流向分：輸入流、輸出流。\n2. 按操作單元分：字節流、字符流。\n3. 按角色分：節點流、處理流。\n\nJava 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：\n\n1. InputStream：字節輸入流\n2. Reader：字符輸入流\n3. OutputStream：字節輸出流\n4. Writer：字符輸出流\n\n![](java-basic/Untitled%202.png)\n\n![](java-basic/Untitled%203.png)\n\n**（2）爲什麼有了字節流還需要字符流？**\n\n不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？\n\n字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。\n\n**（3）BIO、NIO、AIO 有什麼區別？**\n\n1. **BIO**（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（< 單機 1000）的情況，結合線程池一起使用。\n2. **NIO**（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 `java.nio` 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。\n3. **AIO**（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。\n\nNIO 模型：\n\n![](java-basic/Untitled%204.png)\n\n- NIO 服務端代碼\n\n    ```java\n    public class MultiplexerNioServer implements Runnable {\n\n        private Selector selector;\n        private volatile boolean stop = false;\n\n        /**\n         * 初始化多路复用器 绑定监听端口\n         *\n         * @param port\n         */\n        public MultiplexerNioServer(int port) {\n            try {\n                ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//获得一个serverChannel\n                selector = Selector.open();////创建选择器  获得一个多路复用器\n                serverSocketChannel.configureBlocking(false);//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                serverSocketChannel.socket().bind(new InetSocketAddress(port), 1024);//绑定一个端口和等待队列长度\n                serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//把selector注册到channel，关注链接事件\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void stop() {\n            this.stop = true; // 优雅停机\n        }\n\n        public void run() {\n            while (!stop) {\n                try {\n                    //无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的\n                    int client = selector.select(1000);\n                    System.out.println(\"1:\" + client);\n                    // 阻塞,只有当至少一个注册的事件发生的时候才会继续.\n                    // int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪\n                    if (client == 0) {\n                        continue;\n                    }\n                    System.out.println(\"2:\" + client);\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            //处理事件\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (selector != null) {\n                // selector关闭后会自动释放里面管理的资源\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                //连接事件\n                if (key.isAcceptable()) {\n                    ServerSocketChannel ssc = (ServerSocketChannel) key.channel();\n                    // 通过ServerSocketChannel的accept创建SocketChannel实例\n                    // 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立\n                    SocketChannel sc = ssc.accept();//3次握手\n                    sc.configureBlocking(false);\n                    sc.register(selector, SelectionKey.OP_READ);//连接建立后关注读事件\n                }\n\n                //读事件\n                if (key.isReadable()) {\n                    SocketChannel socketChannel = (SocketChannel) key.channel();\n                    ByteBuffer readbuffer = ByteBuffer.allocate(1024);//写 0 1024  1024\n    //                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存\n                    // 读取请求码流，返回读取到的字节数\n                    while (true) {\n                        int readBytes = socketChannel.read(readbuffer);\n                        // 读取到字节，对字节进行编解码\n                        if (readBytes > 0) {\n                            // 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作\n                            readbuffer.flip();//读写模式反转\n                            // 将缓冲区可读字节数组复制到新建的数组中\n                            byte[] bytes = new byte[readbuffer.remaining()];\n                            readbuffer.get(bytes);\n                            String body = new String(bytes, StandardCharsets.UTF_8);\n                            System.out.println(\"input is:\" + body);\n                            res(socketChannel, body);\n                        } else if (readBytes < 0) {\n                            // 链路已经关闭 释放资源\n                            key.cancel();\n                            socketChannel.close();\n                        } else {\n                            // 没有读到字节忽略\n                            return;\n                        }\n                    }\n\n                }\n\n            }\n        }\n\n        private void res(SocketChannel channel, String response) throws IOException {\n            if (response != null && response.length() > 0) {\n                byte[] bytes = response.getBytes();\n                ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);\n                writeBuffer.put(bytes);\n                writeBuffer.flip();\n                channel.write(writeBuffer);\n                System.out.println(\"res end\");\n            }\n        }\n    }\n    ```\n\n- NIO 客戶端代碼\n\n    ```java\n    public class NioClientHandler implements Runnable {\n        private final String host;\n        private final int port;\n        private Selector selector;\n        private SocketChannel socketChannel;\n        private volatile boolean stop;\n\n        public NioClientHandler(String host, int port) {\n            this.host = host;\n            this.port = port;\n            try {\n                // 创建选择器\n                selector = Selector.open();\n                // 打开监听通道\n                socketChannel = SocketChannel.open();\n                // 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                socketChannel.configureBlocking(false); // 开启非阻塞模式\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void run() {\n            try {\n                doConnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n            while (!stop) {\n                try {\n                    int wait = selector.select(1000);\n                    if (wait == 0) {\n                        continue;\n                    }\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n            if (selector != null) {\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void doConnect() throws IOException {\n            if (socketChannel.connect(new InetSocketAddress(host, port))) {\n                socketChannel.register(selector, SelectionKey.OP_READ);\n                doWrite(socketChannel);\n            } else {\n                socketChannel.register(selector, SelectionKey.OP_CONNECT);\n            }\n        }\n\n        private void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                SocketChannel sc = (SocketChannel) key.channel();\n                if (key.isConnectable()) {\n                    if (sc.finishConnect()) {\n                        sc.register(selector, SelectionKey.OP_READ);\n                        doWrite(sc);\n                    } else {\n                        System.exit(1);\n                    }\n                }\n                if (key.isReadable()) {\n                    ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n                    int readBytes = sc.read(readBuffer);\n                    if (readBytes > 0) {\n                        readBuffer.flip();\n                        byte[] bytes = new byte[readBuffer.remaining()];\n                        readBuffer.get(bytes);\n                        String body = new String(bytes, StandardCharsets.UTF_8);\n                        System.out.println(\"res\" + body);\n                        this.stop = true;\n                    } else if (readBytes < 0) {\n                        key.cancel();\n                        sc.close();\n                    }\n\n                }\n            }\n        }\n\n        private void doWrite(SocketChannel sc) throws IOException {\n            // 将消息编码为字节数组\n            byte[] request = \"Hello\".getBytes();\n            // 根据数组容量创建ByteBuffer\n            ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);\n            // 将字节数组复制到缓冲区\n            writeBuffer.put(request);\n            // flip读写切换操作\n            writeBuffer.flip();\n            sc.write(writeBuffer);\n            if (!writeBuffer.hasRemaining()) {\n                System.out.println(\"写入完成\");\n            }\n        }\n    }\n    ```\n\n## Java 項目管理和構建\n\n### Maven 项目\n\n**（1）安装**\n\n從 [Maven 官網](https://maven.apache.org/download.cgi)下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。\n\n**（2）初始化一個 Maven 項目**\n\n使用以下命令：\n\n```bash\nmvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4\n```\n\n或者用 IDEA 直接新建一個 Maven 項目，其結構如下：\n\n![](java-basic/20201114_101407.png)\n\n其中 pom.xml 的內容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>testmaven</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <!--  添加以下屬性，解決編譯報錯  -->\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.encoding>UTF-8</maven.compiler.encoding>\n        <java.version>15</java.version>\n        <maven.compiler.source>15</maven.compiler.source>\n        <maven.compiler.target>15</maven.compiler.target>\n    </properties>\n    <!-- 新增依賴在下方 -->\n    <dependencies>\n        <dependency>\n            <groupId>org.openjdk.jol</groupId>\n            <artifactId>jol-core</artifactId>\n            <version>0.14</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n- 為什麼叫 Maven？\n\n    Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。\n\n- POM 又是指什麼？\n\n    POM（project object model）項目對象模型，maven 使用 `pom.xml` 定義了整個項目的構建、報告和文檔。\n\n**（3）編譯測試打包**\n\n```bash\n# 清理 target 中的文件\nmvn clean\n# 編譯 java 文件成 class 文件，置於 target/classes 文件夾中\nmvn compile\n# 進行單元測試\nmvn test\n# 打包成 jar 文件，置於 target 文件夾中\nmvn package\n# 安裝 jar 包到本地存儲庫（${user.home}/.m2/repository）\nmvn install\n# 生成自己的 maven 站點\nmvn site\n```\n\n- SNAPSHOT 是什麼？\n\n    snapshot 簡要的意思，在版本號之後添加 `-SNAPSHOT` 是說明該版本仍處於開發階段，不是最終的發行版本。以 `x.y-SNAPSHOT` 版本為例，發行時會去除 `-SNAPSHOT`  後綴，然後將最新的開發版本升爲`x.(y+1)-SNAPSHOT` 。\n\n- 使用 mvn compile 生成的 jar 包，其內容是怎樣的？\n\n    除了 class 文件外，還有 `META-INF` 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（`main/resources` ）的文件也會被打包到`META-INF` 文件夾中，代碼中可通過`getClass().getResourceAsStream( \"/application.properties\" )` 調用。\n\n    ```bash\n    $ jar tf target/testmaven-1.0-SNAPSHOT.jar \n    META-INF/\n    META-INF/MANIFEST.MF\n    B.class\n    MemoryLayoutTest.class\n    A.class\n    C.class\n    META-INF/maven/\n    META-INF/maven/org.example/\n    META-INF/maven/org.example/testmaven/\n    META-INF/maven/org.example/testmaven/pom.xml\n    META-INF/maven/org.example/testmaven/pom.properties\n    ```\n\n### Gradle 项目\n\n**（1）安裝**\n\n可從 [gradle 官網](https://www.gradle.org/downloads)下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 `brew install gradle` 的方式安裝。或者直接使用 IDEA 項目中的 `gradle-wrapper` ，此時對應的 `gradle` 命令變爲 `gradlew`。\n\n**（2）gradle 命令能做什麼？**\n\ngradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。\n\n```bash\n$ gradle tasks\n\n:tasks\n\n== All tasks runnable from root project\n\n== Build Setup tasks\nsetupBuild - Initializes a new Gradle build. [incubating]\n\n== Help tasks\ndependencies - Displays all dependencies declared in root project 'gs-gradle'.\ndependencyInsight - Displays the insight into a specific dependency in root project 'gs-gradle'.\nhelp - Displays a help message\nprojects - Displays the sub-projects of root project 'gs-gradle'.\nproperties - Displays the properties of root project 'gs-gradle'.\ntasks - Displays the tasks runnable from root project 'gs-gradle'.\n\nTo see all tasks and more detail, run with --all.\n\nBUILD SUCCESSFUL\n\nTotal time: 3.077 secs\n```\n\n**（3）初始化一個 Gradle 項目**\n\n在項目文件夾中新建一個名爲 `build.gradle` 的文件，其內容如下：\n\n```groovy\napply plugin: 'java'\n```\n\n隨後新建一個名爲 `settings.gradle` 的文件，其內容可暫時爲空。\n\n在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 `gradle-wrapper` ，其過程等價於執行以下命令：\n\n```bash\ngradle wrapper --gradle-version 6.5\n```\n\n**（4）編譯打包**\n\n```bash\n# 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包\ngradle build\n# 或使用 gradle wrapper\n./gradlew build\n\n# 清理生成的文件\ngradle clean\n\n# 生成 jar 文件\ngradle jar\n\n# 運行生成的 jar 文件\ngradle run\n\n# 進行單元測試\ngradle test\n```\n\n**（5）`build.gradle` 中可配置什麼？**\n\n```groovy\n// 配置插件，插件提供語法定義\napply plugin: 'java'\napply plugin: 'application'\n\n// 配置入口類\nmainClassName = 'hello.HelloWorld'\n\n// 配置依賴倉庫\nrepositories {\n    mavenCentral()\n}\n\n// 配置生成的 jar 文件的入口類\njar {\n    manifest {\n        attributes 'Main-Class': mainClassName\n    }\n}\n\n// 配置 JDK 兼容性\nsourceCompatibility = 1.8\ntargetCompatibility = 1.8\n\n// 配置依賴\ndependencies {\n    compile \"joda-time:joda-time:2.2\"\n    testCompile \"junit:junit:4.12\"\n}\n```\n\n如需將所有依賴 jar 打進同一個 jar 包，可使用 [shadow 插件](https://github.com/johnrengelman/shadow)或使用 [spring boot 插件](https://spring.io/quickstart)。","source":"_posts/it/java/java-basic.md","raw":"---\ntitle: Java 基礎\np: it/java/java-basic.md\ndate: 2020-11-08 12:23:00\ntags:\n- Java\n---\n\nJava 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。\n\n- 它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。\n- 它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。\n- 它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。\n- 它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。\n- 它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。\n- 它提供了豐富的集合類、迭代器及工具類。\n- 它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。\n- 它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。\n- 它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。\n- 另外，目前有兩大項目管理工具，Maven 和 Gradle。\n\n<!-- more -->\n\n## Java 入門（基礎概念與常識）\n\n### 歷史\n\nJava 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 `CA FE BA BE` ，即 cafe babe （咖啡寶貝）。\n\n```java\n$ hexdump Test.class\n0000000 ca fe ba be 00 00 00 3b 00 51 0a 00 02 00 03 07\n```\n\n- 1994 年完成 1.0 版本。\n- 1995 年首次對外發佈，Java 語言誕生。\n- 1996 年JDK 1.0 誕生。\n- 2004 年 SUN 公司發佈 Java SE 5。\n- 2005 年 SUN 公司發佈 Java SE 6。\n- 2006 年 SUN 公司推出 OpenJDK 計劃。\n- 2014年 Oracle 公司發佈 Java SE 8。\n- 2017年 Oracle公司發佈 Java SE 9。\n- 2020 年 Oracle 公司發佈 Java SE 15。\n\n### 安裝與卸載JDK\n\n在 Mac 環境下，從 [Oracle JavaSE 下載地址](https://www.oracle.com/tw/java/technologies/javase-downloads.html) 下載並安裝。安裝完成後執行 `java -version`  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 `/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home` 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。\n\n```bash\nsudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin\nsudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane\n\nls /Library/Java/JavaVirtualMachines/\n输出：jdk-9.0.1.jdk\n\nsudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk\n```\n\n### Hello World\n\n運行以下代碼，將輸出 `Hello World`。\n\n```java\npackage hello;\n\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n```\n\n### Java 語言的特點\n\n1. 面向對象（封裝，繼承，多態）\n2. 平台無關性（ Java 虛擬機實現平台無關性）\n3. 支持多線程\n4. 編譯與解釋並存\n\n編譯：生成字節碼(.class文件)，javac 指令。\n解釋：解釋字節碼成機器碼，java 指令。\n\n### JVM、JDK 和  JRE\n\n1. JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。\n2. JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。\n3. JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。\n\n### Java 與 C++ 對比\n\n1. 皆支持面向對象編程（封裝、繼承和多態）。\n2. Java 不提供指針來直接訪問內存；C++ 提供。\n3. Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。\n4. Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。\n5. Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符`\\0` 來表示結束。\n\n## Java 語法\n\n### 基本類型及其大小\n\nJava 共 8 種數據類型（不包括 void），具體如下表：\n\n![](java_basic/20201202_24328.png)\n\nboolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。\n\nchar 值是一個 16 位的 Unicode 字符，最小值是 '\\u0000' ，最大值是 '\\uffff'，即 0～65535，每個數字對應一個字符。\n\n- 代碼\n\n    ```java\n    char a = '中';\n    System.out.println((int)a);\n    // 輸出 20013\n    System.out.println(Integer.toHexString(a));\n    // 輸出 4e2d\n    System.out.println('\\u4e2d');\n    // 輸出 中\n    ```\n\nbyte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。\n\n- 二進制補碼\n    - 過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。\n    - 原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 [https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm](https://www.ruanyifeng.com/blog/2009/08/twos_complement.html)l\n\nlong 類型的數據後面一定要加上 L，否則會被認為是整型。\n\nchar 類型值使用單引號括起來，String 使用雙引號。\n\nJava 有**自動拆裝箱機制**，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。\n\n### 包裝類型及常量池技術\n\n1. Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。\n2. Character 創建了數值在 [0, 127] 的緩存數據。\n3. Boolean 直接返回 True 和 False。\n4. Float 和 Double 沒有實現常量池技術。\n\n使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。\n\n```java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\nInteger i11 = 333;\nInteger i22 = 333;\nSystem.out.println(i11 == i22);// 输出 false\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n```\n\n《阿里巴巴Java開發手冊》規定：\n\n- 【強制】**所有的 POJO 類屬性必須使用包裝數據類型**。\n- 【強制】RPC 方法的返回值和參數必須使用包裝數據類型。\n- 【推薦】所有的局部變量使用基本數據類型。\n\n### BigDecimal\n\n**（1）使用 BigDecimal 進行浮點數比較和精度取捨**\n\n**（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象**\n\n```java\nfloat a = 1.0f - 0.9f;\nfloat b = 0.9f - 0.8f;\nSystem.out.println(a);\nSystem.out.println(b);\nSystem.out.println(a == b); // false\n\nBigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\nSystem.out.println(a.subtract(b));\nSystem.out.println(b.subtract(c));\nSystem.out.println(a.subtract(b).equals(b.subtract(c))); // true\n\nBigDecimal a = new BigDecimal(\"1.1252312\");\n// 取小數點後 2 位，四捨五入\nBigDecimal scale = a.setScale(2, RoundingMode.HALF_UP);\nSystem.out.println(scale.toString()); // 1.13\n```\n\n### 對象及其大小\n\n基本類型的封裝類型是對象，Java 中的對象由以下部分組成：\n\n1. 對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。\n2. 實例數據（instance data）：對象的有效信息。\n3. 對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。\n\n可使用 `org.openjdk.jol` 工具查看一個對象佔用的字節大小，\n\n- 如下：\n\n    ```java\n    public static void main(String[] args){\n        System.out.println(VM.current().details());\n        System.out.println(ClassLayout.parseClass(Object.class).toPrintable());\n        System.out.println(ClassLayout.parseInstance(Integer.valueOf(1)).toPrintable());\n    }\n    ```\n\n    輸出結果：\n\n    ```bash\n    # Running 64-bit HotSpot VM.\n    # Using compressed oop with 3-bit shift.\n    # Using compressed klass with 3-bit shift.\n    # WARNING | Compressed references base/shifts are guessed by the experiment!\n    # WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.\n    # WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.\n    # Objects are 8 bytes aligned.\n    # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n    # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n\n    java.lang.Object object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0    12        (object header)                           N/A\n         12     4        (loss due to the next object alignment)\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 4 bytes external = 4 bytes total\n\n    java.lang.Integer object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)\n          4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)\n          8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)\n         12     4    int Integer.value                             1\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total\n    ```\n\n結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。\n\n### String、StringBuffer 和 String Builder 的區別\n\nString 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。\n\n```java\npublic final class String {\n\t// Java 9 之前\n\tprivate final char[] value;\n\t// Java 9 之後\n\tprivate final byte[] value;\n}\n```\n\nStringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。\n\n下面從不同角度比較下此三者：\n\n1. 線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。\n2. 性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。\n\n### 注釋\n\n代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。\n\n### 標識符和關鍵字的區別\n\n標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：\n\n1. 訪問控制：private、protected、public\n2. 類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile\n3. 程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default\n4. 錯誤處理：try、catch、throw、throws、finally\n5. 包相關：import、package\n6. 基本類型：boolean、byte、char、double、float、int、short、null、true、false\n7. 變量引用：super、this、void\n8. 保留字：goto、const\n\n### 自增自減運算符\n\n符號在前先加減再賦值，符號在後先賦值後加減。假定 `a = 1; b = a++` 最後 a 值爲 2，b 值爲 1。\n\n### == 和 equals 的區別\n\n1. 基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。\n2. equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。\n3. 整型包裝類都應使用 equals 比較大小。\n4. 浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。\n- 重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？\n\n    hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n    HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。\n\n### 序列化時如果有些字段不想序列化，怎麼辦？\n\n使用 transient 關鍵字修飾不想序列化的字段。\n\n### continue、break 和 return 的區別\n\n1. continue：跳出當前這一次循環，繼續下一次循環。\n2. break：跳出整個循環體，繼續執行循環外的語句。\n3. return：跳出所在的方法，結束方法，可以帶一個返回值。\n\n### 泛型、類型擦除和通配符\n\n**泛型的本質是將類型參數化。**Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲**僞泛型**。下面的例子展示了如何在運行期加入非法類型。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(12);\n//這裡直接添加會報錯\n// list.add(\"a\");\nClass<? extends List> clazz = list.getClass();\nMethod add = clazz.getDeclaredMethod(\"add\", Object.class);\n//但是通過反射添加，是可以的\nadd.invoke(list, \"kl\");\nSystem.out.println(list);\n```\n\n泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。\n\n泛型通配符約定：\n\n1. ？ 表示不確定的 Java 類型，用於泛型方法\n2. T（Type）表示確定的一個 Java 類型\n3. K V（Key Value）分別表示映射中的鍵、值\n4. E（Element）表示集合中的一個元素\n5. <? extends A> 上界通配符，表示 A 類型或其子類\n6. <? super A> 下界通配符，表示 A 類型或其父類\n7. <T extends A> 表示 A 類型或其子類的一種\n8. <T extends A & B> 表示 A 類型且B類型的子類的一種\n9. ~~<T super A>~~ \n\n泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<Apple> 的引用並不能傳遞給 Plate<Fruit>，但可以傳遞給 Plate<? extends Fruit>。\n\n元素爲 <? extends E> 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。\n\n```java\npublic static void main(String[] args) {\n  List<? extends A> list = Arrays.asList(new A(), new B());\n  list.add(new A()); // 報錯\n  list.add(new B()); // 報錯\n  A a = list.get(1);\n  System.out.println(a.toString());\n}\n\nstatic class A {\n}\n\nstatic class B extends A {\n}\n```\n\n元素爲 <? super E> 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。\n\n```java\npublic static void main(String[] args) {\n  List<? super B> list = new ArrayList<>();\n  list.add(new A()); // 報錯\n  list.add(new B());\n  list.add(new C());\n  Object object = list.get(1);\n  System.out.println(object.toString());\n}\n\nstatic class A {\n}\nstatic class B extends A {\n}\nstatic class C extends B{\n}\n```\n\n### 獲取鍵盤輸入數據的常用方法\n\n```java\n// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據\nScanner scanner = new Scanner(System.in);\nString s = scanner.nextLine();\nSystem.out.println(s);\n\n// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\nString s1 = bufferedReader.readLine();\nSystem.out.println(s1);\n```\n\n## 方法（函數）\n\n### 爲什麼 Java 只有值傳遞？\n\n首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：\n\n1. 按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。\n2. 按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。\n\n**Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝**。\n\n```java\npublic static void main(String[] args) {\n  String s1 = \"Hello\";\n  String s2 = \"World\";\n  swap(s1, s2);\n  System.out.printf(\"main s1: %s, s2: %s%n\", s1, s2);\n}\n\nstatic void swap(String s1, String s2) {\n  String tmp = s1;\n  s1 = s2;\n  s2 = tmp;\n  System.out.printf(\"swap s1: %s, s2: %s%n\", s1, s2);\n}\n// 運行結果：\n// swap s1: World, s2: Hello\n// main s1: Hello, s2: World\n```\n\n結論：\n\n1. 一個方法不能修改一個基本類型的實參。\n2. 一個方法可以改變一個對象類型的實參狀態。\n3. 一個方法不能讓對象類型的實參引用一個新對象。\n\n### 深拷貝和淺拷貝有什麼不同？\n\n1. 淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。\n2. 深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。\n\n![](java-basic/Untitled.png)\n\n### 重載和重寫有什麼區別？\n\n1. 重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。\n2. 重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。\n\n## Java 面向對象\n\n### 面向對象和面向過程\n\n1. 面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。\n2. 面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。\n\nJava 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。\n\n### 構造方法\n\n1. 特點：名字跟類名相同，沒有返回值，不可重寫但可重載。\n2. 作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。\n3. 子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。\n\n### 成員變量和局部變量的區別\n\n1. 成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。\n2. 局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。\n\n### 對象實例和對象引用的區別\n\n1. 對象實例：存在於堆內存，一個對象實例可以被多個引用指向。\n2. 對象引用：存在於棧內存，一個引用指向一個對象實例。\n\n### 面向對象的三大特徵\n\n**（1）封裝**\n\n封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。\n\n**（2）繼承**\n\n繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：\n\n1. 子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），**僅僅擁有**。\n2. 子類可以對父類進行擴展，增加新的屬性和方法。\n3. 子類可以重寫父類的方法。\n\n**（3）多態**\n\n多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：\n\n1. 對象類型和引用類型之間具有繼承/實現關係。\n2. 對象類型不可變，引用類型可變。\n3. 方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。\n4. 父類的引用不能調用「只有子類存在但在父類不存在」的方法。\n5. 如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。\n\n### **靜態方法內爲什麼不能調用非靜態成員？**\n\n因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。\n\n### 接口和抽象類的區別\n\n1. 方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。\n2. 變量上：接口只能有 static、final 變量；而抽象類沒有限制。\n3. 繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。\n4. 設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。\n\n## Java 核心技術\n\n### 集合\n\n見 [Java 集合](https://tsunhua.github.io/2020/12/02/it/java/java-collection/) \n\n### 反射機制\n\n**（1）什麼是反射**\n\nJava 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。\n\n**（2）反射的優缺點**\n\n1. 優點：運行時確定類型，動態加載類，提高代碼靈活度。\n2. 缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。\n\n反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。\n\n**（3）反射的應用場景**\n\n反射是框架設計的靈魂。其應用場景有：\n\n1. 模塊化開發；\n2. 動態代理設計模式；\n3. Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；\n4. JDBC 連接數據庫等等。\n\n### 異常\n\n**（1）簡介**\n\nJava 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。**Error 通常是 JVM 錯誤，程序無法處理**；**而 Exception 是程序本身可以處理的異常**。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。\n\n![](java-basic/Untitled%201.png)\n\n**Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）**，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：\n\n- *IOException*\n- *EOFException*\n- *MalFormedURLException*\n- *IntruptedException*\n\n**Unchecked Exception 又名 Runtime Exceptions（運行時異常）**，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：\n\n- *ArithmaticException*\n- *NullPointerException*\n- *IndexOutOfBoundsException*\n- *ClassCastException*\n- *ArrayIndexOutOfBoundsException*\n- *NumberFormatException*\n\n**（2）Throwable 類常用方法**\n\n1. `getMessage`：返回異常的簡要描述\n2. `toString`：返回異常的詳細信息\n3. `getLocalizedMessage`：返回異常的本地化信息（需要子類覆蓋該方法，否則與 `getMessage` 一樣）\n4. `printStackTrace`：在控制台打印 Throwable 对象封装的异常信息\n\n**（3）try-catch-finally**\n\n1. try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。\n2. catch 代碼塊：處理捕獲到的異常。\n3. finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。\n\n```java\npublic static int f(int value) {\n  try {\n      return value * value;\n  } finally {\n      if (value == 2) {\n          return 0;\n      }\n  }\n}\n// f(2) 將返回 0 ，而不是 4.\n```\n\n以下情況，finally 代碼塊不會被執行或只部分執行：\n\n1. finally 代碼塊中有異常，代碼會中異常處中止；\n2. 在 catch 代碼塊或 finally 塊中調用了 `System.exit` 函數退出程序；\n3. 程序所在的線程死亡等等不可預料的系統和硬件問題。\n\n**（4）try-witch-resources**\n\nJava 7 中新增了 ****try-witch-resources 語法糖，適用於實現`java.lang.AutoCloseable` 或者 `java.io.Closeable` 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。\n\n```java\n// try-catch-finally\nScanner scanner = null;\ntry {\n    scanner = new Scanner(new File(\"src/main/resources/test.txt\"));\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (scanner != null) {\n        scanner.close();\n    }\n}\n// try-witch-resources\ntry (Scanner scanner = new Scanner(new File(\"src/main/resources/test.txt\"))) {\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n### 多線程\n\n見 [Java 多線程](https://tsunhua.github.io/2020/12/10/it/java/java-concurrent/) \n\n### 文件與 I/O 流\n\n**（1）Java 中 I/O 流分爲幾種？**\n\n按不同的分類方法有不同的分類：\n\n1. 按流向分：輸入流、輸出流。\n2. 按操作單元分：字節流、字符流。\n3. 按角色分：節點流、處理流。\n\nJava 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：\n\n1. InputStream：字節輸入流\n2. Reader：字符輸入流\n3. OutputStream：字節輸出流\n4. Writer：字符輸出流\n\n![](java-basic/Untitled%202.png)\n\n![](java-basic/Untitled%203.png)\n\n**（2）爲什麼有了字節流還需要字符流？**\n\n不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？\n\n字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。\n\n**（3）BIO、NIO、AIO 有什麼區別？**\n\n1. **BIO**（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（< 單機 1000）的情況，結合線程池一起使用。\n2. **NIO**（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 `java.nio` 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。\n3. **AIO**（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。\n\nNIO 模型：\n\n![](java-basic/Untitled%204.png)\n\n- NIO 服務端代碼\n\n    ```java\n    public class MultiplexerNioServer implements Runnable {\n\n        private Selector selector;\n        private volatile boolean stop = false;\n\n        /**\n         * 初始化多路复用器 绑定监听端口\n         *\n         * @param port\n         */\n        public MultiplexerNioServer(int port) {\n            try {\n                ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//获得一个serverChannel\n                selector = Selector.open();////创建选择器  获得一个多路复用器\n                serverSocketChannel.configureBlocking(false);//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                serverSocketChannel.socket().bind(new InetSocketAddress(port), 1024);//绑定一个端口和等待队列长度\n                serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//把selector注册到channel，关注链接事件\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void stop() {\n            this.stop = true; // 优雅停机\n        }\n\n        public void run() {\n            while (!stop) {\n                try {\n                    //无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的\n                    int client = selector.select(1000);\n                    System.out.println(\"1:\" + client);\n                    // 阻塞,只有当至少一个注册的事件发生的时候才会继续.\n                    // int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪\n                    if (client == 0) {\n                        continue;\n                    }\n                    System.out.println(\"2:\" + client);\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            //处理事件\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (selector != null) {\n                // selector关闭后会自动释放里面管理的资源\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                //连接事件\n                if (key.isAcceptable()) {\n                    ServerSocketChannel ssc = (ServerSocketChannel) key.channel();\n                    // 通过ServerSocketChannel的accept创建SocketChannel实例\n                    // 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立\n                    SocketChannel sc = ssc.accept();//3次握手\n                    sc.configureBlocking(false);\n                    sc.register(selector, SelectionKey.OP_READ);//连接建立后关注读事件\n                }\n\n                //读事件\n                if (key.isReadable()) {\n                    SocketChannel socketChannel = (SocketChannel) key.channel();\n                    ByteBuffer readbuffer = ByteBuffer.allocate(1024);//写 0 1024  1024\n    //                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存\n                    // 读取请求码流，返回读取到的字节数\n                    while (true) {\n                        int readBytes = socketChannel.read(readbuffer);\n                        // 读取到字节，对字节进行编解码\n                        if (readBytes > 0) {\n                            // 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作\n                            readbuffer.flip();//读写模式反转\n                            // 将缓冲区可读字节数组复制到新建的数组中\n                            byte[] bytes = new byte[readbuffer.remaining()];\n                            readbuffer.get(bytes);\n                            String body = new String(bytes, StandardCharsets.UTF_8);\n                            System.out.println(\"input is:\" + body);\n                            res(socketChannel, body);\n                        } else if (readBytes < 0) {\n                            // 链路已经关闭 释放资源\n                            key.cancel();\n                            socketChannel.close();\n                        } else {\n                            // 没有读到字节忽略\n                            return;\n                        }\n                    }\n\n                }\n\n            }\n        }\n\n        private void res(SocketChannel channel, String response) throws IOException {\n            if (response != null && response.length() > 0) {\n                byte[] bytes = response.getBytes();\n                ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);\n                writeBuffer.put(bytes);\n                writeBuffer.flip();\n                channel.write(writeBuffer);\n                System.out.println(\"res end\");\n            }\n        }\n    }\n    ```\n\n- NIO 客戶端代碼\n\n    ```java\n    public class NioClientHandler implements Runnable {\n        private final String host;\n        private final int port;\n        private Selector selector;\n        private SocketChannel socketChannel;\n        private volatile boolean stop;\n\n        public NioClientHandler(String host, int port) {\n            this.host = host;\n            this.port = port;\n            try {\n                // 创建选择器\n                selector = Selector.open();\n                // 打开监听通道\n                socketChannel = SocketChannel.open();\n                // 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                socketChannel.configureBlocking(false); // 开启非阻塞模式\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void run() {\n            try {\n                doConnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n            while (!stop) {\n                try {\n                    int wait = selector.select(1000);\n                    if (wait == 0) {\n                        continue;\n                    }\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n            if (selector != null) {\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void doConnect() throws IOException {\n            if (socketChannel.connect(new InetSocketAddress(host, port))) {\n                socketChannel.register(selector, SelectionKey.OP_READ);\n                doWrite(socketChannel);\n            } else {\n                socketChannel.register(selector, SelectionKey.OP_CONNECT);\n            }\n        }\n\n        private void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                SocketChannel sc = (SocketChannel) key.channel();\n                if (key.isConnectable()) {\n                    if (sc.finishConnect()) {\n                        sc.register(selector, SelectionKey.OP_READ);\n                        doWrite(sc);\n                    } else {\n                        System.exit(1);\n                    }\n                }\n                if (key.isReadable()) {\n                    ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n                    int readBytes = sc.read(readBuffer);\n                    if (readBytes > 0) {\n                        readBuffer.flip();\n                        byte[] bytes = new byte[readBuffer.remaining()];\n                        readBuffer.get(bytes);\n                        String body = new String(bytes, StandardCharsets.UTF_8);\n                        System.out.println(\"res\" + body);\n                        this.stop = true;\n                    } else if (readBytes < 0) {\n                        key.cancel();\n                        sc.close();\n                    }\n\n                }\n            }\n        }\n\n        private void doWrite(SocketChannel sc) throws IOException {\n            // 将消息编码为字节数组\n            byte[] request = \"Hello\".getBytes();\n            // 根据数组容量创建ByteBuffer\n            ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);\n            // 将字节数组复制到缓冲区\n            writeBuffer.put(request);\n            // flip读写切换操作\n            writeBuffer.flip();\n            sc.write(writeBuffer);\n            if (!writeBuffer.hasRemaining()) {\n                System.out.println(\"写入完成\");\n            }\n        }\n    }\n    ```\n\n## Java 項目管理和構建\n\n### Maven 项目\n\n**（1）安装**\n\n從 [Maven 官網](https://maven.apache.org/download.cgi)下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。\n\n**（2）初始化一個 Maven 項目**\n\n使用以下命令：\n\n```bash\nmvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4\n```\n\n或者用 IDEA 直接新建一個 Maven 項目，其結構如下：\n\n![](java-basic/20201114_101407.png)\n\n其中 pom.xml 的內容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>testmaven</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <!--  添加以下屬性，解決編譯報錯  -->\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.encoding>UTF-8</maven.compiler.encoding>\n        <java.version>15</java.version>\n        <maven.compiler.source>15</maven.compiler.source>\n        <maven.compiler.target>15</maven.compiler.target>\n    </properties>\n    <!-- 新增依賴在下方 -->\n    <dependencies>\n        <dependency>\n            <groupId>org.openjdk.jol</groupId>\n            <artifactId>jol-core</artifactId>\n            <version>0.14</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n- 為什麼叫 Maven？\n\n    Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。\n\n- POM 又是指什麼？\n\n    POM（project object model）項目對象模型，maven 使用 `pom.xml` 定義了整個項目的構建、報告和文檔。\n\n**（3）編譯測試打包**\n\n```bash\n# 清理 target 中的文件\nmvn clean\n# 編譯 java 文件成 class 文件，置於 target/classes 文件夾中\nmvn compile\n# 進行單元測試\nmvn test\n# 打包成 jar 文件，置於 target 文件夾中\nmvn package\n# 安裝 jar 包到本地存儲庫（${user.home}/.m2/repository）\nmvn install\n# 生成自己的 maven 站點\nmvn site\n```\n\n- SNAPSHOT 是什麼？\n\n    snapshot 簡要的意思，在版本號之後添加 `-SNAPSHOT` 是說明該版本仍處於開發階段，不是最終的發行版本。以 `x.y-SNAPSHOT` 版本為例，發行時會去除 `-SNAPSHOT`  後綴，然後將最新的開發版本升爲`x.(y+1)-SNAPSHOT` 。\n\n- 使用 mvn compile 生成的 jar 包，其內容是怎樣的？\n\n    除了 class 文件外，還有 `META-INF` 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（`main/resources` ）的文件也會被打包到`META-INF` 文件夾中，代碼中可通過`getClass().getResourceAsStream( \"/application.properties\" )` 調用。\n\n    ```bash\n    $ jar tf target/testmaven-1.0-SNAPSHOT.jar \n    META-INF/\n    META-INF/MANIFEST.MF\n    B.class\n    MemoryLayoutTest.class\n    A.class\n    C.class\n    META-INF/maven/\n    META-INF/maven/org.example/\n    META-INF/maven/org.example/testmaven/\n    META-INF/maven/org.example/testmaven/pom.xml\n    META-INF/maven/org.example/testmaven/pom.properties\n    ```\n\n### Gradle 项目\n\n**（1）安裝**\n\n可從 [gradle 官網](https://www.gradle.org/downloads)下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 `brew install gradle` 的方式安裝。或者直接使用 IDEA 項目中的 `gradle-wrapper` ，此時對應的 `gradle` 命令變爲 `gradlew`。\n\n**（2）gradle 命令能做什麼？**\n\ngradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。\n\n```bash\n$ gradle tasks\n\n:tasks\n\n== All tasks runnable from root project\n\n== Build Setup tasks\nsetupBuild - Initializes a new Gradle build. [incubating]\n\n== Help tasks\ndependencies - Displays all dependencies declared in root project 'gs-gradle'.\ndependencyInsight - Displays the insight into a specific dependency in root project 'gs-gradle'.\nhelp - Displays a help message\nprojects - Displays the sub-projects of root project 'gs-gradle'.\nproperties - Displays the properties of root project 'gs-gradle'.\ntasks - Displays the tasks runnable from root project 'gs-gradle'.\n\nTo see all tasks and more detail, run with --all.\n\nBUILD SUCCESSFUL\n\nTotal time: 3.077 secs\n```\n\n**（3）初始化一個 Gradle 項目**\n\n在項目文件夾中新建一個名爲 `build.gradle` 的文件，其內容如下：\n\n```groovy\napply plugin: 'java'\n```\n\n隨後新建一個名爲 `settings.gradle` 的文件，其內容可暫時爲空。\n\n在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 `gradle-wrapper` ，其過程等價於執行以下命令：\n\n```bash\ngradle wrapper --gradle-version 6.5\n```\n\n**（4）編譯打包**\n\n```bash\n# 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包\ngradle build\n# 或使用 gradle wrapper\n./gradlew build\n\n# 清理生成的文件\ngradle clean\n\n# 生成 jar 文件\ngradle jar\n\n# 運行生成的 jar 文件\ngradle run\n\n# 進行單元測試\ngradle test\n```\n\n**（5）`build.gradle` 中可配置什麼？**\n\n```groovy\n// 配置插件，插件提供語法定義\napply plugin: 'java'\napply plugin: 'application'\n\n// 配置入口類\nmainClassName = 'hello.HelloWorld'\n\n// 配置依賴倉庫\nrepositories {\n    mavenCentral()\n}\n\n// 配置生成的 jar 文件的入口類\njar {\n    manifest {\n        attributes 'Main-Class': mainClassName\n    }\n}\n\n// 配置 JDK 兼容性\nsourceCompatibility = 1.8\ntargetCompatibility = 1.8\n\n// 配置依賴\ndependencies {\n    compile \"joda-time:joda-time:2.2\"\n    testCompile \"junit:junit:4.12\"\n}\n```\n\n如需將所有依賴 jar 打進同一個 jar 包，可使用 [shadow 插件](https://github.com/johnrengelman/shadow)或使用 [spring boot 插件](https://spring.io/quickstart)。","slug":"it/java/java-basic","published":1,"updated":"2021-09-13T14:16:43.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfw00401n9kf5k2cd4u","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>Java 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。</p>\n<ul>\n<li>它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。</li>\n<li>它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。</li>\n<li>它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。</li>\n<li>它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。</li>\n<li>它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。</li>\n<li>它提供了豐富的集合類、迭代器及工具類。</li>\n<li>它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。</li>\n<li>它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。</li>\n<li>它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。</li>\n<li>另外，目前有兩大項目管理工具，Maven 和 Gradle。</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"Java-入門（基礎概念與常識）\"><a href=\"#Java-入門（基礎概念與常識）\" class=\"headerlink\" title=\"Java 入門（基礎概念與常識）\"></a>Java 入門（基礎概念與常識）</h2><h3 id=\"歷史\"><a href=\"#歷史\" class=\"headerlink\" title=\"歷史\"></a>歷史</h3><p>Java 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 <code>CA FE BA BE</code> ，即 cafe babe （咖啡寶貝）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexdump Test.class</span><br><span class=\"line\"><span class=\"number\">0000000</span> ca fe ba be <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> 3b <span class=\"number\">00</span> <span class=\"number\">51</span> 0a <span class=\"number\">00</span> <span class=\"number\">02</span> <span class=\"number\">00</span> <span class=\"number\">03</span> <span class=\"number\">07</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1994 年完成 1.0 版本。</li>\n<li>1995 年首次對外發佈，Java 語言誕生。</li>\n<li>1996 年JDK 1.0 誕生。</li>\n<li>2004 年 SUN 公司發佈 Java SE 5。</li>\n<li>2005 年 SUN 公司發佈 Java SE 6。</li>\n<li>2006 年 SUN 公司推出 OpenJDK 計劃。</li>\n<li>2014年 Oracle 公司發佈 Java SE 8。</li>\n<li>2017年 Oracle公司發佈 Java SE 9。</li>\n<li>2020 年 Oracle 公司發佈 Java SE 15。</li>\n</ul>\n<h3 id=\"安裝與卸載JDK\"><a href=\"#安裝與卸載JDK\" class=\"headerlink\" title=\"安裝與卸載JDK\"></a>安裝與卸載JDK</h3><p>在 Mac 環境下，從 <a href=\"https://www.oracle.com/tw/java/technologies/javase-downloads.html\">Oracle JavaSE 下載地址</a> 下載並安裝。安裝完成後執行 <code>java -version</code>  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 <code>/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home</code> 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin</span><br><span class=\"line\">sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane</span><br><span class=\"line\"></span><br><span class=\"line\">ls /Library/Java/JavaVirtualMachines/</span><br><span class=\"line\">输出：jdk-9.0.1.jdk</span><br><span class=\"line\"></span><br><span class=\"line\">sudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>運行以下代碼，將輸出 <code>Hello World</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java-語言的特點\"><a href=\"#Java-語言的特點\" class=\"headerlink\" title=\"Java 語言的特點\"></a>Java 語言的特點</h3><ol>\n<li>面向對象（封裝，繼承，多態）</li>\n<li>平台無關性（ Java 虛擬機實現平台無關性）</li>\n<li>支持多線程</li>\n<li>編譯與解釋並存</li>\n</ol>\n<p>編譯：生成字節碼(.class文件)，javac 指令。<br>解釋：解釋字節碼成機器碼，java 指令。</p>\n<h3 id=\"JVM、JDK-和-JRE\"><a href=\"#JVM、JDK-和-JRE\" class=\"headerlink\" title=\"JVM、JDK 和  JRE\"></a>JVM、JDK 和  JRE</h3><ol>\n<li>JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。</li>\n<li>JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。</li>\n<li>JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。</li>\n</ol>\n<h3 id=\"Java-與-C-對比\"><a href=\"#Java-與-C-對比\" class=\"headerlink\" title=\"Java 與 C++ 對比\"></a>Java 與 C++ 對比</h3><ol>\n<li>皆支持面向對象編程（封裝、繼承和多態）。</li>\n<li>Java 不提供指針來直接訪問內存；C++ 提供。</li>\n<li>Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。</li>\n<li>Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。</li>\n<li>Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符<code>\\0</code> 來表示結束。</li>\n</ol>\n<h2 id=\"Java-語法\"><a href=\"#Java-語法\" class=\"headerlink\" title=\"Java 語法\"></a>Java 語法</h2><h3 id=\"基本類型及其大小\"><a href=\"#基本類型及其大小\" class=\"headerlink\" title=\"基本類型及其大小\"></a>基本類型及其大小</h3><p>Java 共 8 種數據類型（不包括 void），具體如下表：</p>\n<p><img src=\"/it/java/java-basic/20201202_24328.png\" alt></p>\n<p>boolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。</p>\n<p>char 值是一個 16 位的 Unicode 字符，最小值是 ‘\\u0000’ ，最大值是 ‘\\uffff’，即 0～65535，每個數字對應一個字符。</p>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a = <span class=\"string\">&#x27;中&#x27;</span>;</span><br><span class=\"line\">System.out.println((<span class=\"keyword\">int</span>)a);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 20013</span></span><br><span class=\"line\">System.out.println(Integer.toHexString(a));</span><br><span class=\"line\"><span class=\"comment\">// 輸出 4e2d</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&#x27;\\u4e2d&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 中</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>byte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。</p>\n<ul>\n<li>二進制補碼<ul>\n<li>過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。</li>\n<li>原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 <a href=\"https://www.ruanyifeng.com/blog/2009/08/twos_complement.html\">https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm</a>l</li>\n</ul>\n</li>\n</ul>\n<p>long 類型的數據後面一定要加上 L，否則會被認為是整型。</p>\n<p>char 類型值使用單引號括起來，String 使用雙引號。</p>\n<p>Java 有<strong>自動拆裝箱機制</strong>，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。</p>\n<h3 id=\"包裝類型及常量池技術\"><a href=\"#包裝類型及常量池技術\" class=\"headerlink\" title=\"包裝類型及常量池技術\"></a>包裝類型及常量池技術</h3><ol>\n<li>Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。</li>\n<li>Character 創建了數值在 [0, 127] 的緩存數據。</li>\n<li>Boolean 直接返回 True 和 False。</li>\n<li>Float 和 Double 沒有實現常量池技術。</li>\n</ol>\n<p>使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">33</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">Integer i11 = <span class=\"number\">333</span>;</span><br><span class=\"line\">Integer i22 = <span class=\"number\">333</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">Double i3 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">Double i4 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p>《阿里巴巴Java開發手冊》規定：</p>\n<ul>\n<li>【強制】<strong>所有的 POJO 類屬性必須使用包裝數據類型</strong>。</li>\n<li>【強制】RPC 方法的返回值和參數必須使用包裝數據類型。</li>\n<li>【推薦】所有的局部變量使用基本數據類型。</li>\n</ul>\n<h3 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h3><p><strong>（1）使用 BigDecimal 進行浮點數比較和精度取捨</strong></p>\n<p><strong>（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> a = <span class=\"number\">1.0f</span> - <span class=\"number\">0.9f</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> b = <span class=\"number\">0.9f</span> - <span class=\"number\">0.8f</span>;</span><br><span class=\"line\">System.out.println(a);</span><br><span class=\"line\">System.out.println(b);</span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1.0&quot;</span>);</span><br><span class=\"line\">BigDecimal b = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;0.9&quot;</span>);</span><br><span class=\"line\">BigDecimal c = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;0.8&quot;</span>);</span><br><span class=\"line\">System.out.println(a.subtract(b));</span><br><span class=\"line\">System.out.println(b.subtract(c));</span><br><span class=\"line\">System.out.println(a.subtract(b).equals(b.subtract(c))); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1.1252312&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 取小數點後 2 位，四捨五入</span></span><br><span class=\"line\">BigDecimal scale = a.setScale(<span class=\"number\">2</span>, RoundingMode.HALF_UP);</span><br><span class=\"line\">System.out.println(scale.toString()); <span class=\"comment\">// 1.13</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"對象及其大小\"><a href=\"#對象及其大小\" class=\"headerlink\" title=\"對象及其大小\"></a>對象及其大小</h3><p>基本類型的封裝類型是對象，Java 中的對象由以下部分組成：</p>\n<ol>\n<li>對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。</li>\n<li>實例數據（instance data）：對象的有效信息。</li>\n<li>對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。</li>\n</ol>\n<p>可使用 <code>org.openjdk.jol</code> 工具查看一個對象佔用的字節大小，</p>\n<ul>\n<li><p>如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(VM.current().details());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseClass(Object.class).toPrintable());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseInstance(Integer.valueOf(<span class=\"number\">1</span>)).toPrintable());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  輸出結果：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Running 64-bit HotSpot VM.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed oop with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed klass with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Compressed references base/shifts are guessed by the experiment!</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.</span></span><br><span class=\"line\"><span class=\"comment\"># Objects are 8 bytes aligned.</span></span><br><span class=\"line\"><span class=\"comment\"># Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"><span class=\"comment\"># Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Object object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0    12        (object header)                           N/A</span><br><span class=\"line\">     12     4        (loss due to the next object alignment)</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Integer object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)</span><br><span class=\"line\">      4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)</span><br><span class=\"line\">      8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)</span><br><span class=\"line\">     12     4    int Integer.value                             1</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。</p>\n<h3 id=\"String、StringBuffer-和-String-Builder-的區別\"><a href=\"#String、StringBuffer-和-String-Builder-的區別\" class=\"headerlink\" title=\"String、StringBuffer 和 String Builder 的區別\"></a>String、StringBuffer 和 String Builder 的區別</h3><p>String 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Java 9 之前</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\">  <span class=\"comment\">// Java 9 之後</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>StringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。</p>\n<p>下面從不同角度比較下此三者：</p>\n<ol>\n<li>線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。</li>\n<li>性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。</li>\n</ol>\n<h3 id=\"注釋\"><a href=\"#注釋\" class=\"headerlink\" title=\"注釋\"></a>注釋</h3><p>代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。</p>\n<h3 id=\"標識符和關鍵字的區別\"><a href=\"#標識符和關鍵字的區別\" class=\"headerlink\" title=\"標識符和關鍵字的區別\"></a>標識符和關鍵字的區別</h3><p>標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：</p>\n<ol>\n<li>訪問控制：private、protected、public</li>\n<li>類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile</li>\n<li>程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default</li>\n<li>錯誤處理：try、catch、throw、throws、finally</li>\n<li>包相關：import、package</li>\n<li>基本類型：boolean、byte、char、double、float、int、short、null、true、false</li>\n<li>變量引用：super、this、void</li>\n<li>保留字：goto、const</li>\n</ol>\n<h3 id=\"自增自減運算符\"><a href=\"#自增自減運算符\" class=\"headerlink\" title=\"自增自減運算符\"></a>自增自減運算符</h3><p>符號在前先加減再賦值，符號在後先賦值後加減。假定 <code>a = 1; b = a++</code> 最後 a 值爲 2，b 值爲 1。</p>\n<h3 id=\"和-equals-的區別\"><a href=\"#和-equals-的區別\" class=\"headerlink\" title=\"== 和 equals 的區別\"></a>== 和 equals 的區別</h3><ol>\n<li>基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。</li>\n<li>equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。</li>\n<li>整型包裝類都應使用 equals 比較大小。</li>\n<li>浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。</li>\n</ol>\n<ul>\n<li><p>重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？</p>\n<p>  hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<p>  HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。</p>\n</li>\n</ul>\n<h3 id=\"序列化時如果有些字段不想序列化，怎麼辦？\"><a href=\"#序列化時如果有些字段不想序列化，怎麼辦？\" class=\"headerlink\" title=\"序列化時如果有些字段不想序列化，怎麼辦？\"></a>序列化時如果有些字段不想序列化，怎麼辦？</h3><p>使用 transient 關鍵字修飾不想序列化的字段。</p>\n<h3 id=\"continue、break-和-return-的區別\"><a href=\"#continue、break-和-return-的區別\" class=\"headerlink\" title=\"continue、break 和 return 的區別\"></a>continue、break 和 return 的區別</h3><ol>\n<li>continue：跳出當前這一次循環，繼續下一次循環。</li>\n<li>break：跳出整個循環體，繼續執行循環外的語句。</li>\n<li>return：跳出所在的方法，結束方法，可以帶一個返回值。</li>\n</ol>\n<h3 id=\"泛型、類型擦除和通配符\"><a href=\"#泛型、類型擦除和通配符\" class=\"headerlink\" title=\"泛型、類型擦除和通配符\"></a>泛型、類型擦除和通配符</h3><p><strong>泛型的本質是將類型參數化。</strong>Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲<strong>僞泛型</strong>。下面的例子展示了如何在運行期加入非法類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"comment\">//這裡直接添加會報錯</span></span><br><span class=\"line\"><span class=\"comment\">// list.add(&quot;a&quot;);</span></span><br><span class=\"line\">Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class=\"line\">Method add = clazz.getDeclaredMethod(<span class=\"string\">&quot;add&quot;</span>, Object.class);</span><br><span class=\"line\"><span class=\"comment\">//但是通過反射添加，是可以的</span></span><br><span class=\"line\">add.invoke(list, <span class=\"string\">&quot;kl&quot;</span>);</span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<p>泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。</p>\n<p>泛型通配符約定：</p>\n<ol>\n<li>？ 表示不確定的 Java 類型，用於泛型方法</li>\n<li>T（Type）表示確定的一個 Java 類型</li>\n<li>K V（Key Value）分別表示映射中的鍵、值</li>\n<li>E（Element）表示集合中的一個元素</li>\n<li>&lt;? extends A&gt; 上界通配符，表示 A 類型或其子類</li>\n<li>&lt;? super A&gt; 下界通配符，表示 A 類型或其父類</li>\n<li><T extends a> 表示 A 類型或其子類的一種</T></li>\n<li>&lt;T extends A &amp; B&gt; 表示 A 類型且B類型的子類的一種</li>\n<li><del><T super a></T></del> </li>\n</ol>\n<p>泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<Apple> 的引用並不能傳遞給 Plate<Fruit>，但可以傳遞給 Plate&lt;? extends Fruit&gt;。</Fruit></Apple></p>\n<p>元素爲 &lt;? extends E&gt; 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? extends A&gt; list = Arrays.asList(<span class=\"keyword\">new</span> A(), <span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  A a = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(a.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>元素爲 &lt;? super E&gt; 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? <span class=\"keyword\">super</span> B&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> C());</span><br><span class=\"line\">  Object object = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(object.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"獲取鍵盤輸入數據的常用方法\"><a href=\"#獲取鍵盤輸入數據的常用方法\" class=\"headerlink\" title=\"獲取鍵盤輸入數據的常用方法\"></a>獲取鍵盤輸入數據的常用方法</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">String s = scanner.nextLine();</span><br><span class=\"line\">System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException</span></span><br><span class=\"line\">BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">String s1 = bufferedReader.readLine();</span><br><span class=\"line\">System.out.println(s1);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法（函數）\"><a href=\"#方法（函數）\" class=\"headerlink\" title=\"方法（函數）\"></a>方法（函數）</h2><h3 id=\"爲什麼-Java-只有值傳遞？\"><a href=\"#爲什麼-Java-只有值傳遞？\" class=\"headerlink\" title=\"爲什麼 Java 只有值傳遞？\"></a>爲什麼 Java 只有值傳遞？</h3><p>首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：</p>\n<ol>\n<li>按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。</li>\n<li>按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。</li>\n</ol>\n<p><strong>Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  String s1 = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">  String s2 = <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">  swap(s1, s2);</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">&quot;main s1: %s, s2: %s%n&quot;</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">  String tmp = s1;</span><br><span class=\"line\">  s1 = s2;</span><br><span class=\"line\">  s2 = tmp;</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">&quot;swap s1: %s, s2: %s%n&quot;</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 運行結果：</span></span><br><span class=\"line\"><span class=\"comment\">// swap s1: World, s2: Hello</span></span><br><span class=\"line\"><span class=\"comment\">// main s1: Hello, s2: World</span></span><br></pre></td></tr></table></figure>\n\n<p>結論：</p>\n<ol>\n<li>一個方法不能修改一個基本類型的實參。</li>\n<li>一個方法可以改變一個對象類型的實參狀態。</li>\n<li>一個方法不能讓對象類型的實參引用一個新對象。</li>\n</ol>\n<h3 id=\"深拷貝和淺拷貝有什麼不同？\"><a href=\"#深拷貝和淺拷貝有什麼不同？\" class=\"headerlink\" title=\"深拷貝和淺拷貝有什麼不同？\"></a>深拷貝和淺拷貝有什麼不同？</h3><ol>\n<li>淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。</li>\n<li>深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。</li>\n</ol>\n<p><img src=\"/it/java/java-basic/Untitled.png\" alt></p>\n<h3 id=\"重載和重寫有什麼區別？\"><a href=\"#重載和重寫有什麼區別？\" class=\"headerlink\" title=\"重載和重寫有什麼區別？\"></a>重載和重寫有什麼區別？</h3><ol>\n<li>重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。</li>\n<li>重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。</li>\n</ol>\n<h2 id=\"Java-面向對象\"><a href=\"#Java-面向對象\" class=\"headerlink\" title=\"Java 面向對象\"></a>Java 面向對象</h2><h3 id=\"面向對象和面向過程\"><a href=\"#面向對象和面向過程\" class=\"headerlink\" title=\"面向對象和面向過程\"></a>面向對象和面向過程</h3><ol>\n<li>面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。</li>\n<li>面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。</li>\n</ol>\n<p>Java 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。</p>\n<h3 id=\"構造方法\"><a href=\"#構造方法\" class=\"headerlink\" title=\"構造方法\"></a>構造方法</h3><ol>\n<li>特點：名字跟類名相同，沒有返回值，不可重寫但可重載。</li>\n<li>作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。</li>\n<li>子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。</li>\n</ol>\n<h3 id=\"成員變量和局部變量的區別\"><a href=\"#成員變量和局部變量的區別\" class=\"headerlink\" title=\"成員變量和局部變量的區別\"></a>成員變量和局部變量的區別</h3><ol>\n<li>成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。</li>\n<li>局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。</li>\n</ol>\n<h3 id=\"對象實例和對象引用的區別\"><a href=\"#對象實例和對象引用的區別\" class=\"headerlink\" title=\"對象實例和對象引用的區別\"></a>對象實例和對象引用的區別</h3><ol>\n<li>對象實例：存在於堆內存，一個對象實例可以被多個引用指向。</li>\n<li>對象引用：存在於棧內存，一個引用指向一個對象實例。</li>\n</ol>\n<h3 id=\"面向對象的三大特徵\"><a href=\"#面向對象的三大特徵\" class=\"headerlink\" title=\"面向對象的三大特徵\"></a>面向對象的三大特徵</h3><p><strong>（1）封裝</strong></p>\n<p>封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。</p>\n<p><strong>（2）繼承</strong></p>\n<p>繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：</p>\n<ol>\n<li>子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），<strong>僅僅擁有</strong>。</li>\n<li>子類可以對父類進行擴展，增加新的屬性和方法。</li>\n<li>子類可以重寫父類的方法。</li>\n</ol>\n<p><strong>（3）多態</strong></p>\n<p>多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：</p>\n<ol>\n<li>對象類型和引用類型之間具有繼承/實現關係。</li>\n<li>對象類型不可變，引用類型可變。</li>\n<li>方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。</li>\n<li>父類的引用不能調用「只有子類存在但在父類不存在」的方法。</li>\n<li>如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。</li>\n</ol>\n<h3 id=\"靜態方法內爲什麼不能調用非靜態成員？\"><a href=\"#靜態方法內爲什麼不能調用非靜態成員？\" class=\"headerlink\" title=\"靜態方法內爲什麼不能調用非靜態成員？\"></a><strong>靜態方法內爲什麼不能調用非靜態成員？</strong></h3><p>因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。</p>\n<h3 id=\"接口和抽象類的區別\"><a href=\"#接口和抽象類的區別\" class=\"headerlink\" title=\"接口和抽象類的區別\"></a>接口和抽象類的區別</h3><ol>\n<li>方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。</li>\n<li>變量上：接口只能有 static、final 變量；而抽象類沒有限制。</li>\n<li>繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。</li>\n<li>設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。</li>\n</ol>\n<h2 id=\"Java-核心技術\"><a href=\"#Java-核心技術\" class=\"headerlink\" title=\"Java 核心技術\"></a>Java 核心技術</h2><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>見 <a href=\"https://tsunhua.github.io/2020/12/02/it/java/java-collection/\">Java 集合</a> </p>\n<h3 id=\"反射機制\"><a href=\"#反射機制\" class=\"headerlink\" title=\"反射機制\"></a>反射機制</h3><p><strong>（1）什麼是反射</strong></p>\n<p>Java 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。</p>\n<p><strong>（2）反射的優缺點</strong></p>\n<ol>\n<li>優點：運行時確定類型，動態加載類，提高代碼靈活度。</li>\n<li>缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。</li>\n</ol>\n<p>反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。</p>\n<p><strong>（3）反射的應用場景</strong></p>\n<p>反射是框架設計的靈魂。其應用場景有：</p>\n<ol>\n<li>模塊化開發；</li>\n<li>動態代理設計模式；</li>\n<li>Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；</li>\n<li>JDBC 連接數據庫等等。</li>\n</ol>\n<h3 id=\"異常\"><a href=\"#異常\" class=\"headerlink\" title=\"異常\"></a>異常</h3><p><strong>（1）簡介</strong></p>\n<p>Java 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。<strong>Error 通常是 JVM 錯誤，程序無法處理</strong>；<strong>而 Exception 是程序本身可以處理的異常</strong>。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。</p>\n<p><img src=\"/it/java/java-basic/Untitled%201.png\" alt></p>\n<p><strong>Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）</strong>，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：</p>\n<ul>\n<li><em>IOException</em></li>\n<li><em>EOFException</em></li>\n<li><em>MalFormedURLException</em></li>\n<li><em>IntruptedException</em></li>\n</ul>\n<p><strong>Unchecked Exception 又名 Runtime Exceptions（運行時異常）</strong>，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：</p>\n<ul>\n<li><em>ArithmaticException</em></li>\n<li><em>NullPointerException</em></li>\n<li><em>IndexOutOfBoundsException</em></li>\n<li><em>ClassCastException</em></li>\n<li><em>ArrayIndexOutOfBoundsException</em></li>\n<li><em>NumberFormatException</em></li>\n</ul>\n<p><strong>（2）Throwable 類常用方法</strong></p>\n<ol>\n<li><code>getMessage</code>：返回異常的簡要描述</li>\n<li><code>toString</code>：返回異常的詳細信息</li>\n<li><code>getLocalizedMessage</code>：返回異常的本地化信息（需要子類覆蓋該方法，否則與 <code>getMessage</code> 一樣）</li>\n<li><code>printStackTrace</code>：在控制台打印 Throwable 对象封装的异常信息</li>\n</ol>\n<p><strong>（3）try-catch-finally</strong></p>\n<ol>\n<li>try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。</li>\n<li>catch 代碼塊：處理捕獲到的異常。</li>\n<li>finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value * value;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// f(2) 將返回 0 ，而不是 4.</span></span><br></pre></td></tr></table></figure>\n\n<p>以下情況，finally 代碼塊不會被執行或只部分執行：</p>\n<ol>\n<li>finally 代碼塊中有異常，代碼會中異常處中止；</li>\n<li>在 catch 代碼塊或 finally 塊中調用了 <code>System.exit</code> 函數退出程序；</li>\n<li>程序所在的線程死亡等等不可預料的系統和硬件問題。</li>\n</ol>\n<p><strong>（4）try-witch-resources</strong></p>\n<p>Java 7 中新增了 ****try-witch-resources 語法糖，適用於實現<code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try-catch-finally</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;src/main/resources/test.txt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (scanner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        scanner.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// try-witch-resources</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (Scanner scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;src/main/resources/test.txt&quot;</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多線程\"><a href=\"#多線程\" class=\"headerlink\" title=\"多線程\"></a>多線程</h3><p>見 <a href=\"https://tsunhua.github.io/2020/12/10/it/java/java-concurrent/\">Java 多線程</a> </p>\n<h3 id=\"文件與-I-O-流\"><a href=\"#文件與-I-O-流\" class=\"headerlink\" title=\"文件與 I/O 流\"></a>文件與 I/O 流</h3><p><strong>（1）Java 中 I/O 流分爲幾種？</strong></p>\n<p>按不同的分類方法有不同的分類：</p>\n<ol>\n<li>按流向分：輸入流、輸出流。</li>\n<li>按操作單元分：字節流、字符流。</li>\n<li>按角色分：節點流、處理流。</li>\n</ol>\n<p>Java 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：</p>\n<ol>\n<li>InputStream：字節輸入流</li>\n<li>Reader：字符輸入流</li>\n<li>OutputStream：字節輸出流</li>\n<li>Writer：字符輸出流</li>\n</ol>\n<p><img src=\"/it/java/java-basic/Untitled%202.png\" alt></p>\n<p><img src=\"/it/java/java-basic/Untitled%203.png\" alt></p>\n<p><strong>（2）爲什麼有了字節流還需要字符流？</strong></p>\n<p>不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？</p>\n<p>字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。</p>\n<p><strong>（3）BIO、NIO、AIO 有什麼區別？</strong></p>\n<ol>\n<li><strong>BIO</strong>（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（&lt; 單機 1000）的情況，結合線程池一起使用。</li>\n<li><strong>NIO</strong>（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 <code>java.nio</code> 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。</li>\n<li><strong>AIO</strong>（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。</li>\n</ol>\n<p>NIO 模型：</p>\n<p><img src=\"/it/java/java-basic/Untitled%204.png\" alt></p>\n<ul>\n<li><p>NIO 服務端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiplexerNioServer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化多路复用器 绑定监听端口</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> port</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MultiplexerNioServer</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<span class=\"comment\">//获得一个serverChannel</span></span><br><span class=\"line\">            selector = Selector.open();<span class=\"comment\">////创建选择器  获得一个多路复用器</span></span><br><span class=\"line\">            serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);<span class=\"comment\">//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(port), <span class=\"number\">1024</span>);<span class=\"comment\">//绑定一个端口和等待队列长度</span></span><br><span class=\"line\">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<span class=\"comment\">//把selector注册到channel，关注链接事件</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>; <span class=\"comment\">// 优雅停机</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> client = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;1:&quot;</span> + client);</span><br><span class=\"line\">                <span class=\"comment\">// 阻塞,只有当至少一个注册的事件发生的时候才会继续.</span></span><br><span class=\"line\">                <span class=\"comment\">// int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;2:&quot;</span> + client);</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//处理事件</span></span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// selector关闭后会自动释放里面管理的资源</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//连接事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                <span class=\"comment\">// 通过ServerSocketChannel的accept创建SocketChannel实例</span></span><br><span class=\"line\">                <span class=\"comment\">// 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span></span><br><span class=\"line\">                SocketChannel sc = ssc.accept();<span class=\"comment\">//3次握手</span></span><br><span class=\"line\">                sc.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                sc.register(selector, SelectionKey.OP_READ);<span class=\"comment\">//连接建立后关注读事件</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//读事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">                ByteBuffer readbuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);<span class=\"comment\">//写 0 1024  1024</span></span><br><span class=\"line\"><span class=\"comment\">//                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存</span></span><br><span class=\"line\">                <span class=\"comment\">// 读取请求码流，返回读取到的字节数</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> readBytes = socketChannel.read(readbuffer);</span><br><span class=\"line\">                    <span class=\"comment\">// 读取到字节，对字节进行编解码</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span></span><br><span class=\"line\">                        readbuffer.flip();<span class=\"comment\">//读写模式反转</span></span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区可读字节数组复制到新建的数组中</span></span><br><span class=\"line\">                        <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readbuffer.remaining()];</span><br><span class=\"line\">                        readbuffer.get(bytes);</span><br><span class=\"line\">                        String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;input is:&quot;</span> + body);</span><br><span class=\"line\">                        res(socketChannel, body);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 链路已经关闭 释放资源</span></span><br><span class=\"line\">                        key.cancel();</span><br><span class=\"line\">                        socketChannel.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 没有读到字节忽略</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">res</span><span class=\"params\">(SocketChannel channel, String response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span> &amp;&amp; response.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = response.getBytes();</span><br><span class=\"line\">            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class=\"line\">            writeBuffer.put(bytes);</span><br><span class=\"line\">            writeBuffer.flip();</span><br><span class=\"line\">            channel.write(writeBuffer);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;res end&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NIO 客戶端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioClientHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String host;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SocketChannel socketChannel;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NioClientHandler</span><span class=\"params\">(String host, <span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.host = host;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建选择器</span></span><br><span class=\"line\">            selector = Selector.open();</span><br><span class=\"line\">            <span class=\"comment\">// 打开监听通道</span></span><br><span class=\"line\">            socketChannel = SocketChannel.open();</span><br><span class=\"line\">            <span class=\"comment\">// 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            socketChannel.configureBlocking(<span class=\"keyword\">false</span>); <span class=\"comment\">// 开启非阻塞模式</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doConnect();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> wait = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wait == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doConnect</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(host, port))) &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">            doWrite(socketChannel);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc.finishConnect()) &#123;</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    doWrite(sc);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                ByteBuffer readBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> readBytes = sc.read(readBuffer);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    readBuffer.flip();</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readBuffer.remaining()];</span><br><span class=\"line\">                    readBuffer.get(bytes);</span><br><span class=\"line\">                    String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;res&quot;</span> + body);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    key.cancel();</span><br><span class=\"line\">                    sc.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doWrite</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将消息编码为字节数组</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] request = <span class=\"string\">&quot;Hello&quot;</span>.getBytes();</span><br><span class=\"line\">        <span class=\"comment\">// 根据数组容量创建ByteBuffer</span></span><br><span class=\"line\">        ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);</span><br><span class=\"line\">        <span class=\"comment\">// 将字节数组复制到缓冲区</span></span><br><span class=\"line\">        writeBuffer.put(request);</span><br><span class=\"line\">        <span class=\"comment\">// flip读写切换操作</span></span><br><span class=\"line\">        writeBuffer.flip();</span><br><span class=\"line\">        sc.write(writeBuffer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!writeBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;写入完成&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"Java-項目管理和構建\"><a href=\"#Java-項目管理和構建\" class=\"headerlink\" title=\"Java 項目管理和構建\"></a>Java 項目管理和構建</h2><h3 id=\"Maven-项目\"><a href=\"#Maven-项目\" class=\"headerlink\" title=\"Maven 项目\"></a>Maven 项目</h3><p><strong>（1）安装</strong></p>\n<p>從 <a href=\"https://maven.apache.org/download.cgi\">Maven 官網</a>下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。</p>\n<p><strong>（2）初始化一個 Maven 項目</strong></p>\n<p>使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure>\n\n<p>或者用 IDEA 直接新建一個 Maven 項目，其結構如下：</p>\n<p><img src=\"/it/java/java-basic/20201114_101407.png\" alt></p>\n<p>其中 pom.xml 的內容如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.example<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>testmaven<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--  添加以下屬性，解決編譯報錯  --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.encoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.encoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 新增依賴在下方 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.openjdk.jol<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jol-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.14<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>為什麼叫 Maven？</p>\n<p>  Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。</p>\n</li>\n<li><p>POM 又是指什麼？</p>\n<p>  POM（project object model）項目對象模型，maven 使用 <code>pom.xml</code> 定義了整個項目的構建、報告和文檔。</p>\n</li>\n</ul>\n<p><strong>（3）編譯測試打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理 target 中的文件</span></span><br><span class=\"line\">mvn clean</span><br><span class=\"line\"><span class=\"comment\"># 編譯 java 文件成 class 文件，置於 target/classes 文件夾中</span></span><br><span class=\"line\">mvn compile</span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">mvn <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># 打包成 jar 文件，置於 target 文件夾中</span></span><br><span class=\"line\">mvn package</span><br><span class=\"line\"><span class=\"comment\"># 安裝 jar 包到本地存儲庫（$&#123;user.home&#125;/.m2/repository）</span></span><br><span class=\"line\">mvn install</span><br><span class=\"line\"><span class=\"comment\"># 生成自己的 maven 站點</span></span><br><span class=\"line\">mvn site</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>SNAPSHOT 是什麼？</p>\n<p>  snapshot 簡要的意思，在版本號之後添加 <code>-SNAPSHOT</code> 是說明該版本仍處於開發階段，不是最終的發行版本。以 <code>x.y-SNAPSHOT</code> 版本為例，發行時會去除 <code>-SNAPSHOT</code>  後綴，然後將最新的開發版本升爲<code>x.(y+1)-SNAPSHOT</code> 。</p>\n</li>\n<li><p>使用 mvn compile 生成的 jar 包，其內容是怎樣的？</p>\n<p>  除了 class 文件外，還有 <code>META-INF</code> 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（<code>main/resources</code> ）的文件也會被打包到<code>META-INF</code> 文件夾中，代碼中可通過<code>getClass().getResourceAsStream( &quot;/application.properties&quot; )</code> 調用。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ jar tf target/testmaven-1.0-SNAPSHOT.jar </span><br><span class=\"line\">META-INF/</span><br><span class=\"line\">META-INF/MANIFEST.MF</span><br><span class=\"line\">B.class</span><br><span class=\"line\">MemoryLayoutTest.class</span><br><span class=\"line\">A.class</span><br><span class=\"line\">C.class</span><br><span class=\"line\">META-INF/maven/</span><br><span class=\"line\">META-INF/maven/org.example/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.xml</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.properties</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"Gradle-项目\"><a href=\"#Gradle-项目\" class=\"headerlink\" title=\"Gradle 项目\"></a>Gradle 项目</h3><p><strong>（1）安裝</strong></p>\n<p>可從 <a href=\"https://www.gradle.org/downloads\">gradle 官網</a>下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 <code>brew install gradle</code> 的方式安裝。或者直接使用 IDEA 項目中的 <code>gradle-wrapper</code> ，此時對應的 <code>gradle</code> 命令變爲 <code>gradlew</code>。</p>\n<p><strong>（2）gradle 命令能做什麼？</strong></p>\n<p>gradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gradle tasks</span><br><span class=\"line\"></span><br><span class=\"line\">:tasks</span><br><span class=\"line\"></span><br><span class=\"line\">== All tasks runnable from root project</span><br><span class=\"line\"></span><br><span class=\"line\">== Build Setup tasks</span><br><span class=\"line\">setupBuild - Initializes a new Gradle build. [incubating]</span><br><span class=\"line\"></span><br><span class=\"line\">== Help tasks</span><br><span class=\"line\">dependencies - Displays all dependencies declared <span class=\"keyword\">in</span> root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">dependencyInsight - Displays the insight into a specific dependency <span class=\"keyword\">in</span> root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\"><span class=\"built_in\">help</span> - Displays a <span class=\"built_in\">help</span> message</span><br><span class=\"line\">projects - Displays the sub-projects of root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">properties - Displays the properties of root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">tasks - Displays the tasks runnable from root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">To see all tasks and more detail, run with --all.</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL</span><br><span class=\"line\"></span><br><span class=\"line\">Total time: 3.077 secs</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）初始化一個 Gradle 項目</strong></p>\n<p>在項目文件夾中新建一個名爲 <code>build.gradle</code> 的文件，其內容如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;java&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>隨後新建一個名爲 <code>settings.gradle</code> 的文件，其內容可暫時爲空。</p>\n<p>在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 <code>gradle-wrapper</code> ，其過程等價於執行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gradle wrapper --gradle-version 6.5</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）編譯打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包</span></span><br><span class=\"line\">gradle build</span><br><span class=\"line\"><span class=\"comment\"># 或使用 gradle wrapper</span></span><br><span class=\"line\">./gradlew build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理生成的文件</span></span><br><span class=\"line\">gradle clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成 jar 文件</span></span><br><span class=\"line\">gradle jar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 運行生成的 jar 文件</span></span><br><span class=\"line\">gradle run</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">gradle <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）<code>build.gradle</code> 中可配置什麼？</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置插件，插件提供語法定義</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;application&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置入口類</span></span><br><span class=\"line\">mainClassName = <span class=\"string\">&#x27;hello.HelloWorld&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴倉庫</span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置生成的 jar 文件的入口類</span></span><br><span class=\"line\">jar &#123;</span><br><span class=\"line\">    manifest &#123;</span><br><span class=\"line\">        attributes <span class=\"string\">&#x27;Main-Class&#x27;</span>: mainClassName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置 JDK 兼容性</span></span><br><span class=\"line\">sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">targetCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile <span class=\"string\">&quot;joda-time:joda-time:2.2&quot;</span></span><br><span class=\"line\">    testCompile <span class=\"string\">&quot;junit:junit:4.12&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如需將所有依賴 jar 打進同一個 jar 包，可使用 <a href=\"https://github.com/johnrengelman/shadow\">shadow 插件</a>或使用 <a href=\"https://spring.io/quickstart\">spring boot 插件</a>。</p>\n","site":{"data":{}},"excerpt":"<p>Java 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。</p>\n<ul>\n<li>它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。</li>\n<li>它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。</li>\n<li>它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。</li>\n<li>它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。</li>\n<li>它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。</li>\n<li>它提供了豐富的集合類、迭代器及工具類。</li>\n<li>它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。</li>\n<li>它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。</li>\n<li>它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。</li>\n<li>另外，目前有兩大項目管理工具，Maven 和 Gradle。</li>\n</ul>","more":"<h2 id=\"Java-入門（基礎概念與常識）\"><a href=\"#Java-入門（基礎概念與常識）\" class=\"headerlink\" title=\"Java 入門（基礎概念與常識）\"></a>Java 入門（基礎概念與常識）</h2><h3 id=\"歷史\"><a href=\"#歷史\" class=\"headerlink\" title=\"歷史\"></a>歷史</h3><p>Java 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 <code>CA FE BA BE</code> ，即 cafe babe （咖啡寶貝）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexdump Test.class</span><br><span class=\"line\"><span class=\"number\">0000000</span> ca fe ba be <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> 3b <span class=\"number\">00</span> <span class=\"number\">51</span> 0a <span class=\"number\">00</span> <span class=\"number\">02</span> <span class=\"number\">00</span> <span class=\"number\">03</span> <span class=\"number\">07</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1994 年完成 1.0 版本。</li>\n<li>1995 年首次對外發佈，Java 語言誕生。</li>\n<li>1996 年JDK 1.0 誕生。</li>\n<li>2004 年 SUN 公司發佈 Java SE 5。</li>\n<li>2005 年 SUN 公司發佈 Java SE 6。</li>\n<li>2006 年 SUN 公司推出 OpenJDK 計劃。</li>\n<li>2014年 Oracle 公司發佈 Java SE 8。</li>\n<li>2017年 Oracle公司發佈 Java SE 9。</li>\n<li>2020 年 Oracle 公司發佈 Java SE 15。</li>\n</ul>\n<h3 id=\"安裝與卸載JDK\"><a href=\"#安裝與卸載JDK\" class=\"headerlink\" title=\"安裝與卸載JDK\"></a>安裝與卸載JDK</h3><p>在 Mac 環境下，從 <a href=\"https://www.oracle.com/tw/java/technologies/javase-downloads.html\">Oracle JavaSE 下載地址</a> 下載並安裝。安裝完成後執行 <code>java -version</code>  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 <code>/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home</code> 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin</span><br><span class=\"line\">sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane</span><br><span class=\"line\"></span><br><span class=\"line\">ls /Library/Java/JavaVirtualMachines/</span><br><span class=\"line\">输出：jdk-9.0.1.jdk</span><br><span class=\"line\"></span><br><span class=\"line\">sudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>運行以下代碼，將輸出 <code>Hello World</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java-語言的特點\"><a href=\"#Java-語言的特點\" class=\"headerlink\" title=\"Java 語言的特點\"></a>Java 語言的特點</h3><ol>\n<li>面向對象（封裝，繼承，多態）</li>\n<li>平台無關性（ Java 虛擬機實現平台無關性）</li>\n<li>支持多線程</li>\n<li>編譯與解釋並存</li>\n</ol>\n<p>編譯：生成字節碼(.class文件)，javac 指令。<br>解釋：解釋字節碼成機器碼，java 指令。</p>\n<h3 id=\"JVM、JDK-和-JRE\"><a href=\"#JVM、JDK-和-JRE\" class=\"headerlink\" title=\"JVM、JDK 和  JRE\"></a>JVM、JDK 和  JRE</h3><ol>\n<li>JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。</li>\n<li>JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。</li>\n<li>JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。</li>\n</ol>\n<h3 id=\"Java-與-C-對比\"><a href=\"#Java-與-C-對比\" class=\"headerlink\" title=\"Java 與 C++ 對比\"></a>Java 與 C++ 對比</h3><ol>\n<li>皆支持面向對象編程（封裝、繼承和多態）。</li>\n<li>Java 不提供指針來直接訪問內存；C++ 提供。</li>\n<li>Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。</li>\n<li>Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。</li>\n<li>Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符<code>\\0</code> 來表示結束。</li>\n</ol>\n<h2 id=\"Java-語法\"><a href=\"#Java-語法\" class=\"headerlink\" title=\"Java 語法\"></a>Java 語法</h2><h3 id=\"基本類型及其大小\"><a href=\"#基本類型及其大小\" class=\"headerlink\" title=\"基本類型及其大小\"></a>基本類型及其大小</h3><p>Java 共 8 種數據類型（不包括 void），具體如下表：</p>\n<p><img src=\"/it/java/java-basic/20201202_24328.png\" alt></p>\n<p>boolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。</p>\n<p>char 值是一個 16 位的 Unicode 字符，最小值是 ‘\\u0000’ ，最大值是 ‘\\uffff’，即 0～65535，每個數字對應一個字符。</p>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a = <span class=\"string\">&#x27;中&#x27;</span>;</span><br><span class=\"line\">System.out.println((<span class=\"keyword\">int</span>)a);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 20013</span></span><br><span class=\"line\">System.out.println(Integer.toHexString(a));</span><br><span class=\"line\"><span class=\"comment\">// 輸出 4e2d</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&#x27;\\u4e2d&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 中</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>byte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。</p>\n<ul>\n<li>二進制補碼<ul>\n<li>過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。</li>\n<li>原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 <a href=\"https://www.ruanyifeng.com/blog/2009/08/twos_complement.html\">https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm</a>l</li>\n</ul>\n</li>\n</ul>\n<p>long 類型的數據後面一定要加上 L，否則會被認為是整型。</p>\n<p>char 類型值使用單引號括起來，String 使用雙引號。</p>\n<p>Java 有<strong>自動拆裝箱機制</strong>，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。</p>\n<h3 id=\"包裝類型及常量池技術\"><a href=\"#包裝類型及常量池技術\" class=\"headerlink\" title=\"包裝類型及常量池技術\"></a>包裝類型及常量池技術</h3><ol>\n<li>Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。</li>\n<li>Character 創建了數值在 [0, 127] 的緩存數據。</li>\n<li>Boolean 直接返回 True 和 False。</li>\n<li>Float 和 Double 沒有實現常量池技術。</li>\n</ol>\n<p>使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">33</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">Integer i11 = <span class=\"number\">333</span>;</span><br><span class=\"line\">Integer i22 = <span class=\"number\">333</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">Double i3 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">Double i4 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p>《阿里巴巴Java開發手冊》規定：</p>\n<ul>\n<li>【強制】<strong>所有的 POJO 類屬性必須使用包裝數據類型</strong>。</li>\n<li>【強制】RPC 方法的返回值和參數必須使用包裝數據類型。</li>\n<li>【推薦】所有的局部變量使用基本數據類型。</li>\n</ul>\n<h3 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h3><p><strong>（1）使用 BigDecimal 進行浮點數比較和精度取捨</strong></p>\n<p><strong>（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> a = <span class=\"number\">1.0f</span> - <span class=\"number\">0.9f</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> b = <span class=\"number\">0.9f</span> - <span class=\"number\">0.8f</span>;</span><br><span class=\"line\">System.out.println(a);</span><br><span class=\"line\">System.out.println(b);</span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1.0&quot;</span>);</span><br><span class=\"line\">BigDecimal b = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;0.9&quot;</span>);</span><br><span class=\"line\">BigDecimal c = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;0.8&quot;</span>);</span><br><span class=\"line\">System.out.println(a.subtract(b));</span><br><span class=\"line\">System.out.println(b.subtract(c));</span><br><span class=\"line\">System.out.println(a.subtract(b).equals(b.subtract(c))); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1.1252312&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 取小數點後 2 位，四捨五入</span></span><br><span class=\"line\">BigDecimal scale = a.setScale(<span class=\"number\">2</span>, RoundingMode.HALF_UP);</span><br><span class=\"line\">System.out.println(scale.toString()); <span class=\"comment\">// 1.13</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"對象及其大小\"><a href=\"#對象及其大小\" class=\"headerlink\" title=\"對象及其大小\"></a>對象及其大小</h3><p>基本類型的封裝類型是對象，Java 中的對象由以下部分組成：</p>\n<ol>\n<li>對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。</li>\n<li>實例數據（instance data）：對象的有效信息。</li>\n<li>對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。</li>\n</ol>\n<p>可使用 <code>org.openjdk.jol</code> 工具查看一個對象佔用的字節大小，</p>\n<ul>\n<li><p>如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(VM.current().details());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseClass(Object.class).toPrintable());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseInstance(Integer.valueOf(<span class=\"number\">1</span>)).toPrintable());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  輸出結果：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Running 64-bit HotSpot VM.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed oop with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed klass with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Compressed references base/shifts are guessed by the experiment!</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.</span></span><br><span class=\"line\"><span class=\"comment\"># Objects are 8 bytes aligned.</span></span><br><span class=\"line\"><span class=\"comment\"># Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"><span class=\"comment\"># Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Object object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0    12        (object header)                           N/A</span><br><span class=\"line\">     12     4        (loss due to the next object alignment)</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Integer object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)</span><br><span class=\"line\">      4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)</span><br><span class=\"line\">      8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)</span><br><span class=\"line\">     12     4    int Integer.value                             1</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。</p>\n<h3 id=\"String、StringBuffer-和-String-Builder-的區別\"><a href=\"#String、StringBuffer-和-String-Builder-的區別\" class=\"headerlink\" title=\"String、StringBuffer 和 String Builder 的區別\"></a>String、StringBuffer 和 String Builder 的區別</h3><p>String 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Java 9 之前</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\">  <span class=\"comment\">// Java 9 之後</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>StringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。</p>\n<p>下面從不同角度比較下此三者：</p>\n<ol>\n<li>線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。</li>\n<li>性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。</li>\n</ol>\n<h3 id=\"注釋\"><a href=\"#注釋\" class=\"headerlink\" title=\"注釋\"></a>注釋</h3><p>代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。</p>\n<h3 id=\"標識符和關鍵字的區別\"><a href=\"#標識符和關鍵字的區別\" class=\"headerlink\" title=\"標識符和關鍵字的區別\"></a>標識符和關鍵字的區別</h3><p>標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：</p>\n<ol>\n<li>訪問控制：private、protected、public</li>\n<li>類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile</li>\n<li>程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default</li>\n<li>錯誤處理：try、catch、throw、throws、finally</li>\n<li>包相關：import、package</li>\n<li>基本類型：boolean、byte、char、double、float、int、short、null、true、false</li>\n<li>變量引用：super、this、void</li>\n<li>保留字：goto、const</li>\n</ol>\n<h3 id=\"自增自減運算符\"><a href=\"#自增自減運算符\" class=\"headerlink\" title=\"自增自減運算符\"></a>自增自減運算符</h3><p>符號在前先加減再賦值，符號在後先賦值後加減。假定 <code>a = 1; b = a++</code> 最後 a 值爲 2，b 值爲 1。</p>\n<h3 id=\"和-equals-的區別\"><a href=\"#和-equals-的區別\" class=\"headerlink\" title=\"== 和 equals 的區別\"></a>== 和 equals 的區別</h3><ol>\n<li>基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。</li>\n<li>equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。</li>\n<li>整型包裝類都應使用 equals 比較大小。</li>\n<li>浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。</li>\n</ol>\n<ul>\n<li><p>重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？</p>\n<p>  hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<p>  HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。</p>\n</li>\n</ul>\n<h3 id=\"序列化時如果有些字段不想序列化，怎麼辦？\"><a href=\"#序列化時如果有些字段不想序列化，怎麼辦？\" class=\"headerlink\" title=\"序列化時如果有些字段不想序列化，怎麼辦？\"></a>序列化時如果有些字段不想序列化，怎麼辦？</h3><p>使用 transient 關鍵字修飾不想序列化的字段。</p>\n<h3 id=\"continue、break-和-return-的區別\"><a href=\"#continue、break-和-return-的區別\" class=\"headerlink\" title=\"continue、break 和 return 的區別\"></a>continue、break 和 return 的區別</h3><ol>\n<li>continue：跳出當前這一次循環，繼續下一次循環。</li>\n<li>break：跳出整個循環體，繼續執行循環外的語句。</li>\n<li>return：跳出所在的方法，結束方法，可以帶一個返回值。</li>\n</ol>\n<h3 id=\"泛型、類型擦除和通配符\"><a href=\"#泛型、類型擦除和通配符\" class=\"headerlink\" title=\"泛型、類型擦除和通配符\"></a>泛型、類型擦除和通配符</h3><p><strong>泛型的本質是將類型參數化。</strong>Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲<strong>僞泛型</strong>。下面的例子展示了如何在運行期加入非法類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"comment\">//這裡直接添加會報錯</span></span><br><span class=\"line\"><span class=\"comment\">// list.add(&quot;a&quot;);</span></span><br><span class=\"line\">Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class=\"line\">Method add = clazz.getDeclaredMethod(<span class=\"string\">&quot;add&quot;</span>, Object.class);</span><br><span class=\"line\"><span class=\"comment\">//但是通過反射添加，是可以的</span></span><br><span class=\"line\">add.invoke(list, <span class=\"string\">&quot;kl&quot;</span>);</span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<p>泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。</p>\n<p>泛型通配符約定：</p>\n<ol>\n<li>？ 表示不確定的 Java 類型，用於泛型方法</li>\n<li>T（Type）表示確定的一個 Java 類型</li>\n<li>K V（Key Value）分別表示映射中的鍵、值</li>\n<li>E（Element）表示集合中的一個元素</li>\n<li>&lt;? extends A&gt; 上界通配符，表示 A 類型或其子類</li>\n<li>&lt;? super A&gt; 下界通配符，表示 A 類型或其父類</li>\n<li><T extends a> 表示 A 類型或其子類的一種</T></li>\n<li>&lt;T extends A &amp; B&gt; 表示 A 類型且B類型的子類的一種</li>\n<li><del><T super a></T></del> </li>\n</ol>\n<p>泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<Apple> 的引用並不能傳遞給 Plate<Fruit>，但可以傳遞給 Plate&lt;? extends Fruit&gt;。</Fruit></Apple></p>\n<p>元素爲 &lt;? extends E&gt; 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? extends A&gt; list = Arrays.asList(<span class=\"keyword\">new</span> A(), <span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  A a = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(a.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>元素爲 &lt;? super E&gt; 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? <span class=\"keyword\">super</span> B&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> C());</span><br><span class=\"line\">  Object object = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(object.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"獲取鍵盤輸入數據的常用方法\"><a href=\"#獲取鍵盤輸入數據的常用方法\" class=\"headerlink\" title=\"獲取鍵盤輸入數據的常用方法\"></a>獲取鍵盤輸入數據的常用方法</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">String s = scanner.nextLine();</span><br><span class=\"line\">System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException</span></span><br><span class=\"line\">BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">String s1 = bufferedReader.readLine();</span><br><span class=\"line\">System.out.println(s1);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法（函數）\"><a href=\"#方法（函數）\" class=\"headerlink\" title=\"方法（函數）\"></a>方法（函數）</h2><h3 id=\"爲什麼-Java-只有值傳遞？\"><a href=\"#爲什麼-Java-只有值傳遞？\" class=\"headerlink\" title=\"爲什麼 Java 只有值傳遞？\"></a>爲什麼 Java 只有值傳遞？</h3><p>首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：</p>\n<ol>\n<li>按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。</li>\n<li>按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。</li>\n</ol>\n<p><strong>Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  String s1 = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">  String s2 = <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">  swap(s1, s2);</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">&quot;main s1: %s, s2: %s%n&quot;</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">  String tmp = s1;</span><br><span class=\"line\">  s1 = s2;</span><br><span class=\"line\">  s2 = tmp;</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">&quot;swap s1: %s, s2: %s%n&quot;</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 運行結果：</span></span><br><span class=\"line\"><span class=\"comment\">// swap s1: World, s2: Hello</span></span><br><span class=\"line\"><span class=\"comment\">// main s1: Hello, s2: World</span></span><br></pre></td></tr></table></figure>\n\n<p>結論：</p>\n<ol>\n<li>一個方法不能修改一個基本類型的實參。</li>\n<li>一個方法可以改變一個對象類型的實參狀態。</li>\n<li>一個方法不能讓對象類型的實參引用一個新對象。</li>\n</ol>\n<h3 id=\"深拷貝和淺拷貝有什麼不同？\"><a href=\"#深拷貝和淺拷貝有什麼不同？\" class=\"headerlink\" title=\"深拷貝和淺拷貝有什麼不同？\"></a>深拷貝和淺拷貝有什麼不同？</h3><ol>\n<li>淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。</li>\n<li>深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。</li>\n</ol>\n<p><img src=\"/it/java/java-basic/Untitled.png\" alt></p>\n<h3 id=\"重載和重寫有什麼區別？\"><a href=\"#重載和重寫有什麼區別？\" class=\"headerlink\" title=\"重載和重寫有什麼區別？\"></a>重載和重寫有什麼區別？</h3><ol>\n<li>重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。</li>\n<li>重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。</li>\n</ol>\n<h2 id=\"Java-面向對象\"><a href=\"#Java-面向對象\" class=\"headerlink\" title=\"Java 面向對象\"></a>Java 面向對象</h2><h3 id=\"面向對象和面向過程\"><a href=\"#面向對象和面向過程\" class=\"headerlink\" title=\"面向對象和面向過程\"></a>面向對象和面向過程</h3><ol>\n<li>面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。</li>\n<li>面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。</li>\n</ol>\n<p>Java 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。</p>\n<h3 id=\"構造方法\"><a href=\"#構造方法\" class=\"headerlink\" title=\"構造方法\"></a>構造方法</h3><ol>\n<li>特點：名字跟類名相同，沒有返回值，不可重寫但可重載。</li>\n<li>作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。</li>\n<li>子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。</li>\n</ol>\n<h3 id=\"成員變量和局部變量的區別\"><a href=\"#成員變量和局部變量的區別\" class=\"headerlink\" title=\"成員變量和局部變量的區別\"></a>成員變量和局部變量的區別</h3><ol>\n<li>成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。</li>\n<li>局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。</li>\n</ol>\n<h3 id=\"對象實例和對象引用的區別\"><a href=\"#對象實例和對象引用的區別\" class=\"headerlink\" title=\"對象實例和對象引用的區別\"></a>對象實例和對象引用的區別</h3><ol>\n<li>對象實例：存在於堆內存，一個對象實例可以被多個引用指向。</li>\n<li>對象引用：存在於棧內存，一個引用指向一個對象實例。</li>\n</ol>\n<h3 id=\"面向對象的三大特徵\"><a href=\"#面向對象的三大特徵\" class=\"headerlink\" title=\"面向對象的三大特徵\"></a>面向對象的三大特徵</h3><p><strong>（1）封裝</strong></p>\n<p>封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。</p>\n<p><strong>（2）繼承</strong></p>\n<p>繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：</p>\n<ol>\n<li>子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），<strong>僅僅擁有</strong>。</li>\n<li>子類可以對父類進行擴展，增加新的屬性和方法。</li>\n<li>子類可以重寫父類的方法。</li>\n</ol>\n<p><strong>（3）多態</strong></p>\n<p>多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：</p>\n<ol>\n<li>對象類型和引用類型之間具有繼承/實現關係。</li>\n<li>對象類型不可變，引用類型可變。</li>\n<li>方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。</li>\n<li>父類的引用不能調用「只有子類存在但在父類不存在」的方法。</li>\n<li>如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。</li>\n</ol>\n<h3 id=\"靜態方法內爲什麼不能調用非靜態成員？\"><a href=\"#靜態方法內爲什麼不能調用非靜態成員？\" class=\"headerlink\" title=\"靜態方法內爲什麼不能調用非靜態成員？\"></a><strong>靜態方法內爲什麼不能調用非靜態成員？</strong></h3><p>因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。</p>\n<h3 id=\"接口和抽象類的區別\"><a href=\"#接口和抽象類的區別\" class=\"headerlink\" title=\"接口和抽象類的區別\"></a>接口和抽象類的區別</h3><ol>\n<li>方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。</li>\n<li>變量上：接口只能有 static、final 變量；而抽象類沒有限制。</li>\n<li>繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。</li>\n<li>設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。</li>\n</ol>\n<h2 id=\"Java-核心技術\"><a href=\"#Java-核心技術\" class=\"headerlink\" title=\"Java 核心技術\"></a>Java 核心技術</h2><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>見 <a href=\"https://tsunhua.github.io/2020/12/02/it/java/java-collection/\">Java 集合</a> </p>\n<h3 id=\"反射機制\"><a href=\"#反射機制\" class=\"headerlink\" title=\"反射機制\"></a>反射機制</h3><p><strong>（1）什麼是反射</strong></p>\n<p>Java 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。</p>\n<p><strong>（2）反射的優缺點</strong></p>\n<ol>\n<li>優點：運行時確定類型，動態加載類，提高代碼靈活度。</li>\n<li>缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。</li>\n</ol>\n<p>反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。</p>\n<p><strong>（3）反射的應用場景</strong></p>\n<p>反射是框架設計的靈魂。其應用場景有：</p>\n<ol>\n<li>模塊化開發；</li>\n<li>動態代理設計模式；</li>\n<li>Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；</li>\n<li>JDBC 連接數據庫等等。</li>\n</ol>\n<h3 id=\"異常\"><a href=\"#異常\" class=\"headerlink\" title=\"異常\"></a>異常</h3><p><strong>（1）簡介</strong></p>\n<p>Java 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。<strong>Error 通常是 JVM 錯誤，程序無法處理</strong>；<strong>而 Exception 是程序本身可以處理的異常</strong>。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。</p>\n<p><img src=\"/it/java/java-basic/Untitled%201.png\" alt></p>\n<p><strong>Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）</strong>，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：</p>\n<ul>\n<li><em>IOException</em></li>\n<li><em>EOFException</em></li>\n<li><em>MalFormedURLException</em></li>\n<li><em>IntruptedException</em></li>\n</ul>\n<p><strong>Unchecked Exception 又名 Runtime Exceptions（運行時異常）</strong>，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：</p>\n<ul>\n<li><em>ArithmaticException</em></li>\n<li><em>NullPointerException</em></li>\n<li><em>IndexOutOfBoundsException</em></li>\n<li><em>ClassCastException</em></li>\n<li><em>ArrayIndexOutOfBoundsException</em></li>\n<li><em>NumberFormatException</em></li>\n</ul>\n<p><strong>（2）Throwable 類常用方法</strong></p>\n<ol>\n<li><code>getMessage</code>：返回異常的簡要描述</li>\n<li><code>toString</code>：返回異常的詳細信息</li>\n<li><code>getLocalizedMessage</code>：返回異常的本地化信息（需要子類覆蓋該方法，否則與 <code>getMessage</code> 一樣）</li>\n<li><code>printStackTrace</code>：在控制台打印 Throwable 对象封装的异常信息</li>\n</ol>\n<p><strong>（3）try-catch-finally</strong></p>\n<ol>\n<li>try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。</li>\n<li>catch 代碼塊：處理捕獲到的異常。</li>\n<li>finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value * value;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// f(2) 將返回 0 ，而不是 4.</span></span><br></pre></td></tr></table></figure>\n\n<p>以下情況，finally 代碼塊不會被執行或只部分執行：</p>\n<ol>\n<li>finally 代碼塊中有異常，代碼會中異常處中止；</li>\n<li>在 catch 代碼塊或 finally 塊中調用了 <code>System.exit</code> 函數退出程序；</li>\n<li>程序所在的線程死亡等等不可預料的系統和硬件問題。</li>\n</ol>\n<p><strong>（4）try-witch-resources</strong></p>\n<p>Java 7 中新增了 ****try-witch-resources 語法糖，適用於實現<code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try-catch-finally</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;src/main/resources/test.txt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (scanner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        scanner.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// try-witch-resources</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (Scanner scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;src/main/resources/test.txt&quot;</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多線程\"><a href=\"#多線程\" class=\"headerlink\" title=\"多線程\"></a>多線程</h3><p>見 <a href=\"https://tsunhua.github.io/2020/12/10/it/java/java-concurrent/\">Java 多線程</a> </p>\n<h3 id=\"文件與-I-O-流\"><a href=\"#文件與-I-O-流\" class=\"headerlink\" title=\"文件與 I/O 流\"></a>文件與 I/O 流</h3><p><strong>（1）Java 中 I/O 流分爲幾種？</strong></p>\n<p>按不同的分類方法有不同的分類：</p>\n<ol>\n<li>按流向分：輸入流、輸出流。</li>\n<li>按操作單元分：字節流、字符流。</li>\n<li>按角色分：節點流、處理流。</li>\n</ol>\n<p>Java 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：</p>\n<ol>\n<li>InputStream：字節輸入流</li>\n<li>Reader：字符輸入流</li>\n<li>OutputStream：字節輸出流</li>\n<li>Writer：字符輸出流</li>\n</ol>\n<p><img src=\"/it/java/java-basic/Untitled%202.png\" alt></p>\n<p><img src=\"/it/java/java-basic/Untitled%203.png\" alt></p>\n<p><strong>（2）爲什麼有了字節流還需要字符流？</strong></p>\n<p>不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？</p>\n<p>字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。</p>\n<p><strong>（3）BIO、NIO、AIO 有什麼區別？</strong></p>\n<ol>\n<li><strong>BIO</strong>（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（&lt; 單機 1000）的情況，結合線程池一起使用。</li>\n<li><strong>NIO</strong>（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 <code>java.nio</code> 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。</li>\n<li><strong>AIO</strong>（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。</li>\n</ol>\n<p>NIO 模型：</p>\n<p><img src=\"/it/java/java-basic/Untitled%204.png\" alt></p>\n<ul>\n<li><p>NIO 服務端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiplexerNioServer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化多路复用器 绑定监听端口</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> port</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MultiplexerNioServer</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<span class=\"comment\">//获得一个serverChannel</span></span><br><span class=\"line\">            selector = Selector.open();<span class=\"comment\">////创建选择器  获得一个多路复用器</span></span><br><span class=\"line\">            serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);<span class=\"comment\">//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(port), <span class=\"number\">1024</span>);<span class=\"comment\">//绑定一个端口和等待队列长度</span></span><br><span class=\"line\">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<span class=\"comment\">//把selector注册到channel，关注链接事件</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>; <span class=\"comment\">// 优雅停机</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> client = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;1:&quot;</span> + client);</span><br><span class=\"line\">                <span class=\"comment\">// 阻塞,只有当至少一个注册的事件发生的时候才会继续.</span></span><br><span class=\"line\">                <span class=\"comment\">// int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;2:&quot;</span> + client);</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//处理事件</span></span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// selector关闭后会自动释放里面管理的资源</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//连接事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                <span class=\"comment\">// 通过ServerSocketChannel的accept创建SocketChannel实例</span></span><br><span class=\"line\">                <span class=\"comment\">// 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span></span><br><span class=\"line\">                SocketChannel sc = ssc.accept();<span class=\"comment\">//3次握手</span></span><br><span class=\"line\">                sc.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                sc.register(selector, SelectionKey.OP_READ);<span class=\"comment\">//连接建立后关注读事件</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//读事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">                ByteBuffer readbuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);<span class=\"comment\">//写 0 1024  1024</span></span><br><span class=\"line\"><span class=\"comment\">//                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存</span></span><br><span class=\"line\">                <span class=\"comment\">// 读取请求码流，返回读取到的字节数</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> readBytes = socketChannel.read(readbuffer);</span><br><span class=\"line\">                    <span class=\"comment\">// 读取到字节，对字节进行编解码</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span></span><br><span class=\"line\">                        readbuffer.flip();<span class=\"comment\">//读写模式反转</span></span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区可读字节数组复制到新建的数组中</span></span><br><span class=\"line\">                        <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readbuffer.remaining()];</span><br><span class=\"line\">                        readbuffer.get(bytes);</span><br><span class=\"line\">                        String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;input is:&quot;</span> + body);</span><br><span class=\"line\">                        res(socketChannel, body);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 链路已经关闭 释放资源</span></span><br><span class=\"line\">                        key.cancel();</span><br><span class=\"line\">                        socketChannel.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 没有读到字节忽略</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">res</span><span class=\"params\">(SocketChannel channel, String response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span> &amp;&amp; response.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = response.getBytes();</span><br><span class=\"line\">            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class=\"line\">            writeBuffer.put(bytes);</span><br><span class=\"line\">            writeBuffer.flip();</span><br><span class=\"line\">            channel.write(writeBuffer);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;res end&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NIO 客戶端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioClientHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String host;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SocketChannel socketChannel;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NioClientHandler</span><span class=\"params\">(String host, <span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.host = host;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建选择器</span></span><br><span class=\"line\">            selector = Selector.open();</span><br><span class=\"line\">            <span class=\"comment\">// 打开监听通道</span></span><br><span class=\"line\">            socketChannel = SocketChannel.open();</span><br><span class=\"line\">            <span class=\"comment\">// 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            socketChannel.configureBlocking(<span class=\"keyword\">false</span>); <span class=\"comment\">// 开启非阻塞模式</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doConnect();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> wait = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wait == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doConnect</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(host, port))) &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">            doWrite(socketChannel);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc.finishConnect()) &#123;</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    doWrite(sc);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                ByteBuffer readBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> readBytes = sc.read(readBuffer);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    readBuffer.flip();</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readBuffer.remaining()];</span><br><span class=\"line\">                    readBuffer.get(bytes);</span><br><span class=\"line\">                    String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;res&quot;</span> + body);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    key.cancel();</span><br><span class=\"line\">                    sc.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doWrite</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将消息编码为字节数组</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] request = <span class=\"string\">&quot;Hello&quot;</span>.getBytes();</span><br><span class=\"line\">        <span class=\"comment\">// 根据数组容量创建ByteBuffer</span></span><br><span class=\"line\">        ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);</span><br><span class=\"line\">        <span class=\"comment\">// 将字节数组复制到缓冲区</span></span><br><span class=\"line\">        writeBuffer.put(request);</span><br><span class=\"line\">        <span class=\"comment\">// flip读写切换操作</span></span><br><span class=\"line\">        writeBuffer.flip();</span><br><span class=\"line\">        sc.write(writeBuffer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!writeBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;写入完成&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"Java-項目管理和構建\"><a href=\"#Java-項目管理和構建\" class=\"headerlink\" title=\"Java 項目管理和構建\"></a>Java 項目管理和構建</h2><h3 id=\"Maven-项目\"><a href=\"#Maven-项目\" class=\"headerlink\" title=\"Maven 项目\"></a>Maven 项目</h3><p><strong>（1）安装</strong></p>\n<p>從 <a href=\"https://maven.apache.org/download.cgi\">Maven 官網</a>下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。</p>\n<p><strong>（2）初始化一個 Maven 項目</strong></p>\n<p>使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure>\n\n<p>或者用 IDEA 直接新建一個 Maven 項目，其結構如下：</p>\n<p><img src=\"/it/java/java-basic/20201114_101407.png\" alt></p>\n<p>其中 pom.xml 的內容如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.example<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>testmaven<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--  添加以下屬性，解決編譯報錯  --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.encoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.encoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 新增依賴在下方 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.openjdk.jol<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jol-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.14<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>為什麼叫 Maven？</p>\n<p>  Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。</p>\n</li>\n<li><p>POM 又是指什麼？</p>\n<p>  POM（project object model）項目對象模型，maven 使用 <code>pom.xml</code> 定義了整個項目的構建、報告和文檔。</p>\n</li>\n</ul>\n<p><strong>（3）編譯測試打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理 target 中的文件</span></span><br><span class=\"line\">mvn clean</span><br><span class=\"line\"><span class=\"comment\"># 編譯 java 文件成 class 文件，置於 target/classes 文件夾中</span></span><br><span class=\"line\">mvn compile</span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">mvn <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># 打包成 jar 文件，置於 target 文件夾中</span></span><br><span class=\"line\">mvn package</span><br><span class=\"line\"><span class=\"comment\"># 安裝 jar 包到本地存儲庫（$&#123;user.home&#125;/.m2/repository）</span></span><br><span class=\"line\">mvn install</span><br><span class=\"line\"><span class=\"comment\"># 生成自己的 maven 站點</span></span><br><span class=\"line\">mvn site</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>SNAPSHOT 是什麼？</p>\n<p>  snapshot 簡要的意思，在版本號之後添加 <code>-SNAPSHOT</code> 是說明該版本仍處於開發階段，不是最終的發行版本。以 <code>x.y-SNAPSHOT</code> 版本為例，發行時會去除 <code>-SNAPSHOT</code>  後綴，然後將最新的開發版本升爲<code>x.(y+1)-SNAPSHOT</code> 。</p>\n</li>\n<li><p>使用 mvn compile 生成的 jar 包，其內容是怎樣的？</p>\n<p>  除了 class 文件外，還有 <code>META-INF</code> 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（<code>main/resources</code> ）的文件也會被打包到<code>META-INF</code> 文件夾中，代碼中可通過<code>getClass().getResourceAsStream( &quot;/application.properties&quot; )</code> 調用。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ jar tf target/testmaven-1.0-SNAPSHOT.jar </span><br><span class=\"line\">META-INF/</span><br><span class=\"line\">META-INF/MANIFEST.MF</span><br><span class=\"line\">B.class</span><br><span class=\"line\">MemoryLayoutTest.class</span><br><span class=\"line\">A.class</span><br><span class=\"line\">C.class</span><br><span class=\"line\">META-INF/maven/</span><br><span class=\"line\">META-INF/maven/org.example/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.xml</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.properties</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"Gradle-项目\"><a href=\"#Gradle-项目\" class=\"headerlink\" title=\"Gradle 项目\"></a>Gradle 项目</h3><p><strong>（1）安裝</strong></p>\n<p>可從 <a href=\"https://www.gradle.org/downloads\">gradle 官網</a>下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 <code>brew install gradle</code> 的方式安裝。或者直接使用 IDEA 項目中的 <code>gradle-wrapper</code> ，此時對應的 <code>gradle</code> 命令變爲 <code>gradlew</code>。</p>\n<p><strong>（2）gradle 命令能做什麼？</strong></p>\n<p>gradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gradle tasks</span><br><span class=\"line\"></span><br><span class=\"line\">:tasks</span><br><span class=\"line\"></span><br><span class=\"line\">== All tasks runnable from root project</span><br><span class=\"line\"></span><br><span class=\"line\">== Build Setup tasks</span><br><span class=\"line\">setupBuild - Initializes a new Gradle build. [incubating]</span><br><span class=\"line\"></span><br><span class=\"line\">== Help tasks</span><br><span class=\"line\">dependencies - Displays all dependencies declared <span class=\"keyword\">in</span> root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">dependencyInsight - Displays the insight into a specific dependency <span class=\"keyword\">in</span> root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\"><span class=\"built_in\">help</span> - Displays a <span class=\"built_in\">help</span> message</span><br><span class=\"line\">projects - Displays the sub-projects of root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">properties - Displays the properties of root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">tasks - Displays the tasks runnable from root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">To see all tasks and more detail, run with --all.</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL</span><br><span class=\"line\"></span><br><span class=\"line\">Total time: 3.077 secs</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）初始化一個 Gradle 項目</strong></p>\n<p>在項目文件夾中新建一個名爲 <code>build.gradle</code> 的文件，其內容如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;java&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>隨後新建一個名爲 <code>settings.gradle</code> 的文件，其內容可暫時爲空。</p>\n<p>在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 <code>gradle-wrapper</code> ，其過程等價於執行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gradle wrapper --gradle-version 6.5</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）編譯打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包</span></span><br><span class=\"line\">gradle build</span><br><span class=\"line\"><span class=\"comment\"># 或使用 gradle wrapper</span></span><br><span class=\"line\">./gradlew build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理生成的文件</span></span><br><span class=\"line\">gradle clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成 jar 文件</span></span><br><span class=\"line\">gradle jar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 運行生成的 jar 文件</span></span><br><span class=\"line\">gradle run</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">gradle <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）<code>build.gradle</code> 中可配置什麼？</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置插件，插件提供語法定義</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;application&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置入口類</span></span><br><span class=\"line\">mainClassName = <span class=\"string\">&#x27;hello.HelloWorld&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴倉庫</span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置生成的 jar 文件的入口類</span></span><br><span class=\"line\">jar &#123;</span><br><span class=\"line\">    manifest &#123;</span><br><span class=\"line\">        attributes <span class=\"string\">&#x27;Main-Class&#x27;</span>: mainClassName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置 JDK 兼容性</span></span><br><span class=\"line\">sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">targetCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile <span class=\"string\">&quot;joda-time:joda-time:2.2&quot;</span></span><br><span class=\"line\">    testCompile <span class=\"string\">&quot;junit:junit:4.12&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如需將所有依賴 jar 打進同一個 jar 包，可使用 <a href=\"https://github.com/johnrengelman/shadow\">shadow 插件</a>或使用 <a href=\"https://spring.io/quickstart\">spring boot 插件</a>。</p>"},{"title":"Java 多線程","p":"it/java/java-concurrent.md","date":"2020-11-08T04:23:00.000Z","_content":"\n首先區分進程和線程。進程是程序運行的基本單位，也是系統分配資源的最小單位；而線程是 CPU 調度的最小單位，一個進程可以有多個線程，而各個線程擁有獨立的程序計數器、虛擬機棧和本地方法棧，但共享同一個堆和方法區。爲著充分利用系統資源，減少 CPU 空等，多線程技術應運而生。系統使用時間片輪轉法分配 CPU 資源到各個線程，如果線程在分配的時間片內未能處理完任務，則會導致上下文切換。\n\nJava 中線程類爲 `Thread` ，其 `start` 方法會使線程進入 Runnable 狀態；其 `sleep` 方法會阻塞線程而不釋放鎖，跟 `Object.wait` 有別；其 `interrupt` 方法並不停止線程，而是設置一個標誌位通知線程應當關閉，線程可以根據該標誌位決定是否要停止運行。\n\n多個線程可以通過線程池進行統一管理，好處是還可以提前 Ready 好一些線程避免等待線程創建的時間損耗；還可以使用舊的線程，減少線程的頻繁創建和銷毀的資源損耗。線程池推薦直接使用 `ThreadPoolExecutor` 的構造方法去創建，以便設置合適的構造參數。調用 `ThreadPoolExecutor.execute` 可以將一個 `Runnable` 任務放入線程池處理； 調用`ThreadPoolExecutor.submit`  可以將一個 `Callable` 任務放入線程池處理，返回一個 `Future` 代表處理結果，後續通過調用 `Future.get` 獲取處理結果，其過程是阻塞的。\n\nJava 1.5 開始提供`AbstractQueuedSynchronizer`，用於創建多線程訪問共享資源的同步器，其內部使用一個名爲 CLH 的 FIFO 的雙向隊列進行資源分配。其常見實現類有：`ReentrantLock`、`ReadWriteLock` 和 `CountDownLatch` 。其中 `ReadWriteLock` 性能優於 `ReentrantLock` ，因爲兩個讀操作在 `ReadWriteLock` 中不互斥而在 `ReentrantLock` 中互斥。\n\nJava 1.8 開始提供了 `CompletableFuture` ，其實現了 `Future` 接口，並提供了基於回調的函數式異步編程方式和對`CompletableFuture` 的組合，使用者可以不關心底層的線程池，大大簡便了異步編程。\n\nJava 還提供了 ThreadLocal 類可以使得各個線程擁有變量的副本而不會相互影響，底層是使用 Thread 類的 `ThreadLocalMap`，一個類似 HashMap 的結構，其 Key 爲 ThreadLocal 對象的弱引用。\n\n多線程因會有多個線程操作共享的資源而引發了線程安全的擔憂。線程安全要求**原子性、可見性和有序性**。Java 提供了多種方式可以保證線程安全：\n\n1. synchronized 同步鎖，這是一個重量級鎖。可以使用當前類的 class 對象，當前類的對象或者任意對象對方法和代碼塊進行加鎖，方法結束或代碼塊結束則鎖自動釋放。當使用非靜態同步方法時，會使用當前對象爲鎖，因此多個非靜態同步方法共享同一鎖。Java 1.6 後引入**偏向鎖**和**輕量級鎖**的概念，使得 synchronized 不那麼「重」了。\n2. volatile 關鍵字。使用該關鍵字修飾的變量在編譯時不會有寄存器緩存而是直接使用主存、不會進行代碼重排序優化，保證了可見性和有序性；在解釋執行時使用 CPU 內存屏障技術防止指令重排序。\n3. CAS(Compare and Swap) 技術，相比於 synchronized，其假定操作是不會產生衝突的，將舊的預期值和內存中的值進行比較，若相同則更新內存中的值，否則自旋。因此被稱之爲「樂觀鎖」，而 synchronized 被稱之爲「悲觀鎖」。Java 中的 Atomic 類是典型的 CAS 實現。\n\n多線程操作共享資源還會出現死鎖。死鎖產生的條件是：**互斥、請求/等待、不可剝奪和循環等待**。解決死鎖問題的關鍵是破壞死鎖產生的條件。\n\n<!-- more -->\n\n## 多線程\n\n### **程序、進程與線程**\n\n1. 程序：程序是含有指令和數據的文件，被靜態存儲於存儲設備之中。\n2. 進程：进程是程序的一次執行過程，是**操作系統運行程序的基本單位**，是動態的。它佔用一定的系統資源（包括 CPU 時間、內存空間、文件、輸入輸出設備等等），**是資源分配的最小單位**。各進程之間相互獨立。\n3. 線程：**線程是 CPU 調度的最小單位**，擁有**程序計數器、虛擬機棧和本地方法棧**，相比進程，它佔用資源更小，產生和切換線程的負擔更小，也被稱爲**輕量級進程**。一個進程可以產生多個線程。同個進程的多個線程之間共享同一塊**堆和方法區**。\n\n- 堆是幹什麼用的？\n\n    堆是進程中最大的一塊內存，用於存放新建的對象。\n\n- 方法區是幹什麼的？\n\n    根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放程序執行代碼的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(java-concurrent/code segment)，通常只讀。具體來說，它存放了每個類的結構，例如運行時常量池，字段和方法數據，以及方法和構造函數的代碼，包括用於類和實例初始化以及接口初始化的特殊方法。\n\n    另外，UNIX 中的進程將內存劃分成三個部分：text segment,文本區，例如代碼，data segment，數據區，例如變量，stack segment，棧區域。\n\n- 程序計數器爲什麼是線程私有的？\n\n    程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。\n\n    因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。\n\n- 虛擬機棧和本地方法棧爲什麼是線程私有的？\n    - **虛擬機棧**：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態鏈接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。\n    - **本地方法棧**：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。\n\n    爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。\n\n### **線程有哪些基本狀態**\n\nJava 線程共有 6 中狀態，如下：\n\n1. New：新創建的線程，尚未執行。\n2. Runnable：運行中的線程，`run` 方法正在執行中。可細分爲 Ready 和 Running 兩個狀態。\n3. Blocked：運行中的線程，因爲某些操作被阻塞而掛起。\n4. Waiting：運行中的線程，因爲某些操作在等待。\n5. Timed Waiting：運行中的線程，因爲執行 `sleep` 等方法正在計時等待。\n6. Terminated：線程終止，因爲 `run` 方法執行完畢。\n\n![](java-concurrent/Untitled.png)\n\n### 並發和並行的區別\n\n並發（concurrent）：同一時間段，多個任務都在執行。\n\n並行（parallel）：單位時間內，多個任務同時執行。\n\n### 多線程的優勢\n\n1. 提高 CPU 和 IO 設備的綜合利用率，確保 CPU 或 IO 設備不空等。\n2. 提高 CPU 核心利用率，確保 CPU 的多個核心都能被利用到。\n3. 提高系統整體的並發能力和性能，應對高並發場景。\n\n### 上下文切換\n\n**上下文切換就是舊任務被暫停，保存自身狀態，然後新任務被執行的過程**。造成上下文切換的原因是需要同時執行的任務大於 CPU 核心數，而單個 CPU 同一時刻只能執行一個任務。CPU 採用時間片輪轉法分配 CPU 時間給多個線程，當時間片結束舊任務如果未執行完畢會被暫停，保存當前狀態，然後執行新的任務。\n\n上下文切換所需的時間很可觀，可能是操作系統中時間消耗最大的操作。操作系統中數 Linux（及其他類 Unix 系統） 上下文切換時間消耗最少。\n\n### 爲什麼調用 `Thread.start` 方法而不是 `Thread.run` 方法？\n\n調用 `start` 方法會啟動一個新線程並進入就緒狀態，當分配到時間片後會自動調用 `run` 方法。直接調用 `run` 方法只會在調用者所在的線程執行。\n\n### 比較 `Thread.sleep` 方法和 `Object.wait` 方法\n\n共同點：\n\n1. 都可以暫停線程的執行。\n2. `sleep(long)`和 `wait(long)` 都可以在指定時間段後使線程自動甦醒。\n\n不同點：\n\n1. sleep 是 Thread 類的方法，wait 是 Object 類的方法。\n2. **sleep 沒有釋放鎖，wait 釋放了**。\n3. `wait()` 被調用後線程不會自動甦醒，需要別的線程調用同一對象上的 `notify()` 或 `notifyAll()` 方法來喚醒。\n- 代碼\n\n    ```java\n    // Data.java\n    public class Data {\n        private String packet;\n\n        // 单次传输是否结束\n        // True if Receiver should wait\n        // False if Sender should wait\n        private boolean isTransfer = true;\n\n        public synchronized void send(String packet) {\n            while (!isTransfer) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            this.packet = packet;\n            isTransfer = false;\n            notifyAll();\n        }\n\n        public synchronized String receive() {\n            while (isTransfer) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            isTransfer = true;\n            notifyAll();\n            return packet;\n        }\n    }\n\n    // Sender.java\n    public class Sender implements Runnable {\n\n        private final Data data;\n\n        public Sender(Data data) {\n            this.data = data;\n        }\n\n        @Override\n        public void run() {\n            String[] packets = new String[]{\"Hello\", \"Are\", \"You\", \"Ok\", \"Over\"};\n            for (String packet : packets) {\n                data.send(packet);\n            }\n        }\n    }\n\n    // Receiver.java\n    public class Receiver implements Runnable {\n\n        private final Data data;\n\n        public Receiver(Data data) {\n            this.data = data;\n        }\n\n        @Override\n        public void run() {\n            String packet = data.receive();\n            while (!\"Over\".equals(packet)) {\n                System.out.println(packet);\n                packet = data.receive();\n            }\n        }\n    }\n\n    // Main.java\n    public class Main {\n\n        public static void main(String[] args) {\n            Data data = new Data();\n            new Thread(new Receiver(data)).start();\n            new Thread(new Sender(data)).start();\n        }\n    }\n    ```\n\n### 調用 `Thread.interrupt` 意味著什麼？\n\n調用 interrupt 方法並不會中斷一個線程，而是發出出一個中斷信號到目標線程（設置中斷標誌位的值爲 true），目標線程收到信號後可以決定是否處理。\n\n與之相關的方法有：\n\n```java\n// 測試當前線程是否已經中斷。當線程中斷時調用該方法將會清除線程的中斷狀態\npublic static boolean interrupted()\n// 測試線程是否已經中斷。不改變線程的中斷狀態。\npublic boolean isInterrupted()\n// 中斷線程\npublic void interrupt()\n```\n\n[廖雪峰的官方網站](java-concurrent//www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554)提供了以下的代碼：\n\n```java\npublic class Main {\n  public static void main(String[] args) throws InterruptedException {\n      Thread t = new MyThread();\n      t.start();\n      Thread.sleep(java-concurrent// 暫停1毫秒\n      t.interrupt(java-concurrent// 中斷t線程\n      t.join(java-concurrent// 等待t線程結束\n      System.out.println(\"end\");\n  }\n}\n\nclass MyThread extends Thread {\n  public void run() {\n      int n = 0;\n      while (! isInterrupted()) {\n          n ++;\n          System.out.println(n + \" hello!\");\n      }\n  }\n}\n```\n\n值得注意的是：\n\n1. 本線程中斷自己是被允許的；其它線程調用本線程的`interrupt`方法時，會通過`checkAccess`檢查權限。這有可能拋出`SecurityException`異常。\n2. 調用線程的`wait` 方法會讓它進入等待(阻塞)狀態，或者調用線程的`join`, `sleep` 方法也會讓它進入阻塞狀態。若線程在阻塞狀態時，調用了它的`interrupt`方法，那麼它的「中斷狀態」會被清除並且會收到一個`InterruptedException`異常。例如，線程通過`wait()`進入阻塞狀態，此時通過`interrupt()`中斷該線程；調用`interrupt()`會立即將線程的中斷標記設為「true」，但是由於線程處於阻塞狀態，所以該「中斷標記」會立即被清除為「false」，同時，會產生一個`InterruptedException`的異常。\n3. 如果線程被阻塞在一個`Selector`選擇器中，那麼通過`interrupt()`中斷它時；線程的中斷標記會被設置為true，並且它會立即從選擇操作中返回。\n4. 如果不屬於前面所說的情況，那麼通過`interrupt()`中斷線程時，它的中斷標記會被設置為「true」。\n5. 中斷一個「已終止的線程」不會產生任何操作。\n\n### 線程池技術\n\n**（1）爲什麼要使用線程池？**\n\n線程池管理了一組線程資源，並維護了一些基本的統計信息。\n\n《Java 並發編程的藝術》中講述到使用線程池的好處：\n\n1. 降低資源消耗。通過重複使用已創建的線程減少線程創建和銷毀的消耗。\n2. 提高響應速度。線程池預先創建了線程，在需要時可以直接使用不用等。\n3. 提供線程的可管理性。線程是稀缺資源，不能無限制地分配，使用線程池可以進行統一分配、調優和監控。\n\n**（2）Runnable 接口和 Callable 接口的區別**\n\n1. Runnable 始於 Java 1.0 ，Callable 接口始於 Java 1.5.\n2. Runnable 不會返回結果或拋出檢查異常，而 Callable 會。\n\n另外，工具類 `Executors` 可以實現 Runnable 對象和 Callable 對象之間的相互轉換，如下：\n\n```java\nExecutors.callable(Runnable task)\nExecutors.callable(Runnable task，Object resule)\n```\n\n**（3）`execute` 方法和 `submit` 方法有什麼區別？**\n\n1. `execute` 提交任務之後沒有返回值，無法判斷任務是否被執行成功。\n2. `submit` 提交任務之後有返回值 Future，可以知道任務是否被執行成功。調用 `Future.get()` 會阻塞線程直到任務完成；調用 `Future.get(long timeout，TimeUnit unit)`  則是阻塞指定的一段時間後立即返回，不管任務是否執行完成。當然如果提交的是 Runnable，那麼返回的 Future 中的泛型爲 Void。\n\n**（4）如何創建線程池？**\n\n《阿里巴巴 Java 開發手冊》中要求直接用 `ThreadPoolExecutor` 的構造方法去創建線程池，而非通過 Executors 去創建線程池，因爲：\n\n1. `FixedThreadPool` 和 `SingleThreadPool` 中允許請求的隊列長度爲 `Integer.MAX_VALUE`，可能會堆積大量請求，導致 OOM；\n2. `CachedThreadPool` 和 `ScheduledThreadPool` 中允許線程數爲 `Integer.MAX_VALUE`，可能會創建大量線程，導致 OOM。\n\n`ThreadPoolExecutor` 的參數分析：\n\n```java\npublic ThreadPoolExecutor(\n  // 核心線程數，規定了最小的可以同時運行的線程數量\n\tint corePoolSize,\n  // 最大線程數，當請求隊列滿時，可以同時運行的線程數量\n\tint maximumPoolSize,\n  // 當線程空閒且大於規定的核心線程數時，等待 keepAliveTime 時間後多餘的線程會被銷毀\n\tlong keepAliveTime,\n  // keepAliveTime 的時間單位\n\tTimeUnit unit,\n  // 請求隊列，當新任務進來時，當前運行的線程達到核心線程數，則新任務會被放置到請求隊列\n\tBlockingQueue<Runnable> workQueue,\n  // 線程工廠，用於創建新線程\n\tThreadFactory threadFactory,\n  // 飽和策略，當線程數量達到最大線程數且請求隊列也滿的情況下觸發飽和策略\n\tRejectedExecutionHandler handler) {\n}\n```\n\n線程池中的飽和策略有：\n\n1. `ThreadPoolExecutor.AbortPolicy`：默認策略，拋出異常，拒絕處理新任務。\n2. `ThreadPoolExecutor.CallerRunsPolicy`：直接在調用 `execute` 所在的線程執行。\n3. `ThreadPoolExecutor.DiscardPolicy`：不拋出異常，直接丟棄新任務。\n4. `ThreadPoolExecutor.DiscardOldestPolicy`：不拋出異常，丟棄最早未處理的任務。\n\n**（5）線程池對新任務的處理過程**\n\n![](java-concurrent/Untitled%201.png)\n\n### AQS（抽象隊列式同步器）\n\n**（1）概述**\n\nAQS，即 `AbstractQueuedSynchronizer` ，加入於 Java 1.5，作者爲大名鼎鼎的 Doug Lea，其定義了一套多線程訪問共享資源的同步器框架。其下有諸如 `ReentrantLock`、`ReadWriteLock`、`CountDownLatch` 等等實現。\n\nAQS 的實現思路是：如下圖所示，當請求的共享資源空閒時，請求資源的線程會被設置爲有效的工作線程，該資源會被鎖定；當請求的共享資源被佔用時，將請求資源的線程加入 CLH 隊列中。CLH 是三個人名的首字母，CLH 隊列是一個雙向隊列，FIFO。而共享資源的狀態是一個整型值，採用 CAS 方式進行值的原子更新，通常加鎖 state 會加 1，釋放則減 1。\n\n![](java-concurrent/Untitled%202.png)\n\nAQS 可以定義兩種資源共享方式，獨佔 or 共享。其採用模板方法模式編寫，實現類需要選擇性地實現以下方法（默認實現是拋出`UnsupportedOperationException`）：\n\n```java\n//該線程是否正在獨佔資源。只有用到condition才需要去實現它。\nisHeldExclusively()\n//獨佔方式。嘗試獲取資源，成功則返回true，失敗則返回false。\ntryAcquire(int)\n//獨佔方式。嘗試釋放資源，成功則返回true，失敗則返回false。\ntryRelease(int)\n//共享方式。嘗試獲取資源。負數表示失敗；0表示成功，但沒有剩餘可用資源；正數表示成功，且有剩餘資源。\ntryAcquireShared(int)\n//共享方式。嘗試釋放資源，成功則返回true，失敗則返回false。\ntryReleaseShared(int)\n```\n\n**（2）ReentrantLock**\n\nReentrantLock，可重入鎖，同一線程可以反覆加鎖，然後釋放同樣次數的鎖。synchronized 修飾的方法用的也是可重入鎖，但 ReentrantLock 提供了更爲靈活的控制，有 lock、unlock 方法還有類似於 `Object.wait` / `Object.notify` 的 `Condition.await` / `Condition.signal` 方法。\n\n- 代碼\n\n    參考：[https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/](java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/)\n\n    ```java\n    // SharedFifoQueue.java\n    public class SharedFifoQueue {\n\n      private final Object[] content;\n      // 標識當前隊列中擁有的對象數目\n      private int current = 0;\n      private int addIndex = 0;\n      private int removeIndex = 0;\n\n      private final ReentrantLock lock = new ReentrantLock();\n      private final Condition fullCondition = lock.newCondition();\n      private final Condition emptyCondition = lock.newCondition();\n\n      public SharedFifoQueue(int capacity) {\n          content = new Object[capacity];\n      }\n\n      public void add(Object item) throws InterruptedException {\n          lock.lock();\n          while (current >= content.length) {\n              fullCondition.await();\n          }\n          content[addIndex] = item;\n          addIndex = (addIndex + 1) % content.length;\n          current++;\n          emptyCondition.signal();\n          lock.unlock();\n      }\n\n      public Object remove() throws InterruptedException {\n          lock.lock();\n          while (current <= 0) {\n              emptyCondition.await();\n          }\n          Object item = content[removeIndex];\n          removeIndex = (removeIndex + 1) % content.length;\n          current--;\n          fullCondition.signal();\n          lock.unlock();\n          return item;\n      }\n    }\n\n    // Producer.java\n    public class Producer implements Runnable {\n\n      private final SharedFifoQueue queue;\n      private final Random random = new Random();\n\n      public Producer(SharedFifoQueue queue) {\n          this.queue = queue;\n      }\n\n      @Override\n      public void run() {\n          try {\n              for (int i = 0; i < 20; i++) {\n                  queue.add(\"Hello \" + i);\n                  Thread.sleep(random.nextInt(200) );\n              }\n              queue.add(null);\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n\n    // Consumer.java\n    public class Consumer implements Runnable {\n\n      private final SharedFifoQueue queue;\n\n      public Consumer(SharedFifoQueue queue) {\n          this.queue = queue;\n      }\n\n      @Override\n      public void run() {\n          try {\n              while (true) {\n                  Object item = queue.remove();\n                  if (item == null) {\n                      break;\n                  }\n                  System.out.println(item.toString());\n              }\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n\n    // Main.java\n    public static void main(String[] args) throws InterruptedException {\n        SharedFifoQueue sharedFifoQueue = new SharedFifoQueue(10);\n        Thread consumerThread = new Thread(new Consumer(sharedFifoQueue));\n        Thread producerThread = new Thread(new Producer(sharedFifoQueue));\n\n        producerThread.start();\n        consumerThread.start();\n        // join 可以讓主線程等待子線程結束\n        producerThread.join();\n        consumerThread.join();\n    }\n    ```\n\n**（3）ReadWriteLock**\n\nReadWriteLock 相比 ReentrantLock 性能更高，體現在兩個讀操作在 ReadWriteLock 裏是不互斥的，而在 ReentrantLock 裏是互斥的。\n\n- 代碼\n\n    代碼來源：[https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/](java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/)\n\n    ```java\n    public class ThreadSafeArrayList<E> {\n      private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n      private final Lock readLock = readWriteLock.readLock();\n      private final Lock writeLock = readWriteLock.writeLock();\n\n      private final List<E> list = new ArrayList<>();\n\n      public void set(E o) {\n          writeLock.lock();\n          try {\n              list.add(o);\n          } finally {\n              writeLock.unlock();\n          }\n      }\n\n      public E get(int i) {\n          readLock.lock();\n          try {\n              return list.get(i);\n          } finally {\n              readLock.unlock();\n          }\n      }\n    }\n    ```\n\n**（4）CountDownLatch**\n\nCountDownLatch 可以讓一個或多個線程等待指定的操作完成後再開始工作。初始化 CountDownLatch 時需要指定一個 count 值，需要等待的線程使用 `CountDownLatch.await()` 進行等待，當 `CountDownLatch.countDown()` 被調用 count 次時，等待的線程才得以繼續執行。\n\n- 代碼\n\n    代碼來源：[http://tutorials.jenkov.com/java-util-concurrent/countdownlatch.html](java-concurrent//tutorials.jenkov.com/java-util-concurrent/countdownlatch.html)\n\n    ```java\n    // Main.java\n    CountDownLatch latch = new CountDownLatch(3);\n\n    Waiter      waiter      = new Waiter(latch);\n    Decrementer decrementer = new Decrementer(latch);\n\n    new Thread(waiter)     .start();\n    new Thread(decrementer).start();\n\n    Thread.sleep(4000);\n    // Waiter.java\n    public class Waiter implements Runnable{\n\n      CountDownLatch latch = null;\n\n      public Waiter(CountDownLatch latch) {\n          this.latch = latch;\n      }\n\n      public void run() {\n          try {\n              latch.await();\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n\n          System.out.println(\"Waiter Released\");\n      }\n    }\n    // Decrementer.java\n    public class Decrementer implements Runnable {\n\n      CountDownLatch latch = null;\n\n      public Decrementer(CountDownLatch latch) {\n          this.latch = latch;\n      }\n\n      public void run() {\n          try {\n              Thread.sleep(1000);\n              this.latch.countDown();\n\n              Thread.sleep(1000);\n              this.latch.countDown();\n\n              Thread.sleep(1000);\n              this.latch.countDown();\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n    ```\n\n**（5）Semaphore**\n\nSemaphore 用於限制訪問資源的線程數量，以對資源進行保護。[有人將其比做是廁所的坑位數](java-concurrent//blog.csdn.net/eson_15/article/details/51577191)，譬如一個廁所有 3 個坑，則同時上廁所的人只能有 3 個，其他人要上只能等這 3 個人之一釋放坑位。\n\n使用前通過調用 `Semaphore.acquire` 獲取訪問，使用後通過  `Semaphore.release` 釋放許可。\n\n- 代碼\n\n    ```java\n    public static void main(String[] args) {\n        ExecutorService threadPool = Executors.newFixedThreadPool(10);\n        Semaphore semaphore = new Semaphore(3);\n        for (int i = 0; i < 10; i++) {\n            threadPool.execute(() -> {\n                try {\n                    semaphore.acquire();\n                    System.out.printf(\"Running Thread Id: %s, Available permit: %d, Queue length: %d\\n\", Thread.currentThread().getId(), semaphore.availablePermits(), semaphore.getQueueLength());\n                    Thread.sleep(300);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    semaphore.release();\n                }\n            });\n        }\n    }\n    ```\n\n    運行結果：\n\n    初始化總許可量爲 3，一開始被用掉一個許可，可用許可剩餘 2；隨後許可被用光，其他線程開始排隊，出現長度爲 6 的請求隊列，之後隨之許可釋放，隊列長度遞減，直到所有任務處理完成，隊列長度爲 0，許可復爲 3。\n\n    ```java\n    Running Thread Id: 13, Available permit: 2, Queue length: 0\n    Running Thread Id: 15, Available permit: 0, Queue length: 0\n    Running Thread Id: 14, Available permit: 1, Queue length: 0\n    Running Thread Id: 16, Available permit: 0, Queue length: 6\n    Running Thread Id: 17, Available permit: 1, Queue length: 5\n    Running Thread Id: 18, Available permit: 0, Queue length: 4\n    Running Thread Id: 19, Available permit: 0, Queue length: 3\n    Running Thread Id: 20, Available permit: 1, Queue length: 2\n    Running Thread Id: 21, Available permit: 0, Queue length: 1\n    Running Thread Id: 22, Available permit: 2, Queue length: 0\n    ```\n\n### CompletableFuture\n\n參考：[https://colobu.com/2016/02/29/Java-CompletableFuture/](java-concurrent//colobu.com/2016/02/29/Java-CompletableFuture/)、[https://www.jianshu.com/p/6bac52527ca4](java-concurrent//www.jianshu.com/p/6bac52527ca4)\n\nCompletableFuture 是 Java 1.8 提供的類，可以方便函數式異步編程。CompletableFuture 實現了 Future 接口。\n\nFuture 是 Java 1.5 引入的接口，它代表這異步執行的結果。可以通過 `isDone` 判斷執行是否完畢，通過 `get` 阻塞獲取結果，通過 `cancel` 取消執行。\n\nFuture 獲取結果的方式不優雅，要輪詢或一直阻塞等待結果。 CompletableFuture 提供了回調的方式處理結果（正常結果 & 異常結果），還有組合多個 CompletableFuture 的能力。\n\n有了 CompletableFuture，我們甚至可以不關心線程、線程池和同步，因爲 CompletableFuture 內部已經幫我們處理好了，我們只需要鏈式調用函數就可以了。\n\n```java\nCompletableFuture.allOf(CompletableFuture.runAsync(() -> {\n  try {\n      Thread.sleep(200);\n  } catch (InterruptedException e) {\n      e.printStackTrace();\n  }\n  System.out.println(Thread.currentThread().getId() + \" done!\");\n}), CompletableFuture.runAsync(() -> {\n  try {\n      Thread.sleep(200);\n  } catch (InterruptedException e) {\n      e.printStackTrace();\n  }\n  System.out.println(Thread.currentThread().getId() + \" done!\");\n})).handle((BiFunction<Void, Throwable, Void>) (unused, throwable) -> {\n  if (throwable != null) {\n      System.out.println(\"Exception:\" + throwable.getMessage());\n  } else {\n      System.out.println(\"All done!\");\n  }\n  return null;\n}).join();\n```\n\n### ThreadLocal\n\nThreadLocal 可以讓每個線程擁有變量的副本進行讀寫而互不影響。ThreadLocal 的原理就是 Thread 類本身的 ThreadLocalMap，當調用 `ThreadLocal.set` 方法時會去獲取當前線程的 ThreadLocalMap，然後以當前 ThreadLocal 爲 key，將值放入其中；當調用`ThreadLocal.get`時則從 ThreadLocalMap 中讀取。如此每個 Thread 都有各自的專屬變量，不受其他線程影響。\n\n![](java-concurrent/Untitled%203.png)\n\nThreadLocalMap 中的 key 採用弱引用，如果 key 即 ThreadLocal 沒有強引用的話，key 會被 GC 回收變爲 null，而 value 因爲是強引用不會被 GC 回收，於是出現了 key 爲 null 的 Entry，造成內存泄漏。ThreadLocalMap 在調用 `get`、`set` 方法時會清理 key 爲 null 的Entry，雖如此還是在使用完 ThreadLocal 後手動調用下 `remove` 方法爲好。\n\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n  /** The value associated with this ThreadLocal. */\n  Object value;\n\n  Entry(ThreadLocal<?> k, Object v) {\n      super(k);\n      value = v;\n  }\n}\n```\n\n## 線程安全\n\n### 線程安全的保證\n\n1. 原子性：多項操作要麼都執行，要麼都不執行。synchronized 可以保證代碼片段的原子性。\n2. 可見性：當一個線程對共享變量做了修改，其他線程要立即可以看到修改後的值。volatile 可以保證共享變量的可見性。\n3. 有序性：代碼編寫時的順序同編譯執行時的順序一致。volatile 可以禁止指令重排序。\n\n### **synchronized 同步鎖的用法**\n\nsynchronized 使用時需要指定一個鎖，當程序進入 synchronized 代碼塊或方法時該鎖會被鎖住，直到離開 synchronized 代碼塊或方法，鎖才會被釋放。注意：同步的範圍越小越好。\n\n**同步代碼塊**\n\n```java\npublic void f() {\n  synchronized(this){\n  }\n}\n```\n\n同步代碼塊的鎖可以選擇使用當前對象（this）、當前類 class 對象或其他任意對象。\n\n**同步方法**\n\n```java\npublic synchronized void f() {\n}\n```\n\n此時鎖爲同步方法所在類的對象。**同一個對象的多個同步方法共享同一個鎖**，多個實例對象時各個對象有各自的鎖。子類重寫父類的同步方法時可以去除同步。\n\n**同步靜態方法**\n\n```java\npublic static synchronized void f() {\n}\n```\n\n此時鎖為同步靜態方法所在類的 class 對象，即使多個實例對象也共享同一個鎖。\n\n### 使用 String 作爲鎖的注意點\n\n1. 首先 String 是一個特殊的類，JVM 使用常量池技術對其進行了緩存，通過字面量使用時會總是返回同一個 String 對象。\n2. 使用 `new String`、`StringBuilder.toString` 和 `StringBuffer.toString` 每次會返回一個新的 String 對象。\n3. 使用 `String.intern`，當常量池中有值等同的 String 對象時返回該對象，如無則將其加入常量池。\n\n### **Java 同步鎖的本質**\n\n**Java 的鎖是存在於對象頭**中的，具體就 Hotspot 虛擬機來說，是存在於對象頭中的 Mark Word（標記字段）中的鎖標誌位。Java 對象可有四種鎖狀態：\n\n1. 一開始對象無鎖，當一段同步代碼一直被一個線程訪問時，該線程自動獲得鎖，此時該鎖爲**偏向鎖**；\n2. 當鎖是偏向鎖時，另一個線程訪問同步代碼，偏向鎖會升級爲**輕量級鎖**，其他線程會通過**自旋**（指嘗試獲取鎖的線程不會立即阻塞，而是採用循環的方式獲取鎖）嘗試獲取鎖；\n3. 當鎖是輕量級鎖時，另一個線程自旋到一定次數仍然未獲得鎖，輕量級鎖會自動升級爲**重量級鎖**，其他線程進入阻塞狀態。\n\n![](java-concurrent/_2020-11-16_8.54.01.png)\n\n當處於重量級鎖時，對象頭存儲的指針指向的重量級鎖也叫 **monitor 鎖**（監視器鎖）。多個線程爭搶的就是這個 monitor 對象，誰持有誰就可以運行同步代碼。通過使用 `javap -c -s -v -l xx.class` 反彙編字節碼知道：當使用 `synchronized` 同步代碼塊時其實現時 `monitorenter` 和 `monitorexit` 指令，其中的 `monitorenter` 指令指向同步代碼塊開始的位置，`monitorexit` 則指向結束的位置；當使用 `synchronized` 修飾方法時，則是使用 `ACC_SYNCHRONIZED` 標識該方法爲同步方法。\n\n獲取鎖的過程如下圖所示：需要訪問同步代碼的多個線程首先進入 Entry Set，當線程獲取到 monitor 對象時會進入 The Owner 區域，然後將 monitor 對象中的 owner 變量設置爲當前線程，計數器 count 加 1；若線程調用 wait 方法，將釋放持有的 monitor，owner 變量設置爲 null，計數器 count 減 1，同時該線程進入 Wait Set 等待被喚醒；若線程執行完畢也將釋放 monitor 並恢復 monitor 中相關變量的值。\n\n![](java-concurrent/Untitled%204.png)\n\n### volatile 關鍵字\n\n參考：[https://monkeysayhi.github.io/2017/12/28/一文解决内存屏障/](java-concurrent//monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/)\n\nvolatile 關鍵字可以修飾變量，其作用是：\n\n標記該變量以在編譯時，取消編譯層面的緩存和重排序（編譯時的亂序優化）；在解釋執行時使用 CPU 內存屏障技術解決硬件層面的可見性和重排序。具體來說：\n\n1. **被修飾的變量在寄存器中將不會有副本，而是直接從主存進行讀寫操作**，多線程環境下，變量的值的改變**即時可見**。所謂的主存和寄存器是計算機的解決訪問 CPU 處理速度和內存讀寫速度不匹配的手段。一般認爲寄存器的讀寫速度快於主存。\n\n    ![](java-concurrent/Untitled%205.png)\n\n    未聲明 volatile 時\n\n    ![](java-concurrent/Untitled%206.png)\n\n    聲明 volatile 時\n\n2. 編譯器不對該變量進行亂序優化。\n3. JVM 在解釋執行時使用對應 CPU 架構的內存屏障指令防止指令重排序，通常有以下三種：\n    - mfence(StoreLoad Barriers、Full Barrier) 全能屏障\n    - sfence(Store Barriers) 寫屏障\n    - lfence(Load Barrirers) 讀屏障\n\n    以 x86 架構爲例子，如有一以 volatile 修飾的變量 v，JVM 對其操作如下：\n\n    1. 在寫入 v 之後插入一個 sfence，隔離了寫入 v 前後的寫入指令，防止其重排序，且 sfence 之前的修改會被寫入緩存並標記其他 CPU 核心中的緩存失效；\n    2. 在讀取 v 之前插入一個 lfence，隔離了讀取 v 前後的讀取指令，防止其重排序，且 lfence 之後會先刷新緩存，從而讀取最新的值。\n\n    sfence 和 lfence 兩相配合，保證了變量 v 的可見性。\n\n### CAS 鎖\n\nsynchronized 是悲觀鎖，假定操作是有衝突的，要加鎖然後再執行程序，完畢後再釋放鎖。而 CAS(Compare And Swap) 是樂觀鎖，假定操作是沒有衝突的，不需要加鎖，而是把舊的預期值跟內存中已有的值進行比較，如果相同再把要更新的值更新到內存，如果不同則自旋（重試，重新獲取預期值進行比較和替換），Java 中的原子類（比如 AtomicInteger）的底層實現就是 CAS。\n\nCAS 存在一個稱之爲 ABA 的問題，即對於變量 v = A，當其變爲 B 後又復原爲 A 時，無法判斷變量 v 是否被修改過。\n\n![](java-concurrent/Untitled%207.png)\n\n使用 `AtomicStampedReference` 可以防止 ABA 的問題，因爲附帶的 Stamp可以標識 Reference 的版本，Reference 變化，Stamp 隨之遞增。\n\n### Atomic 原子類\n\n`java.util.concurrent.atomic` 包中提供了一系列原子類，包括：\n\n1. 原子類型：\n    - AtomicInteger：針對整型\n    - AtomicLong：針對長整型\n    - AtomicBoolean：針對布爾類型\n2. 數組類型：\n    - AtomicIntegerArray：針對整型數組\n    - AtomicLongArray：針對長整型數組\n    - AtomicReferenceArray：針對引用類型數組\n3. 引用類型：\n    - AtomicReference：針對對象引用\n    - AtomicStampedReference：針對對象引用連同一個整型\n    - AtomicMarkableReference：針對對象引用連同一個布爾類型\n4. 對象的屬性修改類型：\n    - AtomicIntegerFieldUpdater：修改對象的一個整型屬性\n    - AtomicLongFieldUpdater：修改對象的一個長整型屬性\n    - AtomicReferenceFieldUpdater：修改對象的一個整型屬性\n\n其理論基礎就是 **CAS**(Compare and Swap) **鎖 + volatile + native 方法。**CAS 就是將舊的預期值與內存中的值進行比較，當相同時才將新的預期值設入，否則自旋。 \n\n介紹下 AtomicInteger 類的幾個原子方法：\n\n```java\npublic final int get(java-concurrent//獲取當前的值\npublic final int getAndSet(java-concurrent//獲取當前的值，並設置新的值\npublic final int getAndIncrement(java-concurrent//獲取當前的值，並自增\npublic final int getAndDecrement(java-concurrent//獲取當前的值，並自減\npublic final int getAndAdd(java-concurrent//獲取當前的值，並加上預期的值\nboolean compareAndSet(java-concurrent//如果輸入的數值等於預期值，則以原子方式將該值設置為輸入值（update）\npublic final void lazySet(java-concurrent//最終設置為newValue,使用 lazySet 設置之後可能導致其他線程在之後的一小段時間內還是可以讀到舊的值。\n```\n\n### 死鎖 (deadlock)\n\n如果一組線程中的每個線程都在等待一個事件，而這個事件只能由該組中的另一個線程觸發，這種情況會導致死鎖。\n\n死鎖需要滿足四個條件（線程維度上）：\n\n1. 互斥，該資源任意時刻只能由一個線程佔用。\n2. 請求與保持，一個線程因請求資源被阻塞，另一個線程保持該資源不放。\n3. 不剝奪/不可搶佔，一個線程不能強佔另一個線程擁有的資源，除非另一個線程釋放之。\n4. 循環等待，若干個線程形成循環等待資源的關係。\n\n那麼，防止死鎖只需要不滿足以上四個條件之一即可。具體來說：\n\n1. 破壞互斥：不可，這是資源的固有屬性，不可破壞。\n2. 破壞請求與保持：可以一次性請求所有需要的資源。\n3. 破壞不剝奪：\n    - 若有一佔有若干資源的進程請求某資源被拒絕，則它應釋放它佔有的資源。\n    - 若有一進程請求當前被另一個進程佔有的資源，則操作系統可以剝奪另一個進程的資源。\n4. 破壞循環等待：確定資源的申請順序和釋放順序。\n\n下面是一個死鎖的實例，線程A 擁有資源1 後想要獲得資源2，線程B 擁有資源2 後想要獲得資源1。\n\n![](java-concurrent/Untitled%208.png)\n\n```java\nObject res1 = new Object();\nObject res2 = new Object();\n\nnew Thread(() -> {\n  synchronized (res1) {\n      System.out.println(Thread.currentThread() + \" get res1\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res2\");\n      synchronized (res2) {\n          System.out.println(Thread.currentThread() + \" get res2\");\n      }\n  }\n}, \"Thread A\").start();\n\nnew Thread(() -> {\n  synchronized (res2) {\n      System.out.println(Thread.currentThread() + \" get res2\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res1\");\n      synchronized (res1) {\n          System.out.println(Thread.currentThread() + \" get res1\");\n      }\n  }\n}, \"Thread B\").start();\n\n// 按相同順序申請和釋放資源，破壞循環等待條件，從而避免死鎖\nnew Thread(() -> {\n  synchronized (res1) {\n      System.out.println(Thread.currentThread() + \" get res1\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res2\");\n      synchronized (res2) {\n          System.out.println(Thread.currentThread() + \" get res2\");\n      }\n  }\n}, \"Thread B\").start();\n```","source":"_posts/it/java/java-concurrent.md","raw":"---\ntitle: Java 多線程\np: it/java/java-concurrent.md\ndate: 2020-11-08 12:23:00\ntags:\n- Java\n---\n\n首先區分進程和線程。進程是程序運行的基本單位，也是系統分配資源的最小單位；而線程是 CPU 調度的最小單位，一個進程可以有多個線程，而各個線程擁有獨立的程序計數器、虛擬機棧和本地方法棧，但共享同一個堆和方法區。爲著充分利用系統資源，減少 CPU 空等，多線程技術應運而生。系統使用時間片輪轉法分配 CPU 資源到各個線程，如果線程在分配的時間片內未能處理完任務，則會導致上下文切換。\n\nJava 中線程類爲 `Thread` ，其 `start` 方法會使線程進入 Runnable 狀態；其 `sleep` 方法會阻塞線程而不釋放鎖，跟 `Object.wait` 有別；其 `interrupt` 方法並不停止線程，而是設置一個標誌位通知線程應當關閉，線程可以根據該標誌位決定是否要停止運行。\n\n多個線程可以通過線程池進行統一管理，好處是還可以提前 Ready 好一些線程避免等待線程創建的時間損耗；還可以使用舊的線程，減少線程的頻繁創建和銷毀的資源損耗。線程池推薦直接使用 `ThreadPoolExecutor` 的構造方法去創建，以便設置合適的構造參數。調用 `ThreadPoolExecutor.execute` 可以將一個 `Runnable` 任務放入線程池處理； 調用`ThreadPoolExecutor.submit`  可以將一個 `Callable` 任務放入線程池處理，返回一個 `Future` 代表處理結果，後續通過調用 `Future.get` 獲取處理結果，其過程是阻塞的。\n\nJava 1.5 開始提供`AbstractQueuedSynchronizer`，用於創建多線程訪問共享資源的同步器，其內部使用一個名爲 CLH 的 FIFO 的雙向隊列進行資源分配。其常見實現類有：`ReentrantLock`、`ReadWriteLock` 和 `CountDownLatch` 。其中 `ReadWriteLock` 性能優於 `ReentrantLock` ，因爲兩個讀操作在 `ReadWriteLock` 中不互斥而在 `ReentrantLock` 中互斥。\n\nJava 1.8 開始提供了 `CompletableFuture` ，其實現了 `Future` 接口，並提供了基於回調的函數式異步編程方式和對`CompletableFuture` 的組合，使用者可以不關心底層的線程池，大大簡便了異步編程。\n\nJava 還提供了 ThreadLocal 類可以使得各個線程擁有變量的副本而不會相互影響，底層是使用 Thread 類的 `ThreadLocalMap`，一個類似 HashMap 的結構，其 Key 爲 ThreadLocal 對象的弱引用。\n\n多線程因會有多個線程操作共享的資源而引發了線程安全的擔憂。線程安全要求**原子性、可見性和有序性**。Java 提供了多種方式可以保證線程安全：\n\n1. synchronized 同步鎖，這是一個重量級鎖。可以使用當前類的 class 對象，當前類的對象或者任意對象對方法和代碼塊進行加鎖，方法結束或代碼塊結束則鎖自動釋放。當使用非靜態同步方法時，會使用當前對象爲鎖，因此多個非靜態同步方法共享同一鎖。Java 1.6 後引入**偏向鎖**和**輕量級鎖**的概念，使得 synchronized 不那麼「重」了。\n2. volatile 關鍵字。使用該關鍵字修飾的變量在編譯時不會有寄存器緩存而是直接使用主存、不會進行代碼重排序優化，保證了可見性和有序性；在解釋執行時使用 CPU 內存屏障技術防止指令重排序。\n3. CAS(Compare and Swap) 技術，相比於 synchronized，其假定操作是不會產生衝突的，將舊的預期值和內存中的值進行比較，若相同則更新內存中的值，否則自旋。因此被稱之爲「樂觀鎖」，而 synchronized 被稱之爲「悲觀鎖」。Java 中的 Atomic 類是典型的 CAS 實現。\n\n多線程操作共享資源還會出現死鎖。死鎖產生的條件是：**互斥、請求/等待、不可剝奪和循環等待**。解決死鎖問題的關鍵是破壞死鎖產生的條件。\n\n<!-- more -->\n\n## 多線程\n\n### **程序、進程與線程**\n\n1. 程序：程序是含有指令和數據的文件，被靜態存儲於存儲設備之中。\n2. 進程：进程是程序的一次執行過程，是**操作系統運行程序的基本單位**，是動態的。它佔用一定的系統資源（包括 CPU 時間、內存空間、文件、輸入輸出設備等等），**是資源分配的最小單位**。各進程之間相互獨立。\n3. 線程：**線程是 CPU 調度的最小單位**，擁有**程序計數器、虛擬機棧和本地方法棧**，相比進程，它佔用資源更小，產生和切換線程的負擔更小，也被稱爲**輕量級進程**。一個進程可以產生多個線程。同個進程的多個線程之間共享同一塊**堆和方法區**。\n\n- 堆是幹什麼用的？\n\n    堆是進程中最大的一塊內存，用於存放新建的對象。\n\n- 方法區是幹什麼的？\n\n    根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放程序執行代碼的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(java-concurrent/code segment)，通常只讀。具體來說，它存放了每個類的結構，例如運行時常量池，字段和方法數據，以及方法和構造函數的代碼，包括用於類和實例初始化以及接口初始化的特殊方法。\n\n    另外，UNIX 中的進程將內存劃分成三個部分：text segment,文本區，例如代碼，data segment，數據區，例如變量，stack segment，棧區域。\n\n- 程序計數器爲什麼是線程私有的？\n\n    程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。\n\n    因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。\n\n- 虛擬機棧和本地方法棧爲什麼是線程私有的？\n    - **虛擬機棧**：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態鏈接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。\n    - **本地方法棧**：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。\n\n    爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。\n\n### **線程有哪些基本狀態**\n\nJava 線程共有 6 中狀態，如下：\n\n1. New：新創建的線程，尚未執行。\n2. Runnable：運行中的線程，`run` 方法正在執行中。可細分爲 Ready 和 Running 兩個狀態。\n3. Blocked：運行中的線程，因爲某些操作被阻塞而掛起。\n4. Waiting：運行中的線程，因爲某些操作在等待。\n5. Timed Waiting：運行中的線程，因爲執行 `sleep` 等方法正在計時等待。\n6. Terminated：線程終止，因爲 `run` 方法執行完畢。\n\n![](java-concurrent/Untitled.png)\n\n### 並發和並行的區別\n\n並發（concurrent）：同一時間段，多個任務都在執行。\n\n並行（parallel）：單位時間內，多個任務同時執行。\n\n### 多線程的優勢\n\n1. 提高 CPU 和 IO 設備的綜合利用率，確保 CPU 或 IO 設備不空等。\n2. 提高 CPU 核心利用率，確保 CPU 的多個核心都能被利用到。\n3. 提高系統整體的並發能力和性能，應對高並發場景。\n\n### 上下文切換\n\n**上下文切換就是舊任務被暫停，保存自身狀態，然後新任務被執行的過程**。造成上下文切換的原因是需要同時執行的任務大於 CPU 核心數，而單個 CPU 同一時刻只能執行一個任務。CPU 採用時間片輪轉法分配 CPU 時間給多個線程，當時間片結束舊任務如果未執行完畢會被暫停，保存當前狀態，然後執行新的任務。\n\n上下文切換所需的時間很可觀，可能是操作系統中時間消耗最大的操作。操作系統中數 Linux（及其他類 Unix 系統） 上下文切換時間消耗最少。\n\n### 爲什麼調用 `Thread.start` 方法而不是 `Thread.run` 方法？\n\n調用 `start` 方法會啟動一個新線程並進入就緒狀態，當分配到時間片後會自動調用 `run` 方法。直接調用 `run` 方法只會在調用者所在的線程執行。\n\n### 比較 `Thread.sleep` 方法和 `Object.wait` 方法\n\n共同點：\n\n1. 都可以暫停線程的執行。\n2. `sleep(long)`和 `wait(long)` 都可以在指定時間段後使線程自動甦醒。\n\n不同點：\n\n1. sleep 是 Thread 類的方法，wait 是 Object 類的方法。\n2. **sleep 沒有釋放鎖，wait 釋放了**。\n3. `wait()` 被調用後線程不會自動甦醒，需要別的線程調用同一對象上的 `notify()` 或 `notifyAll()` 方法來喚醒。\n- 代碼\n\n    ```java\n    // Data.java\n    public class Data {\n        private String packet;\n\n        // 单次传输是否结束\n        // True if Receiver should wait\n        // False if Sender should wait\n        private boolean isTransfer = true;\n\n        public synchronized void send(String packet) {\n            while (!isTransfer) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            this.packet = packet;\n            isTransfer = false;\n            notifyAll();\n        }\n\n        public synchronized String receive() {\n            while (isTransfer) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            isTransfer = true;\n            notifyAll();\n            return packet;\n        }\n    }\n\n    // Sender.java\n    public class Sender implements Runnable {\n\n        private final Data data;\n\n        public Sender(Data data) {\n            this.data = data;\n        }\n\n        @Override\n        public void run() {\n            String[] packets = new String[]{\"Hello\", \"Are\", \"You\", \"Ok\", \"Over\"};\n            for (String packet : packets) {\n                data.send(packet);\n            }\n        }\n    }\n\n    // Receiver.java\n    public class Receiver implements Runnable {\n\n        private final Data data;\n\n        public Receiver(Data data) {\n            this.data = data;\n        }\n\n        @Override\n        public void run() {\n            String packet = data.receive();\n            while (!\"Over\".equals(packet)) {\n                System.out.println(packet);\n                packet = data.receive();\n            }\n        }\n    }\n\n    // Main.java\n    public class Main {\n\n        public static void main(String[] args) {\n            Data data = new Data();\n            new Thread(new Receiver(data)).start();\n            new Thread(new Sender(data)).start();\n        }\n    }\n    ```\n\n### 調用 `Thread.interrupt` 意味著什麼？\n\n調用 interrupt 方法並不會中斷一個線程，而是發出出一個中斷信號到目標線程（設置中斷標誌位的值爲 true），目標線程收到信號後可以決定是否處理。\n\n與之相關的方法有：\n\n```java\n// 測試當前線程是否已經中斷。當線程中斷時調用該方法將會清除線程的中斷狀態\npublic static boolean interrupted()\n// 測試線程是否已經中斷。不改變線程的中斷狀態。\npublic boolean isInterrupted()\n// 中斷線程\npublic void interrupt()\n```\n\n[廖雪峰的官方網站](java-concurrent//www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554)提供了以下的代碼：\n\n```java\npublic class Main {\n  public static void main(String[] args) throws InterruptedException {\n      Thread t = new MyThread();\n      t.start();\n      Thread.sleep(java-concurrent// 暫停1毫秒\n      t.interrupt(java-concurrent// 中斷t線程\n      t.join(java-concurrent// 等待t線程結束\n      System.out.println(\"end\");\n  }\n}\n\nclass MyThread extends Thread {\n  public void run() {\n      int n = 0;\n      while (! isInterrupted()) {\n          n ++;\n          System.out.println(n + \" hello!\");\n      }\n  }\n}\n```\n\n值得注意的是：\n\n1. 本線程中斷自己是被允許的；其它線程調用本線程的`interrupt`方法時，會通過`checkAccess`檢查權限。這有可能拋出`SecurityException`異常。\n2. 調用線程的`wait` 方法會讓它進入等待(阻塞)狀態，或者調用線程的`join`, `sleep` 方法也會讓它進入阻塞狀態。若線程在阻塞狀態時，調用了它的`interrupt`方法，那麼它的「中斷狀態」會被清除並且會收到一個`InterruptedException`異常。例如，線程通過`wait()`進入阻塞狀態，此時通過`interrupt()`中斷該線程；調用`interrupt()`會立即將線程的中斷標記設為「true」，但是由於線程處於阻塞狀態，所以該「中斷標記」會立即被清除為「false」，同時，會產生一個`InterruptedException`的異常。\n3. 如果線程被阻塞在一個`Selector`選擇器中，那麼通過`interrupt()`中斷它時；線程的中斷標記會被設置為true，並且它會立即從選擇操作中返回。\n4. 如果不屬於前面所說的情況，那麼通過`interrupt()`中斷線程時，它的中斷標記會被設置為「true」。\n5. 中斷一個「已終止的線程」不會產生任何操作。\n\n### 線程池技術\n\n**（1）爲什麼要使用線程池？**\n\n線程池管理了一組線程資源，並維護了一些基本的統計信息。\n\n《Java 並發編程的藝術》中講述到使用線程池的好處：\n\n1. 降低資源消耗。通過重複使用已創建的線程減少線程創建和銷毀的消耗。\n2. 提高響應速度。線程池預先創建了線程，在需要時可以直接使用不用等。\n3. 提供線程的可管理性。線程是稀缺資源，不能無限制地分配，使用線程池可以進行統一分配、調優和監控。\n\n**（2）Runnable 接口和 Callable 接口的區別**\n\n1. Runnable 始於 Java 1.0 ，Callable 接口始於 Java 1.5.\n2. Runnable 不會返回結果或拋出檢查異常，而 Callable 會。\n\n另外，工具類 `Executors` 可以實現 Runnable 對象和 Callable 對象之間的相互轉換，如下：\n\n```java\nExecutors.callable(Runnable task)\nExecutors.callable(Runnable task，Object resule)\n```\n\n**（3）`execute` 方法和 `submit` 方法有什麼區別？**\n\n1. `execute` 提交任務之後沒有返回值，無法判斷任務是否被執行成功。\n2. `submit` 提交任務之後有返回值 Future，可以知道任務是否被執行成功。調用 `Future.get()` 會阻塞線程直到任務完成；調用 `Future.get(long timeout，TimeUnit unit)`  則是阻塞指定的一段時間後立即返回，不管任務是否執行完成。當然如果提交的是 Runnable，那麼返回的 Future 中的泛型爲 Void。\n\n**（4）如何創建線程池？**\n\n《阿里巴巴 Java 開發手冊》中要求直接用 `ThreadPoolExecutor` 的構造方法去創建線程池，而非通過 Executors 去創建線程池，因爲：\n\n1. `FixedThreadPool` 和 `SingleThreadPool` 中允許請求的隊列長度爲 `Integer.MAX_VALUE`，可能會堆積大量請求，導致 OOM；\n2. `CachedThreadPool` 和 `ScheduledThreadPool` 中允許線程數爲 `Integer.MAX_VALUE`，可能會創建大量線程，導致 OOM。\n\n`ThreadPoolExecutor` 的參數分析：\n\n```java\npublic ThreadPoolExecutor(\n  // 核心線程數，規定了最小的可以同時運行的線程數量\n\tint corePoolSize,\n  // 最大線程數，當請求隊列滿時，可以同時運行的線程數量\n\tint maximumPoolSize,\n  // 當線程空閒且大於規定的核心線程數時，等待 keepAliveTime 時間後多餘的線程會被銷毀\n\tlong keepAliveTime,\n  // keepAliveTime 的時間單位\n\tTimeUnit unit,\n  // 請求隊列，當新任務進來時，當前運行的線程達到核心線程數，則新任務會被放置到請求隊列\n\tBlockingQueue<Runnable> workQueue,\n  // 線程工廠，用於創建新線程\n\tThreadFactory threadFactory,\n  // 飽和策略，當線程數量達到最大線程數且請求隊列也滿的情況下觸發飽和策略\n\tRejectedExecutionHandler handler) {\n}\n```\n\n線程池中的飽和策略有：\n\n1. `ThreadPoolExecutor.AbortPolicy`：默認策略，拋出異常，拒絕處理新任務。\n2. `ThreadPoolExecutor.CallerRunsPolicy`：直接在調用 `execute` 所在的線程執行。\n3. `ThreadPoolExecutor.DiscardPolicy`：不拋出異常，直接丟棄新任務。\n4. `ThreadPoolExecutor.DiscardOldestPolicy`：不拋出異常，丟棄最早未處理的任務。\n\n**（5）線程池對新任務的處理過程**\n\n![](java-concurrent/Untitled%201.png)\n\n### AQS（抽象隊列式同步器）\n\n**（1）概述**\n\nAQS，即 `AbstractQueuedSynchronizer` ，加入於 Java 1.5，作者爲大名鼎鼎的 Doug Lea，其定義了一套多線程訪問共享資源的同步器框架。其下有諸如 `ReentrantLock`、`ReadWriteLock`、`CountDownLatch` 等等實現。\n\nAQS 的實現思路是：如下圖所示，當請求的共享資源空閒時，請求資源的線程會被設置爲有效的工作線程，該資源會被鎖定；當請求的共享資源被佔用時，將請求資源的線程加入 CLH 隊列中。CLH 是三個人名的首字母，CLH 隊列是一個雙向隊列，FIFO。而共享資源的狀態是一個整型值，採用 CAS 方式進行值的原子更新，通常加鎖 state 會加 1，釋放則減 1。\n\n![](java-concurrent/Untitled%202.png)\n\nAQS 可以定義兩種資源共享方式，獨佔 or 共享。其採用模板方法模式編寫，實現類需要選擇性地實現以下方法（默認實現是拋出`UnsupportedOperationException`）：\n\n```java\n//該線程是否正在獨佔資源。只有用到condition才需要去實現它。\nisHeldExclusively()\n//獨佔方式。嘗試獲取資源，成功則返回true，失敗則返回false。\ntryAcquire(int)\n//獨佔方式。嘗試釋放資源，成功則返回true，失敗則返回false。\ntryRelease(int)\n//共享方式。嘗試獲取資源。負數表示失敗；0表示成功，但沒有剩餘可用資源；正數表示成功，且有剩餘資源。\ntryAcquireShared(int)\n//共享方式。嘗試釋放資源，成功則返回true，失敗則返回false。\ntryReleaseShared(int)\n```\n\n**（2）ReentrantLock**\n\nReentrantLock，可重入鎖，同一線程可以反覆加鎖，然後釋放同樣次數的鎖。synchronized 修飾的方法用的也是可重入鎖，但 ReentrantLock 提供了更爲靈活的控制，有 lock、unlock 方法還有類似於 `Object.wait` / `Object.notify` 的 `Condition.await` / `Condition.signal` 方法。\n\n- 代碼\n\n    參考：[https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/](java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/)\n\n    ```java\n    // SharedFifoQueue.java\n    public class SharedFifoQueue {\n\n      private final Object[] content;\n      // 標識當前隊列中擁有的對象數目\n      private int current = 0;\n      private int addIndex = 0;\n      private int removeIndex = 0;\n\n      private final ReentrantLock lock = new ReentrantLock();\n      private final Condition fullCondition = lock.newCondition();\n      private final Condition emptyCondition = lock.newCondition();\n\n      public SharedFifoQueue(int capacity) {\n          content = new Object[capacity];\n      }\n\n      public void add(Object item) throws InterruptedException {\n          lock.lock();\n          while (current >= content.length) {\n              fullCondition.await();\n          }\n          content[addIndex] = item;\n          addIndex = (addIndex + 1) % content.length;\n          current++;\n          emptyCondition.signal();\n          lock.unlock();\n      }\n\n      public Object remove() throws InterruptedException {\n          lock.lock();\n          while (current <= 0) {\n              emptyCondition.await();\n          }\n          Object item = content[removeIndex];\n          removeIndex = (removeIndex + 1) % content.length;\n          current--;\n          fullCondition.signal();\n          lock.unlock();\n          return item;\n      }\n    }\n\n    // Producer.java\n    public class Producer implements Runnable {\n\n      private final SharedFifoQueue queue;\n      private final Random random = new Random();\n\n      public Producer(SharedFifoQueue queue) {\n          this.queue = queue;\n      }\n\n      @Override\n      public void run() {\n          try {\n              for (int i = 0; i < 20; i++) {\n                  queue.add(\"Hello \" + i);\n                  Thread.sleep(random.nextInt(200) );\n              }\n              queue.add(null);\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n\n    // Consumer.java\n    public class Consumer implements Runnable {\n\n      private final SharedFifoQueue queue;\n\n      public Consumer(SharedFifoQueue queue) {\n          this.queue = queue;\n      }\n\n      @Override\n      public void run() {\n          try {\n              while (true) {\n                  Object item = queue.remove();\n                  if (item == null) {\n                      break;\n                  }\n                  System.out.println(item.toString());\n              }\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n\n    // Main.java\n    public static void main(String[] args) throws InterruptedException {\n        SharedFifoQueue sharedFifoQueue = new SharedFifoQueue(10);\n        Thread consumerThread = new Thread(new Consumer(sharedFifoQueue));\n        Thread producerThread = new Thread(new Producer(sharedFifoQueue));\n\n        producerThread.start();\n        consumerThread.start();\n        // join 可以讓主線程等待子線程結束\n        producerThread.join();\n        consumerThread.join();\n    }\n    ```\n\n**（3）ReadWriteLock**\n\nReadWriteLock 相比 ReentrantLock 性能更高，體現在兩個讀操作在 ReadWriteLock 裏是不互斥的，而在 ReentrantLock 裏是互斥的。\n\n- 代碼\n\n    代碼來源：[https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/](java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/)\n\n    ```java\n    public class ThreadSafeArrayList<E> {\n      private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n      private final Lock readLock = readWriteLock.readLock();\n      private final Lock writeLock = readWriteLock.writeLock();\n\n      private final List<E> list = new ArrayList<>();\n\n      public void set(E o) {\n          writeLock.lock();\n          try {\n              list.add(o);\n          } finally {\n              writeLock.unlock();\n          }\n      }\n\n      public E get(int i) {\n          readLock.lock();\n          try {\n              return list.get(i);\n          } finally {\n              readLock.unlock();\n          }\n      }\n    }\n    ```\n\n**（4）CountDownLatch**\n\nCountDownLatch 可以讓一個或多個線程等待指定的操作完成後再開始工作。初始化 CountDownLatch 時需要指定一個 count 值，需要等待的線程使用 `CountDownLatch.await()` 進行等待，當 `CountDownLatch.countDown()` 被調用 count 次時，等待的線程才得以繼續執行。\n\n- 代碼\n\n    代碼來源：[http://tutorials.jenkov.com/java-util-concurrent/countdownlatch.html](java-concurrent//tutorials.jenkov.com/java-util-concurrent/countdownlatch.html)\n\n    ```java\n    // Main.java\n    CountDownLatch latch = new CountDownLatch(3);\n\n    Waiter      waiter      = new Waiter(latch);\n    Decrementer decrementer = new Decrementer(latch);\n\n    new Thread(waiter)     .start();\n    new Thread(decrementer).start();\n\n    Thread.sleep(4000);\n    // Waiter.java\n    public class Waiter implements Runnable{\n\n      CountDownLatch latch = null;\n\n      public Waiter(CountDownLatch latch) {\n          this.latch = latch;\n      }\n\n      public void run() {\n          try {\n              latch.await();\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n\n          System.out.println(\"Waiter Released\");\n      }\n    }\n    // Decrementer.java\n    public class Decrementer implements Runnable {\n\n      CountDownLatch latch = null;\n\n      public Decrementer(CountDownLatch latch) {\n          this.latch = latch;\n      }\n\n      public void run() {\n          try {\n              Thread.sleep(1000);\n              this.latch.countDown();\n\n              Thread.sleep(1000);\n              this.latch.countDown();\n\n              Thread.sleep(1000);\n              this.latch.countDown();\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n    ```\n\n**（5）Semaphore**\n\nSemaphore 用於限制訪問資源的線程數量，以對資源進行保護。[有人將其比做是廁所的坑位數](java-concurrent//blog.csdn.net/eson_15/article/details/51577191)，譬如一個廁所有 3 個坑，則同時上廁所的人只能有 3 個，其他人要上只能等這 3 個人之一釋放坑位。\n\n使用前通過調用 `Semaphore.acquire` 獲取訪問，使用後通過  `Semaphore.release` 釋放許可。\n\n- 代碼\n\n    ```java\n    public static void main(String[] args) {\n        ExecutorService threadPool = Executors.newFixedThreadPool(10);\n        Semaphore semaphore = new Semaphore(3);\n        for (int i = 0; i < 10; i++) {\n            threadPool.execute(() -> {\n                try {\n                    semaphore.acquire();\n                    System.out.printf(\"Running Thread Id: %s, Available permit: %d, Queue length: %d\\n\", Thread.currentThread().getId(), semaphore.availablePermits(), semaphore.getQueueLength());\n                    Thread.sleep(300);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    semaphore.release();\n                }\n            });\n        }\n    }\n    ```\n\n    運行結果：\n\n    初始化總許可量爲 3，一開始被用掉一個許可，可用許可剩餘 2；隨後許可被用光，其他線程開始排隊，出現長度爲 6 的請求隊列，之後隨之許可釋放，隊列長度遞減，直到所有任務處理完成，隊列長度爲 0，許可復爲 3。\n\n    ```java\n    Running Thread Id: 13, Available permit: 2, Queue length: 0\n    Running Thread Id: 15, Available permit: 0, Queue length: 0\n    Running Thread Id: 14, Available permit: 1, Queue length: 0\n    Running Thread Id: 16, Available permit: 0, Queue length: 6\n    Running Thread Id: 17, Available permit: 1, Queue length: 5\n    Running Thread Id: 18, Available permit: 0, Queue length: 4\n    Running Thread Id: 19, Available permit: 0, Queue length: 3\n    Running Thread Id: 20, Available permit: 1, Queue length: 2\n    Running Thread Id: 21, Available permit: 0, Queue length: 1\n    Running Thread Id: 22, Available permit: 2, Queue length: 0\n    ```\n\n### CompletableFuture\n\n參考：[https://colobu.com/2016/02/29/Java-CompletableFuture/](java-concurrent//colobu.com/2016/02/29/Java-CompletableFuture/)、[https://www.jianshu.com/p/6bac52527ca4](java-concurrent//www.jianshu.com/p/6bac52527ca4)\n\nCompletableFuture 是 Java 1.8 提供的類，可以方便函數式異步編程。CompletableFuture 實現了 Future 接口。\n\nFuture 是 Java 1.5 引入的接口，它代表這異步執行的結果。可以通過 `isDone` 判斷執行是否完畢，通過 `get` 阻塞獲取結果，通過 `cancel` 取消執行。\n\nFuture 獲取結果的方式不優雅，要輪詢或一直阻塞等待結果。 CompletableFuture 提供了回調的方式處理結果（正常結果 & 異常結果），還有組合多個 CompletableFuture 的能力。\n\n有了 CompletableFuture，我們甚至可以不關心線程、線程池和同步，因爲 CompletableFuture 內部已經幫我們處理好了，我們只需要鏈式調用函數就可以了。\n\n```java\nCompletableFuture.allOf(CompletableFuture.runAsync(() -> {\n  try {\n      Thread.sleep(200);\n  } catch (InterruptedException e) {\n      e.printStackTrace();\n  }\n  System.out.println(Thread.currentThread().getId() + \" done!\");\n}), CompletableFuture.runAsync(() -> {\n  try {\n      Thread.sleep(200);\n  } catch (InterruptedException e) {\n      e.printStackTrace();\n  }\n  System.out.println(Thread.currentThread().getId() + \" done!\");\n})).handle((BiFunction<Void, Throwable, Void>) (unused, throwable) -> {\n  if (throwable != null) {\n      System.out.println(\"Exception:\" + throwable.getMessage());\n  } else {\n      System.out.println(\"All done!\");\n  }\n  return null;\n}).join();\n```\n\n### ThreadLocal\n\nThreadLocal 可以讓每個線程擁有變量的副本進行讀寫而互不影響。ThreadLocal 的原理就是 Thread 類本身的 ThreadLocalMap，當調用 `ThreadLocal.set` 方法時會去獲取當前線程的 ThreadLocalMap，然後以當前 ThreadLocal 爲 key，將值放入其中；當調用`ThreadLocal.get`時則從 ThreadLocalMap 中讀取。如此每個 Thread 都有各自的專屬變量，不受其他線程影響。\n\n![](java-concurrent/Untitled%203.png)\n\nThreadLocalMap 中的 key 採用弱引用，如果 key 即 ThreadLocal 沒有強引用的話，key 會被 GC 回收變爲 null，而 value 因爲是強引用不會被 GC 回收，於是出現了 key 爲 null 的 Entry，造成內存泄漏。ThreadLocalMap 在調用 `get`、`set` 方法時會清理 key 爲 null 的Entry，雖如此還是在使用完 ThreadLocal 後手動調用下 `remove` 方法爲好。\n\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n  /** The value associated with this ThreadLocal. */\n  Object value;\n\n  Entry(ThreadLocal<?> k, Object v) {\n      super(k);\n      value = v;\n  }\n}\n```\n\n## 線程安全\n\n### 線程安全的保證\n\n1. 原子性：多項操作要麼都執行，要麼都不執行。synchronized 可以保證代碼片段的原子性。\n2. 可見性：當一個線程對共享變量做了修改，其他線程要立即可以看到修改後的值。volatile 可以保證共享變量的可見性。\n3. 有序性：代碼編寫時的順序同編譯執行時的順序一致。volatile 可以禁止指令重排序。\n\n### **synchronized 同步鎖的用法**\n\nsynchronized 使用時需要指定一個鎖，當程序進入 synchronized 代碼塊或方法時該鎖會被鎖住，直到離開 synchronized 代碼塊或方法，鎖才會被釋放。注意：同步的範圍越小越好。\n\n**同步代碼塊**\n\n```java\npublic void f() {\n  synchronized(this){\n  }\n}\n```\n\n同步代碼塊的鎖可以選擇使用當前對象（this）、當前類 class 對象或其他任意對象。\n\n**同步方法**\n\n```java\npublic synchronized void f() {\n}\n```\n\n此時鎖爲同步方法所在類的對象。**同一個對象的多個同步方法共享同一個鎖**，多個實例對象時各個對象有各自的鎖。子類重寫父類的同步方法時可以去除同步。\n\n**同步靜態方法**\n\n```java\npublic static synchronized void f() {\n}\n```\n\n此時鎖為同步靜態方法所在類的 class 對象，即使多個實例對象也共享同一個鎖。\n\n### 使用 String 作爲鎖的注意點\n\n1. 首先 String 是一個特殊的類，JVM 使用常量池技術對其進行了緩存，通過字面量使用時會總是返回同一個 String 對象。\n2. 使用 `new String`、`StringBuilder.toString` 和 `StringBuffer.toString` 每次會返回一個新的 String 對象。\n3. 使用 `String.intern`，當常量池中有值等同的 String 對象時返回該對象，如無則將其加入常量池。\n\n### **Java 同步鎖的本質**\n\n**Java 的鎖是存在於對象頭**中的，具體就 Hotspot 虛擬機來說，是存在於對象頭中的 Mark Word（標記字段）中的鎖標誌位。Java 對象可有四種鎖狀態：\n\n1. 一開始對象無鎖，當一段同步代碼一直被一個線程訪問時，該線程自動獲得鎖，此時該鎖爲**偏向鎖**；\n2. 當鎖是偏向鎖時，另一個線程訪問同步代碼，偏向鎖會升級爲**輕量級鎖**，其他線程會通過**自旋**（指嘗試獲取鎖的線程不會立即阻塞，而是採用循環的方式獲取鎖）嘗試獲取鎖；\n3. 當鎖是輕量級鎖時，另一個線程自旋到一定次數仍然未獲得鎖，輕量級鎖會自動升級爲**重量級鎖**，其他線程進入阻塞狀態。\n\n![](java-concurrent/_2020-11-16_8.54.01.png)\n\n當處於重量級鎖時，對象頭存儲的指針指向的重量級鎖也叫 **monitor 鎖**（監視器鎖）。多個線程爭搶的就是這個 monitor 對象，誰持有誰就可以運行同步代碼。通過使用 `javap -c -s -v -l xx.class` 反彙編字節碼知道：當使用 `synchronized` 同步代碼塊時其實現時 `monitorenter` 和 `monitorexit` 指令，其中的 `monitorenter` 指令指向同步代碼塊開始的位置，`monitorexit` 則指向結束的位置；當使用 `synchronized` 修飾方法時，則是使用 `ACC_SYNCHRONIZED` 標識該方法爲同步方法。\n\n獲取鎖的過程如下圖所示：需要訪問同步代碼的多個線程首先進入 Entry Set，當線程獲取到 monitor 對象時會進入 The Owner 區域，然後將 monitor 對象中的 owner 變量設置爲當前線程，計數器 count 加 1；若線程調用 wait 方法，將釋放持有的 monitor，owner 變量設置爲 null，計數器 count 減 1，同時該線程進入 Wait Set 等待被喚醒；若線程執行完畢也將釋放 monitor 並恢復 monitor 中相關變量的值。\n\n![](java-concurrent/Untitled%204.png)\n\n### volatile 關鍵字\n\n參考：[https://monkeysayhi.github.io/2017/12/28/一文解决内存屏障/](java-concurrent//monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/)\n\nvolatile 關鍵字可以修飾變量，其作用是：\n\n標記該變量以在編譯時，取消編譯層面的緩存和重排序（編譯時的亂序優化）；在解釋執行時使用 CPU 內存屏障技術解決硬件層面的可見性和重排序。具體來說：\n\n1. **被修飾的變量在寄存器中將不會有副本，而是直接從主存進行讀寫操作**，多線程環境下，變量的值的改變**即時可見**。所謂的主存和寄存器是計算機的解決訪問 CPU 處理速度和內存讀寫速度不匹配的手段。一般認爲寄存器的讀寫速度快於主存。\n\n    ![](java-concurrent/Untitled%205.png)\n\n    未聲明 volatile 時\n\n    ![](java-concurrent/Untitled%206.png)\n\n    聲明 volatile 時\n\n2. 編譯器不對該變量進行亂序優化。\n3. JVM 在解釋執行時使用對應 CPU 架構的內存屏障指令防止指令重排序，通常有以下三種：\n    - mfence(StoreLoad Barriers、Full Barrier) 全能屏障\n    - sfence(Store Barriers) 寫屏障\n    - lfence(Load Barrirers) 讀屏障\n\n    以 x86 架構爲例子，如有一以 volatile 修飾的變量 v，JVM 對其操作如下：\n\n    1. 在寫入 v 之後插入一個 sfence，隔離了寫入 v 前後的寫入指令，防止其重排序，且 sfence 之前的修改會被寫入緩存並標記其他 CPU 核心中的緩存失效；\n    2. 在讀取 v 之前插入一個 lfence，隔離了讀取 v 前後的讀取指令，防止其重排序，且 lfence 之後會先刷新緩存，從而讀取最新的值。\n\n    sfence 和 lfence 兩相配合，保證了變量 v 的可見性。\n\n### CAS 鎖\n\nsynchronized 是悲觀鎖，假定操作是有衝突的，要加鎖然後再執行程序，完畢後再釋放鎖。而 CAS(Compare And Swap) 是樂觀鎖，假定操作是沒有衝突的，不需要加鎖，而是把舊的預期值跟內存中已有的值進行比較，如果相同再把要更新的值更新到內存，如果不同則自旋（重試，重新獲取預期值進行比較和替換），Java 中的原子類（比如 AtomicInteger）的底層實現就是 CAS。\n\nCAS 存在一個稱之爲 ABA 的問題，即對於變量 v = A，當其變爲 B 後又復原爲 A 時，無法判斷變量 v 是否被修改過。\n\n![](java-concurrent/Untitled%207.png)\n\n使用 `AtomicStampedReference` 可以防止 ABA 的問題，因爲附帶的 Stamp可以標識 Reference 的版本，Reference 變化，Stamp 隨之遞增。\n\n### Atomic 原子類\n\n`java.util.concurrent.atomic` 包中提供了一系列原子類，包括：\n\n1. 原子類型：\n    - AtomicInteger：針對整型\n    - AtomicLong：針對長整型\n    - AtomicBoolean：針對布爾類型\n2. 數組類型：\n    - AtomicIntegerArray：針對整型數組\n    - AtomicLongArray：針對長整型數組\n    - AtomicReferenceArray：針對引用類型數組\n3. 引用類型：\n    - AtomicReference：針對對象引用\n    - AtomicStampedReference：針對對象引用連同一個整型\n    - AtomicMarkableReference：針對對象引用連同一個布爾類型\n4. 對象的屬性修改類型：\n    - AtomicIntegerFieldUpdater：修改對象的一個整型屬性\n    - AtomicLongFieldUpdater：修改對象的一個長整型屬性\n    - AtomicReferenceFieldUpdater：修改對象的一個整型屬性\n\n其理論基礎就是 **CAS**(Compare and Swap) **鎖 + volatile + native 方法。**CAS 就是將舊的預期值與內存中的值進行比較，當相同時才將新的預期值設入，否則自旋。 \n\n介紹下 AtomicInteger 類的幾個原子方法：\n\n```java\npublic final int get(java-concurrent//獲取當前的值\npublic final int getAndSet(java-concurrent//獲取當前的值，並設置新的值\npublic final int getAndIncrement(java-concurrent//獲取當前的值，並自增\npublic final int getAndDecrement(java-concurrent//獲取當前的值，並自減\npublic final int getAndAdd(java-concurrent//獲取當前的值，並加上預期的值\nboolean compareAndSet(java-concurrent//如果輸入的數值等於預期值，則以原子方式將該值設置為輸入值（update）\npublic final void lazySet(java-concurrent//最終設置為newValue,使用 lazySet 設置之後可能導致其他線程在之後的一小段時間內還是可以讀到舊的值。\n```\n\n### 死鎖 (deadlock)\n\n如果一組線程中的每個線程都在等待一個事件，而這個事件只能由該組中的另一個線程觸發，這種情況會導致死鎖。\n\n死鎖需要滿足四個條件（線程維度上）：\n\n1. 互斥，該資源任意時刻只能由一個線程佔用。\n2. 請求與保持，一個線程因請求資源被阻塞，另一個線程保持該資源不放。\n3. 不剝奪/不可搶佔，一個線程不能強佔另一個線程擁有的資源，除非另一個線程釋放之。\n4. 循環等待，若干個線程形成循環等待資源的關係。\n\n那麼，防止死鎖只需要不滿足以上四個條件之一即可。具體來說：\n\n1. 破壞互斥：不可，這是資源的固有屬性，不可破壞。\n2. 破壞請求與保持：可以一次性請求所有需要的資源。\n3. 破壞不剝奪：\n    - 若有一佔有若干資源的進程請求某資源被拒絕，則它應釋放它佔有的資源。\n    - 若有一進程請求當前被另一個進程佔有的資源，則操作系統可以剝奪另一個進程的資源。\n4. 破壞循環等待：確定資源的申請順序和釋放順序。\n\n下面是一個死鎖的實例，線程A 擁有資源1 後想要獲得資源2，線程B 擁有資源2 後想要獲得資源1。\n\n![](java-concurrent/Untitled%208.png)\n\n```java\nObject res1 = new Object();\nObject res2 = new Object();\n\nnew Thread(() -> {\n  synchronized (res1) {\n      System.out.println(Thread.currentThread() + \" get res1\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res2\");\n      synchronized (res2) {\n          System.out.println(Thread.currentThread() + \" get res2\");\n      }\n  }\n}, \"Thread A\").start();\n\nnew Thread(() -> {\n  synchronized (res2) {\n      System.out.println(Thread.currentThread() + \" get res2\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res1\");\n      synchronized (res1) {\n          System.out.println(Thread.currentThread() + \" get res1\");\n      }\n  }\n}, \"Thread B\").start();\n\n// 按相同順序申請和釋放資源，破壞循環等待條件，從而避免死鎖\nnew Thread(() -> {\n  synchronized (res1) {\n      System.out.println(Thread.currentThread() + \" get res1\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res2\");\n      synchronized (res2) {\n          System.out.println(Thread.currentThread() + \" get res2\");\n      }\n  }\n}, \"Thread B\").start();\n```","slug":"it/java/java-concurrent","published":1,"updated":"2021-09-13T14:16:31.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlfx00411n9k0n8f796r","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>首先區分進程和線程。進程是程序運行的基本單位，也是系統分配資源的最小單位；而線程是 CPU 調度的最小單位，一個進程可以有多個線程，而各個線程擁有獨立的程序計數器、虛擬機棧和本地方法棧，但共享同一個堆和方法區。爲著充分利用系統資源，減少 CPU 空等，多線程技術應運而生。系統使用時間片輪轉法分配 CPU 資源到各個線程，如果線程在分配的時間片內未能處理完任務，則會導致上下文切換。</p>\n<p>Java 中線程類爲 <code>Thread</code> ，其 <code>start</code> 方法會使線程進入 Runnable 狀態；其 <code>sleep</code> 方法會阻塞線程而不釋放鎖，跟 <code>Object.wait</code> 有別；其 <code>interrupt</code> 方法並不停止線程，而是設置一個標誌位通知線程應當關閉，線程可以根據該標誌位決定是否要停止運行。</p>\n<p>多個線程可以通過線程池進行統一管理，好處是還可以提前 Ready 好一些線程避免等待線程創建的時間損耗；還可以使用舊的線程，減少線程的頻繁創建和銷毀的資源損耗。線程池推薦直接使用 <code>ThreadPoolExecutor</code> 的構造方法去創建，以便設置合適的構造參數。調用 <code>ThreadPoolExecutor.execute</code> 可以將一個 <code>Runnable</code> 任務放入線程池處理； 調用<code>ThreadPoolExecutor.submit</code>  可以將一個 <code>Callable</code> 任務放入線程池處理，返回一個 <code>Future</code> 代表處理結果，後續通過調用 <code>Future.get</code> 獲取處理結果，其過程是阻塞的。</p>\n<p>Java 1.5 開始提供<code>AbstractQueuedSynchronizer</code>，用於創建多線程訪問共享資源的同步器，其內部使用一個名爲 CLH 的 FIFO 的雙向隊列進行資源分配。其常見實現類有：<code>ReentrantLock</code>、<code>ReadWriteLock</code> 和 <code>CountDownLatch</code> 。其中 <code>ReadWriteLock</code> 性能優於 <code>ReentrantLock</code> ，因爲兩個讀操作在 <code>ReadWriteLock</code> 中不互斥而在 <code>ReentrantLock</code> 中互斥。</p>\n<p>Java 1.8 開始提供了 <code>CompletableFuture</code> ，其實現了 <code>Future</code> 接口，並提供了基於回調的函數式異步編程方式和對<code>CompletableFuture</code> 的組合，使用者可以不關心底層的線程池，大大簡便了異步編程。</p>\n<p>Java 還提供了 ThreadLocal 類可以使得各個線程擁有變量的副本而不會相互影響，底層是使用 Thread 類的 <code>ThreadLocalMap</code>，一個類似 HashMap 的結構，其 Key 爲 ThreadLocal 對象的弱引用。</p>\n<p>多線程因會有多個線程操作共享的資源而引發了線程安全的擔憂。線程安全要求<strong>原子性、可見性和有序性</strong>。Java 提供了多種方式可以保證線程安全：</p>\n<ol>\n<li>synchronized 同步鎖，這是一個重量級鎖。可以使用當前類的 class 對象，當前類的對象或者任意對象對方法和代碼塊進行加鎖，方法結束或代碼塊結束則鎖自動釋放。當使用非靜態同步方法時，會使用當前對象爲鎖，因此多個非靜態同步方法共享同一鎖。Java 1.6 後引入<strong>偏向鎖</strong>和<strong>輕量級鎖</strong>的概念，使得 synchronized 不那麼「重」了。</li>\n<li>volatile 關鍵字。使用該關鍵字修飾的變量在編譯時不會有寄存器緩存而是直接使用主存、不會進行代碼重排序優化，保證了可見性和有序性；在解釋執行時使用 CPU 內存屏障技術防止指令重排序。</li>\n<li>CAS(Compare and Swap) 技術，相比於 synchronized，其假定操作是不會產生衝突的，將舊的預期值和內存中的值進行比較，若相同則更新內存中的值，否則自旋。因此被稱之爲「樂觀鎖」，而 synchronized 被稱之爲「悲觀鎖」。Java 中的 Atomic 類是典型的 CAS 實現。</li>\n</ol>\n<p>多線程操作共享資源還會出現死鎖。死鎖產生的條件是：<strong>互斥、請求/等待、不可剝奪和循環等待</strong>。解決死鎖問題的關鍵是破壞死鎖產生的條件。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"多線程\"><a href=\"#多線程\" class=\"headerlink\" title=\"多線程\"></a>多線程</h2><h3 id=\"程序、進程與線程\"><a href=\"#程序、進程與線程\" class=\"headerlink\" title=\"程序、進程與線程\"></a><strong>程序、進程與線程</strong></h3><ol>\n<li>程序：程序是含有指令和數據的文件，被靜態存儲於存儲設備之中。</li>\n<li>進程：进程是程序的一次執行過程，是<strong>操作系統運行程序的基本單位</strong>，是動態的。它佔用一定的系統資源（包括 CPU 時間、內存空間、文件、輸入輸出設備等等），<strong>是資源分配的最小單位</strong>。各進程之間相互獨立。</li>\n<li>線程：<strong>線程是 CPU 調度的最小單位</strong>，擁有<strong>程序計數器、虛擬機棧和本地方法棧</strong>，相比進程，它佔用資源更小，產生和切換線程的負擔更小，也被稱爲<strong>輕量級進程</strong>。一個進程可以產生多個線程。同個進程的多個線程之間共享同一塊<strong>堆和方法區</strong>。</li>\n</ol>\n<ul>\n<li><p>堆是幹什麼用的？</p>\n<p>  堆是進程中最大的一塊內存，用於存放新建的對象。</p>\n</li>\n<li><p>方法區是幹什麼的？</p>\n<p>  根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放程序執行代碼的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(java-concurrent/code segment)，通常只讀。具體來說，它存放了每個類的結構，例如運行時常量池，字段和方法數據，以及方法和構造函數的代碼，包括用於類和實例初始化以及接口初始化的特殊方法。</p>\n<p>  另外，UNIX 中的進程將內存劃分成三個部分：text segment,文本區，例如代碼，data segment，數據區，例如變量，stack segment，棧區域。</p>\n</li>\n<li><p>程序計數器爲什麼是線程私有的？</p>\n<p>  程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。</p>\n<p>  因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。</p>\n</li>\n<li><p>虛擬機棧和本地方法棧爲什麼是線程私有的？</p>\n<ul>\n<li><p><strong>虛擬機棧</strong>：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態鏈接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。</p>\n</li>\n<li><p><strong>本地方法棧</strong>：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。</p>\n<p>爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"線程有哪些基本狀態\"><a href=\"#線程有哪些基本狀態\" class=\"headerlink\" title=\"線程有哪些基本狀態\"></a><strong>線程有哪些基本狀態</strong></h3><p>Java 線程共有 6 中狀態，如下：</p>\n<ol>\n<li>New：新創建的線程，尚未執行。</li>\n<li>Runnable：運行中的線程，<code>run</code> 方法正在執行中。可細分爲 Ready 和 Running 兩個狀態。</li>\n<li>Blocked：運行中的線程，因爲某些操作被阻塞而掛起。</li>\n<li>Waiting：運行中的線程，因爲某些操作在等待。</li>\n<li>Timed Waiting：運行中的線程，因爲執行 <code>sleep</code> 等方法正在計時等待。</li>\n<li>Terminated：線程終止，因爲 <code>run</code> 方法執行完畢。</li>\n</ol>\n<p><img src=\"/it/java/java-concurrent/Untitled.png\" alt></p>\n<h3 id=\"並發和並行的區別\"><a href=\"#並發和並行的區別\" class=\"headerlink\" title=\"並發和並行的區別\"></a>並發和並行的區別</h3><p>並發（concurrent）：同一時間段，多個任務都在執行。</p>\n<p>並行（parallel）：單位時間內，多個任務同時執行。</p>\n<h3 id=\"多線程的優勢\"><a href=\"#多線程的優勢\" class=\"headerlink\" title=\"多線程的優勢\"></a>多線程的優勢</h3><ol>\n<li>提高 CPU 和 IO 設備的綜合利用率，確保 CPU 或 IO 設備不空等。</li>\n<li>提高 CPU 核心利用率，確保 CPU 的多個核心都能被利用到。</li>\n<li>提高系統整體的並發能力和性能，應對高並發場景。</li>\n</ol>\n<h3 id=\"上下文切換\"><a href=\"#上下文切換\" class=\"headerlink\" title=\"上下文切換\"></a>上下文切換</h3><p><strong>上下文切換就是舊任務被暫停，保存自身狀態，然後新任務被執行的過程</strong>。造成上下文切換的原因是需要同時執行的任務大於 CPU 核心數，而單個 CPU 同一時刻只能執行一個任務。CPU 採用時間片輪轉法分配 CPU 時間給多個線程，當時間片結束舊任務如果未執行完畢會被暫停，保存當前狀態，然後執行新的任務。</p>\n<p>上下文切換所需的時間很可觀，可能是操作系統中時間消耗最大的操作。操作系統中數 Linux（及其他類 Unix 系統） 上下文切換時間消耗最少。</p>\n<h3 id=\"爲什麼調用-Thread-start-方法而不是-Thread-run-方法？\"><a href=\"#爲什麼調用-Thread-start-方法而不是-Thread-run-方法？\" class=\"headerlink\" title=\"爲什麼調用 Thread.start 方法而不是 Thread.run 方法？\"></a>爲什麼調用 <code>Thread.start</code> 方法而不是 <code>Thread.run</code> 方法？</h3><p>調用 <code>start</code> 方法會啟動一個新線程並進入就緒狀態，當分配到時間片後會自動調用 <code>run</code> 方法。直接調用 <code>run</code> 方法只會在調用者所在的線程執行。</p>\n<h3 id=\"比較-Thread-sleep-方法和-Object-wait-方法\"><a href=\"#比較-Thread-sleep-方法和-Object-wait-方法\" class=\"headerlink\" title=\"比較 Thread.sleep 方法和 Object.wait 方法\"></a>比較 <code>Thread.sleep</code> 方法和 <code>Object.wait</code> 方法</h3><p>共同點：</p>\n<ol>\n<li>都可以暫停線程的執行。</li>\n<li><code>sleep(long)</code>和 <code>wait(long)</code> 都可以在指定時間段後使線程自動甦醒。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li>sleep 是 Thread 類的方法，wait 是 Object 類的方法。</li>\n<li><strong>sleep 沒有釋放鎖，wait 釋放了</strong>。</li>\n<li><code>wait()</code> 被調用後線程不會自動甦醒，需要別的線程調用同一對象上的 <code>notify()</code> 或 <code>notifyAll()</code> 方法來喚醒。</li>\n</ol>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Data.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Data</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String packet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单次传输是否结束</span></span><br><span class=\"line\">    <span class=\"comment\">// True if Receiver should wait</span></span><br><span class=\"line\">    <span class=\"comment\">// False if Sender should wait</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isTransfer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(String packet)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!isTransfer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                wait();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.packet = packet;</span><br><span class=\"line\">        isTransfer = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">receive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (isTransfer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                wait();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        isTransfer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> packet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Sender.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sender</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Data data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sender</span><span class=\"params\">(Data data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String[] packets = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;Are&quot;</span>, <span class=\"string\">&quot;You&quot;</span>, <span class=\"string\">&quot;Ok&quot;</span>, <span class=\"string\">&quot;Over&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String packet : packets) &#123;</span><br><span class=\"line\">            data.send(packet);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Receiver.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Receiver</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Data data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Receiver</span><span class=\"params\">(Data data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String packet = data.receive();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!<span class=\"string\">&quot;Over&quot;</span>.equals(packet)) &#123;</span><br><span class=\"line\">            System.out.println(packet);</span><br><span class=\"line\">            packet = data.receive();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Data data = <span class=\"keyword\">new</span> Data();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Receiver(data)).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Sender(data)).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"調用-Thread-interrupt-意味著什麼？\"><a href=\"#調用-Thread-interrupt-意味著什麼？\" class=\"headerlink\" title=\"調用 Thread.interrupt 意味著什麼？\"></a>調用 <code>Thread.interrupt</code> 意味著什麼？</h3><p>調用 interrupt 方法並不會中斷一個線程，而是發出出一個中斷信號到目標線程（設置中斷標誌位的值爲 true），目標線程收到信號後可以決定是否處理。</p>\n<p>與之相關的方法有：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 測試當前線程是否已經中斷。當線程中斷時調用該方法將會清除線程的中斷狀態</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interrupted</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 測試線程是否已經中斷。不改變線程的中斷狀態。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isInterrupted</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 中斷線程</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"java-concurrent//www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554\">廖雪峰的官方網站</a>提供了以下的代碼：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">      t.start();</span><br><span class=\"line\">      Thread.sleep(java-concurrent<span class=\"comment\">// 暫停1毫秒</span></span><br><span class=\"line\">      t.interrupt(java-concurrent<span class=\"comment\">// 中斷t線程</span></span><br><span class=\"line\">      t.join(java-concurrent<span class=\"comment\">// 等待t線程結束</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (! isInterrupted()) &#123;</span><br><span class=\"line\">          n ++;</span><br><span class=\"line\">          System.out.println(n + <span class=\"string\">&quot; hello!&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是：</p>\n<ol>\n<li>本線程中斷自己是被允許的；其它線程調用本線程的<code>interrupt</code>方法時，會通過<code>checkAccess</code>檢查權限。這有可能拋出<code>SecurityException</code>異常。</li>\n<li>調用線程的<code>wait</code> 方法會讓它進入等待(阻塞)狀態，或者調用線程的<code>join</code>, <code>sleep</code> 方法也會讓它進入阻塞狀態。若線程在阻塞狀態時，調用了它的<code>interrupt</code>方法，那麼它的「中斷狀態」會被清除並且會收到一個<code>InterruptedException</code>異常。例如，線程通過<code>wait()</code>進入阻塞狀態，此時通過<code>interrupt()</code>中斷該線程；調用<code>interrupt()</code>會立即將線程的中斷標記設為「true」，但是由於線程處於阻塞狀態，所以該「中斷標記」會立即被清除為「false」，同時，會產生一個<code>InterruptedException</code>的異常。</li>\n<li>如果線程被阻塞在一個<code>Selector</code>選擇器中，那麼通過<code>interrupt()</code>中斷它時；線程的中斷標記會被設置為true，並且它會立即從選擇操作中返回。</li>\n<li>如果不屬於前面所說的情況，那麼通過<code>interrupt()</code>中斷線程時，它的中斷標記會被設置為「true」。</li>\n<li>中斷一個「已終止的線程」不會產生任何操作。</li>\n</ol>\n<h3 id=\"線程池技術\"><a href=\"#線程池技術\" class=\"headerlink\" title=\"線程池技術\"></a>線程池技術</h3><p><strong>（1）爲什麼要使用線程池？</strong></p>\n<p>線程池管理了一組線程資源，並維護了一些基本的統計信息。</p>\n<p>《Java 並發編程的藝術》中講述到使用線程池的好處：</p>\n<ol>\n<li>降低資源消耗。通過重複使用已創建的線程減少線程創建和銷毀的消耗。</li>\n<li>提高響應速度。線程池預先創建了線程，在需要時可以直接使用不用等。</li>\n<li>提供線程的可管理性。線程是稀缺資源，不能無限制地分配，使用線程池可以進行統一分配、調優和監控。</li>\n</ol>\n<p><strong>（2）Runnable 接口和 Callable 接口的區別</strong></p>\n<ol>\n<li>Runnable 始於 Java 1.0 ，Callable 接口始於 Java 1.5.</li>\n<li>Runnable 不會返回結果或拋出檢查異常，而 Callable 會。</li>\n</ol>\n<p>另外，工具類 <code>Executors</code> 可以實現 Runnable 對象和 Callable 對象之間的相互轉換，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Executors.callable(Runnable task)</span><br><span class=\"line\">Executors.callable(Runnable task，Object resule)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）<code>execute</code> 方法和 <code>submit</code> 方法有什麼區別？</strong></p>\n<ol>\n<li><code>execute</code> 提交任務之後沒有返回值，無法判斷任務是否被執行成功。</li>\n<li><code>submit</code> 提交任務之後有返回值 Future，可以知道任務是否被執行成功。調用 <code>Future.get()</code> 會阻塞線程直到任務完成；調用 <code>Future.get(long timeout，TimeUnit unit)</code>  則是阻塞指定的一段時間後立即返回，不管任務是否執行完成。當然如果提交的是 Runnable，那麼返回的 Future 中的泛型爲 Void。</li>\n</ol>\n<p><strong>（4）如何創建線程池？</strong></p>\n<p>《阿里巴巴 Java 開發手冊》中要求直接用 <code>ThreadPoolExecutor</code> 的構造方法去創建線程池，而非通過 Executors 去創建線程池，因爲：</p>\n<ol>\n<li><code>FixedThreadPool</code> 和 <code>SingleThreadPool</code> 中允許請求的隊列長度爲 <code>Integer.MAX_VALUE</code>，可能會堆積大量請求，導致 OOM；</li>\n<li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> 中允許線程數爲 <code>Integer.MAX_VALUE</code>，可能會創建大量線程，導致 OOM。</li>\n</ol>\n<p><code>ThreadPoolExecutor</code> 的參數分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 核心線程數，規定了最小的可以同時運行的線程數量</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 最大線程數，當請求隊列滿時，可以同時運行的線程數量</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 當線程空閒且大於規定的核心線程數時，等待 keepAliveTime 時間後多餘的線程會被銷毀</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // keepAliveTime 的時間單位</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tTimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 請求隊列，當新任務進來時，當前運行的線程達到核心線程數，則新任務會被放置到請求隊列</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tBlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 線程工廠，用於創建新線程</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 飽和策略，當線程數量達到最大線程數且請求隊列也滿的情況下觸發飽和策略</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tRejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>線程池中的飽和策略有：</p>\n<ol>\n<li><code>ThreadPoolExecutor.AbortPolicy</code>：默認策略，拋出異常，拒絕處理新任務。</li>\n<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：直接在調用 <code>execute</code> 所在的線程執行。</li>\n<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不拋出異常，直接丟棄新任務。</li>\n<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：不拋出異常，丟棄最早未處理的任務。</li>\n</ol>\n<p><strong>（5）線程池對新任務的處理過程</strong></p>\n<p><img src=\"/it/java/java-concurrent/Untitled%201.png\" alt></p>\n<h3 id=\"AQS（抽象隊列式同步器）\"><a href=\"#AQS（抽象隊列式同步器）\" class=\"headerlink\" title=\"AQS（抽象隊列式同步器）\"></a>AQS（抽象隊列式同步器）</h3><p><strong>（1）概述</strong></p>\n<p>AQS，即 <code>AbstractQueuedSynchronizer</code> ，加入於 Java 1.5，作者爲大名鼎鼎的 Doug Lea，其定義了一套多線程訪問共享資源的同步器框架。其下有諸如 <code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>CountDownLatch</code> 等等實現。</p>\n<p>AQS 的實現思路是：如下圖所示，當請求的共享資源空閒時，請求資源的線程會被設置爲有效的工作線程，該資源會被鎖定；當請求的共享資源被佔用時，將請求資源的線程加入 CLH 隊列中。CLH 是三個人名的首字母，CLH 隊列是一個雙向隊列，FIFO。而共享資源的狀態是一個整型值，採用 CAS 方式進行值的原子更新，通常加鎖 state 會加 1，釋放則減 1。</p>\n<p><img src=\"/it/java/java-concurrent/Untitled%202.png\" alt></p>\n<p>AQS 可以定義兩種資源共享方式，獨佔 or 共享。其採用模板方法模式編寫，實現類需要選擇性地實現以下方法（默認實現是拋出<code>UnsupportedOperationException</code>）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//該線程是否正在獨佔資源。只有用到condition才需要去實現它。</span></span><br><span class=\"line\">isHeldExclusively()</span><br><span class=\"line\"><span class=\"comment\">//獨佔方式。嘗試獲取資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryAcquire(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//獨佔方式。嘗試釋放資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryRelease(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//共享方式。嘗試獲取資源。負數表示失敗；0表示成功，但沒有剩餘可用資源；正數表示成功，且有剩餘資源。</span></span><br><span class=\"line\">tryAcquireShared(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//共享方式。嘗試釋放資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryReleaseShared(<span class=\"keyword\">int</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）ReentrantLock</strong></p>\n<p>ReentrantLock，可重入鎖，同一線程可以反覆加鎖，然後釋放同樣次數的鎖。synchronized 修飾的方法用的也是可重入鎖，但 ReentrantLock 提供了更爲靈活的控制，有 lock、unlock 方法還有類似於 <code>Object.wait</code> / <code>Object.notify</code> 的 <code>Condition.await</code> / <code>Condition.signal</code> 方法。</p>\n<ul>\n<li><p>代碼</p>\n<p>  參考：<a href=\"java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/\">https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SharedFifoQueue.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedFifoQueue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] content;</span><br><span class=\"line\">  <span class=\"comment\">// 標識當前隊列中擁有的對象數目</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> current = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> addIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> removeIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition fullCondition = lock.newCondition();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition emptyCondition = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SharedFifoQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">      content = <span class=\"keyword\">new</span> Object[capacity];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Object item)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current &gt;= content.length) &#123;</span><br><span class=\"line\">          fullCondition.await();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      content[addIndex] = item;</span><br><span class=\"line\">      addIndex = (addIndex + <span class=\"number\">1</span>) % content.length;</span><br><span class=\"line\">      current++;</span><br><span class=\"line\">      emptyCondition.signal();</span><br><span class=\"line\">      lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">remove</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          emptyCondition.await();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Object item = content[removeIndex];</span><br><span class=\"line\">      removeIndex = (removeIndex + <span class=\"number\">1</span>) % content.length;</span><br><span class=\"line\">      current--;</span><br><span class=\"line\">      fullCondition.signal();</span><br><span class=\"line\">      lock.unlock();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Producer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SharedFifoQueue queue;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Producer</span><span class=\"params\">(SharedFifoQueue queue)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">              queue.add(<span class=\"string\">&quot;Hello &quot;</span> + i);</span><br><span class=\"line\">              Thread.sleep(random.nextInt(<span class=\"number\">200</span>) );</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          queue.add(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Consumer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SharedFifoQueue queue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Consumer</span><span class=\"params\">(SharedFifoQueue queue)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">              Object item = queue.remove();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              System.out.println(item.toString());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    SharedFifoQueue sharedFifoQueue = <span class=\"keyword\">new</span> SharedFifoQueue(<span class=\"number\">10</span>);</span><br><span class=\"line\">    Thread consumerThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Consumer(sharedFifoQueue));</span><br><span class=\"line\">    Thread producerThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Producer(sharedFifoQueue));</span><br><span class=\"line\"></span><br><span class=\"line\">    producerThread.start();</span><br><span class=\"line\">    consumerThread.start();</span><br><span class=\"line\">    <span class=\"comment\">// join 可以讓主線程等待子線程結束</span></span><br><span class=\"line\">    producerThread.join();</span><br><span class=\"line\">    consumerThread.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（3）ReadWriteLock</strong></p>\n<p>ReadWriteLock 相比 ReentrantLock 性能更高，體現在兩個讀操作在 ReadWriteLock 裏是不互斥的，而在 ReentrantLock 裏是互斥的。</p>\n<ul>\n<li><p>代碼</p>\n<p>  代碼來源：<a href=\"java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/\">https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadSafeArrayList</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReadWriteLock readWriteLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock readLock = readWriteLock.readLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;E&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(E o)</span> </span>&#123;</span><br><span class=\"line\">      writeLock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          list.add(o);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          writeLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">      readLock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> list.get(i);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          readLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（4）CountDownLatch</strong></p>\n<p>CountDownLatch 可以讓一個或多個線程等待指定的操作完成後再開始工作。初始化 CountDownLatch 時需要指定一個 count 值，需要等待的線程使用 <code>CountDownLatch.await()</code> 進行等待，當 <code>CountDownLatch.countDown()</code> 被調用 count 次時，等待的線程才得以繼續執行。</p>\n<ul>\n<li><p>代碼</p>\n<p>  代碼來源：<a href=\"java-concurrent//tutorials.jenkov.com/java-util-concurrent/countdownlatch.html\">http://tutorials.jenkov.com/java-util-concurrent/countdownlatch.html</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\">CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Waiter      waiter      = <span class=\"keyword\">new</span> Waiter(latch);</span><br><span class=\"line\">Decrementer decrementer = <span class=\"keyword\">new</span> Decrementer(latch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(waiter)     .start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(decrementer).start();</span><br><span class=\"line\"></span><br><span class=\"line\">Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\"><span class=\"comment\">// Waiter.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Waiter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  CountDownLatch latch = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Waiter</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          latch.await();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Waiter Released&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Decrementer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decrementer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  CountDownLatch latch = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decrementer</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\"></span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\"></span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（5）Semaphore</strong></p>\n<p>Semaphore 用於限制訪問資源的線程數量，以對資源進行保護。<a href=\"java-concurrent//blog.csdn.net/eson_15/article/details/51577191\">有人將其比做是廁所的坑位數</a>，譬如一個廁所有 3 個坑，則同時上廁所的人只能有 3 個，其他人要上只能等這 3 個人之一釋放坑位。</p>\n<p>使用前通過調用 <code>Semaphore.acquire</code> 獲取訪問，使用後通過  <code>Semaphore.release</code> 釋放許可。</p>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\">    Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore.acquire();</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;Running Thread Id: %s, Available permit: %d, Queue length: %d\\n&quot;</span>, Thread.currentThread().getId(), semaphore.availablePermits(), semaphore.getQueueLength());</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  運行結果：</p>\n<p>  初始化總許可量爲 3，一開始被用掉一個許可，可用許可剩餘 2；隨後許可被用光，其他線程開始排隊，出現長度爲 6 的請求隊列，之後隨之許可釋放，隊列長度遞減，直到所有任務處理完成，隊列長度爲 0，許可復爲 3。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Running Thread Id: <span class=\"number\">13</span>, Available permit: <span class=\"number\">2</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">15</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">14</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">16</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">6</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">17</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">5</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">18</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">4</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">19</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">3</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">20</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">2</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">21</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">1</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">22</span>, Available permit: <span class=\"number\">2</span>, Queue length: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"CompletableFuture\"><a href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"></a>CompletableFuture</h3><p>參考：<a href=\"java-concurrent//colobu.com/2016/02/29/Java-CompletableFuture/\">https://colobu.com/2016/02/29/Java-CompletableFuture/</a>、<a href=\"java-concurrent//www.jianshu.com/p/6bac52527ca4\">https://www.jianshu.com/p/6bac52527ca4</a></p>\n<p>CompletableFuture 是 Java 1.8 提供的類，可以方便函數式異步編程。CompletableFuture 實現了 Future 接口。</p>\n<p>Future 是 Java 1.5 引入的接口，它代表這異步執行的結果。可以通過 <code>isDone</code> 判斷執行是否完畢，通過 <code>get</code> 阻塞獲取結果，通過 <code>cancel</code> 取消執行。</p>\n<p>Future 獲取結果的方式不優雅，要輪詢或一直阻塞等待結果。 CompletableFuture 提供了回調的方式處理結果（正常結果 &amp; 異常結果），還有組合多個 CompletableFuture 的能力。</p>\n<p>有了 CompletableFuture，我們甚至可以不關心線程、線程池和同步，因爲 CompletableFuture 內部已經幫我們處理好了，我們只需要鏈式調用函數就可以了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CompletableFuture.allOf(CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(Thread.currentThread().getId() + <span class=\"string\">&quot; done!&quot;</span>);</span><br><span class=\"line\">&#125;), CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(Thread.currentThread().getId() + <span class=\"string\">&quot; done!&quot;</span>);</span><br><span class=\"line\">&#125;)).handle((BiFunction&lt;Void, Throwable, Void&gt;) (unused, throwable) -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (throwable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Exception:&quot;</span> + throwable.getMessage());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;All done!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;).join();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>ThreadLocal 可以讓每個線程擁有變量的副本進行讀寫而互不影響。ThreadLocal 的原理就是 Thread 類本身的 ThreadLocalMap，當調用 <code>ThreadLocal.set</code> 方法時會去獲取當前線程的 ThreadLocalMap，然後以當前 ThreadLocal 爲 key，將值放入其中；當調用<code>ThreadLocal.get</code>時則從 ThreadLocalMap 中讀取。如此每個 Thread 都有各自的專屬變量，不受其他線程影響。</p>\n<p><img src=\"/it/java/java-concurrent/Untitled%203.png\" alt></p>\n<p>ThreadLocalMap 中的 key 採用弱引用，如果 key 即 ThreadLocal 沒有強引用的話，key 會被 GC 回收變爲 null，而 value 因爲是強引用不會被 GC 回收，於是出現了 key 爲 null 的 Entry，造成內存泄漏。ThreadLocalMap 在調用 <code>get</code>、<code>set</code> 方法時會清理 key 爲 null 的Entry，雖如此還是在使用完 ThreadLocal 後手動調用下 <code>remove</code> 方法爲好。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">  Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">      value = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"線程安全\"><a href=\"#線程安全\" class=\"headerlink\" title=\"線程安全\"></a>線程安全</h2><h3 id=\"線程安全的保證\"><a href=\"#線程安全的保證\" class=\"headerlink\" title=\"線程安全的保證\"></a>線程安全的保證</h3><ol>\n<li>原子性：多項操作要麼都執行，要麼都不執行。synchronized 可以保證代碼片段的原子性。</li>\n<li>可見性：當一個線程對共享變量做了修改，其他線程要立即可以看到修改後的值。volatile 可以保證共享變量的可見性。</li>\n<li>有序性：代碼編寫時的順序同編譯執行時的順序一致。volatile 可以禁止指令重排序。</li>\n</ol>\n<h3 id=\"synchronized-同步鎖的用法\"><a href=\"#synchronized-同步鎖的用法\" class=\"headerlink\" title=\"synchronized 同步鎖的用法\"></a><strong>synchronized 同步鎖的用法</strong></h3><p>synchronized 使用時需要指定一個鎖，當程序進入 synchronized 代碼塊或方法時該鎖會被鎖住，直到離開 synchronized 代碼塊或方法，鎖才會被釋放。注意：同步的範圍越小越好。</p>\n<p><strong>同步代碼塊</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同步代碼塊的鎖可以選擇使用當前對象（this）、當前類 class 對象或其他任意對象。</p>\n<p><strong>同步方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此時鎖爲同步方法所在類的對象。<strong>同一個對象的多個同步方法共享同一個鎖</strong>，多個實例對象時各個對象有各自的鎖。子類重寫父類的同步方法時可以去除同步。</p>\n<p><strong>同步靜態方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此時鎖為同步靜態方法所在類的 class 對象，即使多個實例對象也共享同一個鎖。</p>\n<h3 id=\"使用-String-作爲鎖的注意點\"><a href=\"#使用-String-作爲鎖的注意點\" class=\"headerlink\" title=\"使用 String 作爲鎖的注意點\"></a>使用 String 作爲鎖的注意點</h3><ol>\n<li>首先 String 是一個特殊的類，JVM 使用常量池技術對其進行了緩存，通過字面量使用時會總是返回同一個 String 對象。</li>\n<li>使用 <code>new String</code>、<code>StringBuilder.toString</code> 和 <code>StringBuffer.toString</code> 每次會返回一個新的 String 對象。</li>\n<li>使用 <code>String.intern</code>，當常量池中有值等同的 String 對象時返回該對象，如無則將其加入常量池。</li>\n</ol>\n<h3 id=\"Java-同步鎖的本質\"><a href=\"#Java-同步鎖的本質\" class=\"headerlink\" title=\"Java 同步鎖的本質\"></a><strong>Java 同步鎖的本質</strong></h3><p><strong>Java 的鎖是存在於對象頭</strong>中的，具體就 Hotspot 虛擬機來說，是存在於對象頭中的 Mark Word（標記字段）中的鎖標誌位。Java 對象可有四種鎖狀態：</p>\n<ol>\n<li>一開始對象無鎖，當一段同步代碼一直被一個線程訪問時，該線程自動獲得鎖，此時該鎖爲<strong>偏向鎖</strong>；</li>\n<li>當鎖是偏向鎖時，另一個線程訪問同步代碼，偏向鎖會升級爲<strong>輕量級鎖</strong>，其他線程會通過<strong>自旋</strong>（指嘗試獲取鎖的線程不會立即阻塞，而是採用循環的方式獲取鎖）嘗試獲取鎖；</li>\n<li>當鎖是輕量級鎖時，另一個線程自旋到一定次數仍然未獲得鎖，輕量級鎖會自動升級爲<strong>重量級鎖</strong>，其他線程進入阻塞狀態。</li>\n</ol>\n<p><img src=\"/it/java/java-concurrent/_2020-11-16_8.54.01.png\" alt></p>\n<p>當處於重量級鎖時，對象頭存儲的指針指向的重量級鎖也叫 <strong>monitor 鎖</strong>（監視器鎖）。多個線程爭搶的就是這個 monitor 對象，誰持有誰就可以運行同步代碼。通過使用 <code>javap -c -s -v -l xx.class</code> 反彙編字節碼知道：當使用 <code>synchronized</code> 同步代碼塊時其實現時 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中的 <code>monitorenter</code> 指令指向同步代碼塊開始的位置，<code>monitorexit</code> 則指向結束的位置；當使用 <code>synchronized</code> 修飾方法時，則是使用 <code>ACC_SYNCHRONIZED</code> 標識該方法爲同步方法。</p>\n<p>獲取鎖的過程如下圖所示：需要訪問同步代碼的多個線程首先進入 Entry Set，當線程獲取到 monitor 對象時會進入 The Owner 區域，然後將 monitor 對象中的 owner 變量設置爲當前線程，計數器 count 加 1；若線程調用 wait 方法，將釋放持有的 monitor，owner 變量設置爲 null，計數器 count 減 1，同時該線程進入 Wait Set 等待被喚醒；若線程執行完畢也將釋放 monitor 並恢復 monitor 中相關變量的值。</p>\n<p><img src=\"/it/java/java-concurrent/Untitled%204.png\" alt></p>\n<h3 id=\"volatile-關鍵字\"><a href=\"#volatile-關鍵字\" class=\"headerlink\" title=\"volatile 關鍵字\"></a>volatile 關鍵字</h3><p>參考：<a href=\"java-concurrent//monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/\">https://monkeysayhi.github.io/2017/12/28/一文解决内存屏障/</a></p>\n<p>volatile 關鍵字可以修飾變量，其作用是：</p>\n<p>標記該變量以在編譯時，取消編譯層面的緩存和重排序（編譯時的亂序優化）；在解釋執行時使用 CPU 內存屏障技術解決硬件層面的可見性和重排序。具體來說：</p>\n<ol>\n<li><p><strong>被修飾的變量在寄存器中將不會有副本，而是直接從主存進行讀寫操作</strong>，多線程環境下，變量的值的改變<strong>即時可見</strong>。所謂的主存和寄存器是計算機的解決訪問 CPU 處理速度和內存讀寫速度不匹配的手段。一般認爲寄存器的讀寫速度快於主存。</p>\n<p> <img src=\"/it/java/java-concurrent/Untitled%205.png\" alt></p>\n<p> 未聲明 volatile 時</p>\n<p> <img src=\"/it/java/java-concurrent/Untitled%206.png\" alt></p>\n<p> 聲明 volatile 時</p>\n</li>\n<li><p>編譯器不對該變量進行亂序優化。</p>\n</li>\n<li><p>JVM 在解釋執行時使用對應 CPU 架構的內存屏障指令防止指令重排序，通常有以下三種：</p>\n<ul>\n<li><p>mfence(StoreLoad Barriers、Full Barrier) 全能屏障</p>\n</li>\n<li><p>sfence(Store Barriers) 寫屏障</p>\n</li>\n<li><p>lfence(Load Barrirers) 讀屏障</p>\n<p>以 x86 架構爲例子，如有一以 volatile 修飾的變量 v，JVM 對其操作如下：</p>\n</li>\n</ul>\n<ol>\n<li><p>在寫入 v 之後插入一個 sfence，隔離了寫入 v 前後的寫入指令，防止其重排序，且 sfence 之前的修改會被寫入緩存並標記其他 CPU 核心中的緩存失效；</p>\n</li>\n<li><p>在讀取 v 之前插入一個 lfence，隔離了讀取 v 前後的讀取指令，防止其重排序，且 lfence 之後會先刷新緩存，從而讀取最新的值。</p>\n<p>sfence 和 lfence 兩相配合，保證了變量 v 的可見性。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"CAS-鎖\"><a href=\"#CAS-鎖\" class=\"headerlink\" title=\"CAS 鎖\"></a>CAS 鎖</h3><p>synchronized 是悲觀鎖，假定操作是有衝突的，要加鎖然後再執行程序，完畢後再釋放鎖。而 CAS(Compare And Swap) 是樂觀鎖，假定操作是沒有衝突的，不需要加鎖，而是把舊的預期值跟內存中已有的值進行比較，如果相同再把要更新的值更新到內存，如果不同則自旋（重試，重新獲取預期值進行比較和替換），Java 中的原子類（比如 AtomicInteger）的底層實現就是 CAS。</p>\n<p>CAS 存在一個稱之爲 ABA 的問題，即對於變量 v = A，當其變爲 B 後又復原爲 A 時，無法判斷變量 v 是否被修改過。</p>\n<p><img src=\"/it/java/java-concurrent/Untitled%207.png\" alt></p>\n<p>使用 <code>AtomicStampedReference</code> 可以防止 ABA 的問題，因爲附帶的 Stamp可以標識 Reference 的版本，Reference 變化，Stamp 隨之遞增。</p>\n<h3 id=\"Atomic-原子類\"><a href=\"#Atomic-原子類\" class=\"headerlink\" title=\"Atomic 原子類\"></a>Atomic 原子類</h3><p><code>java.util.concurrent.atomic</code> 包中提供了一系列原子類，包括：</p>\n<ol>\n<li>原子類型：<ul>\n<li>AtomicInteger：針對整型</li>\n<li>AtomicLong：針對長整型</li>\n<li>AtomicBoolean：針對布爾類型</li>\n</ul>\n</li>\n<li>數組類型：<ul>\n<li>AtomicIntegerArray：針對整型數組</li>\n<li>AtomicLongArray：針對長整型數組</li>\n<li>AtomicReferenceArray：針對引用類型數組</li>\n</ul>\n</li>\n<li>引用類型：<ul>\n<li>AtomicReference：針對對象引用</li>\n<li>AtomicStampedReference：針對對象引用連同一個整型</li>\n<li>AtomicMarkableReference：針對對象引用連同一個布爾類型</li>\n</ul>\n</li>\n<li>對象的屬性修改類型：<ul>\n<li>AtomicIntegerFieldUpdater：修改對象的一個整型屬性</li>\n<li>AtomicLongFieldUpdater：修改對象的一個長整型屬性</li>\n<li>AtomicReferenceFieldUpdater：修改對象的一個整型屬性</li>\n</ul>\n</li>\n</ol>\n<p>其理論基礎就是 <strong>CAS</strong>(Compare and Swap) <strong>鎖 + volatile + native 方法。</strong>CAS 就是將舊的預期值與內存中的值進行比較，當相同時才將新的預期值設入，否則自旋。 </p>\n<p>介紹下 AtomicInteger 類的幾個原子方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(java-concurrent//獲取當前的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndSet(java-concurrent//獲取當前的值，並設置新的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndIncrement(java-concurrent//獲取當前的值，並自增</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndDecrement(java-concurrent//獲取當前的值，並自減</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndAdd(java-concurrent//獲取當前的值，並加上預期的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">boolean</span> compareAndSet(java-concurrent//如果輸入的數值等於預期值，則以原子方式將該值設置為輸入值（update）</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> lazySet(java-concurrent//最終設置為newValue,使用 lazySet 設置之後可能導致其他線程在之後的一小段時間內還是可以讀到舊的值。</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"死鎖-deadlock\"><a href=\"#死鎖-deadlock\" class=\"headerlink\" title=\"死鎖 (deadlock)\"></a>死鎖 (deadlock)</h3><p>如果一組線程中的每個線程都在等待一個事件，而這個事件只能由該組中的另一個線程觸發，這種情況會導致死鎖。</p>\n<p>死鎖需要滿足四個條件（線程維度上）：</p>\n<ol>\n<li>互斥，該資源任意時刻只能由一個線程佔用。</li>\n<li>請求與保持，一個線程因請求資源被阻塞，另一個線程保持該資源不放。</li>\n<li>不剝奪/不可搶佔，一個線程不能強佔另一個線程擁有的資源，除非另一個線程釋放之。</li>\n<li>循環等待，若干個線程形成循環等待資源的關係。</li>\n</ol>\n<p>那麼，防止死鎖只需要不滿足以上四個條件之一即可。具體來說：</p>\n<ol>\n<li>破壞互斥：不可，這是資源的固有屬性，不可破壞。</li>\n<li>破壞請求與保持：可以一次性請求所有需要的資源。</li>\n<li>破壞不剝奪：<ul>\n<li>若有一佔有若干資源的進程請求某資源被拒絕，則它應釋放它佔有的資源。</li>\n<li>若有一進程請求當前被另一個進程佔有的資源，則操作系統可以剝奪另一個進程的資源。</li>\n</ul>\n</li>\n<li>破壞循環等待：確定資源的申請順序和釋放順序。</li>\n</ol>\n<p>下面是一個死鎖的實例，線程A 擁有資源1 後想要獲得資源2，線程B 擁有資源2 後想要獲得資源1。</p>\n<p><img src=\"/it/java/java-concurrent/Untitled%208.png\" alt></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object res1 = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">Object res2 = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread B&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按相同順序申請和釋放資源，破壞循環等待條件，從而避免死鎖</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread B&quot;</span>).start();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>首先區分進程和線程。進程是程序運行的基本單位，也是系統分配資源的最小單位；而線程是 CPU 調度的最小單位，一個進程可以有多個線程，而各個線程擁有獨立的程序計數器、虛擬機棧和本地方法棧，但共享同一個堆和方法區。爲著充分利用系統資源，減少 CPU 空等，多線程技術應運而生。系統使用時間片輪轉法分配 CPU 資源到各個線程，如果線程在分配的時間片內未能處理完任務，則會導致上下文切換。</p>\n<p>Java 中線程類爲 <code>Thread</code> ，其 <code>start</code> 方法會使線程進入 Runnable 狀態；其 <code>sleep</code> 方法會阻塞線程而不釋放鎖，跟 <code>Object.wait</code> 有別；其 <code>interrupt</code> 方法並不停止線程，而是設置一個標誌位通知線程應當關閉，線程可以根據該標誌位決定是否要停止運行。</p>\n<p>多個線程可以通過線程池進行統一管理，好處是還可以提前 Ready 好一些線程避免等待線程創建的時間損耗；還可以使用舊的線程，減少線程的頻繁創建和銷毀的資源損耗。線程池推薦直接使用 <code>ThreadPoolExecutor</code> 的構造方法去創建，以便設置合適的構造參數。調用 <code>ThreadPoolExecutor.execute</code> 可以將一個 <code>Runnable</code> 任務放入線程池處理； 調用<code>ThreadPoolExecutor.submit</code>  可以將一個 <code>Callable</code> 任務放入線程池處理，返回一個 <code>Future</code> 代表處理結果，後續通過調用 <code>Future.get</code> 獲取處理結果，其過程是阻塞的。</p>\n<p>Java 1.5 開始提供<code>AbstractQueuedSynchronizer</code>，用於創建多線程訪問共享資源的同步器，其內部使用一個名爲 CLH 的 FIFO 的雙向隊列進行資源分配。其常見實現類有：<code>ReentrantLock</code>、<code>ReadWriteLock</code> 和 <code>CountDownLatch</code> 。其中 <code>ReadWriteLock</code> 性能優於 <code>ReentrantLock</code> ，因爲兩個讀操作在 <code>ReadWriteLock</code> 中不互斥而在 <code>ReentrantLock</code> 中互斥。</p>\n<p>Java 1.8 開始提供了 <code>CompletableFuture</code> ，其實現了 <code>Future</code> 接口，並提供了基於回調的函數式異步編程方式和對<code>CompletableFuture</code> 的組合，使用者可以不關心底層的線程池，大大簡便了異步編程。</p>\n<p>Java 還提供了 ThreadLocal 類可以使得各個線程擁有變量的副本而不會相互影響，底層是使用 Thread 類的 <code>ThreadLocalMap</code>，一個類似 HashMap 的結構，其 Key 爲 ThreadLocal 對象的弱引用。</p>\n<p>多線程因會有多個線程操作共享的資源而引發了線程安全的擔憂。線程安全要求<strong>原子性、可見性和有序性</strong>。Java 提供了多種方式可以保證線程安全：</p>\n<ol>\n<li>synchronized 同步鎖，這是一個重量級鎖。可以使用當前類的 class 對象，當前類的對象或者任意對象對方法和代碼塊進行加鎖，方法結束或代碼塊結束則鎖自動釋放。當使用非靜態同步方法時，會使用當前對象爲鎖，因此多個非靜態同步方法共享同一鎖。Java 1.6 後引入<strong>偏向鎖</strong>和<strong>輕量級鎖</strong>的概念，使得 synchronized 不那麼「重」了。</li>\n<li>volatile 關鍵字。使用該關鍵字修飾的變量在編譯時不會有寄存器緩存而是直接使用主存、不會進行代碼重排序優化，保證了可見性和有序性；在解釋執行時使用 CPU 內存屏障技術防止指令重排序。</li>\n<li>CAS(Compare and Swap) 技術，相比於 synchronized，其假定操作是不會產生衝突的，將舊的預期值和內存中的值進行比較，若相同則更新內存中的值，否則自旋。因此被稱之爲「樂觀鎖」，而 synchronized 被稱之爲「悲觀鎖」。Java 中的 Atomic 類是典型的 CAS 實現。</li>\n</ol>\n<p>多線程操作共享資源還會出現死鎖。死鎖產生的條件是：<strong>互斥、請求/等待、不可剝奪和循環等待</strong>。解決死鎖問題的關鍵是破壞死鎖產生的條件。</p>","more":"<h2 id=\"多線程\"><a href=\"#多線程\" class=\"headerlink\" title=\"多線程\"></a>多線程</h2><h3 id=\"程序、進程與線程\"><a href=\"#程序、進程與線程\" class=\"headerlink\" title=\"程序、進程與線程\"></a><strong>程序、進程與線程</strong></h3><ol>\n<li>程序：程序是含有指令和數據的文件，被靜態存儲於存儲設備之中。</li>\n<li>進程：进程是程序的一次執行過程，是<strong>操作系統運行程序的基本單位</strong>，是動態的。它佔用一定的系統資源（包括 CPU 時間、內存空間、文件、輸入輸出設備等等），<strong>是資源分配的最小單位</strong>。各進程之間相互獨立。</li>\n<li>線程：<strong>線程是 CPU 調度的最小單位</strong>，擁有<strong>程序計數器、虛擬機棧和本地方法棧</strong>，相比進程，它佔用資源更小，產生和切換線程的負擔更小，也被稱爲<strong>輕量級進程</strong>。一個進程可以產生多個線程。同個進程的多個線程之間共享同一塊<strong>堆和方法區</strong>。</li>\n</ol>\n<ul>\n<li><p>堆是幹什麼用的？</p>\n<p>  堆是進程中最大的一塊內存，用於存放新建的對象。</p>\n</li>\n<li><p>方法區是幹什麼的？</p>\n<p>  根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放程序執行代碼的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(java-concurrent/code segment)，通常只讀。具體來說，它存放了每個類的結構，例如運行時常量池，字段和方法數據，以及方法和構造函數的代碼，包括用於類和實例初始化以及接口初始化的特殊方法。</p>\n<p>  另外，UNIX 中的進程將內存劃分成三個部分：text segment,文本區，例如代碼，data segment，數據區，例如變量，stack segment，棧區域。</p>\n</li>\n<li><p>程序計數器爲什麼是線程私有的？</p>\n<p>  程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。</p>\n<p>  因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。</p>\n</li>\n<li><p>虛擬機棧和本地方法棧爲什麼是線程私有的？</p>\n<ul>\n<li><p><strong>虛擬機棧</strong>：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態鏈接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。</p>\n</li>\n<li><p><strong>本地方法棧</strong>：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。</p>\n<p>爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"線程有哪些基本狀態\"><a href=\"#線程有哪些基本狀態\" class=\"headerlink\" title=\"線程有哪些基本狀態\"></a><strong>線程有哪些基本狀態</strong></h3><p>Java 線程共有 6 中狀態，如下：</p>\n<ol>\n<li>New：新創建的線程，尚未執行。</li>\n<li>Runnable：運行中的線程，<code>run</code> 方法正在執行中。可細分爲 Ready 和 Running 兩個狀態。</li>\n<li>Blocked：運行中的線程，因爲某些操作被阻塞而掛起。</li>\n<li>Waiting：運行中的線程，因爲某些操作在等待。</li>\n<li>Timed Waiting：運行中的線程，因爲執行 <code>sleep</code> 等方法正在計時等待。</li>\n<li>Terminated：線程終止，因爲 <code>run</code> 方法執行完畢。</li>\n</ol>\n<p><img src=\"/it/java/java-concurrent/Untitled.png\" alt></p>\n<h3 id=\"並發和並行的區別\"><a href=\"#並發和並行的區別\" class=\"headerlink\" title=\"並發和並行的區別\"></a>並發和並行的區別</h3><p>並發（concurrent）：同一時間段，多個任務都在執行。</p>\n<p>並行（parallel）：單位時間內，多個任務同時執行。</p>\n<h3 id=\"多線程的優勢\"><a href=\"#多線程的優勢\" class=\"headerlink\" title=\"多線程的優勢\"></a>多線程的優勢</h3><ol>\n<li>提高 CPU 和 IO 設備的綜合利用率，確保 CPU 或 IO 設備不空等。</li>\n<li>提高 CPU 核心利用率，確保 CPU 的多個核心都能被利用到。</li>\n<li>提高系統整體的並發能力和性能，應對高並發場景。</li>\n</ol>\n<h3 id=\"上下文切換\"><a href=\"#上下文切換\" class=\"headerlink\" title=\"上下文切換\"></a>上下文切換</h3><p><strong>上下文切換就是舊任務被暫停，保存自身狀態，然後新任務被執行的過程</strong>。造成上下文切換的原因是需要同時執行的任務大於 CPU 核心數，而單個 CPU 同一時刻只能執行一個任務。CPU 採用時間片輪轉法分配 CPU 時間給多個線程，當時間片結束舊任務如果未執行完畢會被暫停，保存當前狀態，然後執行新的任務。</p>\n<p>上下文切換所需的時間很可觀，可能是操作系統中時間消耗最大的操作。操作系統中數 Linux（及其他類 Unix 系統） 上下文切換時間消耗最少。</p>\n<h3 id=\"爲什麼調用-Thread-start-方法而不是-Thread-run-方法？\"><a href=\"#爲什麼調用-Thread-start-方法而不是-Thread-run-方法？\" class=\"headerlink\" title=\"爲什麼調用 Thread.start 方法而不是 Thread.run 方法？\"></a>爲什麼調用 <code>Thread.start</code> 方法而不是 <code>Thread.run</code> 方法？</h3><p>調用 <code>start</code> 方法會啟動一個新線程並進入就緒狀態，當分配到時間片後會自動調用 <code>run</code> 方法。直接調用 <code>run</code> 方法只會在調用者所在的線程執行。</p>\n<h3 id=\"比較-Thread-sleep-方法和-Object-wait-方法\"><a href=\"#比較-Thread-sleep-方法和-Object-wait-方法\" class=\"headerlink\" title=\"比較 Thread.sleep 方法和 Object.wait 方法\"></a>比較 <code>Thread.sleep</code> 方法和 <code>Object.wait</code> 方法</h3><p>共同點：</p>\n<ol>\n<li>都可以暫停線程的執行。</li>\n<li><code>sleep(long)</code>和 <code>wait(long)</code> 都可以在指定時間段後使線程自動甦醒。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li>sleep 是 Thread 類的方法，wait 是 Object 類的方法。</li>\n<li><strong>sleep 沒有釋放鎖，wait 釋放了</strong>。</li>\n<li><code>wait()</code> 被調用後線程不會自動甦醒，需要別的線程調用同一對象上的 <code>notify()</code> 或 <code>notifyAll()</code> 方法來喚醒。</li>\n</ol>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Data.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Data</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String packet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单次传输是否结束</span></span><br><span class=\"line\">    <span class=\"comment\">// True if Receiver should wait</span></span><br><span class=\"line\">    <span class=\"comment\">// False if Sender should wait</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isTransfer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(String packet)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!isTransfer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                wait();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.packet = packet;</span><br><span class=\"line\">        isTransfer = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">receive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (isTransfer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                wait();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        isTransfer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> packet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Sender.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sender</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Data data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sender</span><span class=\"params\">(Data data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String[] packets = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;Are&quot;</span>, <span class=\"string\">&quot;You&quot;</span>, <span class=\"string\">&quot;Ok&quot;</span>, <span class=\"string\">&quot;Over&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String packet : packets) &#123;</span><br><span class=\"line\">            data.send(packet);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Receiver.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Receiver</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Data data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Receiver</span><span class=\"params\">(Data data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String packet = data.receive();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!<span class=\"string\">&quot;Over&quot;</span>.equals(packet)) &#123;</span><br><span class=\"line\">            System.out.println(packet);</span><br><span class=\"line\">            packet = data.receive();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Data data = <span class=\"keyword\">new</span> Data();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Receiver(data)).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Sender(data)).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"調用-Thread-interrupt-意味著什麼？\"><a href=\"#調用-Thread-interrupt-意味著什麼？\" class=\"headerlink\" title=\"調用 Thread.interrupt 意味著什麼？\"></a>調用 <code>Thread.interrupt</code> 意味著什麼？</h3><p>調用 interrupt 方法並不會中斷一個線程，而是發出出一個中斷信號到目標線程（設置中斷標誌位的值爲 true），目標線程收到信號後可以決定是否處理。</p>\n<p>與之相關的方法有：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 測試當前線程是否已經中斷。當線程中斷時調用該方法將會清除線程的中斷狀態</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interrupted</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 測試線程是否已經中斷。不改變線程的中斷狀態。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isInterrupted</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 中斷線程</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"java-concurrent//www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554\">廖雪峰的官方網站</a>提供了以下的代碼：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">      t.start();</span><br><span class=\"line\">      Thread.sleep(java-concurrent<span class=\"comment\">// 暫停1毫秒</span></span><br><span class=\"line\">      t.interrupt(java-concurrent<span class=\"comment\">// 中斷t線程</span></span><br><span class=\"line\">      t.join(java-concurrent<span class=\"comment\">// 等待t線程結束</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (! isInterrupted()) &#123;</span><br><span class=\"line\">          n ++;</span><br><span class=\"line\">          System.out.println(n + <span class=\"string\">&quot; hello!&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是：</p>\n<ol>\n<li>本線程中斷自己是被允許的；其它線程調用本線程的<code>interrupt</code>方法時，會通過<code>checkAccess</code>檢查權限。這有可能拋出<code>SecurityException</code>異常。</li>\n<li>調用線程的<code>wait</code> 方法會讓它進入等待(阻塞)狀態，或者調用線程的<code>join</code>, <code>sleep</code> 方法也會讓它進入阻塞狀態。若線程在阻塞狀態時，調用了它的<code>interrupt</code>方法，那麼它的「中斷狀態」會被清除並且會收到一個<code>InterruptedException</code>異常。例如，線程通過<code>wait()</code>進入阻塞狀態，此時通過<code>interrupt()</code>中斷該線程；調用<code>interrupt()</code>會立即將線程的中斷標記設為「true」，但是由於線程處於阻塞狀態，所以該「中斷標記」會立即被清除為「false」，同時，會產生一個<code>InterruptedException</code>的異常。</li>\n<li>如果線程被阻塞在一個<code>Selector</code>選擇器中，那麼通過<code>interrupt()</code>中斷它時；線程的中斷標記會被設置為true，並且它會立即從選擇操作中返回。</li>\n<li>如果不屬於前面所說的情況，那麼通過<code>interrupt()</code>中斷線程時，它的中斷標記會被設置為「true」。</li>\n<li>中斷一個「已終止的線程」不會產生任何操作。</li>\n</ol>\n<h3 id=\"線程池技術\"><a href=\"#線程池技術\" class=\"headerlink\" title=\"線程池技術\"></a>線程池技術</h3><p><strong>（1）爲什麼要使用線程池？</strong></p>\n<p>線程池管理了一組線程資源，並維護了一些基本的統計信息。</p>\n<p>《Java 並發編程的藝術》中講述到使用線程池的好處：</p>\n<ol>\n<li>降低資源消耗。通過重複使用已創建的線程減少線程創建和銷毀的消耗。</li>\n<li>提高響應速度。線程池預先創建了線程，在需要時可以直接使用不用等。</li>\n<li>提供線程的可管理性。線程是稀缺資源，不能無限制地分配，使用線程池可以進行統一分配、調優和監控。</li>\n</ol>\n<p><strong>（2）Runnable 接口和 Callable 接口的區別</strong></p>\n<ol>\n<li>Runnable 始於 Java 1.0 ，Callable 接口始於 Java 1.5.</li>\n<li>Runnable 不會返回結果或拋出檢查異常，而 Callable 會。</li>\n</ol>\n<p>另外，工具類 <code>Executors</code> 可以實現 Runnable 對象和 Callable 對象之間的相互轉換，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Executors.callable(Runnable task)</span><br><span class=\"line\">Executors.callable(Runnable task，Object resule)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）<code>execute</code> 方法和 <code>submit</code> 方法有什麼區別？</strong></p>\n<ol>\n<li><code>execute</code> 提交任務之後沒有返回值，無法判斷任務是否被執行成功。</li>\n<li><code>submit</code> 提交任務之後有返回值 Future，可以知道任務是否被執行成功。調用 <code>Future.get()</code> 會阻塞線程直到任務完成；調用 <code>Future.get(long timeout，TimeUnit unit)</code>  則是阻塞指定的一段時間後立即返回，不管任務是否執行完成。當然如果提交的是 Runnable，那麼返回的 Future 中的泛型爲 Void。</li>\n</ol>\n<p><strong>（4）如何創建線程池？</strong></p>\n<p>《阿里巴巴 Java 開發手冊》中要求直接用 <code>ThreadPoolExecutor</code> 的構造方法去創建線程池，而非通過 Executors 去創建線程池，因爲：</p>\n<ol>\n<li><code>FixedThreadPool</code> 和 <code>SingleThreadPool</code> 中允許請求的隊列長度爲 <code>Integer.MAX_VALUE</code>，可能會堆積大量請求，導致 OOM；</li>\n<li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> 中允許線程數爲 <code>Integer.MAX_VALUE</code>，可能會創建大量線程，導致 OOM。</li>\n</ol>\n<p><code>ThreadPoolExecutor</code> 的參數分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 核心線程數，規定了最小的可以同時運行的線程數量</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 最大線程數，當請求隊列滿時，可以同時運行的線程數量</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 當線程空閒且大於規定的核心線程數時，等待 keepAliveTime 時間後多餘的線程會被銷毀</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // keepAliveTime 的時間單位</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tTimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 請求隊列，當新任務進來時，當前運行的線程達到核心線程數，則新任務會被放置到請求隊列</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tBlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 線程工廠，用於創建新線程</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 飽和策略，當線程數量達到最大線程數且請求隊列也滿的情況下觸發飽和策略</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tRejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>線程池中的飽和策略有：</p>\n<ol>\n<li><code>ThreadPoolExecutor.AbortPolicy</code>：默認策略，拋出異常，拒絕處理新任務。</li>\n<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：直接在調用 <code>execute</code> 所在的線程執行。</li>\n<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不拋出異常，直接丟棄新任務。</li>\n<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：不拋出異常，丟棄最早未處理的任務。</li>\n</ol>\n<p><strong>（5）線程池對新任務的處理過程</strong></p>\n<p><img src=\"/it/java/java-concurrent/Untitled%201.png\" alt></p>\n<h3 id=\"AQS（抽象隊列式同步器）\"><a href=\"#AQS（抽象隊列式同步器）\" class=\"headerlink\" title=\"AQS（抽象隊列式同步器）\"></a>AQS（抽象隊列式同步器）</h3><p><strong>（1）概述</strong></p>\n<p>AQS，即 <code>AbstractQueuedSynchronizer</code> ，加入於 Java 1.5，作者爲大名鼎鼎的 Doug Lea，其定義了一套多線程訪問共享資源的同步器框架。其下有諸如 <code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>CountDownLatch</code> 等等實現。</p>\n<p>AQS 的實現思路是：如下圖所示，當請求的共享資源空閒時，請求資源的線程會被設置爲有效的工作線程，該資源會被鎖定；當請求的共享資源被佔用時，將請求資源的線程加入 CLH 隊列中。CLH 是三個人名的首字母，CLH 隊列是一個雙向隊列，FIFO。而共享資源的狀態是一個整型值，採用 CAS 方式進行值的原子更新，通常加鎖 state 會加 1，釋放則減 1。</p>\n<p><img src=\"/it/java/java-concurrent/Untitled%202.png\" alt></p>\n<p>AQS 可以定義兩種資源共享方式，獨佔 or 共享。其採用模板方法模式編寫，實現類需要選擇性地實現以下方法（默認實現是拋出<code>UnsupportedOperationException</code>）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//該線程是否正在獨佔資源。只有用到condition才需要去實現它。</span></span><br><span class=\"line\">isHeldExclusively()</span><br><span class=\"line\"><span class=\"comment\">//獨佔方式。嘗試獲取資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryAcquire(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//獨佔方式。嘗試釋放資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryRelease(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//共享方式。嘗試獲取資源。負數表示失敗；0表示成功，但沒有剩餘可用資源；正數表示成功，且有剩餘資源。</span></span><br><span class=\"line\">tryAcquireShared(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//共享方式。嘗試釋放資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryReleaseShared(<span class=\"keyword\">int</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）ReentrantLock</strong></p>\n<p>ReentrantLock，可重入鎖，同一線程可以反覆加鎖，然後釋放同樣次數的鎖。synchronized 修飾的方法用的也是可重入鎖，但 ReentrantLock 提供了更爲靈活的控制，有 lock、unlock 方法還有類似於 <code>Object.wait</code> / <code>Object.notify</code> 的 <code>Condition.await</code> / <code>Condition.signal</code> 方法。</p>\n<ul>\n<li><p>代碼</p>\n<p>  參考：<a href=\"java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/\">https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SharedFifoQueue.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedFifoQueue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] content;</span><br><span class=\"line\">  <span class=\"comment\">// 標識當前隊列中擁有的對象數目</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> current = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> addIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> removeIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition fullCondition = lock.newCondition();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition emptyCondition = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SharedFifoQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">      content = <span class=\"keyword\">new</span> Object[capacity];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Object item)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current &gt;= content.length) &#123;</span><br><span class=\"line\">          fullCondition.await();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      content[addIndex] = item;</span><br><span class=\"line\">      addIndex = (addIndex + <span class=\"number\">1</span>) % content.length;</span><br><span class=\"line\">      current++;</span><br><span class=\"line\">      emptyCondition.signal();</span><br><span class=\"line\">      lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">remove</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          emptyCondition.await();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Object item = content[removeIndex];</span><br><span class=\"line\">      removeIndex = (removeIndex + <span class=\"number\">1</span>) % content.length;</span><br><span class=\"line\">      current--;</span><br><span class=\"line\">      fullCondition.signal();</span><br><span class=\"line\">      lock.unlock();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Producer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SharedFifoQueue queue;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Producer</span><span class=\"params\">(SharedFifoQueue queue)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">              queue.add(<span class=\"string\">&quot;Hello &quot;</span> + i);</span><br><span class=\"line\">              Thread.sleep(random.nextInt(<span class=\"number\">200</span>) );</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          queue.add(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Consumer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SharedFifoQueue queue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Consumer</span><span class=\"params\">(SharedFifoQueue queue)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">              Object item = queue.remove();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              System.out.println(item.toString());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    SharedFifoQueue sharedFifoQueue = <span class=\"keyword\">new</span> SharedFifoQueue(<span class=\"number\">10</span>);</span><br><span class=\"line\">    Thread consumerThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Consumer(sharedFifoQueue));</span><br><span class=\"line\">    Thread producerThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Producer(sharedFifoQueue));</span><br><span class=\"line\"></span><br><span class=\"line\">    producerThread.start();</span><br><span class=\"line\">    consumerThread.start();</span><br><span class=\"line\">    <span class=\"comment\">// join 可以讓主線程等待子線程結束</span></span><br><span class=\"line\">    producerThread.join();</span><br><span class=\"line\">    consumerThread.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（3）ReadWriteLock</strong></p>\n<p>ReadWriteLock 相比 ReentrantLock 性能更高，體現在兩個讀操作在 ReadWriteLock 裏是不互斥的，而在 ReentrantLock 裏是互斥的。</p>\n<ul>\n<li><p>代碼</p>\n<p>  代碼來源：<a href=\"java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/\">https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadSafeArrayList</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReadWriteLock readWriteLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock readLock = readWriteLock.readLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;E&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(E o)</span> </span>&#123;</span><br><span class=\"line\">      writeLock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          list.add(o);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          writeLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">      readLock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> list.get(i);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          readLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（4）CountDownLatch</strong></p>\n<p>CountDownLatch 可以讓一個或多個線程等待指定的操作完成後再開始工作。初始化 CountDownLatch 時需要指定一個 count 值，需要等待的線程使用 <code>CountDownLatch.await()</code> 進行等待，當 <code>CountDownLatch.countDown()</code> 被調用 count 次時，等待的線程才得以繼續執行。</p>\n<ul>\n<li><p>代碼</p>\n<p>  代碼來源：<a href=\"java-concurrent//tutorials.jenkov.com/java-util-concurrent/countdownlatch.html\">http://tutorials.jenkov.com/java-util-concurrent/countdownlatch.html</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\">CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Waiter      waiter      = <span class=\"keyword\">new</span> Waiter(latch);</span><br><span class=\"line\">Decrementer decrementer = <span class=\"keyword\">new</span> Decrementer(latch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(waiter)     .start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(decrementer).start();</span><br><span class=\"line\"></span><br><span class=\"line\">Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\"><span class=\"comment\">// Waiter.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Waiter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  CountDownLatch latch = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Waiter</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          latch.await();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Waiter Released&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Decrementer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decrementer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  CountDownLatch latch = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decrementer</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\"></span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\"></span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（5）Semaphore</strong></p>\n<p>Semaphore 用於限制訪問資源的線程數量，以對資源進行保護。<a href=\"java-concurrent//blog.csdn.net/eson_15/article/details/51577191\">有人將其比做是廁所的坑位數</a>，譬如一個廁所有 3 個坑，則同時上廁所的人只能有 3 個，其他人要上只能等這 3 個人之一釋放坑位。</p>\n<p>使用前通過調用 <code>Semaphore.acquire</code> 獲取訪問，使用後通過  <code>Semaphore.release</code> 釋放許可。</p>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\">    Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore.acquire();</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;Running Thread Id: %s, Available permit: %d, Queue length: %d\\n&quot;</span>, Thread.currentThread().getId(), semaphore.availablePermits(), semaphore.getQueueLength());</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  運行結果：</p>\n<p>  初始化總許可量爲 3，一開始被用掉一個許可，可用許可剩餘 2；隨後許可被用光，其他線程開始排隊，出現長度爲 6 的請求隊列，之後隨之許可釋放，隊列長度遞減，直到所有任務處理完成，隊列長度爲 0，許可復爲 3。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Running Thread Id: <span class=\"number\">13</span>, Available permit: <span class=\"number\">2</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">15</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">14</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">16</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">6</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">17</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">5</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">18</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">4</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">19</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">3</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">20</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">2</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">21</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">1</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">22</span>, Available permit: <span class=\"number\">2</span>, Queue length: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"CompletableFuture\"><a href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"></a>CompletableFuture</h3><p>參考：<a href=\"java-concurrent//colobu.com/2016/02/29/Java-CompletableFuture/\">https://colobu.com/2016/02/29/Java-CompletableFuture/</a>、<a href=\"java-concurrent//www.jianshu.com/p/6bac52527ca4\">https://www.jianshu.com/p/6bac52527ca4</a></p>\n<p>CompletableFuture 是 Java 1.8 提供的類，可以方便函數式異步編程。CompletableFuture 實現了 Future 接口。</p>\n<p>Future 是 Java 1.5 引入的接口，它代表這異步執行的結果。可以通過 <code>isDone</code> 判斷執行是否完畢，通過 <code>get</code> 阻塞獲取結果，通過 <code>cancel</code> 取消執行。</p>\n<p>Future 獲取結果的方式不優雅，要輪詢或一直阻塞等待結果。 CompletableFuture 提供了回調的方式處理結果（正常結果 &amp; 異常結果），還有組合多個 CompletableFuture 的能力。</p>\n<p>有了 CompletableFuture，我們甚至可以不關心線程、線程池和同步，因爲 CompletableFuture 內部已經幫我們處理好了，我們只需要鏈式調用函數就可以了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CompletableFuture.allOf(CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(Thread.currentThread().getId() + <span class=\"string\">&quot; done!&quot;</span>);</span><br><span class=\"line\">&#125;), CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(Thread.currentThread().getId() + <span class=\"string\">&quot; done!&quot;</span>);</span><br><span class=\"line\">&#125;)).handle((BiFunction&lt;Void, Throwable, Void&gt;) (unused, throwable) -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (throwable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Exception:&quot;</span> + throwable.getMessage());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;All done!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;).join();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>ThreadLocal 可以讓每個線程擁有變量的副本進行讀寫而互不影響。ThreadLocal 的原理就是 Thread 類本身的 ThreadLocalMap，當調用 <code>ThreadLocal.set</code> 方法時會去獲取當前線程的 ThreadLocalMap，然後以當前 ThreadLocal 爲 key，將值放入其中；當調用<code>ThreadLocal.get</code>時則從 ThreadLocalMap 中讀取。如此每個 Thread 都有各自的專屬變量，不受其他線程影響。</p>\n<p><img src=\"/it/java/java-concurrent/Untitled%203.png\" alt></p>\n<p>ThreadLocalMap 中的 key 採用弱引用，如果 key 即 ThreadLocal 沒有強引用的話，key 會被 GC 回收變爲 null，而 value 因爲是強引用不會被 GC 回收，於是出現了 key 爲 null 的 Entry，造成內存泄漏。ThreadLocalMap 在調用 <code>get</code>、<code>set</code> 方法時會清理 key 爲 null 的Entry，雖如此還是在使用完 ThreadLocal 後手動調用下 <code>remove</code> 方法爲好。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">  Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">      value = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"線程安全\"><a href=\"#線程安全\" class=\"headerlink\" title=\"線程安全\"></a>線程安全</h2><h3 id=\"線程安全的保證\"><a href=\"#線程安全的保證\" class=\"headerlink\" title=\"線程安全的保證\"></a>線程安全的保證</h3><ol>\n<li>原子性：多項操作要麼都執行，要麼都不執行。synchronized 可以保證代碼片段的原子性。</li>\n<li>可見性：當一個線程對共享變量做了修改，其他線程要立即可以看到修改後的值。volatile 可以保證共享變量的可見性。</li>\n<li>有序性：代碼編寫時的順序同編譯執行時的順序一致。volatile 可以禁止指令重排序。</li>\n</ol>\n<h3 id=\"synchronized-同步鎖的用法\"><a href=\"#synchronized-同步鎖的用法\" class=\"headerlink\" title=\"synchronized 同步鎖的用法\"></a><strong>synchronized 同步鎖的用法</strong></h3><p>synchronized 使用時需要指定一個鎖，當程序進入 synchronized 代碼塊或方法時該鎖會被鎖住，直到離開 synchronized 代碼塊或方法，鎖才會被釋放。注意：同步的範圍越小越好。</p>\n<p><strong>同步代碼塊</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同步代碼塊的鎖可以選擇使用當前對象（this）、當前類 class 對象或其他任意對象。</p>\n<p><strong>同步方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此時鎖爲同步方法所在類的對象。<strong>同一個對象的多個同步方法共享同一個鎖</strong>，多個實例對象時各個對象有各自的鎖。子類重寫父類的同步方法時可以去除同步。</p>\n<p><strong>同步靜態方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此時鎖為同步靜態方法所在類的 class 對象，即使多個實例對象也共享同一個鎖。</p>\n<h3 id=\"使用-String-作爲鎖的注意點\"><a href=\"#使用-String-作爲鎖的注意點\" class=\"headerlink\" title=\"使用 String 作爲鎖的注意點\"></a>使用 String 作爲鎖的注意點</h3><ol>\n<li>首先 String 是一個特殊的類，JVM 使用常量池技術對其進行了緩存，通過字面量使用時會總是返回同一個 String 對象。</li>\n<li>使用 <code>new String</code>、<code>StringBuilder.toString</code> 和 <code>StringBuffer.toString</code> 每次會返回一個新的 String 對象。</li>\n<li>使用 <code>String.intern</code>，當常量池中有值等同的 String 對象時返回該對象，如無則將其加入常量池。</li>\n</ol>\n<h3 id=\"Java-同步鎖的本質\"><a href=\"#Java-同步鎖的本質\" class=\"headerlink\" title=\"Java 同步鎖的本質\"></a><strong>Java 同步鎖的本質</strong></h3><p><strong>Java 的鎖是存在於對象頭</strong>中的，具體就 Hotspot 虛擬機來說，是存在於對象頭中的 Mark Word（標記字段）中的鎖標誌位。Java 對象可有四種鎖狀態：</p>\n<ol>\n<li>一開始對象無鎖，當一段同步代碼一直被一個線程訪問時，該線程自動獲得鎖，此時該鎖爲<strong>偏向鎖</strong>；</li>\n<li>當鎖是偏向鎖時，另一個線程訪問同步代碼，偏向鎖會升級爲<strong>輕量級鎖</strong>，其他線程會通過<strong>自旋</strong>（指嘗試獲取鎖的線程不會立即阻塞，而是採用循環的方式獲取鎖）嘗試獲取鎖；</li>\n<li>當鎖是輕量級鎖時，另一個線程自旋到一定次數仍然未獲得鎖，輕量級鎖會自動升級爲<strong>重量級鎖</strong>，其他線程進入阻塞狀態。</li>\n</ol>\n<p><img src=\"/it/java/java-concurrent/_2020-11-16_8.54.01.png\" alt></p>\n<p>當處於重量級鎖時，對象頭存儲的指針指向的重量級鎖也叫 <strong>monitor 鎖</strong>（監視器鎖）。多個線程爭搶的就是這個 monitor 對象，誰持有誰就可以運行同步代碼。通過使用 <code>javap -c -s -v -l xx.class</code> 反彙編字節碼知道：當使用 <code>synchronized</code> 同步代碼塊時其實現時 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中的 <code>monitorenter</code> 指令指向同步代碼塊開始的位置，<code>monitorexit</code> 則指向結束的位置；當使用 <code>synchronized</code> 修飾方法時，則是使用 <code>ACC_SYNCHRONIZED</code> 標識該方法爲同步方法。</p>\n<p>獲取鎖的過程如下圖所示：需要訪問同步代碼的多個線程首先進入 Entry Set，當線程獲取到 monitor 對象時會進入 The Owner 區域，然後將 monitor 對象中的 owner 變量設置爲當前線程，計數器 count 加 1；若線程調用 wait 方法，將釋放持有的 monitor，owner 變量設置爲 null，計數器 count 減 1，同時該線程進入 Wait Set 等待被喚醒；若線程執行完畢也將釋放 monitor 並恢復 monitor 中相關變量的值。</p>\n<p><img src=\"/it/java/java-concurrent/Untitled%204.png\" alt></p>\n<h3 id=\"volatile-關鍵字\"><a href=\"#volatile-關鍵字\" class=\"headerlink\" title=\"volatile 關鍵字\"></a>volatile 關鍵字</h3><p>參考：<a href=\"java-concurrent//monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/\">https://monkeysayhi.github.io/2017/12/28/一文解决内存屏障/</a></p>\n<p>volatile 關鍵字可以修飾變量，其作用是：</p>\n<p>標記該變量以在編譯時，取消編譯層面的緩存和重排序（編譯時的亂序優化）；在解釋執行時使用 CPU 內存屏障技術解決硬件層面的可見性和重排序。具體來說：</p>\n<ol>\n<li><p><strong>被修飾的變量在寄存器中將不會有副本，而是直接從主存進行讀寫操作</strong>，多線程環境下，變量的值的改變<strong>即時可見</strong>。所謂的主存和寄存器是計算機的解決訪問 CPU 處理速度和內存讀寫速度不匹配的手段。一般認爲寄存器的讀寫速度快於主存。</p>\n<p> <img src=\"/it/java/java-concurrent/Untitled%205.png\" alt></p>\n<p> 未聲明 volatile 時</p>\n<p> <img src=\"/it/java/java-concurrent/Untitled%206.png\" alt></p>\n<p> 聲明 volatile 時</p>\n</li>\n<li><p>編譯器不對該變量進行亂序優化。</p>\n</li>\n<li><p>JVM 在解釋執行時使用對應 CPU 架構的內存屏障指令防止指令重排序，通常有以下三種：</p>\n<ul>\n<li><p>mfence(StoreLoad Barriers、Full Barrier) 全能屏障</p>\n</li>\n<li><p>sfence(Store Barriers) 寫屏障</p>\n</li>\n<li><p>lfence(Load Barrirers) 讀屏障</p>\n<p>以 x86 架構爲例子，如有一以 volatile 修飾的變量 v，JVM 對其操作如下：</p>\n</li>\n</ul>\n<ol>\n<li><p>在寫入 v 之後插入一個 sfence，隔離了寫入 v 前後的寫入指令，防止其重排序，且 sfence 之前的修改會被寫入緩存並標記其他 CPU 核心中的緩存失效；</p>\n</li>\n<li><p>在讀取 v 之前插入一個 lfence，隔離了讀取 v 前後的讀取指令，防止其重排序，且 lfence 之後會先刷新緩存，從而讀取最新的值。</p>\n<p>sfence 和 lfence 兩相配合，保證了變量 v 的可見性。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"CAS-鎖\"><a href=\"#CAS-鎖\" class=\"headerlink\" title=\"CAS 鎖\"></a>CAS 鎖</h3><p>synchronized 是悲觀鎖，假定操作是有衝突的，要加鎖然後再執行程序，完畢後再釋放鎖。而 CAS(Compare And Swap) 是樂觀鎖，假定操作是沒有衝突的，不需要加鎖，而是把舊的預期值跟內存中已有的值進行比較，如果相同再把要更新的值更新到內存，如果不同則自旋（重試，重新獲取預期值進行比較和替換），Java 中的原子類（比如 AtomicInteger）的底層實現就是 CAS。</p>\n<p>CAS 存在一個稱之爲 ABA 的問題，即對於變量 v = A，當其變爲 B 後又復原爲 A 時，無法判斷變量 v 是否被修改過。</p>\n<p><img src=\"/it/java/java-concurrent/Untitled%207.png\" alt></p>\n<p>使用 <code>AtomicStampedReference</code> 可以防止 ABA 的問題，因爲附帶的 Stamp可以標識 Reference 的版本，Reference 變化，Stamp 隨之遞增。</p>\n<h3 id=\"Atomic-原子類\"><a href=\"#Atomic-原子類\" class=\"headerlink\" title=\"Atomic 原子類\"></a>Atomic 原子類</h3><p><code>java.util.concurrent.atomic</code> 包中提供了一系列原子類，包括：</p>\n<ol>\n<li>原子類型：<ul>\n<li>AtomicInteger：針對整型</li>\n<li>AtomicLong：針對長整型</li>\n<li>AtomicBoolean：針對布爾類型</li>\n</ul>\n</li>\n<li>數組類型：<ul>\n<li>AtomicIntegerArray：針對整型數組</li>\n<li>AtomicLongArray：針對長整型數組</li>\n<li>AtomicReferenceArray：針對引用類型數組</li>\n</ul>\n</li>\n<li>引用類型：<ul>\n<li>AtomicReference：針對對象引用</li>\n<li>AtomicStampedReference：針對對象引用連同一個整型</li>\n<li>AtomicMarkableReference：針對對象引用連同一個布爾類型</li>\n</ul>\n</li>\n<li>對象的屬性修改類型：<ul>\n<li>AtomicIntegerFieldUpdater：修改對象的一個整型屬性</li>\n<li>AtomicLongFieldUpdater：修改對象的一個長整型屬性</li>\n<li>AtomicReferenceFieldUpdater：修改對象的一個整型屬性</li>\n</ul>\n</li>\n</ol>\n<p>其理論基礎就是 <strong>CAS</strong>(Compare and Swap) <strong>鎖 + volatile + native 方法。</strong>CAS 就是將舊的預期值與內存中的值進行比較，當相同時才將新的預期值設入，否則自旋。 </p>\n<p>介紹下 AtomicInteger 類的幾個原子方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(java-concurrent//獲取當前的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndSet(java-concurrent//獲取當前的值，並設置新的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndIncrement(java-concurrent//獲取當前的值，並自增</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndDecrement(java-concurrent//獲取當前的值，並自減</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndAdd(java-concurrent//獲取當前的值，並加上預期的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">boolean</span> compareAndSet(java-concurrent//如果輸入的數值等於預期值，則以原子方式將該值設置為輸入值（update）</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> lazySet(java-concurrent//最終設置為newValue,使用 lazySet 設置之後可能導致其他線程在之後的一小段時間內還是可以讀到舊的值。</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"死鎖-deadlock\"><a href=\"#死鎖-deadlock\" class=\"headerlink\" title=\"死鎖 (deadlock)\"></a>死鎖 (deadlock)</h3><p>如果一組線程中的每個線程都在等待一個事件，而這個事件只能由該組中的另一個線程觸發，這種情況會導致死鎖。</p>\n<p>死鎖需要滿足四個條件（線程維度上）：</p>\n<ol>\n<li>互斥，該資源任意時刻只能由一個線程佔用。</li>\n<li>請求與保持，一個線程因請求資源被阻塞，另一個線程保持該資源不放。</li>\n<li>不剝奪/不可搶佔，一個線程不能強佔另一個線程擁有的資源，除非另一個線程釋放之。</li>\n<li>循環等待，若干個線程形成循環等待資源的關係。</li>\n</ol>\n<p>那麼，防止死鎖只需要不滿足以上四個條件之一即可。具體來說：</p>\n<ol>\n<li>破壞互斥：不可，這是資源的固有屬性，不可破壞。</li>\n<li>破壞請求與保持：可以一次性請求所有需要的資源。</li>\n<li>破壞不剝奪：<ul>\n<li>若有一佔有若干資源的進程請求某資源被拒絕，則它應釋放它佔有的資源。</li>\n<li>若有一進程請求當前被另一個進程佔有的資源，則操作系統可以剝奪另一個進程的資源。</li>\n</ul>\n</li>\n<li>破壞循環等待：確定資源的申請順序和釋放順序。</li>\n</ol>\n<p>下面是一個死鎖的實例，線程A 擁有資源1 後想要獲得資源2，線程B 擁有資源2 後想要獲得資源1。</p>\n<p><img src=\"/it/java/java-concurrent/Untitled%208.png\" alt></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object res1 = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">Object res2 = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread B&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按相同順序申請和釋放資源，破壞循環等待條件，從而避免死鎖</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread B&quot;</span>).start();</span><br></pre></td></tr></table></figure>"},{"title":"甲子話分類辭表（2020.12）","p":"language/min/gahzi-oi-hung-lui-ci-biao","date":"2020-11-08T12:24:00.000Z","_content":"\n**!!! 注意：本辭表已收錄在典合網中進行維護，請轉閱：[https://dicthub.cn/dicts/kahtsi-ue](https://dicthub.cn/dicts/kahtsi-ue) !!!**\n\n## 序言(su⁶ ngiang⁵)\n\n甲子鎮處在陸豐市，與惠來縣交界，語言文化上偏惠來（其實五百年前與惠來交界處同屬海豐縣）。甲子話是三甲地區（甲子、甲西、甲東三鎮）通行的語言，是甲子地方文化的重要載體之一。在學術上，甲子話被歸入粵東閩南語潮汕話片。 \n\n甲子話保留了好㩼中古乃至上古的漢語詞彙，比如：汝、諸母、新婦、箸、鼎、匏桸、雅、翹楚等等，還有極具地方特色的表達，比如：𨑨迌、走漆、理唔直、孤獨死相等等。然而無會寫甚至無會呾甲子話的人實在㩼，其中不少是受過義務教育其。 有鑑於此，本人草創此表，力求詞雅正且其音形義有所考據，權當拋磚引玉，歡迎大家儂做蜀討論改進。 \n\n另附本表主要參考資料：\n\n1. 《潮汕方言詞考釋》（林倫倫）\n2. 《海豐話分類辭表》（羅志海、鍾顯坤）\n3. [《潮典》](https://www.mogher.com/baike) \n4. 《新潮汕字典》（張曉山）\n5. [《台灣閩南語常用詞辭典》](https://twblg.dict.edu.tw/holodict%5C_new/index.html) \n6. [《小學堂閩語》](https://xiaoxue.iis.sinica.edu.tw/minyu)\n\n阿華\n2020年10月成稿，12月修訂\n\n<!--more-->\n\n## 總表(zong² biao²)\n\n### 🤵稱謂(cêng¹ ui⁶)\n\n1. 我 /ua²/\n2. 汝 /lu²/ 你\n3. 伊 /i¹/ 他/她/它\n4. 恁 /ning²/ 你們\n5. 伊人 /i¹ nang⁷/ 他們\n6. 家己 /ga¹ gi⁷/ 自己\n7. 人家 /nang⁵ gê¹/ 別人\n8. 諸夫 /za¹ bao¹/ 男人、男子\n9. 諸母 /za¹ bhao²/ 女人\n10. 諸娘 /zu¹ nion⁵/ 女子\n11. 大人 /dua⁷ nang⁷/\n12. 老人 /lao⁶ nang⁵/\n13. 後生囝 /hao⁶ sên¹ gian²/ 年輕人\n14. 孥囝 /nao⁵ gian²/、/nong⁶ gian²/ 小孩子\n15. 諸夫囝 /za¹ bao¹ gian²/ 男孩子、兒子\n16. 諸母囝 /za¹ bhao² gian²/ 女孩子、女兒\n17. 諸娘囝 /zu¹ nion⁵ gian²/ 年輕女子\n18. 阿公 /a¹ gong¹/ 爺爺\n19. 阿媽 /a¹ ma²/ 奶奶\n20. 媽人 /ma² nang⁵/ 婦女\n21. 媽祖 /ma² zao²/ 原名林默，南海保護神\n22. 爸爸 /ba¹ ba¹/ 爸爸\n23. 媽媽 /ma¹ ma¹/\n24. 父母 /bê⁶ bho²/\n25. 兄 /hian¹/ 哥哥\n26. 弟 /di⁶/ 弟弟\n27. 姐 /zê²/ 姐姐\n28. 妹 /moi⁷/ 妹妹\n29. 姊妹 /zi² moi⁷/ 姐妹\n30. 叔伯兄弟 /zêh⁴ bêh⁴ hian¹ di⁶/ 堂兄弟\n31. 同沿 /dang⁵ iang⁵/ 同輩、同儕\n32. 翁 /ang¹/ 丈夫\n33. 母 /bhao²/ 妻子\n34. 翁姐 /ang¹ zia²/ 夫妻\n35. 新婦 /sing¹ bu⁶/ 媳婦\n36. 大家 /dua⁷ gê¹/ 丈夫的母親、家婆\n37. 大家官 /dua⁷ gê¹ guan¹/ 丈夫的父親、家公\n38. 丈人 /dion⁶ nang⁵/ 岳父\n39. 丈母 /dion⁶ m²/ 岳母\n40. 妻舅 /ci¹ gu⁶/ 妻子的兄弟\n41. 妻姨 /ci¹ i⁵/ 妻子的姐妹\n42. 伯 /bêh⁴/ 伯伯\n43. 姆 /m²/ 伯父的妻子\n44. 叔 /zêh⁴/ 叔叔\n45. 嬸 /sim²/ 叔父的妻子\n46. 舅 /gu⁶/ 舅舅\n47. 妗 /gim⁶/ 舅父的妻子\n48. 姑 /gao¹/ 父親的姐妹、姑姑\n49. 姑丈 /gou¹ dion⁶/ 姑姑的丈夫\n50. 姨 /i⁵/ 母親的姐妹；母親\n51. 姨丈 /i⁵ dion⁶/ 母親的姐妹的丈夫\n52. 先生 /sing¹ sên¹/\n53. 學生 /hag⁴ sêng¹/\n54. 師父 /sai¹ bê⁶/ 工匠師傅\n55. 師父 /su¹ hu⁶/ 出家人、和尚\n56. 和尚 /hoi⁵ sion⁷/、/hua⁵ siang⁶/\n57. 腳色 /ka¹ siao³/ 人手、幫手\n58. 青暝囝 /cên¹ mên⁵ gian²/ 瞎子\n\n### 🦶身體(sing¹ ti²)\n\n1. 頭毛 /tao⁵ mo⁵/ 頭髮\n2. 頭神 /tao⁵ sing⁵/ 思維、記憶的能力\n3. 頭碗骨 /tao⁵ uan² gug⁴/ 頭蓋骨\n4. 旋 /zng⁷/ 頭髮呈漩渦狀的地方\n5. 囟 /sing³/ 嬰兒頭頂骨未合縫處\n6. 額頭 /hia² tao⁵/\n7. 面 /ming⁷/ 臉\n8. 頰溝 /gih⁴ gao¹/ 腮\n9. 痣 /gi³/\n10. 目 /mag⁸/ 眼睛\n11. 目仁 /mag⁸ ring⁵/ 眼珠子\n12. 目汁 /mag⁸ zab⁴/ 眼淚\n13. 眉 /bhai⁵/ 眉毛\n14. 耳 /hin⁶/ 耳朵\n15. 耳空、耳孔 /hin⁶ kang¹/\n16. 鼻 /pin⁷/ 鼻子\n17. 鼻空、鼻孔 /pin⁷ kang¹/\n18. 喙、嘴 /cui⁷/ 嘴巴\n19. 䶕牙 /bha³ ghê⁵/ 龅牙\n20. 涎 /nua⁶/ 唾液\n21. 痰 /tam⁵/\n22. 頷 /am⁶/ 脖子\n23. 下頦 /ê⁶ hai⁵/ 下巴\n24. 喙後肚 /cui⁷ ao⁶ dao²/ 下巴後面柔軟處\n25. 鬚 /ciu¹/ 鬍鬚\n26. 嚨喉 /na⁵ ao⁵/ 喉嚨\n27. 手 /ciu²/\n28. 正手 /zian³ ciu²/ 右手\n29. 倒手 /do³ ciu²/ 左手\n30. 胳囊跤 /goh⁴ lang⁵ ka¹/ 腋下\n31. 手後曲 /ciu² ao⁶ kiao¹/ 手肘\n32. 手模 /ciu² bhao⁵/ 手印\n33. 腡 /lê⁵/ 圓形手指紋\n34. 指頭公 /zain² tao⁵ gong¹/ 大拇指\n35. 尾指囝 /bhoi² zain² gian²/ 小指\n36. 胸 /hêng¹/\n37. 嬭、奶 /nê¹/\n38. 𩩍篱 /pian¹ li⁵/ 肋骨\n39. 肚臍 /dao² zai⁵/\n40. 背脊 /ba¹ ziah⁴/ 脊背\n41. 腰 /io¹/\n42. 跤、骹、腳 /ka¹/\n43. 跤頭趺 /ka¹ tao⁵ u⁶/ 膝蓋\n44. 大跤腿 /dua⁷ ka¹ tui²/ 大腿\n45. 跤腸肚 /ka¹ dng⁵ dao²/ 小腿後部肌肉凸出處\n46. 跤後蹬 /ka¹ ao⁶ dên¹/ 腳後跟\n47. 跤盤 /ka¹ buan⁵/ 腳板\n48. 跤目 /ka¹ mag⁸/ 腳踝\n49. 跤指公 /ka¹ zain² gong¹/ 腳大拇趾\n50. 跤液 /ka¹ sio²/ 腳汗\n51. 卵 /lang⁶/ 陰莖、屌、勢\n52. 卵鳥 /lang⁶ ziao²/ 陰莖、屌、勢\n53. 卵脬 /lang⁶ pa¹/ 精囊\n54. 卵核 /lang⁶ hug⁸/ 睪丸\n55. 膣 /zi¹/ 女陰\n56. 膣眉 /zi¹ bhai¹/ 女陰\n57. 尻川 /ka¹ cng¹/ 屁股\n58. 雞母皮 /goi¹ bho² poi⁵/ 雞皮疙瘩\n59. 汗 /guan⁷/\n60. 垢圿 /gao² goih⁴/ 體表污垢\n\n### 🍵飲食(im² ziah⁸)\n\n1. 食 /ziah⁸/ 吃、喝、抽\n2. 祭 /zi³/ 狼吞虎咽；坐享其成\n3. 咬 /ga⁶/\n4. 哺 /bao⁷/ 咀嚼\n5. 吞 /tung¹/\n6. 舐 /zi⁶/ 舔\n7. 含 /gam⁵/\n8. 啜 /coih⁴/ 喝\n9. 啉 /lim⁵/ 小口喝\n10. 灌 /guang¹/ 大口喝\n11. 吸 /kib⁴/\n12. 搵 /ung³/ 蘸\n13. 買鹹 /moi² giam⁵/ 買菜\n14. 食透早 /ziah⁸ tao⁷ za²/ 吃早飯\n15. 食眠起 /ziah⁸ mng⁵ ki²/ 吃早飯\n16. 食晝 /ziah⁸ dao³/ 吃午飯\n17. 食當晝 /ziah⁸ dêng¹ dao³/ 吃午飯\n18. 食夜昏、食暝昏 /ziah⁸ mê⁵ hng⁵/ 吃晚飯\n19. 飯 /bng⁷/\n20. 米 /bhi²/\n21. 糜 /moi⁵/ 粥\n22. 飲 /am²/ 米湯\n23. 配 /poi³/ 菜\n24. 菜式 /cai³ sêg⁴/\n25. 粿、餜 /goi²/\n26. 丸、圓 /in⁵/\n27. 油䭔 /iu⁵ zui¹/ 一種油炸食品\n28. 汰米 /tua⁷ bhi²/ 淘米\n29. 熬 /ngao⁵/ 長時間煮。～糜。\n30. 煲 /bu⁵/ 煮、熬。～藥。\n31. 潘 /png¹/ 餿水\n32. 油 /iu⁵/\n33. 鹽 /iam⁵/\n34. 醋 /cao³/\n35. 豉油 /si⁷ iu⁵/ 醬油\n36. 豆汁 /dao⁷ zab⁴/ 醬油\n37. 雞卵 /goi¹ nng⁶/ 雞蛋\n38. 豬肉 /du¹ nêg⁸/\n39. 澀肉 /siab⁴ nêg⁸/、/siab⁴ bhah⁴/ 瘦肉。澀，少油。\n40. 肉脞 /nêg⁸ co³/ 肉末\n41. 烏糖 /ao¹ tng⁵/ 紅糖、黑糖\n42. 赤砂糖 /ciah⁴ sua¹ tng⁵/\n43. 白砂糖 /bêh⁸ sua¹ tng⁵/\n44. 薰 /hung¹/ 香菸\n45. 茶 /dê⁵/\n46. 酒 /ziu²/\n47. 淖 /cioh⁴/ 粥稀\n48. 凊 /cing³/ 飯菜涼了\n49. 燒 /sio¹/ 熱呼呼\n50. 燒烘燒烘 /sio¹ hang¹ sio¹ hang¹/ 熱呼呼\n51. 芳 /pang¹/ 香\n52. 甘 /gam¹/\n53. 甜 /diam⁵/\n54. 鹹 /giam⁵/\n55. 薟 /hiam¹/ 辛辣\n56. 䭕 /zian²/ 清淡\n57. 臊 /co¹/ 腥\n58. 臭 /cao³/\n\n### 👔穿戴(cêng⁷ dua³)\n\n1. 帽 /bho⁷/\n2. 目鏡 /mah⁸ gian³/ 眼鏡\n3. 圍巾 /ui⁵ ging¹/\n4. 頷幔 /am⁶ muan¹/ 披肩\n5. 衫褲 /san¹ kao³/ 衣服\n6. 西裝 /sai¹ zuang¹/\n7. 褸 /lao¹/ 大衣\n8. 葵笠 /goi⁵ loih⁸/ 斗笠，竹編成的圓錐形大帽子。\n9. 羊毛衫 /ion⁵ mo⁵ san¹/\n10. 長䘼衫 /dng⁵ ng² san¹/ 長袖衫\n11. 短䘼衫 /dê² ng² san¹/ 短袖衫\n12. 貼身衫 /dah⁴ sing¹ san¹/ 貼身的上衣\n13. 䘥囝 /gah⁴ gian²/ 無袖內衣\n14. 底衫 /doi² san¹/ 內衣\n15. 肚綰 /dao² guan⁶/ 肚兜\n16. 長褲 /dng⁵ kao³/\n17. 短褲 /dê² kao³/\n18. 褲頭 /kao³ tao⁵/ 短褲、內褲\n19. 褲橛 /kao³ goi²/ 短褲、內褲\n20. 三角褲 /san¹ gag⁴ kao³/\n21. 裙 /gung⁵/\n22. 圍裙 /ui⁵ gung⁵/\n23. 文胸 /bhung⁵ hêng¹/ 胸罩\n24. 奶帕、嬭帕 /nê¹ pê³/ 胸罩\n25. 皮帶 /poi⁵ dua³/\n26. 手囊 /ciu² lob⁴/ 套袖\n27. 手鐲 /ciu² sio²/\n28. 鞋拖 /tua¹ oi⁵/ 拖鞋\n29. 波鞋 /bo¹ oi⁵/ 球鞋。波，英文 ball 的音譯。\n30. 釘鞋 /dêng¹ oi⁵/ 運動鞋的一種\n31. 皮鞋 /poi⁵ oi⁵/\n32. 高跟鞋 /gao¹ ging¹ oi⁵/\n33. 靴 /hia¹/\n34. 襪 /ghoih⁸/\n35. 布 /bao³/\n36. 襊 /zoi⁷/ 折痕\n37. 頷領 /am⁶ nia²/ 領子\n38. 褲袋 /kao³ dê⁷/ 位於褲子的口袋\n39. 衫袋 /san¹ dê⁷/ 位於上衣的口袋\n40. 暗袋 /am³ dê⁷/ 內側袋\n41. 內裏 /lai⁶ li²/ 衣物不露出在外的裏層\n42. 鈕 /liu²/ 鈕扣\n43. 針 /zam¹/\n44. 線 /suan³/\n45. 拉鍊 /la¹ liang³/\n46. 穿 /cêng⁷/\n47. 褪 /tng⁷/ 脱\n48. 紩 /tin⁷/ 縫\n49. 補 /bao²/\n50. 車衫褲 /cia¹ san¹ kao³/ 用縫紉機縫衣服\n\n### 🎏物件(mi² gian⁶、mian⁶)\n\n1. 眠牀 /mng⁵ cng⁵/ 牀\n2. 鋪 /pao¹/ 牀\n3. 高低牀 /gao¹ di¹ cng⁵/ 上下鋪\n4. 蓆 /cioh⁸/\n5. 簟 /diam⁶/ 竹席\n6. 毡 /ziang¹/\n7. 被 /poi⁶/\n8. 棉被 /mi⁵ poi⁶/\n9. 被單 /poi⁶ duan¹/\n10. 枕頭 /zim² tao⁵/\n11. 枕頭囊 /zim² tao⁵ lob⁴/ 枕套\n12. 蠓罩、蚊罩 /mang² da³/ 蚊帳\n13. 蠓熏、蚊熏 /mang² hung¹/ 蚊香\n14. 窗罩 /têng¹ zao⁶/\n15. 口罩 /kao² zao⁶/\n16. 壁櫥 /biah⁴ du⁵/\n17. 椅 /in²/\n18. 桌 /doh⁴/\n19. 櫃 /gui⁷/\n20. 架 /gê³/\n21. 盒 /ab⁸/\n22. 籃 /na⁵/\n23. 瓶 /bang⁵/\n24. 鎖頭 /so² tao⁵/\n25. 鎖匙 /so² si⁵/ 鑰匙\n26. 葉疊 /iab² diab⁸/ 合葉\n27. 牙簽 /ghê⁵ ciam¹/\n28. 茶盤 /dê⁵ buan⁵/\n29. 茶壺 /dê⁵ hu⁵/\n30. 沖罐 /cong¹ guang³/ 茶壺\n31. 茶杯 /dê⁵ boi¹/\n32. 茶几 /dê⁵ gi²/\n33. 熏咬 /hung¹ ga⁶/ 煙斗\n34. 熏碟 /hung¹ dih⁸/ 煙灰缸\n35. 熱壺 /riag⁸ hu⁵/ 熱水瓶\n36. 熨斗 /ug⁴ dao²/\n37. 電燈 /diang⁶ dêng¹/\n38. 電泡 /diang⁶ pa⁶/\n39. 燈籠 /dêng¹ lang⁵/\n40. 燈火 /dêng¹ hoi²/ 電燈；燈光\n41. 風箏 /hong¹ zêng¹/\n42. 米甕 /bhi² ang³/ 米缸\n43. 水䀇 /zui² gao²/ 大型儲水器\n44. 跤桶 /ka¹ tang²/ 原指洗腳桶，後泛指洗衣盆，也可用來給小孩洗澡。\n45. 面盆 /ming⁷ png⁵/ 臉盆\n46. 瓠桸 /bu⁵ hia¹/ 水瓢\n47. 口㼦 /kao² gong²/ 漱口杯\n48. 碗 /uan²/\n49. 盤 /buan⁵/\n50. 碟 /dih⁸/\n51. 甌 /ao¹/ 大碗\n52. 箸 /du⁷/ 筷子\n53. 湯匙 /tng¹ si⁵/\n54. 調羹 /tiao⁵ gên¹/ 喝粥用的小勺子；湯匙\n55. 糜匙 /moi⁵ si⁵/ 舀粥用的勺子\n56. 飯匙 /bng⁷ si⁵/ 飯勺\n57. 飯添 /bng⁷ tin¹/ 飯勺\n58. 鼎 /dian²/ 鍋\n59. 鼎㧕 /dian² liu⁶/ 鍋鏟。㧕，存疑。\n60. 鼎蓋 /dian² kain³/ 鍋蓋\n61. 菜刀 /cai³ do¹/\n62. 瓜刨 /goi¹ pao⁵/\n63. 砧 /diam¹/\n64. 篩 /tai¹/\n65. 筅 /cain²/ 刷子\n66. 菜篩 /cai³ tai¹/\n67. 鉸刀 /ga¹ do¹/ 剪刀\n68. 螺絲批 /lo⁵ si¹ poi¹/ 螺絲刀\n69. 螺絲釘 /lo⁵ si¹ dêng¹/\n70. 旋螺絲 /suag⁸ lo⁵ si¹/ 擰螺絲\n71. 鐵錘 /tih⁴ tui⁵/\n72. 鉸夾 /ga¹ giab⁸/ 鉗子\n73. 扳手 /bang² ciu²/\n74. 電筆 /diang⁶ big⁴/ 測電筆\n75. 烏膠布 /ao¹ ga¹ bao³/ 電工膠帶\n76. 黏紙 /niam⁵ zua²/ 透明膠帶\n77. 布拖 /bao³ tu¹/ 拖把\n78. 掃帚 /sao³ siu²/ 掃把\n79. 畚斗 /bng³ dao²/ 垃圾鏟\n80. 畚箕 /bng³ gi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled.png)\n\n81. 梯 /tui¹/\n82. 吸石 /hiab⁴ zioh⁸/ 磁鐵、磁石\n83. 箠 /coi⁵/ 鞭子，可用來教育孩子。\n84. 火箠 /hoi² coi⁵/ 火筷子，夾爐中煤炭或通火的用具。\n85. 角畢 /gag⁴ big⁴/ 皮箱\n86. 樹嬭 /ciu⁷ ni⁵/ 橡皮、橡膠。嬭，樹之乳膠。\n87. 嬭漱 /ni⁵ ciu³/ 橡皮擦\n88. 毛筆 /mo⁵ big⁴/\n89. 鋼筆 /gng³ big⁴/\n90. 鉛筆 /iang⁵ big⁴/\n91. 鉛筆旋 /iang⁵ big⁴ suag⁸/ 卷筆刀、筆刨\n92. 模 /bhao⁵/ 模子\n93. 㨹 /zoi⁷/ 裂縫、痕跡\n94. 離衣機 /li⁵ i¹ gi¹/ 洗衣機\n\n### 🏠建築(giang³ dog⁴)\n\n1. 茨、厝 /cu³/ 房子、家\n2. 寮 /liao⁵/ 简陋小屋\n3. 瓦茨 /hia⁶ cu³/ 瓦舍\n4. 茨手 /cu³ ciu²/ 潮汕民居天井旁兩間廂房的名稱。\n5. 兩間直 /no⁶ gain¹ dig⁸/ 傳統民居，兩房。\n6. 獨腳靴 /dog⁸ ka¹ hia¹/ 傳統民居，一聽一茨手一房。\n7. 下山虎 /hia⁶ suan¹ haon²/ 傳統民居，三合院，一廳二房二茨手。\n8. 四點金 /si³ diam² gim¹/ 傳統民居，四合院，中軸爲前廳天井後聽，兩廳兩旁各有一房。\n9. 竹竿茨 /dêg⁴ go¹ cu³/ 傳統民居，廚房客廳住房天井排列成狹長的空間，如竹竿。\n10. 駟馬拖車 /si³ mê² tua¹ cia¹/ 傳統民居，在四點金上縱加一廳，橫加兩房，三廳二天丼。\n11. 茨邊 /cu³ bin¹/ 鄰居\n12. 起茨 /ki² cu³/ 蓋房子\n13. 租茨 /zao¹ cu³/ 租房子\n14. 搬茨 /buan⁵ cu³/ 搬家\n15. 入新茨 /rib⁸ sing¹ cu³/ 搬入新家\n16. 客廳 /kêh⁴ tian¹/\n17. 客房 /kêh⁴ bang⁵/\n18. 廚房 /dao⁵ bang⁵/\n19. 浴室 /êg⁸ sig⁴/\n20. 洗浴 /soi² êg⁸/ 洗澡\n21. 廁所 /cê³ so²/\n22. 屎壑 /sai² hag⁸/ 茅廁\n23. 門窗 /mng⁵ têng¹/\n24. 門閂 /mng⁵ cuan³/\n25. 門楣 /mng⁵ bhai⁵/\n26. 門橂 /mng⁵ dain⁶/ 門檻\n27. 門扇後 /mng⁵ sin³ ao⁶/ 門後\n28. 柱 /tiao⁶/\n29. 牆壁 /cion⁵ biah⁴/\n30. 庭、埕 /dian⁵/ 寬闊平地，可曬鹽、曬穀。\n31. 临檐 /lim⁵ zin⁵/ 檐廊\n32. 塗角 /tao⁵ gag⁴/ 土磚\n33. 磚 /zng¹/\n34. 廟 /bhio⁷/\n35. 亭 /dêng⁵/\n36. 祠堂 /su⁵ dng⁵/\n37. 庵寺 /am¹ zin⁷/ 尼寺、僧寺的通稱。\n38. 學校 /hag⁸ hao⁶/\n39. 醫院 /ui¹ in⁷/\n40. 鎮府 /ding³ hu²/ 鎮政府\n41. 舖囝 /pao³ gian²/ 小賣部\n\n### 🛵交通(gao¹ tong¹)\n\n1. 腳車、跤車 /ka¹ cia¹/ 腳踏車、自行車\n2. 摩托 /mo⁵ toh⁸/ 摩托，英文 motorcycle 音譯省。\n3. 三輪車 /san¹ lung⁵ cia¹/\n4. 的士 /dêg⁴ si⁶/ 計程車、出租車。的士，英文 taxi 音譯。\n5. 小車 /sio² cia¹/ 小汽車\n6. 麵包車 /min⁷ bao¹ cia¹/\n7. 公交車 /gong¹ gao¹ cia¹/\n8. 大巴 /dua⁷ ba¹/ 巴，英文 bus 音譯。\n9. 車站 /cia¹ zam⁶/\n10. 輪船 /lung⁵ zung⁵/\n11. 龍船 /lêng⁵ zung⁵/ 龍舟\n12. 火車 /hoi² cia¹/\n13. 地鐵 /di⁷ tih⁴/\n14. 高鐵 /gao¹ tih⁴/\n15. 飛機 /boi¹ gi¹/\n16. 行路 /gian⁵ lao⁷/ 走路\n17. 踏腳車 /dah⁸ ka¹ cia¹/ 騎自行車\n18. 駛車 /sai² cia¹/ 開車\n19. 撐船 /tên¹ zung⁵/\n20. 載客 /zai³ kêh⁴/\n21. 拗䷀囝 /ao² gag⁴ gian²/ 摩托車司機。拗，載；扛。\n22. 落車 /lo² cia¹/ 下車\n23. 碼頭 /bhê² tao⁵/\n24. 涵空、涵孔 /am⁵ kang¹/ 涵洞、涵管、地下水道\n25. 橋墩 /gio⁵ dun¹/ 橋梁下面的圓柱狀基石\n\n### 🐒眾生(zêng³ sên¹)\n\n1. 眾生 /zêng³ sên¹/ 牲畜\n2. 禽兽 /kim⁵ siu⁶/\n3. 害蟲 /hai⁷ tang⁵/\n4. 豬豭 /du¹ go¹/ 配種的公豬，也比喻好色之徒。\n5. 豬槽 /du¹ zo⁵/\n6. 羊牢 /ion⁵ lo⁵/\n7. 雞翁 /goi¹ ang¹/ 雄雞\n8. 雞母 /goi¹ bho²/ 母雞\n9. 鴨囝 /ah⁴ gian²/ 小鴨子\n10. 鵝 /gho⁵/\n11. 貓牯 /ngiao¹ gao²/ 母貓\n12. 鳥 /ziao²/\n13. 燕囝 /in³ gian²/ 小燕子\n14. 鶴 /hoh⁸/\n15. 鷹 /êng¹/\n16. 白鴿 /bêh⁸ gab⁴/\n17. 白鷺鷥 /bêh⁸ lao⁷ si¹/\n18. 鸚哥 /êng¹ go¹/ 鸚鵡\n19. 麻雀 /mua⁵ ziah⁴/\n20. 蝠婆 /big⁴ bo⁵/ 蝙蝠\n21. 蛇 /zua⁵/\n22. 雨傘節 /hao⁶ suan³ zag⁴/ 一种毒蛇。\n23. 狗母蛇 /gao² bho² zua⁵/ 蛇舅母、石龍子、四腳蛇，蜥蜴的一種\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%201.png)\n\n24. 兩棲動物 /liang² ci¹ dong⁶ moih⁸/\n25. 蟾蜍 /ziong¹ zu⁵/\n26. 蛤虯 /gab⁴ giu²/ 青蛙\n27. 蛤蛙 /gab⁴ guai¹/ 蝌蚪\n28. 蚼蟻 /gao² hia⁶/ 螞蟻\n29. 白蟻 /bêh⁸ hia⁶/\n30. 蜜蜂 /bhig⁸ pang¹/\n31. 虎頭蜂 /hao² tao⁵ pang¹/ 黄蜂\n32. 龜 /gu¹/ 烏龜或像烏龜的昆蟲\n33. 金龜 /gim¹ gu¹/ 金龜子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%202.png)\n\n34. 鱉 /bih⁴/\n35. 土蚓 /dao⁶ ung²/ 蚯蚓\n36. 蜈蚣 /gê⁵ gang¹/\n37. 火金蛄 /hoi² gim¹ gao¹/ 螢火蟲\n38. 牛屎龜 /ghu⁵ sai² gu¹/ 屎殼郎、蜣螂\n39. 烏點龜 /ao¹ diam² gu¹/ 七星瓢蟲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%203.png)\n\n40. 紅新娘 /ang⁵ sing¹ nion⁵/ 紅姬緣椿象\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%204.png)\n\n41. 山蛚 /sua¹ lê⁷/ 蟬；多指[蚱蝉](http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14818)\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%205.png)\n\n42. 蝘悲蟬 /iam⁶ bi¹ sung⁵/ [蟪蛄](http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14817)\n\n    ![gahzi-oi-hung-lui-ci-biao/image.jpg](gahzi-oi-hung-lui-ci-biao/image.jpg)\n\n43. 蟋蟀 /tih⁴ sug⁴/ 又稱烏龍。\n44. ䷀ // 螽斯、莎蟲、紡織娘、蟈蟈。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%206.png)\n\n45. 草猴 // 稻蝦\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%207.png)\n\n46. ䷀ // 金盾龜金花蟲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%208.png)\n\n47. 草蜢 /cao² mên²/ 螞蚱、蚱蜢。\n48. 螳螂、螳蜋 /tang⁵ lang⁵/\n49. 神螂 /sing⁵ lang⁵/ 壁虎，蜥蜴的一種。\n50. 蛤蚧蛇 /gab⁴ gai³ zua⁵/ 大壁虎，蜥蜴的一種。\n51. 土猴 /dao⁶ gao⁵/ 螻蛄\n52. 蝶、蜨 /iah⁸/ 蝴蝶\n53. 山螟 /suan¹ mê¹/ 蜻蜓\n54. 米龜 /bhi² gu¹/ 米象，蛀食稻穀、麥粒等米糧爲生。\n55. 蛀蟲 /zu³ tang⁵/\n56. 蛓毛蟲 /ci³ mo⁵ tang⁵/ 毛毛蟲\n57. 流鼻螺 /lao⁵ pin⁷ lê⁵/ 蝸牛\n58. 戶蠅 /hao⁵ sing⁵/ 蒼蠅\n59. 枯蠅 /gao¹ sing⁵/ 介殼蟲\n60. 蠓、蚊 /mang²/\n61. 蝨母 /sag⁴ bho²/ 蝨子\n62. 曱甴、虼蚻 /ga¹ zuah⁸/ 蟑螂\n63. 蜈蜞 /ghao⁵ ki⁵/ 水蛭，喜歡吸血人畜血液。\n\n### 🐳水產(zui² suan²)\n\n1. 䭕水魚 /zian² zui² hu⁵/ 淡水魚\n2. 鹹水魚 /giam⁵ zui² hu⁵/ 海水魚\n3. 刣魚 /tai⁵ hu⁵/ 宰魚\n4. 魚春 /hu⁵ cung¹/ 魚卵。屈大均《廣東新語》：「粵方言凡禽魚卵皆為春。唐時吳君貢魚春子，即魚子也。」 \n5. 魚鱗 /hu⁵ lang⁵/\n6. 魚鰾 /hu⁵ pio⁶/\n7. 魚鰓 /hu⁵ ci¹/\n8. 魚刺 /hu⁵ ci³/\n9. 鯁 /gên²/ 魚刺在喉\n10. 馬鮫 /mê² ga¹/\n11. 鯧 /cion¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%209.png)\n\n12. 鰇魚 /riu⁵ hu⁵/ 魷魚\n13. 墨斗 /bhag⁸ dao²/、/mag⁸ dao²/ 墨魚\n14. 絲丁魚 /si¹ dêng⁶ hu⁵/ 龍頭魚、硬魚、橂魚(殿魚)、豆腐魚\n15. 狗母魚 // 蝦虎魚、狗魽仔魚、九甘魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2010.png)\n\n16. 白目噯 /ain²/\n17. 狗母囝 // 身體透明，似魩仔鱼，有淡水和海水兩種\n18. 鰻魚 /muan⁵ hu⁵/\n19. 花仙魚 /hoi¹ siang¹ hu⁵/ 鮐魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2011.png)\n\n20. 鸚哥魚 /êng¹ go¹ hu⁵/ 洛神項鰭魚、紅姑娘、紅新娘、碼頭魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2012.png)\n\n21. 癩瘑魚 /na³ go¹ hu⁵/、/lai³ go¹ hu⁵/ 多齒蛇鯔，俗稱「那哥魚」，常用於製魚丸。\n22. 娘愛魚 /nion⁵ ain¹ hu⁵/ 泥猛魚、褐篮子鱼、臭肚鱼。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2013.png)\n\n23. ䷀囝 /dêg⁸ gian²/ 又稱迪仔、綠鰭馬面魨、剝皮魚。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2014.png)\n\n24. 䱛囝 /oig⁸ gian²/ 䱛仔、䱛魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2015.png)\n\n25. 金龍䱛 /gim¹ lêng⁵ oig⁸/ 金龍魚、黃花魚，狀似䱛魚但個頭大、嘴圓、體黃。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2016.png)\n\n26. 福壽魚 /hog⁴ siu⁶ hu⁵/ 羅非魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2017.png)\n\n27. 鮭魚 /guai¹ hu⁵/ 河魨，俗稱「乖魚」，常指黃鰭東方魨。\n28. 黃牆 /ng⁵ cion⁵/ 黃鰭鯛\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2018.png)\n\n29. 軟甘 /nng² gang¹/ 杜氏鰤、油甘，體側有黃色縱帶。 \n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2019.png)\n\n30. 沙尖 /sua¹ ziam¹/ 多鱗鱚、沙鯪、北方稱沙丁魚。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2020.png)\n\n31. 龍箭 /lang⁷ zin⁷/ 鯪魚 ，淡水魚，可用於做罐頭魚。\n32. 石剎 /zio² sag⁴/ 又稱烏雞，松鯛。\n33. 淡角魚 /dam⁶ gag⁴ hu⁵/ 鯒魚、辮子魚\n34. 烏魚 /ao¹ hu⁵/ 又稱烏頭，鯔魚。\n35. 烏前魚 /ao¹ zain⁵ hu⁵/\n36. 塗虱 /tao⁵ sag⁴/ 鬍子鯰\n37. 龍舌 /lêng⁵ zi²/ 龍利魚\n38. 巴浪 /ba¹ lang¹/ 藍圓鯵\n39. 鯇魚 /uang² hu⁵/ 草魚\n40. 姑魚 /gao¹ hu⁵/ 金色小沙丁魚\n41. 鯽魚 /zig⁴ hu⁵/\n42. 秋刀魚 /ciu¹ do¹ hu⁵/\n43. 紅目鰱 /ang⁵ mag⁸ liang⁵/ 紅目大眼鯛\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2021.png)\n\n44. 田鱔 /cang⁵ cuan⁶/ 鱔魚、黃鱔\n45. 白帶魚 /bêh⁸ dua³ hu⁵/ 鞭魚、裙帶魚、海刀魚\n46. 鰐魚 /ngag⁸ hu⁵/\n47. 鯊魚 /sua¹ hu⁵/\n48. 鯨魚 /kêng⁵ hu⁵/\n49. 紅哥鯉 /ang⁵ go¹ li²/ 金線魚\n50. 蝦 /hê⁵/\n51. 蟹 /hoi⁶/\n52. 三目蠘 /san¹ mag⁸ cih⁸/ 紅星梭子蟹、三目蟹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2022.png)\n\n53. 海哲 /hai² diag⁴/\n54. 蠔、蚝、蚵 /o⁵/ 牡蠣\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2023.png)\n\n55. 紅肉 /ang⁵ nê²/ 紅肉藍蛤\n56. 蚶 /ham¹/\n57. 蜆 /hain⁶/\n58. 青匙 /cên¹ si⁵/ 綠殼菜蛤、翡翠貽貝\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2024.png)\n\n59. 花蛤 /hoi¹ gab⁴/ 菲律賓簾蛤、花甲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2025.png)\n\n60. 車白 /cia¹ bêh⁸/ 文蛤，邊緣弧度較花蛤圓。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2026.png)\n\n61. 青蛤 /cên¹ gab⁴/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2027.png)\n\n62. 毛蚶 /mo⁵ ham¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2028.png)\n\n63. 薄殼 /bo² kag⁴/ 尋氏肌蛤、海蛔、海瓜子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2029.png)\n\n64. 指甲螳 /zain² gah⁴ tang⁵/ 又稱指甲蚌hong²，蟶sêng³子。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2030.png)\n\n65. 田螺 /cang⁵ lê⁵/\n66. 尖螺 /ziang¹ lê⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2031.png)\n\n### 🌾 蔬菜(so¹ cai³)\n\n1. 五穀 /ngao⁶ gag⁴/\n2. 稻 /diu⁶/\n3. 粟 /cêg⁴/ 稻粒\n4. 麥 /mê²/\n5. 秫米 /zu² bhi²/ 糯米\n6. 薏米 /in³ bhi²/\n7. 薏仁 /in³ ring⁵/ 玉米\n8. 蕃薯 /huang¹ zu⁵/、/hang¹ zu⁵/\n9. 馬鈴薯 /mê² lêng¹ zu⁵/ 土豆\n10. 黃豆 /ng⁵ dao⁷/ 大豆、菽\n11. 綠豆 /lê² dao⁷/\n12. 烏豆 /ao¹ dao⁷/ 黑豆\n13. 赤豆 /ciah⁴ dao⁷/ 紅小豆\n14. 荷目豆 /ho⁵ mag⁸ dao⁷/ 荷蘭豆、豌豆\n15. 地豆 /di⁷ dao⁷/ 花生\n16. 豆仁 /dao⁷ ring⁵/ 花生米\n17. 油麻 /iu⁵ mua⁵/ 芝麻\n18. 菜豆 /cai³ dao⁷/ 常指四季豆\n19. 茄 /gio⁵/\n20. 苦瓜 /kao² goi¹/\n21. 角瓜 /gag⁴ goi¹/ 稜角絲瓜\n22. 秋瓜 /ciu¹ goi¹/ 絲瓜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2032.png)\n\n23. 嬭瓜、奶瓜 /nê¹ goi¹/ 木瓜\n24. 蓮藕 /nain⁵ nao⁶/\n25. 菠薐菜 /boi¹ lêng⁵ cai³/ 菠菜\n26. 蕹菜 /êng³ cai³/ 空心菜\n27. 春菜 /cung¹ cai³/ 長葉芥菜\n28. 菜花 /cai³ hoi¹/ 花椰菜\n29. 芥菜 /gua³ cai³/ 大芥菜、包心芥菜\n30. 芥藍 /gêg⁴ na⁵/\n31. 菜頭 /cai³ tao⁵/ 白蘿蔔\n32. 紅菜頭 /ang⁵ cai³ tao⁵/ 紅蘿蔔\n33. 薺蔥、錢蔥 /zin⁵ cang¹/ 荸薺\n34. 韭菜 /gu² cai³/\n35. 芫荽 /iang¹ sui¹/ 香菜\n36. 芳菜 /pang¹ cai³/\n37. 厚合 /gao⁶ hah⁸/ 厚皮菜、莙薘菜、葉用甜菜\n38. 九層塔 /gao² zang⁵ tah³/ 金不換、羅勒\n39. 萵菜 /oi¹ cai³/ 皺葉萵苣、生菜\n40. 劍菜 /giam³ cai³/ 油麥菜\n41. 上海青 /siang⁶ hai² cên¹/ 青菜的一種\n42. 芹菜 /king⁵ cai³/\n43. 津白 /gian¹ bêh⁸/ 又稱紹菜、黃芽白，天津盛產，是大白菜的一種。以下是大白菜的不同品種。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2033.png)\n\n    天津大白菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2034.png)\n\n    大白菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2035.png)\n\n    娃娃菜\n\n44. 高麗菜 /go¹ lê⁵ cai³/ 捲心菜、包菜、結球甘藍\n45. 菜花 /cai³ hoi¹/ 花椰菜\n46. 茼蒿 /dang⁵ o¹/\n47. 枸杞菜 /gao² gi² cai³/\n48. 真珠菜 /zing¹ zu¹ cai³/ 珍珠花菜、白苞蒿\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2036.png)\n\n49. 薟椒 /hiam¹ tsio¹/ 辣椒\n50. 生果 /cên¹ goi²/ 水果\n51. 荔果 /nai⁶ goi²/ 荔枝\n52. 龍眼 /nging⁵ ain²/\n53. 桑垂 /siong¹ sui⁵/ 桑葚\n54. 草莓 /cao² bhoi⁵/\n55. 刺菠 /ci³ bo¹/ 蛇莓、覆盆子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2037.png)\n\n56. 弓蕉 /gêng¹ zio¹/ 香蕉\n57. 米蕉 /bhi² zio¹/\n58. 鳥梨 /ziao² lai⁵/\n59. 檨 /suain⁷/ 芒果\n60. 菝囝 /bag⁸ gian²/ 番石榴\n61. 西瓜 /si¹ goi¹/\n62. 香櫞 /hion¹ ng⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2038.png)\n\n63. 柚 /iu⁷/\n64. 柑 /gan¹/ 柑橘\n65. 桔 /gig⁴/\n66. 橙 /cêng⁵/\n67. 菠蘿 /bo¹ lo⁵/\n68. 油甘 /iu⁵ gam¹/ 餘甘果，先苦後甜，齒留餘甘。\n69. 番茄 /huang¹ gio⁵/\n70. 青竹梅 /cên¹ dêg⁴ bhoi⁵/\n71. 李 /li²/\n72. 棗 /zo²/\n73. 蔗 /zia³/ 甘蔗\n\n### 🌿草藥 /cao² ioh⁸/\n\n1. 艾 /hia³/ 艾草 \n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2039.png)\n\n2. 草粿草 /cao² goi² cao²/ 仙草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2040.png)\n\n3. 策草 /cêg⁴ cao²/ 又稱抹(bhuah⁴)草、廣防風、防風草，甲子地區神位常年插此草。策 ，大概是指其像馬鞭。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2041.png)\n\n4. 青菭 /cên¹ ti⁵/ 青苔\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2042.png)\n\n5. 薄荷 /bo⁵ ho³/、/bon⁵ hon³/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2043.png)\n\n6. 金銀花 /gim¹ nging⁵ hoi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2044.png)\n\n7. 午時花 /ngao² si⁵ hoi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2045.png)\n\n8. 四季春 /si³ kui³ cung¹/ 四季春花\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2046.png)\n\n9. 葉下紅 /hio² ê⁶ ang⁵/ 一點紅\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2047.png)\n\n10. 臭草花 /cao³ cao² hoi¹/ 五色梅、馬纓丹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2048.png)\n\n11. 飛天蜈蚣 /boi¹ tin¹ ghê⁵ gang¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2049.png)\n\n12. 金雞脫殼 /gim¹ goi¹ tug⁴ kag⁴/\n13. 路跤菊 /lao⁷ ka¹ gêg⁴/ 路邊菊\n14. 臘裏葉 /lah⁸ li² hioh⁸/ 金邊紅桑\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2050.png)\n\n15. 芒囝筍 /mang⁵ gian² sung²/ 芒草的嫩芽\n16. 竹菜 /dêg⁴ cai³/ 竹葉草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2051.png)\n\n17. 葛菜 /guah⁴ cai³/ 野葛菜，可食。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2052.png)\n\n18. 烏規菜 /ao¹ gui¹ cai³/ 龍葵\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2053.png)\n\n19. 豬母菜 /du¹ bho² cai³/ 馬齒莧\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2054.png)\n\n20. 刺莧 /ci³ hain⁷/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2055.png)\n\n21. 苦刺 /kao² ci³/ 白簕\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2056.png)\n\n22. 苦草 /kao² cao²/ 豨薟草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2057.png)\n\n23. 兩公根 /liang² gong¹ ging¹/ 崩大碗\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2058.png)\n\n24. 鋪地錦 /pao¹ di⁷ gim²/ 滿天星\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2059.png)\n\n25. 雞屎藤 /goi¹ sai² ding⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2060.png)\n\n26. 伸筋藤 /cung¹ ging¹ ding⁵/ 蔓九節\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2061.png)\n\n27. 無頭藤 /bho⁵ tao⁵ ding⁵/ 寄生於其他植物之上\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2062.png)\n\n28. 酒甕囝 /ziu² ang³ gian²/\n29. 盐酸鸡囝 /iam⁵ sng¹ goi¹ gian²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2063.png)\n\n30. 見笑草 /giang³ siao³ cao²/ 含羞草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2064.png)\n\n31. 燈籠草 /dêng¹ lang⁵ cao²/ 其果子稱爲「姑娘果」\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2065.png)\n\n32. 車前草 /cia¹ zain⁵ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2066.png)\n\n33. 馬鞭草 /bhê² bin¹ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2067.png)\n\n34. 蟋蟀草 /tig⁴ sug⁴ cao²/ 烏龍草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2068.png)\n\n35. 蒲公英 /pu⁵ gong¹ êng¹/\n36. 鸭舌草 /ah³ zih⁸ cao²/ 苦菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2069.png)\n\n37. 魚腥草 /hu⁵ co³ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2070.png)\n\n38. 益母草 /iah⁴ bho² cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2071.png)\n\n39. 龍膽草 /lêng⁵ dan² cao²/ 苦地膽草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2072.png)\n\n40. 奶汁草 /nê¹ zab⁴ cao²/ 乳汁草，草折斷會有白色液體流出。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2073.png)\n\n41. 虎耳草 /haon² hin⁶ cao³/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2074.png)\n\n42. 大號奶汁草 /dua⁷ ho⁷ nê¹ zab⁴ cao³/ 蠔割草、飛揚草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2075.png)\n\n43. 貓毛兒 /ngiao¹ mo⁵ ri⁵/ 金絲草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2076.png)\n\n44. 貓鬚草 /ngiao¹ ciu¹ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2077.png)\n\n45. 鹅囝香 /gho⁵ gian² hiang¹/ 鹅不食草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2078.png)\n\n46. 白花蛇舌草 /bêh⁸ hoi¹ zua⁵ zih⁸ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2079.png)\n\n47. 白花蟛蜞草 /bêh⁸ hoi¹ pen⁵ ki⁵ cao²/、/bêh⁸ hoi¹ mua⁵ ki⁵ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2080.png)\n\n48. 四方枝苦楝 /si³ bang¹ gi¹ kao² nai⁷/ 鬼針草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2081.png)\n\n49. 苦楝 /kao² nai⁷/ 苦楝樹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2082.png)\n\n50. 挨礱被哺 /oi⁵ lang⁵ bi⁶ bu⁶/ 磨盤草、磨礱草、挨礱地堵，其果實似磨盤和礱。礱，磨谷農具。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2083.png)\n\n### 🏮時節(si⁵ zoih⁴)\n\n1. 今年 /gim¹ ni⁵/\n2. 舊年 /gu⁷ ni⁵/ 去年\n3. 前年 /zain³ ni⁵/、/zung³ ni⁵/\n4. 下年 /ê⁶ ni⁵/ 明年\n5. 熱天時 /ruah⁸ tin¹ si⁵/ 夏天\n6. 寒天時 /guan⁵ tin¹ si⁵/ 冬天\n7. 凝天時 /ngang⁵ tin¹ si⁵/ 冬天\n8. 春夏秋冬 /cung¹ hê⁶ ciu¹ dang¹/\n9. 老歷 /lao⁶ lê²/ 農曆\n10. 新曆 /sing¹ lê²/ 公曆\n11. 今日 /gim¹ rig⁸/\n12. 明日 /mêng⁵ rig⁸/\n13. 今旦日 /gian² rig⁸/ 今天\n14. 明旦日 /man³ rig⁸/ 明天\n15. 明眠起 /ma³ mng⁵ ki²/ 明天\n16. 昨日 /za¹ rig⁸/\n17. 前日 /zain⁵ rig⁸/、/zoh⁸ rig⁸/\n18. 後日 /ao⁶ rig⁸/\n19. 大前日 /dua⁷ zain⁵ rig⁸/、/dua⁷ zoh⁸ rig⁸/\n20. 大後日 /dua⁷ ao⁶ rig⁸/\n21. 天光 /tin¹ gng¹/ 天亮\n22. 透早 /tao³ za²/ 黎明\n23. 眠起 /mng⁵ ki²/ 早晨\n24. 日時 /rig⁸ si⁷/ 白天\n25. 早晝 /za² dao³/ 上午\n26. 中晝 /dêng¹ dao³/ 中午\n27. 中晝時 /dêng¹ dao³ si⁵/ 中午\n28. 下晝 /ê⁶ dao³/ 下午\n29. 下旰 /ê⁶ gua³/ 下午\n30. 暗頭 /am³ tao⁵/ 傍晚\n31. 暗頭時 /am³ tao⁵ si⁵/ 傍晚\n32. 下昏 /ê⁶ hng⁵/ 晚上\n33. 下昏時 /ê⁶ hng⁵ si⁵/、/êng² si⁵/ 晚上\n34. 下昏囝 /êng² gian²/ 晚上\n35. 暗時 /am³ si⁷/ 晚上\n36. 暝時、夜時 /mê⁵ si⁷/ 晚上\n37. 暝昏、夜昏 /mê⁵ hng⁵/ 晚上\n38. 暝昏時、夜昏時 /mê⁵ hng⁵ si⁵/、/mêng² si⁵/ 晚上\n39. 暝昏囝 /mêng² gian²/ 晚上\n40. 半暝、半夜 /buan³ mê⁵/\n41. 時分秒 /si⁵ hung⁵ miao²/\n42. 個字 /gai⁵ ri⁷/ 五分鐘\n43. 兩個字久 /no⁶ gai⁵ ri⁷ gu²/ 十分鐘\n44. 頭前 /tao⁵ zain⁵/ 之前\n45. 頭陣 /tao⁵ zung⁵/ 剛才\n46. 下 /ê⁶ miag⁸/、/ê⁶ mig⁸/ 剛才\n47. 一頃 /zêg⁸ kuang³/ 一會兒\n48. 一頃頭 /zêg⁸ kuang³ tao⁵/ 一下子\n49. 煞尾 /suah⁴ bhoi²/ 最後\n50. 今 /dan¹/ 現在\n51. 逐日 /dag⁸ rig⁸/ 每天\n52. 逐暝 /dag⁸ mê⁵/ 每晚\n53. 通日 /tang³ rig⁸/ 整天\n54. 半日 /buan³ rig⁸/\n55. 隔日 /gêh⁴ rig⁸/\n56. 隔暝、隔夜 /gêh⁴ mê⁵/\n57. 別日 /bag⁸ rig⁸/ 改天\n58. 即時 /ziag⁴ si⁵/ 立刻、馬上\n59. 平常時 /pêng⁵ sion⁵ si⁵/ 平時\n60. 一日通通 /zêg⁸ rig⁸ tang³ tang³/ 一整天\n61. 七早八早 /cig⁴ za² boih⁴ za²/ 一大早\n62. 七早蒙流 /cig⁴ za² mo⁵ liu⁵/ 一大早\n63. 烏暗天地 /ao¹ am³ tin¹ di¹/ 天昏地暗\n64. 立春 /lib⁸ cung¹/\n65. 雨水 /u² sui²/\n66. 驚蟄 /gêng¹ dêg8/\n67. 春分 /cung¹ hung¹/\n68. 清明 /cêng¹ mêng⁵/\n69. 谷雨 /gog⁴ u²/\n70. 立夏 /lib⁸ hê⁶/\n71. 小滿 /sio² muan²/\n72. 芒種 /mang⁵ zêng²/\n73. 夏至 /hê⁶ zi³/\n74. 小暑 /siao² su²/\n75. 大暑 /dai⁶ su²/\n76. 立秋 /lib⁸ ciu¹/\n77. 處暑 /cu³ su²/\n78. 白露 /bêh⁸ lao⁷/\n79. 秋分 /ciu¹ hung¹/\n80. 寒露 /guan⁵ lao⁷/\n81. 霜降 /sang¹ gang³/\n82. 立冬 /lib⁸ dang¹/\n83. 小雪 /siao² soh⁴/\n84. 大雪 /dai⁶ soh⁴/\n85. 冬至 /dang¹ zi³/\n86. 小寒 /siao² hang⁵/\n87. 大寒 /dai⁶ hang⁵/\n88. 時年八節 /si⁵ ni⁵ boih⁴ zoih⁴/ 一年四季八個節，最早的八節指立春、春分、立夏、夏至、立秋、秋分、立冬和冬至。而在甲子時年八節指元宵、春分、清明、五月節、七月半、秋分、八月半、冬節，過此八節要拜祖，除春分、秋分外的節還需要拜神。\n    - 四時，四季、春夏秋冬。\n    - 年，甲骨文象人負禾之形，會穀物豐收之意，古時禾穀一年一熟，於是「年」被（引申）用作周年之年。【爾雅•釋天】夏曰歲，商曰祀，周日年，唐虞曰載。古時一度流行歲星（即木星、朱比特星，公轉週期爲 398.88 天）紀年，故一年又稱一歲。\n    - 時年，一年四季。\n    - 節，中國曆法把一年分為二十四段，每段的開始即爲節。早期只有春分、秋分、夏至、冬至四節，後又加入立春、立夏、立秋、立冬，形成八節，再來後逐漸形成了二十四節。「節」早期是天文曆法上的概念，與氣候相關，後又逐漸加入了紀念或慶祝的元素。\n89. 元宵節 /nguang⁵ siao¹ zoih⁴/\n90. 公忌節 /gong¹ gi⁷ zoih⁴/ 春分和秋分，祭拜先祖，但不拜神。\n91. 清明節 /cêng¹ mêng⁵ zoih⁴/\n92. 五月節 /ngao⁶ ghoih⁸ zoih⁴/ 端午節\n93. 七月半 /cig⁴ ghoih⁸ buan³/ 中元節、鬼節\n94. 八月半 /boih⁴ ghoih⁸ buan³/ 中秋節\n95. 冬節 /dang¹ zoih⁴/ 冬至節的簡稱。\n96. 廿九暝、廿九夜 /rig⁸ gao² mê⁵/ 除夕（小月）\n97. 三十暝、三十夜 /san¹ zab⁸ mê⁵/ 除夕（大月）\n98. 春節 /cung¹ zoih⁴/\n99. 重陽 /ciang⁵ iang⁵/、/dêng⁵ iang⁵/\n100. 國慶節 /gog⁴ kêng³ zoih⁴/\n101. 勞動節 /lao⁵ dong⁶ zoih⁴/\n102. 婦女節 /hu⁶ nng² zoih⁴/\n103. 兒童節 /ri⁵ tong⁵ zoih⁴/\n104. 教師節 /ga³ su¹ zoih⁴/\n105. 做節 /zo³ zoih⁴/ 過節日\n106. 做壽 /zo³ siu⁶/ 過壽辰\n107. 做生日 /zo³ sên¹ rig⁸/ 過生日\n108. 公忌 /gong¹ gi⁷/ 先祖忌日\n109. 拜公忌 /bai³ gong¹ gi⁷/ 在忌日祭拜先祖\n110. 拜祖 // 祭拜先祖\n111. 拜老爺 // 拜神\n112. 假日 /gia² rig⁸/\n113. 放假 /bang³ gia²/、/bang³ gian²/\n114. 暑假 /su² gia²/\n115. 寒假 /hang⁵ gia²/\n\n### 🌀天時(tin¹ si⁵)\n\n1. 晴 /zên⁵/ 晴朗\n2. 出日 /cug⁴ rig⁸/ 太陽出來了\n3. 透堂白日 /tao³ dng⁵ bêh⁸ rig⁸/ 大白天\n4. 烏陰天 /ao¹ im¹ tin¹/ 陰天\n5. 透風 /tao³ hong¹/ 刮大風\n6. 風颱 /hong¹ tai¹/ 颱風\n7. 南風天 /nang¹ hong¹ tin¹/ 刮南風，濕氣加重\n8. 轉南風 /dng² nang¹ hong¹/ 南風天來了\n9. 透南風 /tao³ nang¹ hong¹/ 刮南風，伍佰有一 Live 同名。\n10. 蒙煙天 /mong⁵ iang¹ tin¹/ 霧霾天\n11. 落雨 /lo² hao⁶/ 下雨\n12. 一陣雨 /zêg⁸ zung⁵ hao⁶/\n13. 日頭雨 /rig⁸ tao⁵ hao⁶/ 一邊下雨，一邊出太陽\n14. 烏寒雨 /ao¹ guan⁵ hao⁶/ 天時烏陰落寒雨\n15. 爍焰 /sih⁴ iam⁶/ 閃電\n16. 敲雷 /ka³ lui⁵/ 打雷\n17. 冷空氣 /lêng² kong¹ ki⁷/\n18. 落雪 /lo² soh⁴/ 下雪\n19. 落雹 /lo² pag⁸/ 下冰雹\n20. 旱 /uan⁶/ 乾旱\n21. 寒 /guan⁵/ 寒冷\n22. 冷 /lêng²/ 寒冷\n23. 凝 /ngang⁵/ 寒冷\n24. 熱 /ruah⁸/\n25. 翕熱 /hib⁴ ruah⁸/ 悶熱\n26. 乾燥 /gang¹ cao³/\n27. 濕 /sib⁴/ 濕潤\n28. 涼 /liang⁵/ 涼爽\n\n### 🌛天文(tiang¹ bhung⁵)\n\n1. 天頂 /tin¹ dêng²/ 天上\n2. 日頭 /rig⁸ tao⁵/ 太陽\n3. 蝕日 /sih⁸ rig⁸/ 日食\n4. 狗齧日 /gao² na² rig⁸/ 天狗食日\n5. 西照日 /sai¹ zio³ rig⁸/ 夕陽\n6. 月娘 /ghoih⁸ nion⁵/ 月亮\n7. 月眉 /ghoih⁸ bhai⁵/ 弦月\n8. 蝕月 /sih⁸ ghoih⁸/ 月食\n9. 河溪 /ho⁵ koi¹/ 銀河、天河\n10. 落屎星 /lo² sai² cên¹/ 流星\n11. 星宿 /cên¹ siu³/\n\n### ⛰️地理(di⁷ li²)\n\n1. 中央 /diong¹ iang¹/ 中間\n2. 內底 /lai⁶ doi²/ 裏面\n3. 外口 /ghua⁷ kao²/、/la¹ kao²/ 外面\n4. 頭頂 /tao⁵ dêng²/ 上面\n5. 下跤 /ê⁶ ka¹/ 下面\n6. 下底 /ê⁶ doi²/ 下面\n7. 正手爿 /ziang³ ciu² bain⁵/ 左邊\n8. 倒手爿 /do³ ciu² bain⁵/ 右邊\n9. 頭前 /tao⁵ zain⁵/ 前面\n10. 後底 /ao⁶ doi²/ 後面\n11. 後壁 /ao⁶ biah⁴/ 後面\n12. 對面 /dui³ ming⁷/\n13. 隔壁 /gêh⁴ biah⁴/\n14. 鄰近 /lim¹ ging⁶/\n15. 塗跤 /tao⁵ ka¹/\n16. 番爿 /huang¹ bain⁵/\n17. 北爿 /bag⁴ bain⁵/\n18. 東南西北 /dang¹ nam⁵ sai¹ bag⁴/\n19. 地盤 /di⁷ buan⁵/\n20. 領域 /nia² oig⁸/\n21. 境內 /gêng² lai⁶/\n22. 世界 /si³ gai³/\n23. 宇宙 /u² diu²/\n24. 全球 /cuang¹ giu⁵/\n25. 天涯 /tiang¹ ngai⁵/\n26. 山頂 /suan¹ dêng²/\n27. 山跤 /suan¹ ka¹/\n28. 外地 /ghua⁷ dê³/\n29. 本地 /bng² di⁷/\n30. 別地 /bag⁸ dê³/ 外地\n31. 別地地 /bag⁸ di⁷ dê³/ 外地\n32. 塗 /tao⁵/ 泥\n33. 塗膏 /tao⁵ go¹/ 泥巴\n34. 石頭 /zioh⁸ tao⁵/\n35. 田園 /cang⁵ hng⁵/\n36. 溪墘 /koi¹ gin⁵/ 溪邊\n37. 草埔 /cao² bao¹/ 草坪\n38. 崎 /gia⁶/ 小山坡\n39. 坑 /kên/ 山谷、溪谷。\n40. 嶺 /nia²/ 有路可通的山頂\n41. 岑 /ngim⁵/、/cam⁵/ 小而高的山\n42. 墟 /hu¹/ 大土山\n43. 壩 /ba³/ 沙灘、沙洲。\n44. 潭 /tam⁵/ 深水池\n45. 溪 /koi¹/\n46. 江 /gang¹/\n47. 河 /ho⁵/\n48. 湖 /ao⁵/\n49. 海 /hai²/\n50. 海拔 /hai² buag⁸/\n51. 洲 /ziu¹/\n52. 港 /gang²/\n53. 灣 /uang¹/\n54. 溝 /gao¹/\n55. 渠 /ku⁵/ 水道，特指人工開的河道。\n56. 浦 /pao²/ 水邊或江河入海處\n57. 澳 /o³/ 海邊彎曲且可停泊船隻的地方\n58. 汕 /suan³/ 河流沖刷或沖刷而積成的沙灘\n59. 汕頭 /suan¹ tao⁵/\n60. 汕尾 /suan³ bhoi²/\n61. 海湧 /hai² êng²/ 海浪。湧，波浪。\n62. 東濠湧 /dang¹ hao⁵ cong¹/ 地名，在廣州越秀。濠，溝渠。湧，河流分叉處。\n63. 湧泉相報 /iong³ zuan⁵ siang¹ bo³/ 湧，水冒出。\n64. 庭、埕 /dian⁵/ 院子、宽阔处\n65. 礦物 /kuang³ moih⁸/\n66. 化石 /hoi³ zioh⁸/\n67. 原油 /nguang¹ iu⁵/\n68. 燃料 /riang⁵ liao⁷/\n69. 金屬 /gim¹ siog⁸/\n70. 金銀財寶 /gim¹ nging⁵ cai⁵ bo²/\n71. 鋼鐵 /gng³ tih⁴/\n72. 蘇打 /so³ da²/ 英文 soda 的音譯，常指小蘇打，即碳酸氫鈉。\n73. 蘇州 /sao¹ ziu¹/\n74. 蠟 /la²/\n75. 硫磺 /liu⁵ ng⁵/\n76. 砒霜 /bi¹ sng¹/\n77. 砂石 /sua¹ zioh⁸/\n78. 大理石 /dai⁶ li² zioh⁸/\n79. 碳 /tuan³/\n80. 水銀 /zui² nging⁵/\n81. 水龍水 /zui² lêng⁵ zui²/ 自來水\n82. 地牛換肩 /di⁷ ghu⁵ uang⁷ gain¹/ 地震\n83. 許婆寮 /kao² pua⁵ liao⁵/ 今可和村\n84. 北輋 /bag⁴ sia⁵/ 今博社村\n85. 四捻石 /si³ niam³ zio²/ 四片石\n86. 甲子八景：六十甲子欄、潮來人字水、雙帆跨海島、五馬渡江邊、仙人踏石積、海甲蓮花山、西峯古寺、雷廟天堂。（《陸豐縣誌》卷之二疆域四 P21）\n87. 擎天石：位於甲秀書院的側邊的一塊巨石。《陸豐縣誌》記載：在甲子所北門內峙立聳拔高出雉堞丈余，中開一痕，俗謂雷打石。胡文烜銘其上曰：「天開甲子，巨石臨門，一聲霹靂，振動乾坤 ……」。字大如鬥，余銘苔蝕莫辨。（《陸豐縣誌》卷之二古蹟十二 ）\n88. 甲秀書院：甲秀書院位於陸豐縣甲子鎮北門內。甲秀書院建於明代，歷來為粵東文人會萃講學之所。至今院內仍保存著不少歷代的石碑石刻。解放后，人民政府在此興辦中學。\n89. 福源寺：座落於甲子鎮北郊雨亭路，原名「復元寺」，又稱「蓮花山草庵」。據傳，福源寺建於宋代。因歷史久遠，原址僅遺存牆基。1990年由光茂法師主持重建。經過10多年的建造，先後建成天王殿、大雄寶殿、觀音殿、地藏殿、鐘樓、鼓樓和禪房等，重塑了諸位菩薩聖像。寺區佔地面積1.2萬多平方米，建築面積3000多平方米。\n90. 南海夫人廟：位於甲子鎮城西社區環城路東。明萬曆元年（1573），李棠中舉後爲其妻卓氏而建的紀念祠，御史鄧練題匾「南海夫人」，故稱南海夫人廟。\n91. 烈士墓\n\n### 📐計量(goi³ liang⁶)\n\n1. 〇、零 /lêng⁵/、/lang⁵/\n2. 一、壹 /zêg⁸/、/ig⁴/\n3. 二、贰 /no⁶/、/ri⁶/\n4. 三、叁 /san¹/、/sam¹/\n5. 四、肆 /si³/、/su³/\n6. 五、伍 /ngao⁶/、/u²/\n7. 六、陆 /lag⁸/\n8. 七、柒 /cig⁴/\n9. 八、捌 /boih⁴/、/bag⁴/\n10. 九、玖 /gao²/、/giu²/\n11. 十、拾 /zab⁸/\n12. 百、佰 /bêh⁴/\n13. 千、仟 /cain¹/、/ciang¹/\n14. 萬 /mang⁷/\n15. 億 /êg⁸/\n16. 一二個 /zêg⁸ no² gai⁵/\n17. 二十六 /ri⁸ ab⁸ lag⁸/、/ri⁸ zab⁸ lag⁸/\n18. 廿六號 /rig⁸ lag⁸ ho⁷/ 二十六號\n19. 五十外個 /ngao⁶ zab⁸ ghua⁷ gai⁵/\n20. 一百空八 /zêg⁸ bêh⁴ kang³ boih⁴/ 一百零八\n21. 第一 /doi⁷ ig⁴/\n22. 第二 /doi⁷ ri⁶/\n23. 第三 /doi⁷ san¹/\n24. 一個人 /zêg⁸ gai⁵ nang⁵/\n25. 一爿花 /zêg⁸ bain⁵ hoi¹/ 一片花瓣\n26. 一蕊花 /zêg⁸ lui² hoi¹/ 一朵花\n27. 一葩花 /zêg⁸ pa¹ hoi¹/ 一朵花\n28. 一枝花 /zêg⁸ gi¹ hoi¹/\n29. 一縛花 /zêg⁸ ba² hoi¹/ 一束花\n30. 一叢樹 /zêg⁸ zang⁵ hoi¹/ 一棵樹\n31. 一簇頭毛 /zêg⁸ cog⁴ tao⁵ mo⁵/ 一撮頭髮\n32. 一粒糖 /zêg⁸ liab⁸ tng⁵/\n33. 一隻車 /zêg⁸ ziah⁴ cia¹/ 一輛車\n34. 一架車 /zêg⁸ gê³ cia¹/ 一輛車\n35. 一杯茶 /zêg⁸ boi¹ dê⁵/\n36. 一碗水 /zêg⁸ uan² zui²/\n37. 一喙水、一嘴水 /zêg⁸ cui³ zui²/ 一口水\n38. 一條弓蕉 /zêg⁸ diao⁵ gêng¹ zio¹/ 一條香蕉\n39. 一本書 /zêg⁸ bng² zu¹/\n40. 一枝手機 /zêg⁸ gi¹ ciu² gi¹/ 一隻手機\n41. 一枝鎖匙 /zêg⁸ gi¹ so² si⁵/ 一把鑰匙\n42. 一個銀 /zêg⁸ gai⁵ nging⁵/ 一塊錢\n43. 一領被 /zêg⁸ nia² poi⁶/ 一席被子\n44. 一個鋪 /zêg⁸ gai⁵ pao¹/ 一張床\n45. 一個鐘頭 /zêg⁸ gai⁵ zêng¹ tao⁵/ 一個小時\n46. 一副衫褲 /zêg⁸ hu³ san¹ kao³/ 一套衣服\n47. 一腰裙 /zêg⁸ io¹ gung⁵/ 一件裙子\n48. 一尾魚 /zêg⁸ bhoi² hu⁵/ 一條魚\n49. 一墩物件 /zêg⁸ dung¹ mi² gian⁶/ 一堆東西\n50. 一橛蔗 /zêg⁸ goi² zia³/ 一截甘蔗\n51. 一葩電火 /zêg⁸ pa¹ diang⁶ hoi²/ 一盞電燈\n52. 一跤箸、一腳箸 /zêg⁸ ka¹ du⁷/ 一隻筷子\n53. 一雙箸 /zêg⁸ sang¹ du⁷/ 一雙筷子\n54. 一腹火 /zêg⁸ bag⁴ hoi²/ 一肚子火\n55. 一脬屎 /zêg⁸ bu⁵ sai²/ 一坨屎\n56. 一脬尿 /zêg⁸ bu⁵ rio⁷/ 一泡尿\n57. 一逝路 /zêg⁸ zua⁷ lao⁷/ 一趟路\n58. 一丸塗 /zêg⁸ uang⁵ tao⁵/ 一團泥土\n59. 一過 /zêg⁸ goi³/ 一次\n\n### 🧭 指代(zi² toi³)\n\n1. 只 /zi²/ 這，近指。\n2. 許 /hi²/ 那，遠指。\n3. 者、這 /zê²/、/zia²/ 這，近指。\n4. 遐 /hê²/、/hia²/ 那，遠指。\n5. 底個 /di⁷ gai⁵/ 哪個\n6. 者個 /zê² gai⁷/、/zia² gai⁷/ 這個\n7. 遐個 /hê² gai⁷/、/hia² gai⁷/ 那個\n8. 怎樣 /za³ ion⁷/、/zion²/\n9. 乜樣 /mig⁴ ion⁷/ 怎樣\n10. 底樣 /di⁷ ion⁷/ 怎樣\n11. 怎生 /za³ sên¹/、/zai¹ sên¹/怎樣\n12. 怎樣生 /zion² sên¹/ 怎樣\n13. 怎樣然 /zion² ni⁵/、/zo⁵ ni⁵/ 怎麼、幹啥\n14. 怎樣麼 /zion² mo⁷/、/ziom²/\n15. 者樣 /zê² ion⁷/、/zion¹/\n16. 遐樣 /hê² ion⁷/、/hion¹/\n17. 者樣生 /zion¹ sên¹/ 這樣\n18. 遐樣生 /hion¹ sên¹/ 那樣\n19. 底搭 /di⁷ dah⁴/ 哪裏\n20. 者搭 /zê² dah⁴/ 這裏\n21. 遐搭 /hê² dah⁴/ 那裏\n22. 底地 /di⁷ dê³/ 哪裏\n23. 者地方 /zê² ding¹/ 這裏\n24. 遐地方 /hê² ding¹/ 那裏\n25. 底囝 /di⁷ gian²/ 哪兒\n26. 者囝 /zê gian²/ 這兒\n27. 遐囝 /hê² gian²/ 那兒\n28. 底人 /di⁷ nang⁵/、/diang⁶/、/di⁷ diang⁶/ 誰\n29. 底位 /di⁷ ui⁷/ 哪位\n30. 者位 /zê² ui⁷/\n31. 遐位 /hê² ui⁷/ 那位\n32. 底時 /di⁷ si⁵/ 什麼時候\n33. 底當時 /diang⁶ si⁵/ 什麼時候\n34. 者時 /zê² si⁵/\n35. 遐時 /hê² si⁵/ 那時\n36. 乜事 /mig⁴ su⁷/ 什麼事情\n37. 若㩼 /rioh⁸ zoi⁷/、/rua⁷ zoi⁷/ 多少\n38. 幾 /gui²/\n39. 豈是 /ka³ si⁷/ 是否是\n40. 敢是 /gam² si⁷/ 是否是\n\n### 🏃‍♀️動詞(dong⁶ su⁵)\n\n**第一部分**\n\n1. 會 /oi⁶/\n2. 無會、袂、𠀾 /bhoi⁶/ 不會\n3. 未 /bhoi⁷/ 沒有（事情還沒做）\n4. 無 /bho⁵/ 沒有\n5. 有 /u⁶/\n6. 好 /ho²/\n7. 毋好、孬 /mo²/ 不好\n8. 欲 /bhêh⁴/ 要\n9. 毋、唔 /m⁶/ 不要\n10. 欲毋 /bhêh⁴ m⁶/、/bhên⁶/ 要不要\n11. 愛 /ain³/ 要\n12. 無愛 /bho⁵ ain³/ 不要\n13. 毋愛、勿、嫑 /main³/ 不要\n14. 用 /êng⁶/ 需要\n15. 免 /miang²/ 不需要\n16. 肯 /kêng²/、/kiang²/ 願意\n17. 毋肯 /m⁶ kêng²/、/m⁶ kiang²/ 不願意\n18. 架勢是 /gê³ si³ si⁷/ 看這情形是。例如：舖關了，架勢是去做節了。 \n\n**第二部分 頭、喙**\n\n1. dag⁴ 頭 // 點頭\n2. 搖頭 /io⁵ tao⁵/\n3. 攲頭 /ki¹ tao⁵/ 歪頭\n4. 呾 /dan³/ 說\n5. 參詳 // 商量\n6. 學古 /oh⁴ gao²/ 講故事\n7. 罵 /mê⁷/\n8. 詏 /a³/ 爭辯\n9. 冤家 /uang¹ gê¹/ 吵架\n10. 恬 /diam⁷/ 閉嘴、安靜\n11. 咬 /ga⁶/\n12. 哺 /bao⁷/ 咀嚼\n13. 唵 /am⁶/ 將食物放進嘴巴\n14. 喷 /pung³/ 散射\n15. 啡痰 /pui³ tam⁵/ 吐痰\n16. 歕 /bung⁵/ 吹氣\n17. 嗾？ /zag⁸/ 呛到、岔到 \n\n**第三部分 目、心**\n\n1. 睇 /toi²/ 看\n2. 看詳睇 /kang³ siang⁵ toi²/ 仔細看\n3. 經心 /gêng¹ sim¹/ 用心\n4. 經心衋事 // 操心\n5. 經破頭腦 // 想破頭 \n\n**第四部分 手、跤**\n\n1. 揨 /dian¹/ 觸、碰\n2. 拍 /pah⁴/ 打\n3. 舂 /cêng⁵/ 用力打\n4. /dng⁷/ 打\n5. 刜 /hug⁴/ 揮、打\n6. 剚、倳 /sai⁷/ 打\n7. 抶 /diag⁴/ 用鞭、杖或竹板打。～手\n8. 摔 /sug⁴/ 抽打、鞭打\n9. 拗折 /a² zi²/ 折斷\n10. 盖 /kain³/ 由上往下覆。～頭\n11. 掃 /sao³/ 迅速掠過。～面\n12. 揞 /an¹/ 掩。～面\n13. diu³ 竹囝\n14. 擎 /gia⁵/ 舉、握、拿\n15. 𢭪 /kioh⁴/ 撿、拾\n16. 挈 /kioh⁸/ 取、拿\n17. 摜 /guan⁶/ 提\n18. 厾 /doh⁴/ 戳\n19. 割 /guah⁴/\n20. 殺 /suah⁴/\n21. 斬 /zam²/\n22. 斫 /dog⁴/ 剁\n23. 宰 /zai²/ 殺\n24. 刣 /tai⁵/ 殺\n25. 拭 /cig⁴/ 擦\n26. 濡 /ru⁵/ 用濕布擦或用拖把拖\n27. 爬 /bê⁵/ 搔(癢)\n28. 掊 /boi²/ 扒開\n29. 揂 /ciu⁵/ 拉引繩子\n30. 𠡒 /dui²/ 用力拉\n31. 捏 /dên⁶/ 掐\n32. 漱牙 /ciu³ ghê⁵/ 刷牙\n33. 跋 /buah⁸/ 摔倒\n34. 踏 /dah⁴/ 踩\n35. 踢 /tag⁴/\n36. 去 /ku³/、/ka³/\n37. 轉 /dng²/ 回來\n38. 綴 /doi³/ 跟著；縫合。\n39. 修理 /siu¹ li²/、/su¹ li²/\n40. 泊車 /pag⁴ cia¹/ 停車。泊，粵語音譯英文 park 得來，停車的意思。\n\n**第五部分**\n\n1. 曳、𤆬 /cua⁷/ 帶、領\n2. 娶 /cua⁷/ 取婦\n3. 徙 /sua²/ 移動\n4. 歇 /hiah⁴/ 放置、休息\n5. 煩惱 /huang⁵ lo²/ 擔心\n6. 相信 /sion¹ siang³/、/siang¹ sing⁷/ 相信\n7. 相輔 /sion³ hu⁶/ 幫忙\n8. 排比 /bai⁵ bi²/ 安排\n9. 含包 /ham⁵ bao¹/ 包含\n10. 拚頭前 /bian³ tao⁵ zain⁵/ 爭先\n11. 輸服 /su¹ hog⁸/ 佩服\n12. ䷀䷀ /dag⁴ nng⁷/ 浪費\n13. ䷀落 /ga¹ lao⁵/ 掉落\n14. 沕 /bhih⁴/ 躲藏\n15. 支 /zin¹/ 預付\n16. 圖賴 /tu⁵ tai²/ 耍賴\n17. 放惰 /bang¹ dua⁶/ 懶得\n\n### 🧜‍♀️形容(hêng⁵ iong⁵)\n\n1. 媠 /sui²/ 好、漂亮\n2. 雅 /ngia²/ 正、漂亮\n3. 生好 /sên¹ ho²/ 漂亮、好看\n4. 䆀 /bhai²/ 差、醜陋\n5. 好 /ho²/\n6. 痞、歹 /pai²/\n7. 大細 /dua⁷ soi³/ 大小\n8. 㩼少 /zoi⁷ zio²/ 多少\n9. 加加減減 /gê¹ gê¹ giam² giam²/ 多多少少\n10. 稀罕 // 稀少，罕見。\n11. 賤 /la¹ zuan⁷/ 繁多，低賤。物以稀為貴，多則賤。\n12. 猛慢 /mê² mang⁷/ 快慢、早晚。猛，快。\n13. 肥 /bui⁵/ 胖\n14. 肥腯肥腯 /bui⁵ tuh⁸ bui⁵ tuh⁸/ 胖嘟嘟\n15. 㾪 /sang²/ 瘦\n16. 㾪猴 /sang² gao⁵/ 瘦得跟猴子一樣\n17. 㾪脯皺 /sang² bao² niao³/ 又瘦又缺水又褶皺，形容飢瘦。\n18. 懸下 /guai⁵/ 高低\n19. 早 /za²/\n20. 晏 /uang³/ 晚\n21. 粗 /cao¹/\n22. 幼 /iun³/ 細\n23. 粗殘 /cao¹ cang⁵/ 粗魯\n24. 仔細 /zu² soi⁷/ 小心\n25. 芳 /pang¹/ 香\n26. 臭 /cao³/\n27. 僫 /oh⁴/ 困難\n28. 易 /goi⁷/ 容易\n29. 闊 /kuah⁴/ 寬\n30. 狹 /oih⁸/ 窄\n31. 光 /gng¹/ 亮\n32. 暗 /am³/\n33. 恬 /diam⁷/ 安靜\n34. 吵 /cao¹/ 吵鬧\n35. 吵吵著 /cao¹ cao¹ dioh⁴/ 吵吵鬧鬧的\n36. 飽 /ba²/\n37. 枵 /iao¹/ 餓\n38. 橂 /dain⁷/ 堅實、堅硬\n39. 軟 /nam³/ 軟弱。本字不明，訓用「軟」。\n40. 韌 /rung⁷/ 堅強；不容易斷裂。\n41. 脆 /cê³/ 脆弱；容易斷裂。\n42. 聰明 /cong¹ mêng⁵/\n43. 愚蠢 /ngo⁵ cung²/\n44. 戇 /gong³/ 愚笨\n45. 賰 /cung⁵/ 剩餘\n46. 欠 /kiam³/ 缺少\n47. 清 // 清晰、乾淨\n48. 雾 /bhu⁷/ 模糊\n49. 清氣 /cêng¹ ki³/ 乾淨\n50. 清氣相 /cêng¹ ki³ sion³/ 乾淨的樣子\n51. 垃圾 /lah⁴ sab⁴/ 骯臟\n52. 垃圾相 /lah⁴ sab⁴ sion³/ 骯臟的樣子\n53. 無沙無圾 /bho⁵ sua¹ bho⁵ sab⁴/ 一塵不染\n54. 灱 /da¹/ 乾燥\n55. 㴷 /dam⁵/ 濕潤\n56. 落雨㴷渧 /lo² hao⁶ dam⁵ di³/ 下雨濕漉漉的樣子\n57. 著 /dioh⁸/ 對、正確\n58. 毋著 /m⁷ dioh⁸/ 不對\n59. 錯 /co³/\n60. 熟 /sêg⁸/\n61. 生 /cên¹/ (瓜果等)未成熟\n62. 臭生 /cao³ cên¹/ 未煮熟或瓜果未成熟\n63. 臭酸 /cao³ sng¹/ 食物變質\n64. 黐黐 /ti¹ ti¹/ 黏稠\n65. 切要 /ciag⁴ iao³/ 要緊\n66. 無要緊 /bho⁵ iao³ ging²/ 不要緊\n67. 大扮\n68. 咸澀\n69. 力相 // 努力\n70. 惰 /duan⁶/ 懶惰\n71. 鬧熱 /nao⁶ ria²/ 熱鬧\n72. 活神 // 精神好，灵活\n73. 健 /gian⁷/ 身體好\n74. 碩㦙 /sêg⁴ ngo³/ 聰明和愚蠢\n75. 夠力 /gao³ lag⁸/ 厲害\n76. 夠強 /gao³ kiang³/ 厲害\n77. 夠衰 /gao³ soi¹/ 好慘\n78. 緊要 /ging² iao³/ 要緊\n79. 切要 /ciag⁴ iao³/ 要緊\n80. 癩瘑糜烂 //\n81. 枝毛小節、枝毛細節 // 無關緊要\n82. 偪側 /bêg⁴ cêg⁴/ 心中有氣，煩躁不安。\n83. 生分 /cên¹ hung⁷/ 陌生、疏遠\n84. 無影無跡 // 沒有根據\n85. 一生跪跋 /zêg⁸ sên¹ gui⁶ buah⁸/ 一生坎坷\n\n### 🐴副詞(hu³ su⁵)\n\n1. 好 /hoh⁴/ 表示程度深。例如：好㩼人 // 好多人。\n2. 死 /si²/ 表示程度特別深。例如：死㩼人 // 超級多人。死雅 // 超漂亮的。\n3. 若 /rua⁷/ 多麼。例如：若雅 // 多麼漂亮。\n4. 者 /zia²/ 這麼。例如：者細 // 這麼小。\n5. 遐 /hia²/ 那麼。例如：遐好 // 那麼好。\n6. 上好 /siang⁶ ho²/ 最好。\n7. 上減 /siang⁶ giam²/ 最少。\n8. 上加 /siang⁶ gê¹/ 最多。\n9. 較 /ga³/ 比較地。例如：伊較厲害 // 他比較厲害。\n10. 曾 /bhah⁴/ 曾經。例如：我毋曾來過 // 我不曾來過。\n11. 攏總 /long² zong²/ 全部。例如：攏總 100 銀 // 總共 100 塊。\n12. 煞 /sua⁵/ 竟然。例如：汝煞毋知 // 你竟然不知道。\n13. 顛倒 /ding¹ do³/ 反而。例如：六月顛倒來落雪 // 六月反而下起雪。\n14. 做蜀 /zo³ zêg⁸/ 一起。例如：做蜀 ka³ // 一起去。\n\n### 😲象聲詞(siang⁶ sian¹ su⁵)\n\n1. 喏 /no⁷/ 使人注意某物\n2. 囉、咯 /lo⁷/ 表示事情完成\n3. /hoin⁷/ 呼人\n4. /oin⁷/ 應人\n5. 喂 /uê⁷/ 打招呼。\n6. 啊 /a⁷/ 加強語氣\n7. 呀 /ia⁷/ 表示贊同\n8. 喔、噢 /o⁷/ 表示醒悟、驚訝或了解\n9. 哇 /ua⁷/ 表示驚訝\n10. 嗯 /ng⁷/ 表示同意或了解\n11. 哼 /hng²/ 表示不滿\n12. 哎、噯 /ai⁷/ 嘆氣\n13. 嗐 /hai⁷/ 嘆氣，比「哎」重些。\n14. /ho⁷～/、/o⁷～/ 長吁，含有一種無力、操碎了心的感覺。\n\n### 🙃俗語(siog⁸ ngo²)\n\n1. 哇浪、我卵 /ua² lang⁶/ 哇噻\n2. 我無閒 /ua² bho⁵ ain⁵/ 我沒空\n3. 走街邊 /zao² goi¹ bin¹/ 擺地攤\n4. 汝愛去怎樣麼緊 /lu² ain³ ku³ zion² mo⁷ ging⁷/ 你趕著去幹嗎\n5. 勿者樣生 /mai³ zion¹ sên¹/ 不要這樣\n6. 知收煞 /zai¹ siu¹ suah⁴/ 適時停手\n7. 毋別世代 /m⁶ bhag⁴ si³ dê³/ 不懂事\n8. 無變 /bho⁵ biang³/ 沒有辦法\n9. 堵著無變 /du² dioh⁴ bho⁵ biang³/ 碰到沒有辦法\n10. 無理路 /bho⁵ li² lao⁷/ 無道理。路，道。\n11. 無奈何 /bho⁵ da¹ ua⁵/ 無可奈何\n12. 無奈寫作不得已 /bho⁵ nai⁶ sia² zo³ bug⁴ dêg⁴ in²/ \n13. 呾死無會變 /dan⁵ si² bhoi⁶ bin³/ 冥頑不靈\n14. 橂過石部 /dain⁷ goi³ zio² bao⁶/ 比石頭還硬\n15. 三斗油麻倒無一粒落耳 /san¹ dao² iu⁵ mua⁵ do³ bho⁵ zêg⁸ liab⁴ lo² hin⁶/ 怎麼說都聽不進去\n16. 瀉衰人 /sia³ soi¹ nang⁵/ 丟人、令人蒙羞\n17. 見笑 /giang³ siao³/ 丟人、令人蒙羞\n18. 雙目囥著褲底 /sang¹ mag⁸ kng³ dioh⁴ kao³ doi²/ 看不見\n19. 無目睇 /bho⁵ mag⁸ toin³/ 不想看\n20. 鴨囝聽雷 /ah⁴ gian² tian¹ lui⁵/ 聽不懂\n21. 戅過隻鴨 /gong⁵ goi³ ziah⁴ ah⁴/ 比鴨子還戇\n22. 一樣糜飯飼千外樣人 /zêg⁸ ion⁷ moi⁵ bng⁷ ci⁷ cain¹ ghua⁷ ion⁷ nang⁵/ 社會人各種各樣\n23. 暗過魂宫 /am³ goi³ hung⁵ gêng¹/ 比陰間還暗\n24. 三更想，半暝反 /san¹ gên¹ sion⁶, buan³ mê⁵ huang²/ 思來想去，反反覆覆。\n25. 過跤事知歇 /goi¹ ka¹ su⁷ zai¹ hiah⁴/ 過去的事情就不要計較了\n26. 無會少禮 /bhoi⁶ siao² li²/ 不害臊\n27. 刣雞教猴 /tai⁵ goi¹ ga³ gao⁵/ 殺雞儆猴\n28. 勞生拚死 /lu⁵ sên¹ bian³ si²/ 拚死拚活\n29. 食呾會，躕人強 /ziah⁸ dan³ oi⁶, du⁵ nang⁵ kiang³/ 能吃會說還很頑皮\n30. 勿踟躕我 /mai³ di¹ du⁵ ua⁷/ 別纏我，使得我不知所措。\n31. 老過伯爺 /lao⁶ goi³ bêh⁴ ia⁵/ 比土地公還年長\n32. 平樣平樣 /pên⁵ ion⁷ pên⁵ ion⁷/ 一模一樣\n33. 假力洗茶渣 /gê² lag⁸ soi² dê⁵ za¹/ 該做的不做，做了不該做的。\n34. 死無命凝 /si² bho⁵ mian⁷ ngang⁵/ 冷死了\n35. 富到流油 /bu⁷ gao³ lao⁵ iu⁵/ 很富有\n36. 人熟禮毋熟 /nang⁵ sêg⁸ li² m⁶ sêg⁸/ 雖然人很熟，但還是要講禮。\n37. 熟人免行生禮 /sêg⁸ nang⁵ miang² gian⁵ cên¹ loi²/\n38. 千人千般苦，無人苦平樣 /cain¹ nang⁵ cain¹ buan¹ kao², bho⁵ nang⁷ kao² pên⁵ ion⁷/ 各有各的煩惱\n39. 蟹有橂奅，人有碩㦙 /hoi⁶ u⁶ dain⁷ pan³, nang⁵ u⁶ sêg⁴ nga³/ 有人聰明有人愚笨。橂，堅實。奅，中空。碩，學問高、聰明。㦙，愚笨。\n40. 鳥飛會落毛，人行有跤跡 /ziao² boi¹ oi⁶ lo² mo⁵, nang⁵ gian⁵ u⁶ ka¹ ziah⁴/ 做過了的事總會留痕跡\n41. 客情好過吊頷鬼 /kêh⁴ cêng⁵ ho² goi³ diao³ am⁶ gui²/ 吊死鬼熱情地勸人上吊好代替自己，比喻虛情假意。\n42. 貓兒無葷無著茨，鴨囝無粟無會過暝 /ngiao¹ ri⁵ bho⁵ hung¹ bho⁵ dioh⁴ cu⁷, ah⁴ gian² bho⁵ cêg⁴ bhoi⁶ goi³ mê⁵/ 小貓沒有葷菜就不在家，小鴨沒有稻粒就不過夜。\n43. 衰雞無會食粟 /soi¹ goi¹ bhoi⁶ ziah⁸ cêg⁴/ 如病雞般吃不下飯\n44. 無會死大破相 /bhoi⁶ si² dua⁷ pua³ sion³/ 不死也會頭破血流\n45. 十八棚頭做到透 /zab⁸ boih⁴ bên⁵ tao⁵ zo³ gao³ tao³/ 指每種事都嘗試，貶義。十八棚頭，指十八齣溫州南戲。\n46. 無跤蟹 /bho⁵ ga¹ hoi⁶/ 孤立無援\n47. 大細目 /dua⁷ soi³ mag⁸/ 偏心\n48. 平安當大趁 /pêng⁵ ang¹ dng¹ dua⁷ tang⁷/ 平安無疾就當作是大賺一筆了\n49. 大人彎，孥囝直 /dua⁷ nang⁷ uain¹, nao⁵ gian² dig⁸/ 大人說話拐彎抹角，小孩子則是直來直去。\n50. 錢囝毋使使大錢 /zin⁵ gian² m⁶ sai² sai² dua⁷ zin⁵/ 小錢不花，久了就得要花大錢了。\n51. 未學行，先學飛 /bhoi⁷ oh⁸ gian², sain¹ oh⁸ boi¹/ 還沒學走路就要學飛了，基礎未打好。\n52. 一人主張，毋如二人參詳 /zêg⁸ nang⁷ zu² ziang¹, m⁶ ru⁵ no⁶ nang⁷ cam¹ ciang⁵/ 自作主張不如多個人一起商量\n53. 通街市獵無 /tong¹ goi¹ ci⁶ lah⁸ bho⁵/ 整條街都找不到。獵，尋找。\n54. 喙尖舌囝利 /cui³ ziamvi/ 牙尖嘴利\n55. 九月狗吶日，無用諸娘理毋直 /gao² goi² gao² nah⁴ rig⁸, bho⁵ êng⁷ zu¹ nion⁵ li² m⁶ dig⁸/ 九月份開始晝短夜長，沒用的婦女家務事搞不定了。\n56. 茶薄人情厚，茶厚有禮貌 /dê⁵ bo² nang⁵ cêng⁵ gao⁶, dê⁵ gao⁶ u⁶ li² mao⁶/\n57. 三十歲無妻是孩童 /san¹ zab⁸ hoi³ bho⁵ ci¹ si⁶ hai⁵ tong⁵/\n58. 目汁是財，愈哭愈來 /mag⁸ zab⁴ si⁶ cai⁵, ru² kao³ ru⁶ lai⁵/\n59. 呾破無酒食 /dan³ pua³ bho⁵ ziu² ziah⁸/ 師傅教徒弟，徒弟設酒宴款待，師傅酒後授予秘方。之後徒弟不再宴請師傅。\n60. 軟過豆腐 /nam³ goi³ dao⁷ hu⁷/\n61. 車大炮 /cia¹ dua⁷ pao³/ 吹牛\n62. 樹大分椏，囝大分家 /ciu⁷ dua⁷ bng¹ a¹, gian² dua⁷ bng¹ ga¹/ \n63. 閒過仙 /ain⁵ goi³ siang¹/ 比神仙還閒\n64. 雙目望無一寸長 /sang¹ mag⁸ mo⁷ bho⁵ zêg⁸ cung³ dng⁵/ 鼠目寸光\n65. 一鼠二牛三虎四兔五龍六蛇七馬八羊九猴十雞十一狗十二豬 /ig⁴ cu² ri⁶ ghu⁵ san¹ haon² si³ tao³ ngao⁶ lêng⁵ lag⁸ zua⁵ cig⁴ bhê² boih⁴ ion⁵ gao² gao⁵ zab⁸ goi¹ zab⁸ ig⁴ gao² zab⁸ ri⁶ du¹/\n66. 差豬差狗，不如家己走 /cê¹ du¹ cê¹ gao², bug⁴ ru⁵ ga¹ gi⁷ zao²/ 求人不如求己\n67. 後生擔石，老人食藥 /hao⁶ sên¹ dan¹ zioh⁸, lao⁶ nang⁵ ziah⁸ ioh⁸/ 年少積勞，年老吃藥\n68. 疑心生暗鬼 /ghi⁵ sim¹ sên¹ am³ gui²/ 因多疑而產生各種幻覺和錯誤判斷\n69. 羊尾短短，遮毋著羊尻川 /ion⁵ bhoi² dê² dê², zia¹ m⁶ dioh⁴ ion⁵ ka¹ cng¹/ 自己的缺點尷尬能自己找個遮醜的就很好了，別去取笑別人的不堪。\n70. 愛母著刻苦 /ain³ bhao² dioh⁴ kag⁴ kao²/ 要老婆就要努力了\n71. 無好家神通外鬼 /bho⁵ ho² gê¹ sing⁵ tong¹ ghua⁷ gui²/\n72. How do you do，好事來堵 /hao³ su⁷ lai³ du²/ 嗨，要搞事情我不怕你。好事，喜歡搞事情。堵，應對、抵抗。\n73. 秋瓜棚下無好人 /ciu¹ goi¹ bên⁵ ê⁶ bho⁵ ho² nang⁵/ 秋瓜，絲瓜。\n74. 三跤椅囝毋知䆀 /san¹ ka¹ in² gian² m⁶ zai¹ bhai²/ 坐著少了一腿的椅子竟然不知道壞了，比喻身處困境而不自知。\n\n### 🤣歇後語(hiah⁴ ao⁶ ngo²)\n\n1. 柴目狗耳 — 假靈 /ca⁵ mag⁸ gao² hin⁶ — gê² lêng⁵/ 目雕的眼睛看不見，狗一般耳朵卻很靈，聽風是雨。\n2. 雞跤長鴨跤短 — 有懸下 /goi¹ ka¹ dng⁵ ah⁴ ka¹ dê² — u⁶ guain⁵ gê⁶/ 雞腳長，鴨腳短，有高有矮。\n3. 爐底碳 — 塊塊通 /lao⁵ doi² tuan³ — dê⁷ dê⁷ tang³/ 百事通\n4. 孥囝食奶 — 坐亭 /nao⁶ gian² ziah⁸ nê¹ — zê⁶ dêng⁵/ 亭，直。\n5. 菜頭面刺無血 — 面皮厚 /cai³ tao⁵ ming¹ ci³ bho⁵ hoih⁴ — ming¹ poi⁵ gao⁶/\n6. 褪褲放屁 — 假工夫 /tng³ kao³ bang³ pui³ — gê² gang¹ hu¹/\n7. 竹葉包沙 — 假壯 /dêg⁴ hio² bao¹ sua¹ — gê² zang³/ 壯，與「粽」諧音。\n8. 元宵燈籠 — 一肚火 /nguang⁵ siao¹ dêng¹ lang⁵ — zêg⁸ dao² hoi²/\n9. 半天吊燈籠 —四搭无向 /buan³ tin¹ diao³ dêng¹ lang⁵ — si³ dah⁴ bho⁵ hiang³/\n10. 青暝睒鏡 — 無望 /cên¹ mên⁵ iam² gian³ — bho⁵ mo⁷/\n11. 青暝睇天 — 張樣張相 /cên¹ mên⁵ toi² tin¹ — dion¹ ion⁷ dion¹ sion⁷/\n12. 青暝點燈 — 照舊 /cên¹ mên⁵ diam² dêng¹ — zio³ gu⁷/ 對青暝人來說，點不點燈，一切照舊。\n13. 青暝掠魚 — 散摸 /cên¹ mên⁵ liah⁸ hu⁵ — suan³ mong⁵/\n14. 青暝娶母 — 稱重 /cên¹ mên⁵ cua⁷ bhao² — cing³ dang⁶/\n15. 青暝擎手電 — 各人各人善 /cên¹ mên⁵ gia⁵ ciu² diang⁶ — gag⁴ nang⁵ gag⁴ nang⁵ siang⁶/\n16. 青暝睇電影 — 聽聲 /cên¹ mên⁵ toi² diang⁶ ian² — tian¹ sian¹/\n17. 啞人食苦瓜 — 有苦難言 /ê² nang⁵ ziah⁸ kao² goi¹ — u⁶ kao² nang⁵ ngiang⁵/\n18. 啞囝食黃連 — 有苦難言 /ê² gian² ziah⁸ ng⁵ nain⁵ — u⁶ kao² nang⁵ ngiang⁵/\n19. 閻羅王嫁諸母囝 — 鬼正敢愛 /ngiam⁵ lo⁵ uang⁵ gê³ za¹ bhao² gian² — gui² zian³ gan² ain³/\n20. 閻羅王請人 — 鬼正敢食  /ngiam⁵ lo⁵ uang⁵ cian² nang⁵ — gui² zian³ gan² ziah⁸/\n21. 閻羅王賣假貨 — 騙鬼 /ngiam⁵ lo⁵ uang⁵ bhoi⁷ gê² hoi⁷ — piang³ gui²/\n22. 閻羅王出告示 — 無句人話 /ngiam⁵ lo⁵ uang⁵ cug⁴ go³ si⁷ — bho⁵ gu³ nang⁵ oi⁷/\n23. 鬼簿無名 — 免死 /gui² pao⁶ bho⁵ mian⁵ — miang² si²/\n24. 醫生開了棺材舖 — 死活都愛錢 /ui¹ sên¹ kui¹ liao² gua¹ ca⁵ pao⁷ — si² ua² do¹ ain³ zin⁵/\n25. 身長棺材短 — 屈死人 /sing¹ dng⁵ gua¹ ca⁵ dê² — kug⁴ si² nang⁵/\n26. 棺材頭畫老虎 — 驚死人 /gua¹ ca⁵ tao⁵ oi⁷ lao⁶ haon² — gian¹ si² nang⁵/\n27. 歪喙和尚 — 唸無一句正經 /uain¹ cui³ hoi⁵ sion⁷ — niam⁷ bho⁵ zêg⁸ gu³ zian³ gêng⁵/\n28. 師公和尚 — 毋同道 /sai¹ gong¹ hoi⁵ sion⁷ — m⁶ dang⁵ dao⁶/\n29. 和尚抹粉 — 白勞 /hoi⁵ sion⁷ bhuah⁴ hung² — bêh⁸ lu⁵/ 勞，與「驢」諧音。\n30. 和尚擎雨遮 — 無法無天 /hoi⁵ sion⁷ gia⁵ hao⁶ zia¹ — bho⁵ huab⁴ bho⁵ tin¹/ 法，與「髮」諧音。\n31. 橄欖尻川 — 坐毋恬 /gan¹ na² ka¹ cng¹ — zê⁶ m⁶ diam⁷/ 屁股像橄榄一般尖，坐不住。恬，静、定。\n32. 火燒豬頭 — 熟面熟面 /hoi² sio¹ du¹ tao⁵ — sêg⁸ ming⁷ sêg⁸ ming⁷/\n33. 六月芥菜 — 假有心 /lag⁸ ghoih⁸ gua³ cai³ — gê² u⁶ sim¹/\n34. 十月芥菜 — 大䀌心 /zab⁸ ghoih⁸ gua³ cai³ — dua⁷ gêg⁴ sim¹/ 䀌，與「激」諧音。\n35. 六月蕃薯 — 雙死 /lag⁸ ghoih⁸ huang¹ zu⁵ — sang¹ si²/ 雙，與「鬆」諧音。\n36. 阿媽生諸母囝 — 生菇 /a¹ ma² sên¹ za¹ bhao² gian² — sên¹ gao¹/ 生菇，發霉。菇，與「姑」諧音。\n37. 老人跤纏 — 又長又臭 /lao⁶ nang⁵ ka¹ din⁵ — ui⁶ dng⁵ ui⁶ cao³/ 講話囉嗦像老人纏足一樣\n38. 老人食豬跤 — 試味 /lao⁶ nang⁵ ziah⁸ du¹ ka¹ — ci³ bhi⁷/ 嘗試下而已\n39. 老婆跋落水 — 淒涼 /lao⁶ pua⁵ buah⁸ lo² zui² — ci¹ liang⁵/ 跋，絆倒。淒，與「妻」諧音。\n40. 老婆其阿兄 — 痴哥 /lao⁶ pua⁵ gai⁵ a¹ hian¹ — ci¹ go¹/ 痴，與「妻」諧音。\n41. 菜頭粿熱單爿 — 自作多情 /cai³ tao⁵ goi² riah⁸ duan¹ bain⁵ — zu⁶ zag⁴ do¹ cêng⁵/ 菜頭粿，蘿蔔糕。热单爿，切片下鍋油煎，但只煎單邊，上焦下嫩。一頭熱（悅），單戀。\n42. 龍眼核拭尻川 — 賽道行 /nging¹ ain² hug⁸ cih⁴ ka¹ cng¹ — sai³ dao⁶ hang⁵/ 「龍眼核拭尻川」比喻有難度的事情，看各家誰本領強了。\n43. 水仙不開花 — 裝蒜 /zui² siang¹ bug⁴ kui¹ hoi¹ — zng¹ sng³/\n44. 大炮拍麻雀 — 騙伊驚 /dua⁷ pao³ pah⁴ mua⁵ ziah⁴ — piang³ i¹ gian¹/\n45. 有錢買蠓香，無錢買蠓罩 — 會算無會除 /u⁶ zin⁵ bhoi² mang² hion¹, bho⁵ zin⁵ bhoi² mang² dan³ — oi⁶ sng³ bhoi⁶ du⁵/\n46. 天頂滴鳥屎 — 無好相覓 /tin¹ dêng² dig⁴ ziao² sai² — mo² sion¹ coi⁷/\n47. 六月薄殼 — 假大頭 /lag⁸ ghoih⁸ boh⁸ kag⁴ — gê² dua⁷ tao⁵/ 大頭，一種比薄殼略大的小貝類海鮮。假大頭，愛充大頭。\n48. 七角錢二人分 — 毋三毋四 /cig⁴ gag⁴ zin⁵ no⁶ nang⁵ bng¹ — m⁶ san¹ m⁶ si³/\n49. 十二碗圓食賰一粒 — 假客氣 /zab⁸ ri⁶ liab⁸ in⁵ ziah⁸ cung⁵ zêg⁸ liab⁸ — gê² kêh⁴ ki⁷/ 圓，丸子。賰，剩下。\n50. 狗母蛇 — 假靈 /gao² bho² zua⁵ — gê² lêng⁵/ 靈，與「龍」諧音。\n51. 兄獨目弟缺喙 — 大無好樣，細無好相 /hian¹ dog⁸ mag⁸ di⁶ koih⁴ cui³ — dua⁷ bho⁵ ho² ion⁷, soi³ bho⁵ ho² sion³/\n52. 山螟咬尾 — 食家己 /suan¹ mê¹ ga⁶ bhoi² — ziah⁸ ga¹ gi⁷/\n53. 風吹牆頭草 — 就勢倚勢 /hong¹ coi¹ ciong⁵ tao⁵ cao² — ziu⁶ si³ ua² si³/\n54. 老鼠跋落粟倉 — 倒好 /ngiao² cu² buah⁸ lo² cêg⁴ cng¹ — do³ ho²/\n55. 老鼠心肝 — 頭食頭搬 /ngiao² cu² sim¹ guan¹ — tao⁵ ziah⁸ tao⁵ buan⁵/\n56. 孥囝拍炮 — 又驚又好 /nao⁵ gian² pah⁴ pao⁷ — ui⁶ gian¹ ui⁶ hao⁷/\n57. 五行缺一 — 欠金 /ngao⁶ hêng⁵ koih⁴ ig⁴ — kiang³ gim¹/\n58. 茂生進酒 — 厚情 /mao⁶ sêng¹ zing³ ziu² — gao⁶ cêng⁵/\n59. 食人雞肉還人豬肉 — 物來物去 /ziah⁸ nang⁷ goi¹ nê² hain⁵ nang⁷ du¹ nê² — moih⁸ lai⁵ moih⁸ ko³/\n60. 刀截蕹菜 — 二頭空 /do¹ zoi² êng³ cai³ — no⁶ tao⁵ kong¹/\n61. 三個半錢 — 趕勢 /san¹ gai⁵ buan³ zin⁵ — guan² si³/ 勢，與「四」諧音。\n62. 隔暝皇帝 — 無權勢 /gêh⁴ mê⁵ huang⁵ di⁷ — bho⁵ kuang⁵ si³/\n63. 大肚水蛙 — 假鮭 /dua⁷ dao² zui² goi¹ — gê² guai¹/ 水蛙，青蛙。鮭，河魨。\n64. 五月龍船 — 相鬥 /ngao⁶ ghoih⁸ lêng⁵ zung⁵ — sion¹ dao³/\n65. 燈籠照路 — 目前光 /dêng¹ lang⁵ zio³ lao⁷ — mag⁸ zain⁵ gng¹/ 比喻目光短淺\n66. 暗室穿針 — 難過 /am³ sig⁴ cng¹ zam¹ — nang⁵ goi³/\n67. 嫁諸母囝娶新婦 — 出入平安 /gê³ za¹ bhao² gian² cua⁷ sing¹ bu⁶ — cug⁴ rib⁸ pêng⁵ ang¹/ 安，與「翁」諧音。\n68. 過關送文憑 — 做人情 /goi³ guan¹ sang³ bhung⁵ pêng⁵ — zo³ nang⁵ zian⁵/\n69. 火燒草料場 — 事出有因 /hoi² sio¹ cao² liao⁷ dion⁵ — su⁷ cu⁷ u⁶ ing¹/ 因，與「煙」諧音。\n70. 黑白電視 — 無彩 /hêg⁴ bêh⁸ dian⁶ si⁶ — bho⁵ cain²/ 無彩，可惜。\n71. 小郎遇著雨 — 積惡 /sio² nng⁵ ngo⁶ dioh⁴ hao⁶ — zêg⁴ ag⁴/ 小郎，女子稱呼丈夫的弟弟。積惡，可憐；罪惡。積，與「叔」諧音。惡，與「沃」諧音。\n\n### 🙂禮貌用語(li² mao⁶ êng³ ngo²)\n\n1. 汝食饱未 /lu² ziah⁸ ba² bhoi⁷/ 你吃飽了嗎\n2. 汝愛去底地 /lu² ain³ ku³ di⁷ dê⁷/ 你要去哪裏\n3. 汝好 /lu² ho²/ 你好\n4. 㩼謝 /zoi⁷ sia⁷/ 多謝\n5. 寬行 /kuan¹ gian⁵/ 慢走\n6. 寬駛 /kuan¹ sai²/ 慢點開車\n7. 对毋住 /dui³ m⁶ zu⁶/ 对不起\n8. 对毋起 /dui³ m⁶ ki²/ 对不起\n9. 無相干 /bho⁵ siang¹ gang¹/ 沒關係\n10. 毋知頭 /m⁶ zai¹ tao⁵/ 不是故意的\n11. 先這呾 /sain¹ zion² dan³/ 回頭再聊 \n12. 萬事應想 /mang⁷ su⁷ êng³ sion⁶/ 萬事如意\n13. 生理大趁 /sêng¹ li² dua⁷ tang⁷/ 生意興隆\n14. 新年大趁 /sing¹ ni⁵ dua⁷ tang⁷/ 新年大賺\n15. 新年合想 /sing¹ ni⁵ gah⁴ sion⁶/ 新年如意\n16. 大吉大利 /dai⁶ gig⁴ dai⁶ li⁶/\n\n### 🤐粗話(cao¹ oi⁷)\n\n1. 咒誓 /ziu³ zua⁷/ 發誓、詛咒\n2. 痟 /siao²/ 神經錯亂\n3. 神經 /sing⁵ gêng¹/\n4. 腦孬 /nao² mo³/ 腦子壞了\n5. 破脑囝 /puah⁸ nao² gian²/ 弱智\n6. 肚痛 /dao² tian³/ 「問候」別人是否肚子痛所以一直在叫。\n7. 鬼叫 /gui² gio⁷/ 「問候」別人是否聽到鬼在叫。\n8. 哭 cang¹ 哭 nain⁵ // 又哭又喊，吵死人了。\n9. 哭父死母 /kao³ bê⁶ si² bho²/ 「問候」別人是否父母過世所以一直在哭叫。\n10. 咋死人 /zag⁴ si² nang⁵/ 吵死了\n11. 鬼囝 /gui² gian²/ 小鬼\n12. 鬼卒囝 /gui² zug⁴ gian²/ 小鬼\n13. 鬼然然 /gui² riang⁵ riang⁵/ 像鬼一樣\n14. 鬼囉作禍 /gui² lo⁷ zo³ ho³/ 鬼在作祟、作怪\n15. 妖怪精 /iao¹ guai³ zian¹/\n16. 去死掉掉 /ku³ si² diao³ diao³/\n17. 散哭父 /suan⁷ kao³ bê⁶/ 散，到處。\n18. 吐屎 /tao³ sai²/ 亂說\n19. 卵屎人 /lang⁶ sai² nang⁵/ 屌絲，沒前途的人。\n20. 卵屎話 /lang⁶ sai² oi⁷/ 廢話\n21. 臭喙卵面 /cao³ cui³ lang⁶ ming⁷/ 亂說、討人厭。\n22. 關汝卵事 /guang¹ lu² lang⁶ dai⁷/ 與你何干\n23. 膣精 /zi¹ zian¹/ 多管閒事\n24. 臭膣 /cao³ zi¹/ 臭婊子\n25. 豺狗 /sai² gao²/ 狗腿子\n26. 怪卵 /guai³ lang⁶/ 古怪\n27. 無卵 /bho⁵ lang⁶/ 沒膽量\n28. 無腦 /bho⁵ nao²/ 沒腦子\n29. 𠀾好 /bhoi⁶ ho²/ 咒別人倒霉\n30. 痞囝 /pai² gian²/ 痞子、流氓。\n31. 肏母囝 /pu² bho² gian²/\n32. 早死囝 /za² si² gian²/\n33. 短命囝 /dê² mian⁷ gian²/、/dêng² mian⁷ gian²/\n34. 破家囝 /pua⁷ gê¹ gian²/ 败家子\n35. 內仙囝  /lai⁶ siang¹ gian²/ 難伺候\n36. 十惡囝 /zab⁸ ag⁴ gian²/ 十惡不赦\n37. 棺材囝 /gua¹ ca⁵ gian²/\n38. 痴哥囝 /ci¹ go¹ gian²/ 色狼\n39. 吐血死囝 /tao³ hoih⁴ si² gian²/\n40. 替人死囝 /toi⁵ nang⁵ si² gian²/\n41. 半路死囝 /buan³ lao⁷ si² gian²/\n42. 祭屎祭䷀ /zi³ sai² zi³ hê⁷/ 亂吃東西\n43. 乞鬼侵著 /koh⁴ gui² cin⁵ dioh⁴/ 鬼上身了。乞，給。侵，本讀 /cim⁵/，音變爲 /cin⁵/，附身。\n\n### 🧨娛樂(ngo⁵ log⁸)\n\n1. 耍遊戲 /sng² iu⁵ hi³/ 玩遊戲\n2. ䷀箭 /diong³ zin³/ 射箭\n3. ䷀珠 /diong³ zu¹/ 打彈珠\n4. 彈槍 /duan⁷ ciong¹/ 開槍\n5. 跳索 /tiao³ soh⁴/ 跳繩\n6. 踏孔 /dah⁸ kong²/ 捉迷藏\n7. 泅水 /siu⁵ zui²/ 游泳\n8. 釣魚 /dio³ hu⁵/\n9. 掠魚 /liah⁸ hu⁵/ 抓魚\n10. 行棋 /gian⁵ gi⁵/ 下棋\n11. 放風箏 /bang³ hong¹ zêng¹/\n12. 拍連炮 /pah⁴ liang⁵ pao³/ 放鞭炮\n13. 扣人囝 /kob⁴ nang⁵ gian²/ 人囝，也叫公仔紙、洋畫，舊時供兒童玩樂用的紙牌。\n14. 沃花 /ag⁴ hoi¹/ 澆花\n15. 做戲 /zo³ hi³/ 演戲劇\n\n### ⛩ 神明(sing⁵ mêng⁵)\n\n1. 天地父母 // 天地，原始信仰。\n2. 月娘 // 月球，原始信仰。\n3. 媽祖 // 原名林默，南海保護神，在甲子天后宮有供。\n4. 七聖娘 // 又稱七星娘娘、七聖夫人，是織女神分化出的七位仙女，是兒童保護神。\n5. 觀音娘 // 觀音菩薩\n6. 慈悲娘 // 即普悲觀音，觀音菩薩化身之一（傳說觀音菩薩有三十三化身），普遍施給眾生慈悲。\n7. 註生娘 // 全稱「大慈大悲救苦救難送子娘娘」，主管懷孕與生育。\n8. 佛祖 // 釋迦牟尼佛，姓喬達摩，名悉達多，古印度思想家、教育家、宗教改革家，佛教的創始人。\n9. 達摩祖師 // 南天竺人或波斯人，將佛教禪宗帶入中國，爲中國禪宗之開創者。\n10. 元天上帝 // 玄武大帝，象徵北極星與二十八宿中的北宮玄武，爲統理北方之道教大神。\n11. 水仙大帝 // 水仙尊王，海神之一，媽祖的從神之一。\n12. 汾陽王帝 // 郭子儀，華州鄭縣（今陝西渭南市華州區）人，唐朝名將，平定安史之亂，封汾陽郡王。此人富貴壽考，權極一時，甲子天后宮媽祖廟有供之。\n13. 王公 // 指隴尾王爺、王爺公，名鄒普勝，麻城花橋（今屬湖北）人，元末農民起義軍將領，陳友諒軍師。朱元璋建立明朝後流浪到甲子地區，爲甲子地區改造「風水」等，今甲子隴尾王爺廟有供之，大年初四在此求「落馬簽」。\n14. 關公 // 關羽，河東郡解縣（今山西省運城市鹽湖區解州鎮）人，三國時期名將，與劉備、張飛桃園三結義。又稱伽藍老爺、伽藍尊者，是寺廟、道場守護神，也有稱之爲武財神。\n15. 八仙公 // 傳說中的八位仙人，爲漢鍾離、張果老、韓湘子、鐵拐李、曹國舅、呂洞賓、藍采和、何仙姑八人。\n16. 伯公 // 福德老爺、土地公。\n17. 五穀公 // 神農大帝，相傳其發明耒耜，教民耕種五穀，並能以百草為民治病。農曆十月十五拜之。\n18. 城隍公 // 古代城鎮保護神。\n19. 皇帝公 // 南宋小皇帝趙昰，曾流亡到甲子待渡山。\n20. 灶公 // 灶君，主掌廚房和飲食的神。\n21. 百姓公 // 無主死者，集中掩埋於百姓公墓，稱爲百姓公(媽)，其中多喪於 1943 年的大飢荒，其時僅甲子一鎮亡者就近 2 萬人，慘絕。\n22. 地主爺 // 住宅的守護靈。\n23. 財神爺 // 常指陝西終南山的玄壇真君趙公明，也指關聖帝君關羽。\n24. 三山國王 // 指現揭西縣河婆鎮北面的三座山——巾山、明山、獨山的三位山神。\n\n## 風俗(hong¹ sioh⁸)\n\n1. 大年初一：食齋菜（菠薐菜、粉絲、菜頭丸、豆腐乾）。\n2. 人日(正月初七)：食七樣菜（厚合、蒜仔、芥藍、高麗菜、真珠菜、香菜、大菜芯）。\n3. 元宵(正月十五)：食蔗。\n4. 三月初三：食青草飯（雞屎藤、伸筋藤、苦刺心、臭草心、蠟裏葉、四方枝苦楝葉）。\n5. 清明：食硬殼餅，掃墓掛紙。\n6. 佛誕(四月初八)：食飯茶。\n7. 端午：食梔粽、梔粿，洗午時水。\n8. 七月初七：出花園。\n9. 中秋：食月餅、芋頭、蔗。\n10. 重陽(九月初九)：食雞湯。\n11. 冬節：食冬節丸、羊肉。\n12. 三十夜、廿九夜：食團圓飯、送壓腰錢（dêh⁴ io¹ zin⁵, 壓歲錢）。\n\n## 歷史(lêg⁸ su²)\n\n1. 甲子的名號是因爲港後有六十塊大石頭，應了干支紀年法一甲子的數目，故名。\n2. 漢文帝時曾派遣大臣陸賈（約公元前240年～公元前170年）到南越國，期間命令將士調查海岸線，到過甲子門。\n3. 三國時，吳侯孫權派遣將軍衛溫（？～231年）攻打福建、琉球和台灣（夷州），被風雨刮到甲子門。\n4. 南宋乾道五年(1169)，承奉郎致仕范有仁建順濟橋，橋從大膽山腳(今東宮社轄區)跨越瀛江到後庭（今甲東鎮雨亭村轄區）。\n\n    ![順濟橋（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）](gahzi-oi-hung-lui-ci-biao/Untitled%2084.png)\n\n5. 宋嘉定甲申年(1224)，南宋承奉郎范良臣（范有仁之孫）登腹石山，因山對面可見甲子門奇石十八，屹立如人，遂刻「登瀛」二字於石，取十八學士登瀛洲之義。\n6. 1276 年，元兵攻陷南宋京城臨安，南宋擁立幼帝趙昰，從福州乘船經福建沿海入廣東，於冬十二月抵甲子門腹石山（後人爲紀念此事，更山名爲待渡山），范良臣給軍食三日，留帝像登瀛石上。\n7. 1277 年正月，漁民鄭復組織義兵509人乘船護送宋帝昺及隨臣去崖門。途中在現珠海橫琴島和澳門與元兵相遇，十六日宋室全軍覆滅，陸秀夫背幼帝昺投海自盡，鄭復等在激戰中全部士兵犧牲。\n8. 明永樂六年(1408)，順濟橋被拆。因「指揮花茂奉旨建甲子所，慮倭寇泊海易渡，拆之以為城基。」\n9. 明嘉靖三十九年(1560)，八萬洞資首黃啓薦扎寨惠來冰山頭（今邦山村）攻陷甲子所城，城中居民移至龍溪都（今惠來隆江以南）為逃避倭禍而暫居，該城之難民，慘遭殺害者甚眾，婦女被擄掠，有的全家罹難。\n10. 明隆慶二年(1568)，倭寇入侵甲子，千戶馬壽麻痹輕敵，城被攻陷，甲子和龍溪都一帶受害慘重。馬壽因失職罪下獄，死於獄中。\n11. 明隆慶四年(1570)，大旱，入春至初夏，天無滴雨，時又常遭賊寇蹂躪，田園拋荒，赤地千里，人民苦不堪言。\n12. 明隆慶四年(1570)九月，曾作倭寇嚮導之海寇楊老復，率賊眾攻陷甲子所城，擄掠男女上船，千戶董（佚名）戰死。次日，船遇颱風，賊與被擄者均溺死。\n13. 隆慶五年(1571)七月，海盜林道乾（又名林鳳，惠來人），於龍溪都一帶擄民劫捨，後聞朝廷將派兵進剿，遂遠循至甲子一帶搶劫，攻破新寨，劫擄李棠，其妻卓氏攜二子上船換夫歸，遂投海殉節。後朝廷封為「南海夫人」。\n14. 明萬曆二十六年(1598)，湯顯祖作《牡丹亭》，其第六齣中有詞句「榕樹梢頭訪古台，下看甲子海門開。越王歌舞今何在？時有鷓鴣飛去來。」\n15. 明萬曆二十八年(1600)八月二十三日，惠來及甲子一帶地震。\n16. 明萬曆三十三年(1605)三月，惠來及甲子一帶地震，七月初三至初七颱風暴雨，沿海田舍淹沒。\n17. 明萬曆三十五年(1607)，參將張萬紀、守備胡文烜在待渡山下建宋帝亭，即進食亭。\n18. 明萬曆四十二年(1620)春正月，海盜袁八老余黨林新老入甲子沃，把總金允武出戰死之。\n19. 明天啓七年(1627)三月，海寇入甲子門，守備葉台死亡。\n20. 明崇禎八年(1635)，海寇劉香攻陷甲子，擄去守道洪雲蒸。閩粵大兵突至，洪遇害，後劉香被擄伏誅。\n21. 明崇禎十四年(1641)十二月十四日夜，惠來地震，波及甲子。\n22. 民國32年(1943，癸未年)，甲子乃至整個海陸豐地區、潮汕地區遭遇大飢荒，時兵災、旱災、蝗災和瘟疫，餓殍遍野，僅甲子一鎮亡者就近 2 萬，佔當時鎮人口逾 45%。\n23. 1966年，中國大陸爆發文化大革命，「破四舊」。次年，有360年歷史的進食亭被炸毀！\n24. 2004年夏～2005年秋，甲子諸賢達捐資重建了進食亭。\n25. 2013年12月29日凌晨，廣東警方出動3000多人的警力對有「毒品村」之稱的甲西鎮博社村開展清繳行動，當天繳獲近3噸冰毒，抓捕180多名涉毒犯罪嫌疑人，原村委書記蔡東家名列其中。\n\n## 建置(giang³ di³)\n\n1. 秦以前：屬南越國\n2. 秦：屬南海郡之博羅縣\n3. 漢：屬博羅縣\n4. 三國：屬博羅縣\n5. 晉：咸和六年（326）析博羅，置海豐縣，屬东官郡\n6. 宋：屬海豐縣\n7. 齊：屬海豐縣\n8. 梁：屬海豐縣\n9. 陳：屬海豐縣\n10. 隋：海豐縣屬循州\n11. 唐：海豐縣屬循州。武德五年（622）析置安陸縣；貞觀元年（627）復歸海豐縣。\n12. 五代：大寶元年（958）海豐縣属祯州。\n13. 宋：海豐縣屬祯州。天禧五年（1021）屬惠州。\n14. 元：海豐縣屬惠州路。\n15. 明：海豐縣屬惠州府。洪武二十七年(1394)，置甲子守禦千戸所，隸屬碣石衛。嘉靖三年（1524）海豐划出龍溪都、潮州府析出潮陽縣合置惠來縣。\n\n    ![甲子所城範圍（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）](gahzi-oi-hung-lui-ci-biao/Untitled%2085.png)\n    \n16. 清：海豐縣屬惠州府。雍正九年（1731）海豐划出石帆（甲子屬石帆都）、吉康、坊廓3都置陸豐縣，並裁甲子所設立甲子巡檢司。\n17. 中華民國：陸豐縣屬潮循道。\n18. 中華人民共和國：1957年甲子鎮劃出甲東鎮、甲西鎮（取甲子之東、甲子之西義）；1958年鎮改爲人民公社，陸豐縣屬汕頭地區；1983年陸豐屬惠陽地區；1980年成立甲子鎮人民政府；1988年陸豐縣改屬汕尾市；1995年陸豐撤縣建市。\n\n## 拼音方案(pêng³ im¹ huang¹ uan³)\n\n### 聲母表(sian¹ bho² biao²)\n\n格式：`聲母 [國際音標] 例字`\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png)\n\n### 韻母表(ung¹ bho² biao²)\n\n格式：`韻母 [國際音標] 例字 / 入聲韻 [國際音標] 例字`\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png)\n\n### 聲調(sian¹ diao⁶)\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png)\n\n### 變調(biang³ diao⁶)\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png)\n\n## 地圖(di⁷ dao⁵)\n\n![三甲地區（來源：騰訊地圖）](gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg)\n\n","source":"_posts/language/min/gahzi-oi-hung-lui-ci-biao.md","raw":"---\ntitle: 甲子話分類辭表（2020.12）\np: language/min/gahzi-oi-hung-lui-ci-biao\ndate: 2020-11-08 20:24:00\ntags:\n- 甲子話\n- 閩南語\n---\n\n**!!! 注意：本辭表已收錄在典合網中進行維護，請轉閱：[https://dicthub.cn/dicts/kahtsi-ue](https://dicthub.cn/dicts/kahtsi-ue) !!!**\n\n## 序言(su⁶ ngiang⁵)\n\n甲子鎮處在陸豐市，與惠來縣交界，語言文化上偏惠來（其實五百年前與惠來交界處同屬海豐縣）。甲子話是三甲地區（甲子、甲西、甲東三鎮）通行的語言，是甲子地方文化的重要載體之一。在學術上，甲子話被歸入粵東閩南語潮汕話片。 \n\n甲子話保留了好㩼中古乃至上古的漢語詞彙，比如：汝、諸母、新婦、箸、鼎、匏桸、雅、翹楚等等，還有極具地方特色的表達，比如：𨑨迌、走漆、理唔直、孤獨死相等等。然而無會寫甚至無會呾甲子話的人實在㩼，其中不少是受過義務教育其。 有鑑於此，本人草創此表，力求詞雅正且其音形義有所考據，權當拋磚引玉，歡迎大家儂做蜀討論改進。 \n\n另附本表主要參考資料：\n\n1. 《潮汕方言詞考釋》（林倫倫）\n2. 《海豐話分類辭表》（羅志海、鍾顯坤）\n3. [《潮典》](https://www.mogher.com/baike) \n4. 《新潮汕字典》（張曉山）\n5. [《台灣閩南語常用詞辭典》](https://twblg.dict.edu.tw/holodict%5C_new/index.html) \n6. [《小學堂閩語》](https://xiaoxue.iis.sinica.edu.tw/minyu)\n\n阿華\n2020年10月成稿，12月修訂\n\n<!--more-->\n\n## 總表(zong² biao²)\n\n### 🤵稱謂(cêng¹ ui⁶)\n\n1. 我 /ua²/\n2. 汝 /lu²/ 你\n3. 伊 /i¹/ 他/她/它\n4. 恁 /ning²/ 你們\n5. 伊人 /i¹ nang⁷/ 他們\n6. 家己 /ga¹ gi⁷/ 自己\n7. 人家 /nang⁵ gê¹/ 別人\n8. 諸夫 /za¹ bao¹/ 男人、男子\n9. 諸母 /za¹ bhao²/ 女人\n10. 諸娘 /zu¹ nion⁵/ 女子\n11. 大人 /dua⁷ nang⁷/\n12. 老人 /lao⁶ nang⁵/\n13. 後生囝 /hao⁶ sên¹ gian²/ 年輕人\n14. 孥囝 /nao⁵ gian²/、/nong⁶ gian²/ 小孩子\n15. 諸夫囝 /za¹ bao¹ gian²/ 男孩子、兒子\n16. 諸母囝 /za¹ bhao² gian²/ 女孩子、女兒\n17. 諸娘囝 /zu¹ nion⁵ gian²/ 年輕女子\n18. 阿公 /a¹ gong¹/ 爺爺\n19. 阿媽 /a¹ ma²/ 奶奶\n20. 媽人 /ma² nang⁵/ 婦女\n21. 媽祖 /ma² zao²/ 原名林默，南海保護神\n22. 爸爸 /ba¹ ba¹/ 爸爸\n23. 媽媽 /ma¹ ma¹/\n24. 父母 /bê⁶ bho²/\n25. 兄 /hian¹/ 哥哥\n26. 弟 /di⁶/ 弟弟\n27. 姐 /zê²/ 姐姐\n28. 妹 /moi⁷/ 妹妹\n29. 姊妹 /zi² moi⁷/ 姐妹\n30. 叔伯兄弟 /zêh⁴ bêh⁴ hian¹ di⁶/ 堂兄弟\n31. 同沿 /dang⁵ iang⁵/ 同輩、同儕\n32. 翁 /ang¹/ 丈夫\n33. 母 /bhao²/ 妻子\n34. 翁姐 /ang¹ zia²/ 夫妻\n35. 新婦 /sing¹ bu⁶/ 媳婦\n36. 大家 /dua⁷ gê¹/ 丈夫的母親、家婆\n37. 大家官 /dua⁷ gê¹ guan¹/ 丈夫的父親、家公\n38. 丈人 /dion⁶ nang⁵/ 岳父\n39. 丈母 /dion⁶ m²/ 岳母\n40. 妻舅 /ci¹ gu⁶/ 妻子的兄弟\n41. 妻姨 /ci¹ i⁵/ 妻子的姐妹\n42. 伯 /bêh⁴/ 伯伯\n43. 姆 /m²/ 伯父的妻子\n44. 叔 /zêh⁴/ 叔叔\n45. 嬸 /sim²/ 叔父的妻子\n46. 舅 /gu⁶/ 舅舅\n47. 妗 /gim⁶/ 舅父的妻子\n48. 姑 /gao¹/ 父親的姐妹、姑姑\n49. 姑丈 /gou¹ dion⁶/ 姑姑的丈夫\n50. 姨 /i⁵/ 母親的姐妹；母親\n51. 姨丈 /i⁵ dion⁶/ 母親的姐妹的丈夫\n52. 先生 /sing¹ sên¹/\n53. 學生 /hag⁴ sêng¹/\n54. 師父 /sai¹ bê⁶/ 工匠師傅\n55. 師父 /su¹ hu⁶/ 出家人、和尚\n56. 和尚 /hoi⁵ sion⁷/、/hua⁵ siang⁶/\n57. 腳色 /ka¹ siao³/ 人手、幫手\n58. 青暝囝 /cên¹ mên⁵ gian²/ 瞎子\n\n### 🦶身體(sing¹ ti²)\n\n1. 頭毛 /tao⁵ mo⁵/ 頭髮\n2. 頭神 /tao⁵ sing⁵/ 思維、記憶的能力\n3. 頭碗骨 /tao⁵ uan² gug⁴/ 頭蓋骨\n4. 旋 /zng⁷/ 頭髮呈漩渦狀的地方\n5. 囟 /sing³/ 嬰兒頭頂骨未合縫處\n6. 額頭 /hia² tao⁵/\n7. 面 /ming⁷/ 臉\n8. 頰溝 /gih⁴ gao¹/ 腮\n9. 痣 /gi³/\n10. 目 /mag⁸/ 眼睛\n11. 目仁 /mag⁸ ring⁵/ 眼珠子\n12. 目汁 /mag⁸ zab⁴/ 眼淚\n13. 眉 /bhai⁵/ 眉毛\n14. 耳 /hin⁶/ 耳朵\n15. 耳空、耳孔 /hin⁶ kang¹/\n16. 鼻 /pin⁷/ 鼻子\n17. 鼻空、鼻孔 /pin⁷ kang¹/\n18. 喙、嘴 /cui⁷/ 嘴巴\n19. 䶕牙 /bha³ ghê⁵/ 龅牙\n20. 涎 /nua⁶/ 唾液\n21. 痰 /tam⁵/\n22. 頷 /am⁶/ 脖子\n23. 下頦 /ê⁶ hai⁵/ 下巴\n24. 喙後肚 /cui⁷ ao⁶ dao²/ 下巴後面柔軟處\n25. 鬚 /ciu¹/ 鬍鬚\n26. 嚨喉 /na⁵ ao⁵/ 喉嚨\n27. 手 /ciu²/\n28. 正手 /zian³ ciu²/ 右手\n29. 倒手 /do³ ciu²/ 左手\n30. 胳囊跤 /goh⁴ lang⁵ ka¹/ 腋下\n31. 手後曲 /ciu² ao⁶ kiao¹/ 手肘\n32. 手模 /ciu² bhao⁵/ 手印\n33. 腡 /lê⁵/ 圓形手指紋\n34. 指頭公 /zain² tao⁵ gong¹/ 大拇指\n35. 尾指囝 /bhoi² zain² gian²/ 小指\n36. 胸 /hêng¹/\n37. 嬭、奶 /nê¹/\n38. 𩩍篱 /pian¹ li⁵/ 肋骨\n39. 肚臍 /dao² zai⁵/\n40. 背脊 /ba¹ ziah⁴/ 脊背\n41. 腰 /io¹/\n42. 跤、骹、腳 /ka¹/\n43. 跤頭趺 /ka¹ tao⁵ u⁶/ 膝蓋\n44. 大跤腿 /dua⁷ ka¹ tui²/ 大腿\n45. 跤腸肚 /ka¹ dng⁵ dao²/ 小腿後部肌肉凸出處\n46. 跤後蹬 /ka¹ ao⁶ dên¹/ 腳後跟\n47. 跤盤 /ka¹ buan⁵/ 腳板\n48. 跤目 /ka¹ mag⁸/ 腳踝\n49. 跤指公 /ka¹ zain² gong¹/ 腳大拇趾\n50. 跤液 /ka¹ sio²/ 腳汗\n51. 卵 /lang⁶/ 陰莖、屌、勢\n52. 卵鳥 /lang⁶ ziao²/ 陰莖、屌、勢\n53. 卵脬 /lang⁶ pa¹/ 精囊\n54. 卵核 /lang⁶ hug⁸/ 睪丸\n55. 膣 /zi¹/ 女陰\n56. 膣眉 /zi¹ bhai¹/ 女陰\n57. 尻川 /ka¹ cng¹/ 屁股\n58. 雞母皮 /goi¹ bho² poi⁵/ 雞皮疙瘩\n59. 汗 /guan⁷/\n60. 垢圿 /gao² goih⁴/ 體表污垢\n\n### 🍵飲食(im² ziah⁸)\n\n1. 食 /ziah⁸/ 吃、喝、抽\n2. 祭 /zi³/ 狼吞虎咽；坐享其成\n3. 咬 /ga⁶/\n4. 哺 /bao⁷/ 咀嚼\n5. 吞 /tung¹/\n6. 舐 /zi⁶/ 舔\n7. 含 /gam⁵/\n8. 啜 /coih⁴/ 喝\n9. 啉 /lim⁵/ 小口喝\n10. 灌 /guang¹/ 大口喝\n11. 吸 /kib⁴/\n12. 搵 /ung³/ 蘸\n13. 買鹹 /moi² giam⁵/ 買菜\n14. 食透早 /ziah⁸ tao⁷ za²/ 吃早飯\n15. 食眠起 /ziah⁸ mng⁵ ki²/ 吃早飯\n16. 食晝 /ziah⁸ dao³/ 吃午飯\n17. 食當晝 /ziah⁸ dêng¹ dao³/ 吃午飯\n18. 食夜昏、食暝昏 /ziah⁸ mê⁵ hng⁵/ 吃晚飯\n19. 飯 /bng⁷/\n20. 米 /bhi²/\n21. 糜 /moi⁵/ 粥\n22. 飲 /am²/ 米湯\n23. 配 /poi³/ 菜\n24. 菜式 /cai³ sêg⁴/\n25. 粿、餜 /goi²/\n26. 丸、圓 /in⁵/\n27. 油䭔 /iu⁵ zui¹/ 一種油炸食品\n28. 汰米 /tua⁷ bhi²/ 淘米\n29. 熬 /ngao⁵/ 長時間煮。～糜。\n30. 煲 /bu⁵/ 煮、熬。～藥。\n31. 潘 /png¹/ 餿水\n32. 油 /iu⁵/\n33. 鹽 /iam⁵/\n34. 醋 /cao³/\n35. 豉油 /si⁷ iu⁵/ 醬油\n36. 豆汁 /dao⁷ zab⁴/ 醬油\n37. 雞卵 /goi¹ nng⁶/ 雞蛋\n38. 豬肉 /du¹ nêg⁸/\n39. 澀肉 /siab⁴ nêg⁸/、/siab⁴ bhah⁴/ 瘦肉。澀，少油。\n40. 肉脞 /nêg⁸ co³/ 肉末\n41. 烏糖 /ao¹ tng⁵/ 紅糖、黑糖\n42. 赤砂糖 /ciah⁴ sua¹ tng⁵/\n43. 白砂糖 /bêh⁸ sua¹ tng⁵/\n44. 薰 /hung¹/ 香菸\n45. 茶 /dê⁵/\n46. 酒 /ziu²/\n47. 淖 /cioh⁴/ 粥稀\n48. 凊 /cing³/ 飯菜涼了\n49. 燒 /sio¹/ 熱呼呼\n50. 燒烘燒烘 /sio¹ hang¹ sio¹ hang¹/ 熱呼呼\n51. 芳 /pang¹/ 香\n52. 甘 /gam¹/\n53. 甜 /diam⁵/\n54. 鹹 /giam⁵/\n55. 薟 /hiam¹/ 辛辣\n56. 䭕 /zian²/ 清淡\n57. 臊 /co¹/ 腥\n58. 臭 /cao³/\n\n### 👔穿戴(cêng⁷ dua³)\n\n1. 帽 /bho⁷/\n2. 目鏡 /mah⁸ gian³/ 眼鏡\n3. 圍巾 /ui⁵ ging¹/\n4. 頷幔 /am⁶ muan¹/ 披肩\n5. 衫褲 /san¹ kao³/ 衣服\n6. 西裝 /sai¹ zuang¹/\n7. 褸 /lao¹/ 大衣\n8. 葵笠 /goi⁵ loih⁸/ 斗笠，竹編成的圓錐形大帽子。\n9. 羊毛衫 /ion⁵ mo⁵ san¹/\n10. 長䘼衫 /dng⁵ ng² san¹/ 長袖衫\n11. 短䘼衫 /dê² ng² san¹/ 短袖衫\n12. 貼身衫 /dah⁴ sing¹ san¹/ 貼身的上衣\n13. 䘥囝 /gah⁴ gian²/ 無袖內衣\n14. 底衫 /doi² san¹/ 內衣\n15. 肚綰 /dao² guan⁶/ 肚兜\n16. 長褲 /dng⁵ kao³/\n17. 短褲 /dê² kao³/\n18. 褲頭 /kao³ tao⁵/ 短褲、內褲\n19. 褲橛 /kao³ goi²/ 短褲、內褲\n20. 三角褲 /san¹ gag⁴ kao³/\n21. 裙 /gung⁵/\n22. 圍裙 /ui⁵ gung⁵/\n23. 文胸 /bhung⁵ hêng¹/ 胸罩\n24. 奶帕、嬭帕 /nê¹ pê³/ 胸罩\n25. 皮帶 /poi⁵ dua³/\n26. 手囊 /ciu² lob⁴/ 套袖\n27. 手鐲 /ciu² sio²/\n28. 鞋拖 /tua¹ oi⁵/ 拖鞋\n29. 波鞋 /bo¹ oi⁵/ 球鞋。波，英文 ball 的音譯。\n30. 釘鞋 /dêng¹ oi⁵/ 運動鞋的一種\n31. 皮鞋 /poi⁵ oi⁵/\n32. 高跟鞋 /gao¹ ging¹ oi⁵/\n33. 靴 /hia¹/\n34. 襪 /ghoih⁸/\n35. 布 /bao³/\n36. 襊 /zoi⁷/ 折痕\n37. 頷領 /am⁶ nia²/ 領子\n38. 褲袋 /kao³ dê⁷/ 位於褲子的口袋\n39. 衫袋 /san¹ dê⁷/ 位於上衣的口袋\n40. 暗袋 /am³ dê⁷/ 內側袋\n41. 內裏 /lai⁶ li²/ 衣物不露出在外的裏層\n42. 鈕 /liu²/ 鈕扣\n43. 針 /zam¹/\n44. 線 /suan³/\n45. 拉鍊 /la¹ liang³/\n46. 穿 /cêng⁷/\n47. 褪 /tng⁷/ 脱\n48. 紩 /tin⁷/ 縫\n49. 補 /bao²/\n50. 車衫褲 /cia¹ san¹ kao³/ 用縫紉機縫衣服\n\n### 🎏物件(mi² gian⁶、mian⁶)\n\n1. 眠牀 /mng⁵ cng⁵/ 牀\n2. 鋪 /pao¹/ 牀\n3. 高低牀 /gao¹ di¹ cng⁵/ 上下鋪\n4. 蓆 /cioh⁸/\n5. 簟 /diam⁶/ 竹席\n6. 毡 /ziang¹/\n7. 被 /poi⁶/\n8. 棉被 /mi⁵ poi⁶/\n9. 被單 /poi⁶ duan¹/\n10. 枕頭 /zim² tao⁵/\n11. 枕頭囊 /zim² tao⁵ lob⁴/ 枕套\n12. 蠓罩、蚊罩 /mang² da³/ 蚊帳\n13. 蠓熏、蚊熏 /mang² hung¹/ 蚊香\n14. 窗罩 /têng¹ zao⁶/\n15. 口罩 /kao² zao⁶/\n16. 壁櫥 /biah⁴ du⁵/\n17. 椅 /in²/\n18. 桌 /doh⁴/\n19. 櫃 /gui⁷/\n20. 架 /gê³/\n21. 盒 /ab⁸/\n22. 籃 /na⁵/\n23. 瓶 /bang⁵/\n24. 鎖頭 /so² tao⁵/\n25. 鎖匙 /so² si⁵/ 鑰匙\n26. 葉疊 /iab² diab⁸/ 合葉\n27. 牙簽 /ghê⁵ ciam¹/\n28. 茶盤 /dê⁵ buan⁵/\n29. 茶壺 /dê⁵ hu⁵/\n30. 沖罐 /cong¹ guang³/ 茶壺\n31. 茶杯 /dê⁵ boi¹/\n32. 茶几 /dê⁵ gi²/\n33. 熏咬 /hung¹ ga⁶/ 煙斗\n34. 熏碟 /hung¹ dih⁸/ 煙灰缸\n35. 熱壺 /riag⁸ hu⁵/ 熱水瓶\n36. 熨斗 /ug⁴ dao²/\n37. 電燈 /diang⁶ dêng¹/\n38. 電泡 /diang⁶ pa⁶/\n39. 燈籠 /dêng¹ lang⁵/\n40. 燈火 /dêng¹ hoi²/ 電燈；燈光\n41. 風箏 /hong¹ zêng¹/\n42. 米甕 /bhi² ang³/ 米缸\n43. 水䀇 /zui² gao²/ 大型儲水器\n44. 跤桶 /ka¹ tang²/ 原指洗腳桶，後泛指洗衣盆，也可用來給小孩洗澡。\n45. 面盆 /ming⁷ png⁵/ 臉盆\n46. 瓠桸 /bu⁵ hia¹/ 水瓢\n47. 口㼦 /kao² gong²/ 漱口杯\n48. 碗 /uan²/\n49. 盤 /buan⁵/\n50. 碟 /dih⁸/\n51. 甌 /ao¹/ 大碗\n52. 箸 /du⁷/ 筷子\n53. 湯匙 /tng¹ si⁵/\n54. 調羹 /tiao⁵ gên¹/ 喝粥用的小勺子；湯匙\n55. 糜匙 /moi⁵ si⁵/ 舀粥用的勺子\n56. 飯匙 /bng⁷ si⁵/ 飯勺\n57. 飯添 /bng⁷ tin¹/ 飯勺\n58. 鼎 /dian²/ 鍋\n59. 鼎㧕 /dian² liu⁶/ 鍋鏟。㧕，存疑。\n60. 鼎蓋 /dian² kain³/ 鍋蓋\n61. 菜刀 /cai³ do¹/\n62. 瓜刨 /goi¹ pao⁵/\n63. 砧 /diam¹/\n64. 篩 /tai¹/\n65. 筅 /cain²/ 刷子\n66. 菜篩 /cai³ tai¹/\n67. 鉸刀 /ga¹ do¹/ 剪刀\n68. 螺絲批 /lo⁵ si¹ poi¹/ 螺絲刀\n69. 螺絲釘 /lo⁵ si¹ dêng¹/\n70. 旋螺絲 /suag⁸ lo⁵ si¹/ 擰螺絲\n71. 鐵錘 /tih⁴ tui⁵/\n72. 鉸夾 /ga¹ giab⁸/ 鉗子\n73. 扳手 /bang² ciu²/\n74. 電筆 /diang⁶ big⁴/ 測電筆\n75. 烏膠布 /ao¹ ga¹ bao³/ 電工膠帶\n76. 黏紙 /niam⁵ zua²/ 透明膠帶\n77. 布拖 /bao³ tu¹/ 拖把\n78. 掃帚 /sao³ siu²/ 掃把\n79. 畚斗 /bng³ dao²/ 垃圾鏟\n80. 畚箕 /bng³ gi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled.png)\n\n81. 梯 /tui¹/\n82. 吸石 /hiab⁴ zioh⁸/ 磁鐵、磁石\n83. 箠 /coi⁵/ 鞭子，可用來教育孩子。\n84. 火箠 /hoi² coi⁵/ 火筷子，夾爐中煤炭或通火的用具。\n85. 角畢 /gag⁴ big⁴/ 皮箱\n86. 樹嬭 /ciu⁷ ni⁵/ 橡皮、橡膠。嬭，樹之乳膠。\n87. 嬭漱 /ni⁵ ciu³/ 橡皮擦\n88. 毛筆 /mo⁵ big⁴/\n89. 鋼筆 /gng³ big⁴/\n90. 鉛筆 /iang⁵ big⁴/\n91. 鉛筆旋 /iang⁵ big⁴ suag⁸/ 卷筆刀、筆刨\n92. 模 /bhao⁵/ 模子\n93. 㨹 /zoi⁷/ 裂縫、痕跡\n94. 離衣機 /li⁵ i¹ gi¹/ 洗衣機\n\n### 🏠建築(giang³ dog⁴)\n\n1. 茨、厝 /cu³/ 房子、家\n2. 寮 /liao⁵/ 简陋小屋\n3. 瓦茨 /hia⁶ cu³/ 瓦舍\n4. 茨手 /cu³ ciu²/ 潮汕民居天井旁兩間廂房的名稱。\n5. 兩間直 /no⁶ gain¹ dig⁸/ 傳統民居，兩房。\n6. 獨腳靴 /dog⁸ ka¹ hia¹/ 傳統民居，一聽一茨手一房。\n7. 下山虎 /hia⁶ suan¹ haon²/ 傳統民居，三合院，一廳二房二茨手。\n8. 四點金 /si³ diam² gim¹/ 傳統民居，四合院，中軸爲前廳天井後聽，兩廳兩旁各有一房。\n9. 竹竿茨 /dêg⁴ go¹ cu³/ 傳統民居，廚房客廳住房天井排列成狹長的空間，如竹竿。\n10. 駟馬拖車 /si³ mê² tua¹ cia¹/ 傳統民居，在四點金上縱加一廳，橫加兩房，三廳二天丼。\n11. 茨邊 /cu³ bin¹/ 鄰居\n12. 起茨 /ki² cu³/ 蓋房子\n13. 租茨 /zao¹ cu³/ 租房子\n14. 搬茨 /buan⁵ cu³/ 搬家\n15. 入新茨 /rib⁸ sing¹ cu³/ 搬入新家\n16. 客廳 /kêh⁴ tian¹/\n17. 客房 /kêh⁴ bang⁵/\n18. 廚房 /dao⁵ bang⁵/\n19. 浴室 /êg⁸ sig⁴/\n20. 洗浴 /soi² êg⁸/ 洗澡\n21. 廁所 /cê³ so²/\n22. 屎壑 /sai² hag⁸/ 茅廁\n23. 門窗 /mng⁵ têng¹/\n24. 門閂 /mng⁵ cuan³/\n25. 門楣 /mng⁵ bhai⁵/\n26. 門橂 /mng⁵ dain⁶/ 門檻\n27. 門扇後 /mng⁵ sin³ ao⁶/ 門後\n28. 柱 /tiao⁶/\n29. 牆壁 /cion⁵ biah⁴/\n30. 庭、埕 /dian⁵/ 寬闊平地，可曬鹽、曬穀。\n31. 临檐 /lim⁵ zin⁵/ 檐廊\n32. 塗角 /tao⁵ gag⁴/ 土磚\n33. 磚 /zng¹/\n34. 廟 /bhio⁷/\n35. 亭 /dêng⁵/\n36. 祠堂 /su⁵ dng⁵/\n37. 庵寺 /am¹ zin⁷/ 尼寺、僧寺的通稱。\n38. 學校 /hag⁸ hao⁶/\n39. 醫院 /ui¹ in⁷/\n40. 鎮府 /ding³ hu²/ 鎮政府\n41. 舖囝 /pao³ gian²/ 小賣部\n\n### 🛵交通(gao¹ tong¹)\n\n1. 腳車、跤車 /ka¹ cia¹/ 腳踏車、自行車\n2. 摩托 /mo⁵ toh⁸/ 摩托，英文 motorcycle 音譯省。\n3. 三輪車 /san¹ lung⁵ cia¹/\n4. 的士 /dêg⁴ si⁶/ 計程車、出租車。的士，英文 taxi 音譯。\n5. 小車 /sio² cia¹/ 小汽車\n6. 麵包車 /min⁷ bao¹ cia¹/\n7. 公交車 /gong¹ gao¹ cia¹/\n8. 大巴 /dua⁷ ba¹/ 巴，英文 bus 音譯。\n9. 車站 /cia¹ zam⁶/\n10. 輪船 /lung⁵ zung⁵/\n11. 龍船 /lêng⁵ zung⁵/ 龍舟\n12. 火車 /hoi² cia¹/\n13. 地鐵 /di⁷ tih⁴/\n14. 高鐵 /gao¹ tih⁴/\n15. 飛機 /boi¹ gi¹/\n16. 行路 /gian⁵ lao⁷/ 走路\n17. 踏腳車 /dah⁸ ka¹ cia¹/ 騎自行車\n18. 駛車 /sai² cia¹/ 開車\n19. 撐船 /tên¹ zung⁵/\n20. 載客 /zai³ kêh⁴/\n21. 拗䷀囝 /ao² gag⁴ gian²/ 摩托車司機。拗，載；扛。\n22. 落車 /lo² cia¹/ 下車\n23. 碼頭 /bhê² tao⁵/\n24. 涵空、涵孔 /am⁵ kang¹/ 涵洞、涵管、地下水道\n25. 橋墩 /gio⁵ dun¹/ 橋梁下面的圓柱狀基石\n\n### 🐒眾生(zêng³ sên¹)\n\n1. 眾生 /zêng³ sên¹/ 牲畜\n2. 禽兽 /kim⁵ siu⁶/\n3. 害蟲 /hai⁷ tang⁵/\n4. 豬豭 /du¹ go¹/ 配種的公豬，也比喻好色之徒。\n5. 豬槽 /du¹ zo⁵/\n6. 羊牢 /ion⁵ lo⁵/\n7. 雞翁 /goi¹ ang¹/ 雄雞\n8. 雞母 /goi¹ bho²/ 母雞\n9. 鴨囝 /ah⁴ gian²/ 小鴨子\n10. 鵝 /gho⁵/\n11. 貓牯 /ngiao¹ gao²/ 母貓\n12. 鳥 /ziao²/\n13. 燕囝 /in³ gian²/ 小燕子\n14. 鶴 /hoh⁸/\n15. 鷹 /êng¹/\n16. 白鴿 /bêh⁸ gab⁴/\n17. 白鷺鷥 /bêh⁸ lao⁷ si¹/\n18. 鸚哥 /êng¹ go¹/ 鸚鵡\n19. 麻雀 /mua⁵ ziah⁴/\n20. 蝠婆 /big⁴ bo⁵/ 蝙蝠\n21. 蛇 /zua⁵/\n22. 雨傘節 /hao⁶ suan³ zag⁴/ 一种毒蛇。\n23. 狗母蛇 /gao² bho² zua⁵/ 蛇舅母、石龍子、四腳蛇，蜥蜴的一種\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%201.png)\n\n24. 兩棲動物 /liang² ci¹ dong⁶ moih⁸/\n25. 蟾蜍 /ziong¹ zu⁵/\n26. 蛤虯 /gab⁴ giu²/ 青蛙\n27. 蛤蛙 /gab⁴ guai¹/ 蝌蚪\n28. 蚼蟻 /gao² hia⁶/ 螞蟻\n29. 白蟻 /bêh⁸ hia⁶/\n30. 蜜蜂 /bhig⁸ pang¹/\n31. 虎頭蜂 /hao² tao⁵ pang¹/ 黄蜂\n32. 龜 /gu¹/ 烏龜或像烏龜的昆蟲\n33. 金龜 /gim¹ gu¹/ 金龜子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%202.png)\n\n34. 鱉 /bih⁴/\n35. 土蚓 /dao⁶ ung²/ 蚯蚓\n36. 蜈蚣 /gê⁵ gang¹/\n37. 火金蛄 /hoi² gim¹ gao¹/ 螢火蟲\n38. 牛屎龜 /ghu⁵ sai² gu¹/ 屎殼郎、蜣螂\n39. 烏點龜 /ao¹ diam² gu¹/ 七星瓢蟲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%203.png)\n\n40. 紅新娘 /ang⁵ sing¹ nion⁵/ 紅姬緣椿象\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%204.png)\n\n41. 山蛚 /sua¹ lê⁷/ 蟬；多指[蚱蝉](http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14818)\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%205.png)\n\n42. 蝘悲蟬 /iam⁶ bi¹ sung⁵/ [蟪蛄](http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14817)\n\n    ![gahzi-oi-hung-lui-ci-biao/image.jpg](gahzi-oi-hung-lui-ci-biao/image.jpg)\n\n43. 蟋蟀 /tih⁴ sug⁴/ 又稱烏龍。\n44. ䷀ // 螽斯、莎蟲、紡織娘、蟈蟈。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%206.png)\n\n45. 草猴 // 稻蝦\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%207.png)\n\n46. ䷀ // 金盾龜金花蟲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%208.png)\n\n47. 草蜢 /cao² mên²/ 螞蚱、蚱蜢。\n48. 螳螂、螳蜋 /tang⁵ lang⁵/\n49. 神螂 /sing⁵ lang⁵/ 壁虎，蜥蜴的一種。\n50. 蛤蚧蛇 /gab⁴ gai³ zua⁵/ 大壁虎，蜥蜴的一種。\n51. 土猴 /dao⁶ gao⁵/ 螻蛄\n52. 蝶、蜨 /iah⁸/ 蝴蝶\n53. 山螟 /suan¹ mê¹/ 蜻蜓\n54. 米龜 /bhi² gu¹/ 米象，蛀食稻穀、麥粒等米糧爲生。\n55. 蛀蟲 /zu³ tang⁵/\n56. 蛓毛蟲 /ci³ mo⁵ tang⁵/ 毛毛蟲\n57. 流鼻螺 /lao⁵ pin⁷ lê⁵/ 蝸牛\n58. 戶蠅 /hao⁵ sing⁵/ 蒼蠅\n59. 枯蠅 /gao¹ sing⁵/ 介殼蟲\n60. 蠓、蚊 /mang²/\n61. 蝨母 /sag⁴ bho²/ 蝨子\n62. 曱甴、虼蚻 /ga¹ zuah⁸/ 蟑螂\n63. 蜈蜞 /ghao⁵ ki⁵/ 水蛭，喜歡吸血人畜血液。\n\n### 🐳水產(zui² suan²)\n\n1. 䭕水魚 /zian² zui² hu⁵/ 淡水魚\n2. 鹹水魚 /giam⁵ zui² hu⁵/ 海水魚\n3. 刣魚 /tai⁵ hu⁵/ 宰魚\n4. 魚春 /hu⁵ cung¹/ 魚卵。屈大均《廣東新語》：「粵方言凡禽魚卵皆為春。唐時吳君貢魚春子，即魚子也。」 \n5. 魚鱗 /hu⁵ lang⁵/\n6. 魚鰾 /hu⁵ pio⁶/\n7. 魚鰓 /hu⁵ ci¹/\n8. 魚刺 /hu⁵ ci³/\n9. 鯁 /gên²/ 魚刺在喉\n10. 馬鮫 /mê² ga¹/\n11. 鯧 /cion¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%209.png)\n\n12. 鰇魚 /riu⁵ hu⁵/ 魷魚\n13. 墨斗 /bhag⁸ dao²/、/mag⁸ dao²/ 墨魚\n14. 絲丁魚 /si¹ dêng⁶ hu⁵/ 龍頭魚、硬魚、橂魚(殿魚)、豆腐魚\n15. 狗母魚 // 蝦虎魚、狗魽仔魚、九甘魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2010.png)\n\n16. 白目噯 /ain²/\n17. 狗母囝 // 身體透明，似魩仔鱼，有淡水和海水兩種\n18. 鰻魚 /muan⁵ hu⁵/\n19. 花仙魚 /hoi¹ siang¹ hu⁵/ 鮐魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2011.png)\n\n20. 鸚哥魚 /êng¹ go¹ hu⁵/ 洛神項鰭魚、紅姑娘、紅新娘、碼頭魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2012.png)\n\n21. 癩瘑魚 /na³ go¹ hu⁵/、/lai³ go¹ hu⁵/ 多齒蛇鯔，俗稱「那哥魚」，常用於製魚丸。\n22. 娘愛魚 /nion⁵ ain¹ hu⁵/ 泥猛魚、褐篮子鱼、臭肚鱼。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2013.png)\n\n23. ䷀囝 /dêg⁸ gian²/ 又稱迪仔、綠鰭馬面魨、剝皮魚。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2014.png)\n\n24. 䱛囝 /oig⁸ gian²/ 䱛仔、䱛魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2015.png)\n\n25. 金龍䱛 /gim¹ lêng⁵ oig⁸/ 金龍魚、黃花魚，狀似䱛魚但個頭大、嘴圓、體黃。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2016.png)\n\n26. 福壽魚 /hog⁴ siu⁶ hu⁵/ 羅非魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2017.png)\n\n27. 鮭魚 /guai¹ hu⁵/ 河魨，俗稱「乖魚」，常指黃鰭東方魨。\n28. 黃牆 /ng⁵ cion⁵/ 黃鰭鯛\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2018.png)\n\n29. 軟甘 /nng² gang¹/ 杜氏鰤、油甘，體側有黃色縱帶。 \n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2019.png)\n\n30. 沙尖 /sua¹ ziam¹/ 多鱗鱚、沙鯪、北方稱沙丁魚。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2020.png)\n\n31. 龍箭 /lang⁷ zin⁷/ 鯪魚 ，淡水魚，可用於做罐頭魚。\n32. 石剎 /zio² sag⁴/ 又稱烏雞，松鯛。\n33. 淡角魚 /dam⁶ gag⁴ hu⁵/ 鯒魚、辮子魚\n34. 烏魚 /ao¹ hu⁵/ 又稱烏頭，鯔魚。\n35. 烏前魚 /ao¹ zain⁵ hu⁵/\n36. 塗虱 /tao⁵ sag⁴/ 鬍子鯰\n37. 龍舌 /lêng⁵ zi²/ 龍利魚\n38. 巴浪 /ba¹ lang¹/ 藍圓鯵\n39. 鯇魚 /uang² hu⁵/ 草魚\n40. 姑魚 /gao¹ hu⁵/ 金色小沙丁魚\n41. 鯽魚 /zig⁴ hu⁵/\n42. 秋刀魚 /ciu¹ do¹ hu⁵/\n43. 紅目鰱 /ang⁵ mag⁸ liang⁵/ 紅目大眼鯛\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2021.png)\n\n44. 田鱔 /cang⁵ cuan⁶/ 鱔魚、黃鱔\n45. 白帶魚 /bêh⁸ dua³ hu⁵/ 鞭魚、裙帶魚、海刀魚\n46. 鰐魚 /ngag⁸ hu⁵/\n47. 鯊魚 /sua¹ hu⁵/\n48. 鯨魚 /kêng⁵ hu⁵/\n49. 紅哥鯉 /ang⁵ go¹ li²/ 金線魚\n50. 蝦 /hê⁵/\n51. 蟹 /hoi⁶/\n52. 三目蠘 /san¹ mag⁸ cih⁸/ 紅星梭子蟹、三目蟹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2022.png)\n\n53. 海哲 /hai² diag⁴/\n54. 蠔、蚝、蚵 /o⁵/ 牡蠣\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2023.png)\n\n55. 紅肉 /ang⁵ nê²/ 紅肉藍蛤\n56. 蚶 /ham¹/\n57. 蜆 /hain⁶/\n58. 青匙 /cên¹ si⁵/ 綠殼菜蛤、翡翠貽貝\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2024.png)\n\n59. 花蛤 /hoi¹ gab⁴/ 菲律賓簾蛤、花甲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2025.png)\n\n60. 車白 /cia¹ bêh⁸/ 文蛤，邊緣弧度較花蛤圓。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2026.png)\n\n61. 青蛤 /cên¹ gab⁴/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2027.png)\n\n62. 毛蚶 /mo⁵ ham¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2028.png)\n\n63. 薄殼 /bo² kag⁴/ 尋氏肌蛤、海蛔、海瓜子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2029.png)\n\n64. 指甲螳 /zain² gah⁴ tang⁵/ 又稱指甲蚌hong²，蟶sêng³子。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2030.png)\n\n65. 田螺 /cang⁵ lê⁵/\n66. 尖螺 /ziang¹ lê⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2031.png)\n\n### 🌾 蔬菜(so¹ cai³)\n\n1. 五穀 /ngao⁶ gag⁴/\n2. 稻 /diu⁶/\n3. 粟 /cêg⁴/ 稻粒\n4. 麥 /mê²/\n5. 秫米 /zu² bhi²/ 糯米\n6. 薏米 /in³ bhi²/\n7. 薏仁 /in³ ring⁵/ 玉米\n8. 蕃薯 /huang¹ zu⁵/、/hang¹ zu⁵/\n9. 馬鈴薯 /mê² lêng¹ zu⁵/ 土豆\n10. 黃豆 /ng⁵ dao⁷/ 大豆、菽\n11. 綠豆 /lê² dao⁷/\n12. 烏豆 /ao¹ dao⁷/ 黑豆\n13. 赤豆 /ciah⁴ dao⁷/ 紅小豆\n14. 荷目豆 /ho⁵ mag⁸ dao⁷/ 荷蘭豆、豌豆\n15. 地豆 /di⁷ dao⁷/ 花生\n16. 豆仁 /dao⁷ ring⁵/ 花生米\n17. 油麻 /iu⁵ mua⁵/ 芝麻\n18. 菜豆 /cai³ dao⁷/ 常指四季豆\n19. 茄 /gio⁵/\n20. 苦瓜 /kao² goi¹/\n21. 角瓜 /gag⁴ goi¹/ 稜角絲瓜\n22. 秋瓜 /ciu¹ goi¹/ 絲瓜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2032.png)\n\n23. 嬭瓜、奶瓜 /nê¹ goi¹/ 木瓜\n24. 蓮藕 /nain⁵ nao⁶/\n25. 菠薐菜 /boi¹ lêng⁵ cai³/ 菠菜\n26. 蕹菜 /êng³ cai³/ 空心菜\n27. 春菜 /cung¹ cai³/ 長葉芥菜\n28. 菜花 /cai³ hoi¹/ 花椰菜\n29. 芥菜 /gua³ cai³/ 大芥菜、包心芥菜\n30. 芥藍 /gêg⁴ na⁵/\n31. 菜頭 /cai³ tao⁵/ 白蘿蔔\n32. 紅菜頭 /ang⁵ cai³ tao⁵/ 紅蘿蔔\n33. 薺蔥、錢蔥 /zin⁵ cang¹/ 荸薺\n34. 韭菜 /gu² cai³/\n35. 芫荽 /iang¹ sui¹/ 香菜\n36. 芳菜 /pang¹ cai³/\n37. 厚合 /gao⁶ hah⁸/ 厚皮菜、莙薘菜、葉用甜菜\n38. 九層塔 /gao² zang⁵ tah³/ 金不換、羅勒\n39. 萵菜 /oi¹ cai³/ 皺葉萵苣、生菜\n40. 劍菜 /giam³ cai³/ 油麥菜\n41. 上海青 /siang⁶ hai² cên¹/ 青菜的一種\n42. 芹菜 /king⁵ cai³/\n43. 津白 /gian¹ bêh⁸/ 又稱紹菜、黃芽白，天津盛產，是大白菜的一種。以下是大白菜的不同品種。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2033.png)\n\n    天津大白菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2034.png)\n\n    大白菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2035.png)\n\n    娃娃菜\n\n44. 高麗菜 /go¹ lê⁵ cai³/ 捲心菜、包菜、結球甘藍\n45. 菜花 /cai³ hoi¹/ 花椰菜\n46. 茼蒿 /dang⁵ o¹/\n47. 枸杞菜 /gao² gi² cai³/\n48. 真珠菜 /zing¹ zu¹ cai³/ 珍珠花菜、白苞蒿\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2036.png)\n\n49. 薟椒 /hiam¹ tsio¹/ 辣椒\n50. 生果 /cên¹ goi²/ 水果\n51. 荔果 /nai⁶ goi²/ 荔枝\n52. 龍眼 /nging⁵ ain²/\n53. 桑垂 /siong¹ sui⁵/ 桑葚\n54. 草莓 /cao² bhoi⁵/\n55. 刺菠 /ci³ bo¹/ 蛇莓、覆盆子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2037.png)\n\n56. 弓蕉 /gêng¹ zio¹/ 香蕉\n57. 米蕉 /bhi² zio¹/\n58. 鳥梨 /ziao² lai⁵/\n59. 檨 /suain⁷/ 芒果\n60. 菝囝 /bag⁸ gian²/ 番石榴\n61. 西瓜 /si¹ goi¹/\n62. 香櫞 /hion¹ ng⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2038.png)\n\n63. 柚 /iu⁷/\n64. 柑 /gan¹/ 柑橘\n65. 桔 /gig⁴/\n66. 橙 /cêng⁵/\n67. 菠蘿 /bo¹ lo⁵/\n68. 油甘 /iu⁵ gam¹/ 餘甘果，先苦後甜，齒留餘甘。\n69. 番茄 /huang¹ gio⁵/\n70. 青竹梅 /cên¹ dêg⁴ bhoi⁵/\n71. 李 /li²/\n72. 棗 /zo²/\n73. 蔗 /zia³/ 甘蔗\n\n### 🌿草藥 /cao² ioh⁸/\n\n1. 艾 /hia³/ 艾草 \n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2039.png)\n\n2. 草粿草 /cao² goi² cao²/ 仙草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2040.png)\n\n3. 策草 /cêg⁴ cao²/ 又稱抹(bhuah⁴)草、廣防風、防風草，甲子地區神位常年插此草。策 ，大概是指其像馬鞭。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2041.png)\n\n4. 青菭 /cên¹ ti⁵/ 青苔\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2042.png)\n\n5. 薄荷 /bo⁵ ho³/、/bon⁵ hon³/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2043.png)\n\n6. 金銀花 /gim¹ nging⁵ hoi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2044.png)\n\n7. 午時花 /ngao² si⁵ hoi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2045.png)\n\n8. 四季春 /si³ kui³ cung¹/ 四季春花\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2046.png)\n\n9. 葉下紅 /hio² ê⁶ ang⁵/ 一點紅\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2047.png)\n\n10. 臭草花 /cao³ cao² hoi¹/ 五色梅、馬纓丹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2048.png)\n\n11. 飛天蜈蚣 /boi¹ tin¹ ghê⁵ gang¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2049.png)\n\n12. 金雞脫殼 /gim¹ goi¹ tug⁴ kag⁴/\n13. 路跤菊 /lao⁷ ka¹ gêg⁴/ 路邊菊\n14. 臘裏葉 /lah⁸ li² hioh⁸/ 金邊紅桑\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2050.png)\n\n15. 芒囝筍 /mang⁵ gian² sung²/ 芒草的嫩芽\n16. 竹菜 /dêg⁴ cai³/ 竹葉草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2051.png)\n\n17. 葛菜 /guah⁴ cai³/ 野葛菜，可食。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2052.png)\n\n18. 烏規菜 /ao¹ gui¹ cai³/ 龍葵\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2053.png)\n\n19. 豬母菜 /du¹ bho² cai³/ 馬齒莧\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2054.png)\n\n20. 刺莧 /ci³ hain⁷/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2055.png)\n\n21. 苦刺 /kao² ci³/ 白簕\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2056.png)\n\n22. 苦草 /kao² cao²/ 豨薟草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2057.png)\n\n23. 兩公根 /liang² gong¹ ging¹/ 崩大碗\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2058.png)\n\n24. 鋪地錦 /pao¹ di⁷ gim²/ 滿天星\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2059.png)\n\n25. 雞屎藤 /goi¹ sai² ding⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2060.png)\n\n26. 伸筋藤 /cung¹ ging¹ ding⁵/ 蔓九節\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2061.png)\n\n27. 無頭藤 /bho⁵ tao⁵ ding⁵/ 寄生於其他植物之上\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2062.png)\n\n28. 酒甕囝 /ziu² ang³ gian²/\n29. 盐酸鸡囝 /iam⁵ sng¹ goi¹ gian²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2063.png)\n\n30. 見笑草 /giang³ siao³ cao²/ 含羞草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2064.png)\n\n31. 燈籠草 /dêng¹ lang⁵ cao²/ 其果子稱爲「姑娘果」\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2065.png)\n\n32. 車前草 /cia¹ zain⁵ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2066.png)\n\n33. 馬鞭草 /bhê² bin¹ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2067.png)\n\n34. 蟋蟀草 /tig⁴ sug⁴ cao²/ 烏龍草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2068.png)\n\n35. 蒲公英 /pu⁵ gong¹ êng¹/\n36. 鸭舌草 /ah³ zih⁸ cao²/ 苦菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2069.png)\n\n37. 魚腥草 /hu⁵ co³ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2070.png)\n\n38. 益母草 /iah⁴ bho² cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2071.png)\n\n39. 龍膽草 /lêng⁵ dan² cao²/ 苦地膽草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2072.png)\n\n40. 奶汁草 /nê¹ zab⁴ cao²/ 乳汁草，草折斷會有白色液體流出。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2073.png)\n\n41. 虎耳草 /haon² hin⁶ cao³/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2074.png)\n\n42. 大號奶汁草 /dua⁷ ho⁷ nê¹ zab⁴ cao³/ 蠔割草、飛揚草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2075.png)\n\n43. 貓毛兒 /ngiao¹ mo⁵ ri⁵/ 金絲草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2076.png)\n\n44. 貓鬚草 /ngiao¹ ciu¹ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2077.png)\n\n45. 鹅囝香 /gho⁵ gian² hiang¹/ 鹅不食草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2078.png)\n\n46. 白花蛇舌草 /bêh⁸ hoi¹ zua⁵ zih⁸ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2079.png)\n\n47. 白花蟛蜞草 /bêh⁸ hoi¹ pen⁵ ki⁵ cao²/、/bêh⁸ hoi¹ mua⁵ ki⁵ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2080.png)\n\n48. 四方枝苦楝 /si³ bang¹ gi¹ kao² nai⁷/ 鬼針草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2081.png)\n\n49. 苦楝 /kao² nai⁷/ 苦楝樹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2082.png)\n\n50. 挨礱被哺 /oi⁵ lang⁵ bi⁶ bu⁶/ 磨盤草、磨礱草、挨礱地堵，其果實似磨盤和礱。礱，磨谷農具。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2083.png)\n\n### 🏮時節(si⁵ zoih⁴)\n\n1. 今年 /gim¹ ni⁵/\n2. 舊年 /gu⁷ ni⁵/ 去年\n3. 前年 /zain³ ni⁵/、/zung³ ni⁵/\n4. 下年 /ê⁶ ni⁵/ 明年\n5. 熱天時 /ruah⁸ tin¹ si⁵/ 夏天\n6. 寒天時 /guan⁵ tin¹ si⁵/ 冬天\n7. 凝天時 /ngang⁵ tin¹ si⁵/ 冬天\n8. 春夏秋冬 /cung¹ hê⁶ ciu¹ dang¹/\n9. 老歷 /lao⁶ lê²/ 農曆\n10. 新曆 /sing¹ lê²/ 公曆\n11. 今日 /gim¹ rig⁸/\n12. 明日 /mêng⁵ rig⁸/\n13. 今旦日 /gian² rig⁸/ 今天\n14. 明旦日 /man³ rig⁸/ 明天\n15. 明眠起 /ma³ mng⁵ ki²/ 明天\n16. 昨日 /za¹ rig⁸/\n17. 前日 /zain⁵ rig⁸/、/zoh⁸ rig⁸/\n18. 後日 /ao⁶ rig⁸/\n19. 大前日 /dua⁷ zain⁵ rig⁸/、/dua⁷ zoh⁸ rig⁸/\n20. 大後日 /dua⁷ ao⁶ rig⁸/\n21. 天光 /tin¹ gng¹/ 天亮\n22. 透早 /tao³ za²/ 黎明\n23. 眠起 /mng⁵ ki²/ 早晨\n24. 日時 /rig⁸ si⁷/ 白天\n25. 早晝 /za² dao³/ 上午\n26. 中晝 /dêng¹ dao³/ 中午\n27. 中晝時 /dêng¹ dao³ si⁵/ 中午\n28. 下晝 /ê⁶ dao³/ 下午\n29. 下旰 /ê⁶ gua³/ 下午\n30. 暗頭 /am³ tao⁵/ 傍晚\n31. 暗頭時 /am³ tao⁵ si⁵/ 傍晚\n32. 下昏 /ê⁶ hng⁵/ 晚上\n33. 下昏時 /ê⁶ hng⁵ si⁵/、/êng² si⁵/ 晚上\n34. 下昏囝 /êng² gian²/ 晚上\n35. 暗時 /am³ si⁷/ 晚上\n36. 暝時、夜時 /mê⁵ si⁷/ 晚上\n37. 暝昏、夜昏 /mê⁵ hng⁵/ 晚上\n38. 暝昏時、夜昏時 /mê⁵ hng⁵ si⁵/、/mêng² si⁵/ 晚上\n39. 暝昏囝 /mêng² gian²/ 晚上\n40. 半暝、半夜 /buan³ mê⁵/\n41. 時分秒 /si⁵ hung⁵ miao²/\n42. 個字 /gai⁵ ri⁷/ 五分鐘\n43. 兩個字久 /no⁶ gai⁵ ri⁷ gu²/ 十分鐘\n44. 頭前 /tao⁵ zain⁵/ 之前\n45. 頭陣 /tao⁵ zung⁵/ 剛才\n46. 下 /ê⁶ miag⁸/、/ê⁶ mig⁸/ 剛才\n47. 一頃 /zêg⁸ kuang³/ 一會兒\n48. 一頃頭 /zêg⁸ kuang³ tao⁵/ 一下子\n49. 煞尾 /suah⁴ bhoi²/ 最後\n50. 今 /dan¹/ 現在\n51. 逐日 /dag⁸ rig⁸/ 每天\n52. 逐暝 /dag⁸ mê⁵/ 每晚\n53. 通日 /tang³ rig⁸/ 整天\n54. 半日 /buan³ rig⁸/\n55. 隔日 /gêh⁴ rig⁸/\n56. 隔暝、隔夜 /gêh⁴ mê⁵/\n57. 別日 /bag⁸ rig⁸/ 改天\n58. 即時 /ziag⁴ si⁵/ 立刻、馬上\n59. 平常時 /pêng⁵ sion⁵ si⁵/ 平時\n60. 一日通通 /zêg⁸ rig⁸ tang³ tang³/ 一整天\n61. 七早八早 /cig⁴ za² boih⁴ za²/ 一大早\n62. 七早蒙流 /cig⁴ za² mo⁵ liu⁵/ 一大早\n63. 烏暗天地 /ao¹ am³ tin¹ di¹/ 天昏地暗\n64. 立春 /lib⁸ cung¹/\n65. 雨水 /u² sui²/\n66. 驚蟄 /gêng¹ dêg8/\n67. 春分 /cung¹ hung¹/\n68. 清明 /cêng¹ mêng⁵/\n69. 谷雨 /gog⁴ u²/\n70. 立夏 /lib⁸ hê⁶/\n71. 小滿 /sio² muan²/\n72. 芒種 /mang⁵ zêng²/\n73. 夏至 /hê⁶ zi³/\n74. 小暑 /siao² su²/\n75. 大暑 /dai⁶ su²/\n76. 立秋 /lib⁸ ciu¹/\n77. 處暑 /cu³ su²/\n78. 白露 /bêh⁸ lao⁷/\n79. 秋分 /ciu¹ hung¹/\n80. 寒露 /guan⁵ lao⁷/\n81. 霜降 /sang¹ gang³/\n82. 立冬 /lib⁸ dang¹/\n83. 小雪 /siao² soh⁴/\n84. 大雪 /dai⁶ soh⁴/\n85. 冬至 /dang¹ zi³/\n86. 小寒 /siao² hang⁵/\n87. 大寒 /dai⁶ hang⁵/\n88. 時年八節 /si⁵ ni⁵ boih⁴ zoih⁴/ 一年四季八個節，最早的八節指立春、春分、立夏、夏至、立秋、秋分、立冬和冬至。而在甲子時年八節指元宵、春分、清明、五月節、七月半、秋分、八月半、冬節，過此八節要拜祖，除春分、秋分外的節還需要拜神。\n    - 四時，四季、春夏秋冬。\n    - 年，甲骨文象人負禾之形，會穀物豐收之意，古時禾穀一年一熟，於是「年」被（引申）用作周年之年。【爾雅•釋天】夏曰歲，商曰祀，周日年，唐虞曰載。古時一度流行歲星（即木星、朱比特星，公轉週期爲 398.88 天）紀年，故一年又稱一歲。\n    - 時年，一年四季。\n    - 節，中國曆法把一年分為二十四段，每段的開始即爲節。早期只有春分、秋分、夏至、冬至四節，後又加入立春、立夏、立秋、立冬，形成八節，再來後逐漸形成了二十四節。「節」早期是天文曆法上的概念，與氣候相關，後又逐漸加入了紀念或慶祝的元素。\n89. 元宵節 /nguang⁵ siao¹ zoih⁴/\n90. 公忌節 /gong¹ gi⁷ zoih⁴/ 春分和秋分，祭拜先祖，但不拜神。\n91. 清明節 /cêng¹ mêng⁵ zoih⁴/\n92. 五月節 /ngao⁶ ghoih⁸ zoih⁴/ 端午節\n93. 七月半 /cig⁴ ghoih⁸ buan³/ 中元節、鬼節\n94. 八月半 /boih⁴ ghoih⁸ buan³/ 中秋節\n95. 冬節 /dang¹ zoih⁴/ 冬至節的簡稱。\n96. 廿九暝、廿九夜 /rig⁸ gao² mê⁵/ 除夕（小月）\n97. 三十暝、三十夜 /san¹ zab⁸ mê⁵/ 除夕（大月）\n98. 春節 /cung¹ zoih⁴/\n99. 重陽 /ciang⁵ iang⁵/、/dêng⁵ iang⁵/\n100. 國慶節 /gog⁴ kêng³ zoih⁴/\n101. 勞動節 /lao⁵ dong⁶ zoih⁴/\n102. 婦女節 /hu⁶ nng² zoih⁴/\n103. 兒童節 /ri⁵ tong⁵ zoih⁴/\n104. 教師節 /ga³ su¹ zoih⁴/\n105. 做節 /zo³ zoih⁴/ 過節日\n106. 做壽 /zo³ siu⁶/ 過壽辰\n107. 做生日 /zo³ sên¹ rig⁸/ 過生日\n108. 公忌 /gong¹ gi⁷/ 先祖忌日\n109. 拜公忌 /bai³ gong¹ gi⁷/ 在忌日祭拜先祖\n110. 拜祖 // 祭拜先祖\n111. 拜老爺 // 拜神\n112. 假日 /gia² rig⁸/\n113. 放假 /bang³ gia²/、/bang³ gian²/\n114. 暑假 /su² gia²/\n115. 寒假 /hang⁵ gia²/\n\n### 🌀天時(tin¹ si⁵)\n\n1. 晴 /zên⁵/ 晴朗\n2. 出日 /cug⁴ rig⁸/ 太陽出來了\n3. 透堂白日 /tao³ dng⁵ bêh⁸ rig⁸/ 大白天\n4. 烏陰天 /ao¹ im¹ tin¹/ 陰天\n5. 透風 /tao³ hong¹/ 刮大風\n6. 風颱 /hong¹ tai¹/ 颱風\n7. 南風天 /nang¹ hong¹ tin¹/ 刮南風，濕氣加重\n8. 轉南風 /dng² nang¹ hong¹/ 南風天來了\n9. 透南風 /tao³ nang¹ hong¹/ 刮南風，伍佰有一 Live 同名。\n10. 蒙煙天 /mong⁵ iang¹ tin¹/ 霧霾天\n11. 落雨 /lo² hao⁶/ 下雨\n12. 一陣雨 /zêg⁸ zung⁵ hao⁶/\n13. 日頭雨 /rig⁸ tao⁵ hao⁶/ 一邊下雨，一邊出太陽\n14. 烏寒雨 /ao¹ guan⁵ hao⁶/ 天時烏陰落寒雨\n15. 爍焰 /sih⁴ iam⁶/ 閃電\n16. 敲雷 /ka³ lui⁵/ 打雷\n17. 冷空氣 /lêng² kong¹ ki⁷/\n18. 落雪 /lo² soh⁴/ 下雪\n19. 落雹 /lo² pag⁸/ 下冰雹\n20. 旱 /uan⁶/ 乾旱\n21. 寒 /guan⁵/ 寒冷\n22. 冷 /lêng²/ 寒冷\n23. 凝 /ngang⁵/ 寒冷\n24. 熱 /ruah⁸/\n25. 翕熱 /hib⁴ ruah⁸/ 悶熱\n26. 乾燥 /gang¹ cao³/\n27. 濕 /sib⁴/ 濕潤\n28. 涼 /liang⁵/ 涼爽\n\n### 🌛天文(tiang¹ bhung⁵)\n\n1. 天頂 /tin¹ dêng²/ 天上\n2. 日頭 /rig⁸ tao⁵/ 太陽\n3. 蝕日 /sih⁸ rig⁸/ 日食\n4. 狗齧日 /gao² na² rig⁸/ 天狗食日\n5. 西照日 /sai¹ zio³ rig⁸/ 夕陽\n6. 月娘 /ghoih⁸ nion⁵/ 月亮\n7. 月眉 /ghoih⁸ bhai⁵/ 弦月\n8. 蝕月 /sih⁸ ghoih⁸/ 月食\n9. 河溪 /ho⁵ koi¹/ 銀河、天河\n10. 落屎星 /lo² sai² cên¹/ 流星\n11. 星宿 /cên¹ siu³/\n\n### ⛰️地理(di⁷ li²)\n\n1. 中央 /diong¹ iang¹/ 中間\n2. 內底 /lai⁶ doi²/ 裏面\n3. 外口 /ghua⁷ kao²/、/la¹ kao²/ 外面\n4. 頭頂 /tao⁵ dêng²/ 上面\n5. 下跤 /ê⁶ ka¹/ 下面\n6. 下底 /ê⁶ doi²/ 下面\n7. 正手爿 /ziang³ ciu² bain⁵/ 左邊\n8. 倒手爿 /do³ ciu² bain⁵/ 右邊\n9. 頭前 /tao⁵ zain⁵/ 前面\n10. 後底 /ao⁶ doi²/ 後面\n11. 後壁 /ao⁶ biah⁴/ 後面\n12. 對面 /dui³ ming⁷/\n13. 隔壁 /gêh⁴ biah⁴/\n14. 鄰近 /lim¹ ging⁶/\n15. 塗跤 /tao⁵ ka¹/\n16. 番爿 /huang¹ bain⁵/\n17. 北爿 /bag⁴ bain⁵/\n18. 東南西北 /dang¹ nam⁵ sai¹ bag⁴/\n19. 地盤 /di⁷ buan⁵/\n20. 領域 /nia² oig⁸/\n21. 境內 /gêng² lai⁶/\n22. 世界 /si³ gai³/\n23. 宇宙 /u² diu²/\n24. 全球 /cuang¹ giu⁵/\n25. 天涯 /tiang¹ ngai⁵/\n26. 山頂 /suan¹ dêng²/\n27. 山跤 /suan¹ ka¹/\n28. 外地 /ghua⁷ dê³/\n29. 本地 /bng² di⁷/\n30. 別地 /bag⁸ dê³/ 外地\n31. 別地地 /bag⁸ di⁷ dê³/ 外地\n32. 塗 /tao⁵/ 泥\n33. 塗膏 /tao⁵ go¹/ 泥巴\n34. 石頭 /zioh⁸ tao⁵/\n35. 田園 /cang⁵ hng⁵/\n36. 溪墘 /koi¹ gin⁵/ 溪邊\n37. 草埔 /cao² bao¹/ 草坪\n38. 崎 /gia⁶/ 小山坡\n39. 坑 /kên/ 山谷、溪谷。\n40. 嶺 /nia²/ 有路可通的山頂\n41. 岑 /ngim⁵/、/cam⁵/ 小而高的山\n42. 墟 /hu¹/ 大土山\n43. 壩 /ba³/ 沙灘、沙洲。\n44. 潭 /tam⁵/ 深水池\n45. 溪 /koi¹/\n46. 江 /gang¹/\n47. 河 /ho⁵/\n48. 湖 /ao⁵/\n49. 海 /hai²/\n50. 海拔 /hai² buag⁸/\n51. 洲 /ziu¹/\n52. 港 /gang²/\n53. 灣 /uang¹/\n54. 溝 /gao¹/\n55. 渠 /ku⁵/ 水道，特指人工開的河道。\n56. 浦 /pao²/ 水邊或江河入海處\n57. 澳 /o³/ 海邊彎曲且可停泊船隻的地方\n58. 汕 /suan³/ 河流沖刷或沖刷而積成的沙灘\n59. 汕頭 /suan¹ tao⁵/\n60. 汕尾 /suan³ bhoi²/\n61. 海湧 /hai² êng²/ 海浪。湧，波浪。\n62. 東濠湧 /dang¹ hao⁵ cong¹/ 地名，在廣州越秀。濠，溝渠。湧，河流分叉處。\n63. 湧泉相報 /iong³ zuan⁵ siang¹ bo³/ 湧，水冒出。\n64. 庭、埕 /dian⁵/ 院子、宽阔处\n65. 礦物 /kuang³ moih⁸/\n66. 化石 /hoi³ zioh⁸/\n67. 原油 /nguang¹ iu⁵/\n68. 燃料 /riang⁵ liao⁷/\n69. 金屬 /gim¹ siog⁸/\n70. 金銀財寶 /gim¹ nging⁵ cai⁵ bo²/\n71. 鋼鐵 /gng³ tih⁴/\n72. 蘇打 /so³ da²/ 英文 soda 的音譯，常指小蘇打，即碳酸氫鈉。\n73. 蘇州 /sao¹ ziu¹/\n74. 蠟 /la²/\n75. 硫磺 /liu⁵ ng⁵/\n76. 砒霜 /bi¹ sng¹/\n77. 砂石 /sua¹ zioh⁸/\n78. 大理石 /dai⁶ li² zioh⁸/\n79. 碳 /tuan³/\n80. 水銀 /zui² nging⁵/\n81. 水龍水 /zui² lêng⁵ zui²/ 自來水\n82. 地牛換肩 /di⁷ ghu⁵ uang⁷ gain¹/ 地震\n83. 許婆寮 /kao² pua⁵ liao⁵/ 今可和村\n84. 北輋 /bag⁴ sia⁵/ 今博社村\n85. 四捻石 /si³ niam³ zio²/ 四片石\n86. 甲子八景：六十甲子欄、潮來人字水、雙帆跨海島、五馬渡江邊、仙人踏石積、海甲蓮花山、西峯古寺、雷廟天堂。（《陸豐縣誌》卷之二疆域四 P21）\n87. 擎天石：位於甲秀書院的側邊的一塊巨石。《陸豐縣誌》記載：在甲子所北門內峙立聳拔高出雉堞丈余，中開一痕，俗謂雷打石。胡文烜銘其上曰：「天開甲子，巨石臨門，一聲霹靂，振動乾坤 ……」。字大如鬥，余銘苔蝕莫辨。（《陸豐縣誌》卷之二古蹟十二 ）\n88. 甲秀書院：甲秀書院位於陸豐縣甲子鎮北門內。甲秀書院建於明代，歷來為粵東文人會萃講學之所。至今院內仍保存著不少歷代的石碑石刻。解放后，人民政府在此興辦中學。\n89. 福源寺：座落於甲子鎮北郊雨亭路，原名「復元寺」，又稱「蓮花山草庵」。據傳，福源寺建於宋代。因歷史久遠，原址僅遺存牆基。1990年由光茂法師主持重建。經過10多年的建造，先後建成天王殿、大雄寶殿、觀音殿、地藏殿、鐘樓、鼓樓和禪房等，重塑了諸位菩薩聖像。寺區佔地面積1.2萬多平方米，建築面積3000多平方米。\n90. 南海夫人廟：位於甲子鎮城西社區環城路東。明萬曆元年（1573），李棠中舉後爲其妻卓氏而建的紀念祠，御史鄧練題匾「南海夫人」，故稱南海夫人廟。\n91. 烈士墓\n\n### 📐計量(goi³ liang⁶)\n\n1. 〇、零 /lêng⁵/、/lang⁵/\n2. 一、壹 /zêg⁸/、/ig⁴/\n3. 二、贰 /no⁶/、/ri⁶/\n4. 三、叁 /san¹/、/sam¹/\n5. 四、肆 /si³/、/su³/\n6. 五、伍 /ngao⁶/、/u²/\n7. 六、陆 /lag⁸/\n8. 七、柒 /cig⁴/\n9. 八、捌 /boih⁴/、/bag⁴/\n10. 九、玖 /gao²/、/giu²/\n11. 十、拾 /zab⁸/\n12. 百、佰 /bêh⁴/\n13. 千、仟 /cain¹/、/ciang¹/\n14. 萬 /mang⁷/\n15. 億 /êg⁸/\n16. 一二個 /zêg⁸ no² gai⁵/\n17. 二十六 /ri⁸ ab⁸ lag⁸/、/ri⁸ zab⁸ lag⁸/\n18. 廿六號 /rig⁸ lag⁸ ho⁷/ 二十六號\n19. 五十外個 /ngao⁶ zab⁸ ghua⁷ gai⁵/\n20. 一百空八 /zêg⁸ bêh⁴ kang³ boih⁴/ 一百零八\n21. 第一 /doi⁷ ig⁴/\n22. 第二 /doi⁷ ri⁶/\n23. 第三 /doi⁷ san¹/\n24. 一個人 /zêg⁸ gai⁵ nang⁵/\n25. 一爿花 /zêg⁸ bain⁵ hoi¹/ 一片花瓣\n26. 一蕊花 /zêg⁸ lui² hoi¹/ 一朵花\n27. 一葩花 /zêg⁸ pa¹ hoi¹/ 一朵花\n28. 一枝花 /zêg⁸ gi¹ hoi¹/\n29. 一縛花 /zêg⁸ ba² hoi¹/ 一束花\n30. 一叢樹 /zêg⁸ zang⁵ hoi¹/ 一棵樹\n31. 一簇頭毛 /zêg⁸ cog⁴ tao⁵ mo⁵/ 一撮頭髮\n32. 一粒糖 /zêg⁸ liab⁸ tng⁵/\n33. 一隻車 /zêg⁸ ziah⁴ cia¹/ 一輛車\n34. 一架車 /zêg⁸ gê³ cia¹/ 一輛車\n35. 一杯茶 /zêg⁸ boi¹ dê⁵/\n36. 一碗水 /zêg⁸ uan² zui²/\n37. 一喙水、一嘴水 /zêg⁸ cui³ zui²/ 一口水\n38. 一條弓蕉 /zêg⁸ diao⁵ gêng¹ zio¹/ 一條香蕉\n39. 一本書 /zêg⁸ bng² zu¹/\n40. 一枝手機 /zêg⁸ gi¹ ciu² gi¹/ 一隻手機\n41. 一枝鎖匙 /zêg⁸ gi¹ so² si⁵/ 一把鑰匙\n42. 一個銀 /zêg⁸ gai⁵ nging⁵/ 一塊錢\n43. 一領被 /zêg⁸ nia² poi⁶/ 一席被子\n44. 一個鋪 /zêg⁸ gai⁵ pao¹/ 一張床\n45. 一個鐘頭 /zêg⁸ gai⁵ zêng¹ tao⁵/ 一個小時\n46. 一副衫褲 /zêg⁸ hu³ san¹ kao³/ 一套衣服\n47. 一腰裙 /zêg⁸ io¹ gung⁵/ 一件裙子\n48. 一尾魚 /zêg⁸ bhoi² hu⁵/ 一條魚\n49. 一墩物件 /zêg⁸ dung¹ mi² gian⁶/ 一堆東西\n50. 一橛蔗 /zêg⁸ goi² zia³/ 一截甘蔗\n51. 一葩電火 /zêg⁸ pa¹ diang⁶ hoi²/ 一盞電燈\n52. 一跤箸、一腳箸 /zêg⁸ ka¹ du⁷/ 一隻筷子\n53. 一雙箸 /zêg⁸ sang¹ du⁷/ 一雙筷子\n54. 一腹火 /zêg⁸ bag⁴ hoi²/ 一肚子火\n55. 一脬屎 /zêg⁸ bu⁵ sai²/ 一坨屎\n56. 一脬尿 /zêg⁸ bu⁵ rio⁷/ 一泡尿\n57. 一逝路 /zêg⁸ zua⁷ lao⁷/ 一趟路\n58. 一丸塗 /zêg⁸ uang⁵ tao⁵/ 一團泥土\n59. 一過 /zêg⁸ goi³/ 一次\n\n### 🧭 指代(zi² toi³)\n\n1. 只 /zi²/ 這，近指。\n2. 許 /hi²/ 那，遠指。\n3. 者、這 /zê²/、/zia²/ 這，近指。\n4. 遐 /hê²/、/hia²/ 那，遠指。\n5. 底個 /di⁷ gai⁵/ 哪個\n6. 者個 /zê² gai⁷/、/zia² gai⁷/ 這個\n7. 遐個 /hê² gai⁷/、/hia² gai⁷/ 那個\n8. 怎樣 /za³ ion⁷/、/zion²/\n9. 乜樣 /mig⁴ ion⁷/ 怎樣\n10. 底樣 /di⁷ ion⁷/ 怎樣\n11. 怎生 /za³ sên¹/、/zai¹ sên¹/怎樣\n12. 怎樣生 /zion² sên¹/ 怎樣\n13. 怎樣然 /zion² ni⁵/、/zo⁵ ni⁵/ 怎麼、幹啥\n14. 怎樣麼 /zion² mo⁷/、/ziom²/\n15. 者樣 /zê² ion⁷/、/zion¹/\n16. 遐樣 /hê² ion⁷/、/hion¹/\n17. 者樣生 /zion¹ sên¹/ 這樣\n18. 遐樣生 /hion¹ sên¹/ 那樣\n19. 底搭 /di⁷ dah⁴/ 哪裏\n20. 者搭 /zê² dah⁴/ 這裏\n21. 遐搭 /hê² dah⁴/ 那裏\n22. 底地 /di⁷ dê³/ 哪裏\n23. 者地方 /zê² ding¹/ 這裏\n24. 遐地方 /hê² ding¹/ 那裏\n25. 底囝 /di⁷ gian²/ 哪兒\n26. 者囝 /zê gian²/ 這兒\n27. 遐囝 /hê² gian²/ 那兒\n28. 底人 /di⁷ nang⁵/、/diang⁶/、/di⁷ diang⁶/ 誰\n29. 底位 /di⁷ ui⁷/ 哪位\n30. 者位 /zê² ui⁷/\n31. 遐位 /hê² ui⁷/ 那位\n32. 底時 /di⁷ si⁵/ 什麼時候\n33. 底當時 /diang⁶ si⁵/ 什麼時候\n34. 者時 /zê² si⁵/\n35. 遐時 /hê² si⁵/ 那時\n36. 乜事 /mig⁴ su⁷/ 什麼事情\n37. 若㩼 /rioh⁸ zoi⁷/、/rua⁷ zoi⁷/ 多少\n38. 幾 /gui²/\n39. 豈是 /ka³ si⁷/ 是否是\n40. 敢是 /gam² si⁷/ 是否是\n\n### 🏃‍♀️動詞(dong⁶ su⁵)\n\n**第一部分**\n\n1. 會 /oi⁶/\n2. 無會、袂、𠀾 /bhoi⁶/ 不會\n3. 未 /bhoi⁷/ 沒有（事情還沒做）\n4. 無 /bho⁵/ 沒有\n5. 有 /u⁶/\n6. 好 /ho²/\n7. 毋好、孬 /mo²/ 不好\n8. 欲 /bhêh⁴/ 要\n9. 毋、唔 /m⁶/ 不要\n10. 欲毋 /bhêh⁴ m⁶/、/bhên⁶/ 要不要\n11. 愛 /ain³/ 要\n12. 無愛 /bho⁵ ain³/ 不要\n13. 毋愛、勿、嫑 /main³/ 不要\n14. 用 /êng⁶/ 需要\n15. 免 /miang²/ 不需要\n16. 肯 /kêng²/、/kiang²/ 願意\n17. 毋肯 /m⁶ kêng²/、/m⁶ kiang²/ 不願意\n18. 架勢是 /gê³ si³ si⁷/ 看這情形是。例如：舖關了，架勢是去做節了。 \n\n**第二部分 頭、喙**\n\n1. dag⁴ 頭 // 點頭\n2. 搖頭 /io⁵ tao⁵/\n3. 攲頭 /ki¹ tao⁵/ 歪頭\n4. 呾 /dan³/ 說\n5. 參詳 // 商量\n6. 學古 /oh⁴ gao²/ 講故事\n7. 罵 /mê⁷/\n8. 詏 /a³/ 爭辯\n9. 冤家 /uang¹ gê¹/ 吵架\n10. 恬 /diam⁷/ 閉嘴、安靜\n11. 咬 /ga⁶/\n12. 哺 /bao⁷/ 咀嚼\n13. 唵 /am⁶/ 將食物放進嘴巴\n14. 喷 /pung³/ 散射\n15. 啡痰 /pui³ tam⁵/ 吐痰\n16. 歕 /bung⁵/ 吹氣\n17. 嗾？ /zag⁸/ 呛到、岔到 \n\n**第三部分 目、心**\n\n1. 睇 /toi²/ 看\n2. 看詳睇 /kang³ siang⁵ toi²/ 仔細看\n3. 經心 /gêng¹ sim¹/ 用心\n4. 經心衋事 // 操心\n5. 經破頭腦 // 想破頭 \n\n**第四部分 手、跤**\n\n1. 揨 /dian¹/ 觸、碰\n2. 拍 /pah⁴/ 打\n3. 舂 /cêng⁵/ 用力打\n4. /dng⁷/ 打\n5. 刜 /hug⁴/ 揮、打\n6. 剚、倳 /sai⁷/ 打\n7. 抶 /diag⁴/ 用鞭、杖或竹板打。～手\n8. 摔 /sug⁴/ 抽打、鞭打\n9. 拗折 /a² zi²/ 折斷\n10. 盖 /kain³/ 由上往下覆。～頭\n11. 掃 /sao³/ 迅速掠過。～面\n12. 揞 /an¹/ 掩。～面\n13. diu³ 竹囝\n14. 擎 /gia⁵/ 舉、握、拿\n15. 𢭪 /kioh⁴/ 撿、拾\n16. 挈 /kioh⁸/ 取、拿\n17. 摜 /guan⁶/ 提\n18. 厾 /doh⁴/ 戳\n19. 割 /guah⁴/\n20. 殺 /suah⁴/\n21. 斬 /zam²/\n22. 斫 /dog⁴/ 剁\n23. 宰 /zai²/ 殺\n24. 刣 /tai⁵/ 殺\n25. 拭 /cig⁴/ 擦\n26. 濡 /ru⁵/ 用濕布擦或用拖把拖\n27. 爬 /bê⁵/ 搔(癢)\n28. 掊 /boi²/ 扒開\n29. 揂 /ciu⁵/ 拉引繩子\n30. 𠡒 /dui²/ 用力拉\n31. 捏 /dên⁶/ 掐\n32. 漱牙 /ciu³ ghê⁵/ 刷牙\n33. 跋 /buah⁸/ 摔倒\n34. 踏 /dah⁴/ 踩\n35. 踢 /tag⁴/\n36. 去 /ku³/、/ka³/\n37. 轉 /dng²/ 回來\n38. 綴 /doi³/ 跟著；縫合。\n39. 修理 /siu¹ li²/、/su¹ li²/\n40. 泊車 /pag⁴ cia¹/ 停車。泊，粵語音譯英文 park 得來，停車的意思。\n\n**第五部分**\n\n1. 曳、𤆬 /cua⁷/ 帶、領\n2. 娶 /cua⁷/ 取婦\n3. 徙 /sua²/ 移動\n4. 歇 /hiah⁴/ 放置、休息\n5. 煩惱 /huang⁵ lo²/ 擔心\n6. 相信 /sion¹ siang³/、/siang¹ sing⁷/ 相信\n7. 相輔 /sion³ hu⁶/ 幫忙\n8. 排比 /bai⁵ bi²/ 安排\n9. 含包 /ham⁵ bao¹/ 包含\n10. 拚頭前 /bian³ tao⁵ zain⁵/ 爭先\n11. 輸服 /su¹ hog⁸/ 佩服\n12. ䷀䷀ /dag⁴ nng⁷/ 浪費\n13. ䷀落 /ga¹ lao⁵/ 掉落\n14. 沕 /bhih⁴/ 躲藏\n15. 支 /zin¹/ 預付\n16. 圖賴 /tu⁵ tai²/ 耍賴\n17. 放惰 /bang¹ dua⁶/ 懶得\n\n### 🧜‍♀️形容(hêng⁵ iong⁵)\n\n1. 媠 /sui²/ 好、漂亮\n2. 雅 /ngia²/ 正、漂亮\n3. 生好 /sên¹ ho²/ 漂亮、好看\n4. 䆀 /bhai²/ 差、醜陋\n5. 好 /ho²/\n6. 痞、歹 /pai²/\n7. 大細 /dua⁷ soi³/ 大小\n8. 㩼少 /zoi⁷ zio²/ 多少\n9. 加加減減 /gê¹ gê¹ giam² giam²/ 多多少少\n10. 稀罕 // 稀少，罕見。\n11. 賤 /la¹ zuan⁷/ 繁多，低賤。物以稀為貴，多則賤。\n12. 猛慢 /mê² mang⁷/ 快慢、早晚。猛，快。\n13. 肥 /bui⁵/ 胖\n14. 肥腯肥腯 /bui⁵ tuh⁸ bui⁵ tuh⁸/ 胖嘟嘟\n15. 㾪 /sang²/ 瘦\n16. 㾪猴 /sang² gao⁵/ 瘦得跟猴子一樣\n17. 㾪脯皺 /sang² bao² niao³/ 又瘦又缺水又褶皺，形容飢瘦。\n18. 懸下 /guai⁵/ 高低\n19. 早 /za²/\n20. 晏 /uang³/ 晚\n21. 粗 /cao¹/\n22. 幼 /iun³/ 細\n23. 粗殘 /cao¹ cang⁵/ 粗魯\n24. 仔細 /zu² soi⁷/ 小心\n25. 芳 /pang¹/ 香\n26. 臭 /cao³/\n27. 僫 /oh⁴/ 困難\n28. 易 /goi⁷/ 容易\n29. 闊 /kuah⁴/ 寬\n30. 狹 /oih⁸/ 窄\n31. 光 /gng¹/ 亮\n32. 暗 /am³/\n33. 恬 /diam⁷/ 安靜\n34. 吵 /cao¹/ 吵鬧\n35. 吵吵著 /cao¹ cao¹ dioh⁴/ 吵吵鬧鬧的\n36. 飽 /ba²/\n37. 枵 /iao¹/ 餓\n38. 橂 /dain⁷/ 堅實、堅硬\n39. 軟 /nam³/ 軟弱。本字不明，訓用「軟」。\n40. 韌 /rung⁷/ 堅強；不容易斷裂。\n41. 脆 /cê³/ 脆弱；容易斷裂。\n42. 聰明 /cong¹ mêng⁵/\n43. 愚蠢 /ngo⁵ cung²/\n44. 戇 /gong³/ 愚笨\n45. 賰 /cung⁵/ 剩餘\n46. 欠 /kiam³/ 缺少\n47. 清 // 清晰、乾淨\n48. 雾 /bhu⁷/ 模糊\n49. 清氣 /cêng¹ ki³/ 乾淨\n50. 清氣相 /cêng¹ ki³ sion³/ 乾淨的樣子\n51. 垃圾 /lah⁴ sab⁴/ 骯臟\n52. 垃圾相 /lah⁴ sab⁴ sion³/ 骯臟的樣子\n53. 無沙無圾 /bho⁵ sua¹ bho⁵ sab⁴/ 一塵不染\n54. 灱 /da¹/ 乾燥\n55. 㴷 /dam⁵/ 濕潤\n56. 落雨㴷渧 /lo² hao⁶ dam⁵ di³/ 下雨濕漉漉的樣子\n57. 著 /dioh⁸/ 對、正確\n58. 毋著 /m⁷ dioh⁸/ 不對\n59. 錯 /co³/\n60. 熟 /sêg⁸/\n61. 生 /cên¹/ (瓜果等)未成熟\n62. 臭生 /cao³ cên¹/ 未煮熟或瓜果未成熟\n63. 臭酸 /cao³ sng¹/ 食物變質\n64. 黐黐 /ti¹ ti¹/ 黏稠\n65. 切要 /ciag⁴ iao³/ 要緊\n66. 無要緊 /bho⁵ iao³ ging²/ 不要緊\n67. 大扮\n68. 咸澀\n69. 力相 // 努力\n70. 惰 /duan⁶/ 懶惰\n71. 鬧熱 /nao⁶ ria²/ 熱鬧\n72. 活神 // 精神好，灵活\n73. 健 /gian⁷/ 身體好\n74. 碩㦙 /sêg⁴ ngo³/ 聰明和愚蠢\n75. 夠力 /gao³ lag⁸/ 厲害\n76. 夠強 /gao³ kiang³/ 厲害\n77. 夠衰 /gao³ soi¹/ 好慘\n78. 緊要 /ging² iao³/ 要緊\n79. 切要 /ciag⁴ iao³/ 要緊\n80. 癩瘑糜烂 //\n81. 枝毛小節、枝毛細節 // 無關緊要\n82. 偪側 /bêg⁴ cêg⁴/ 心中有氣，煩躁不安。\n83. 生分 /cên¹ hung⁷/ 陌生、疏遠\n84. 無影無跡 // 沒有根據\n85. 一生跪跋 /zêg⁸ sên¹ gui⁶ buah⁸/ 一生坎坷\n\n### 🐴副詞(hu³ su⁵)\n\n1. 好 /hoh⁴/ 表示程度深。例如：好㩼人 // 好多人。\n2. 死 /si²/ 表示程度特別深。例如：死㩼人 // 超級多人。死雅 // 超漂亮的。\n3. 若 /rua⁷/ 多麼。例如：若雅 // 多麼漂亮。\n4. 者 /zia²/ 這麼。例如：者細 // 這麼小。\n5. 遐 /hia²/ 那麼。例如：遐好 // 那麼好。\n6. 上好 /siang⁶ ho²/ 最好。\n7. 上減 /siang⁶ giam²/ 最少。\n8. 上加 /siang⁶ gê¹/ 最多。\n9. 較 /ga³/ 比較地。例如：伊較厲害 // 他比較厲害。\n10. 曾 /bhah⁴/ 曾經。例如：我毋曾來過 // 我不曾來過。\n11. 攏總 /long² zong²/ 全部。例如：攏總 100 銀 // 總共 100 塊。\n12. 煞 /sua⁵/ 竟然。例如：汝煞毋知 // 你竟然不知道。\n13. 顛倒 /ding¹ do³/ 反而。例如：六月顛倒來落雪 // 六月反而下起雪。\n14. 做蜀 /zo³ zêg⁸/ 一起。例如：做蜀 ka³ // 一起去。\n\n### 😲象聲詞(siang⁶ sian¹ su⁵)\n\n1. 喏 /no⁷/ 使人注意某物\n2. 囉、咯 /lo⁷/ 表示事情完成\n3. /hoin⁷/ 呼人\n4. /oin⁷/ 應人\n5. 喂 /uê⁷/ 打招呼。\n6. 啊 /a⁷/ 加強語氣\n7. 呀 /ia⁷/ 表示贊同\n8. 喔、噢 /o⁷/ 表示醒悟、驚訝或了解\n9. 哇 /ua⁷/ 表示驚訝\n10. 嗯 /ng⁷/ 表示同意或了解\n11. 哼 /hng²/ 表示不滿\n12. 哎、噯 /ai⁷/ 嘆氣\n13. 嗐 /hai⁷/ 嘆氣，比「哎」重些。\n14. /ho⁷～/、/o⁷～/ 長吁，含有一種無力、操碎了心的感覺。\n\n### 🙃俗語(siog⁸ ngo²)\n\n1. 哇浪、我卵 /ua² lang⁶/ 哇噻\n2. 我無閒 /ua² bho⁵ ain⁵/ 我沒空\n3. 走街邊 /zao² goi¹ bin¹/ 擺地攤\n4. 汝愛去怎樣麼緊 /lu² ain³ ku³ zion² mo⁷ ging⁷/ 你趕著去幹嗎\n5. 勿者樣生 /mai³ zion¹ sên¹/ 不要這樣\n6. 知收煞 /zai¹ siu¹ suah⁴/ 適時停手\n7. 毋別世代 /m⁶ bhag⁴ si³ dê³/ 不懂事\n8. 無變 /bho⁵ biang³/ 沒有辦法\n9. 堵著無變 /du² dioh⁴ bho⁵ biang³/ 碰到沒有辦法\n10. 無理路 /bho⁵ li² lao⁷/ 無道理。路，道。\n11. 無奈何 /bho⁵ da¹ ua⁵/ 無可奈何\n12. 無奈寫作不得已 /bho⁵ nai⁶ sia² zo³ bug⁴ dêg⁴ in²/ \n13. 呾死無會變 /dan⁵ si² bhoi⁶ bin³/ 冥頑不靈\n14. 橂過石部 /dain⁷ goi³ zio² bao⁶/ 比石頭還硬\n15. 三斗油麻倒無一粒落耳 /san¹ dao² iu⁵ mua⁵ do³ bho⁵ zêg⁸ liab⁴ lo² hin⁶/ 怎麼說都聽不進去\n16. 瀉衰人 /sia³ soi¹ nang⁵/ 丟人、令人蒙羞\n17. 見笑 /giang³ siao³/ 丟人、令人蒙羞\n18. 雙目囥著褲底 /sang¹ mag⁸ kng³ dioh⁴ kao³ doi²/ 看不見\n19. 無目睇 /bho⁵ mag⁸ toin³/ 不想看\n20. 鴨囝聽雷 /ah⁴ gian² tian¹ lui⁵/ 聽不懂\n21. 戅過隻鴨 /gong⁵ goi³ ziah⁴ ah⁴/ 比鴨子還戇\n22. 一樣糜飯飼千外樣人 /zêg⁸ ion⁷ moi⁵ bng⁷ ci⁷ cain¹ ghua⁷ ion⁷ nang⁵/ 社會人各種各樣\n23. 暗過魂宫 /am³ goi³ hung⁵ gêng¹/ 比陰間還暗\n24. 三更想，半暝反 /san¹ gên¹ sion⁶, buan³ mê⁵ huang²/ 思來想去，反反覆覆。\n25. 過跤事知歇 /goi¹ ka¹ su⁷ zai¹ hiah⁴/ 過去的事情就不要計較了\n26. 無會少禮 /bhoi⁶ siao² li²/ 不害臊\n27. 刣雞教猴 /tai⁵ goi¹ ga³ gao⁵/ 殺雞儆猴\n28. 勞生拚死 /lu⁵ sên¹ bian³ si²/ 拚死拚活\n29. 食呾會，躕人強 /ziah⁸ dan³ oi⁶, du⁵ nang⁵ kiang³/ 能吃會說還很頑皮\n30. 勿踟躕我 /mai³ di¹ du⁵ ua⁷/ 別纏我，使得我不知所措。\n31. 老過伯爺 /lao⁶ goi³ bêh⁴ ia⁵/ 比土地公還年長\n32. 平樣平樣 /pên⁵ ion⁷ pên⁵ ion⁷/ 一模一樣\n33. 假力洗茶渣 /gê² lag⁸ soi² dê⁵ za¹/ 該做的不做，做了不該做的。\n34. 死無命凝 /si² bho⁵ mian⁷ ngang⁵/ 冷死了\n35. 富到流油 /bu⁷ gao³ lao⁵ iu⁵/ 很富有\n36. 人熟禮毋熟 /nang⁵ sêg⁸ li² m⁶ sêg⁸/ 雖然人很熟，但還是要講禮。\n37. 熟人免行生禮 /sêg⁸ nang⁵ miang² gian⁵ cên¹ loi²/\n38. 千人千般苦，無人苦平樣 /cain¹ nang⁵ cain¹ buan¹ kao², bho⁵ nang⁷ kao² pên⁵ ion⁷/ 各有各的煩惱\n39. 蟹有橂奅，人有碩㦙 /hoi⁶ u⁶ dain⁷ pan³, nang⁵ u⁶ sêg⁴ nga³/ 有人聰明有人愚笨。橂，堅實。奅，中空。碩，學問高、聰明。㦙，愚笨。\n40. 鳥飛會落毛，人行有跤跡 /ziao² boi¹ oi⁶ lo² mo⁵, nang⁵ gian⁵ u⁶ ka¹ ziah⁴/ 做過了的事總會留痕跡\n41. 客情好過吊頷鬼 /kêh⁴ cêng⁵ ho² goi³ diao³ am⁶ gui²/ 吊死鬼熱情地勸人上吊好代替自己，比喻虛情假意。\n42. 貓兒無葷無著茨，鴨囝無粟無會過暝 /ngiao¹ ri⁵ bho⁵ hung¹ bho⁵ dioh⁴ cu⁷, ah⁴ gian² bho⁵ cêg⁴ bhoi⁶ goi³ mê⁵/ 小貓沒有葷菜就不在家，小鴨沒有稻粒就不過夜。\n43. 衰雞無會食粟 /soi¹ goi¹ bhoi⁶ ziah⁸ cêg⁴/ 如病雞般吃不下飯\n44. 無會死大破相 /bhoi⁶ si² dua⁷ pua³ sion³/ 不死也會頭破血流\n45. 十八棚頭做到透 /zab⁸ boih⁴ bên⁵ tao⁵ zo³ gao³ tao³/ 指每種事都嘗試，貶義。十八棚頭，指十八齣溫州南戲。\n46. 無跤蟹 /bho⁵ ga¹ hoi⁶/ 孤立無援\n47. 大細目 /dua⁷ soi³ mag⁸/ 偏心\n48. 平安當大趁 /pêng⁵ ang¹ dng¹ dua⁷ tang⁷/ 平安無疾就當作是大賺一筆了\n49. 大人彎，孥囝直 /dua⁷ nang⁷ uain¹, nao⁵ gian² dig⁸/ 大人說話拐彎抹角，小孩子則是直來直去。\n50. 錢囝毋使使大錢 /zin⁵ gian² m⁶ sai² sai² dua⁷ zin⁵/ 小錢不花，久了就得要花大錢了。\n51. 未學行，先學飛 /bhoi⁷ oh⁸ gian², sain¹ oh⁸ boi¹/ 還沒學走路就要學飛了，基礎未打好。\n52. 一人主張，毋如二人參詳 /zêg⁸ nang⁷ zu² ziang¹, m⁶ ru⁵ no⁶ nang⁷ cam¹ ciang⁵/ 自作主張不如多個人一起商量\n53. 通街市獵無 /tong¹ goi¹ ci⁶ lah⁸ bho⁵/ 整條街都找不到。獵，尋找。\n54. 喙尖舌囝利 /cui³ ziamvi/ 牙尖嘴利\n55. 九月狗吶日，無用諸娘理毋直 /gao² goi² gao² nah⁴ rig⁸, bho⁵ êng⁷ zu¹ nion⁵ li² m⁶ dig⁸/ 九月份開始晝短夜長，沒用的婦女家務事搞不定了。\n56. 茶薄人情厚，茶厚有禮貌 /dê⁵ bo² nang⁵ cêng⁵ gao⁶, dê⁵ gao⁶ u⁶ li² mao⁶/\n57. 三十歲無妻是孩童 /san¹ zab⁸ hoi³ bho⁵ ci¹ si⁶ hai⁵ tong⁵/\n58. 目汁是財，愈哭愈來 /mag⁸ zab⁴ si⁶ cai⁵, ru² kao³ ru⁶ lai⁵/\n59. 呾破無酒食 /dan³ pua³ bho⁵ ziu² ziah⁸/ 師傅教徒弟，徒弟設酒宴款待，師傅酒後授予秘方。之後徒弟不再宴請師傅。\n60. 軟過豆腐 /nam³ goi³ dao⁷ hu⁷/\n61. 車大炮 /cia¹ dua⁷ pao³/ 吹牛\n62. 樹大分椏，囝大分家 /ciu⁷ dua⁷ bng¹ a¹, gian² dua⁷ bng¹ ga¹/ \n63. 閒過仙 /ain⁵ goi³ siang¹/ 比神仙還閒\n64. 雙目望無一寸長 /sang¹ mag⁸ mo⁷ bho⁵ zêg⁸ cung³ dng⁵/ 鼠目寸光\n65. 一鼠二牛三虎四兔五龍六蛇七馬八羊九猴十雞十一狗十二豬 /ig⁴ cu² ri⁶ ghu⁵ san¹ haon² si³ tao³ ngao⁶ lêng⁵ lag⁸ zua⁵ cig⁴ bhê² boih⁴ ion⁵ gao² gao⁵ zab⁸ goi¹ zab⁸ ig⁴ gao² zab⁸ ri⁶ du¹/\n66. 差豬差狗，不如家己走 /cê¹ du¹ cê¹ gao², bug⁴ ru⁵ ga¹ gi⁷ zao²/ 求人不如求己\n67. 後生擔石，老人食藥 /hao⁶ sên¹ dan¹ zioh⁸, lao⁶ nang⁵ ziah⁸ ioh⁸/ 年少積勞，年老吃藥\n68. 疑心生暗鬼 /ghi⁵ sim¹ sên¹ am³ gui²/ 因多疑而產生各種幻覺和錯誤判斷\n69. 羊尾短短，遮毋著羊尻川 /ion⁵ bhoi² dê² dê², zia¹ m⁶ dioh⁴ ion⁵ ka¹ cng¹/ 自己的缺點尷尬能自己找個遮醜的就很好了，別去取笑別人的不堪。\n70. 愛母著刻苦 /ain³ bhao² dioh⁴ kag⁴ kao²/ 要老婆就要努力了\n71. 無好家神通外鬼 /bho⁵ ho² gê¹ sing⁵ tong¹ ghua⁷ gui²/\n72. How do you do，好事來堵 /hao³ su⁷ lai³ du²/ 嗨，要搞事情我不怕你。好事，喜歡搞事情。堵，應對、抵抗。\n73. 秋瓜棚下無好人 /ciu¹ goi¹ bên⁵ ê⁶ bho⁵ ho² nang⁵/ 秋瓜，絲瓜。\n74. 三跤椅囝毋知䆀 /san¹ ka¹ in² gian² m⁶ zai¹ bhai²/ 坐著少了一腿的椅子竟然不知道壞了，比喻身處困境而不自知。\n\n### 🤣歇後語(hiah⁴ ao⁶ ngo²)\n\n1. 柴目狗耳 — 假靈 /ca⁵ mag⁸ gao² hin⁶ — gê² lêng⁵/ 目雕的眼睛看不見，狗一般耳朵卻很靈，聽風是雨。\n2. 雞跤長鴨跤短 — 有懸下 /goi¹ ka¹ dng⁵ ah⁴ ka¹ dê² — u⁶ guain⁵ gê⁶/ 雞腳長，鴨腳短，有高有矮。\n3. 爐底碳 — 塊塊通 /lao⁵ doi² tuan³ — dê⁷ dê⁷ tang³/ 百事通\n4. 孥囝食奶 — 坐亭 /nao⁶ gian² ziah⁸ nê¹ — zê⁶ dêng⁵/ 亭，直。\n5. 菜頭面刺無血 — 面皮厚 /cai³ tao⁵ ming¹ ci³ bho⁵ hoih⁴ — ming¹ poi⁵ gao⁶/\n6. 褪褲放屁 — 假工夫 /tng³ kao³ bang³ pui³ — gê² gang¹ hu¹/\n7. 竹葉包沙 — 假壯 /dêg⁴ hio² bao¹ sua¹ — gê² zang³/ 壯，與「粽」諧音。\n8. 元宵燈籠 — 一肚火 /nguang⁵ siao¹ dêng¹ lang⁵ — zêg⁸ dao² hoi²/\n9. 半天吊燈籠 —四搭无向 /buan³ tin¹ diao³ dêng¹ lang⁵ — si³ dah⁴ bho⁵ hiang³/\n10. 青暝睒鏡 — 無望 /cên¹ mên⁵ iam² gian³ — bho⁵ mo⁷/\n11. 青暝睇天 — 張樣張相 /cên¹ mên⁵ toi² tin¹ — dion¹ ion⁷ dion¹ sion⁷/\n12. 青暝點燈 — 照舊 /cên¹ mên⁵ diam² dêng¹ — zio³ gu⁷/ 對青暝人來說，點不點燈，一切照舊。\n13. 青暝掠魚 — 散摸 /cên¹ mên⁵ liah⁸ hu⁵ — suan³ mong⁵/\n14. 青暝娶母 — 稱重 /cên¹ mên⁵ cua⁷ bhao² — cing³ dang⁶/\n15. 青暝擎手電 — 各人各人善 /cên¹ mên⁵ gia⁵ ciu² diang⁶ — gag⁴ nang⁵ gag⁴ nang⁵ siang⁶/\n16. 青暝睇電影 — 聽聲 /cên¹ mên⁵ toi² diang⁶ ian² — tian¹ sian¹/\n17. 啞人食苦瓜 — 有苦難言 /ê² nang⁵ ziah⁸ kao² goi¹ — u⁶ kao² nang⁵ ngiang⁵/\n18. 啞囝食黃連 — 有苦難言 /ê² gian² ziah⁸ ng⁵ nain⁵ — u⁶ kao² nang⁵ ngiang⁵/\n19. 閻羅王嫁諸母囝 — 鬼正敢愛 /ngiam⁵ lo⁵ uang⁵ gê³ za¹ bhao² gian² — gui² zian³ gan² ain³/\n20. 閻羅王請人 — 鬼正敢食  /ngiam⁵ lo⁵ uang⁵ cian² nang⁵ — gui² zian³ gan² ziah⁸/\n21. 閻羅王賣假貨 — 騙鬼 /ngiam⁵ lo⁵ uang⁵ bhoi⁷ gê² hoi⁷ — piang³ gui²/\n22. 閻羅王出告示 — 無句人話 /ngiam⁵ lo⁵ uang⁵ cug⁴ go³ si⁷ — bho⁵ gu³ nang⁵ oi⁷/\n23. 鬼簿無名 — 免死 /gui² pao⁶ bho⁵ mian⁵ — miang² si²/\n24. 醫生開了棺材舖 — 死活都愛錢 /ui¹ sên¹ kui¹ liao² gua¹ ca⁵ pao⁷ — si² ua² do¹ ain³ zin⁵/\n25. 身長棺材短 — 屈死人 /sing¹ dng⁵ gua¹ ca⁵ dê² — kug⁴ si² nang⁵/\n26. 棺材頭畫老虎 — 驚死人 /gua¹ ca⁵ tao⁵ oi⁷ lao⁶ haon² — gian¹ si² nang⁵/\n27. 歪喙和尚 — 唸無一句正經 /uain¹ cui³ hoi⁵ sion⁷ — niam⁷ bho⁵ zêg⁸ gu³ zian³ gêng⁵/\n28. 師公和尚 — 毋同道 /sai¹ gong¹ hoi⁵ sion⁷ — m⁶ dang⁵ dao⁶/\n29. 和尚抹粉 — 白勞 /hoi⁵ sion⁷ bhuah⁴ hung² — bêh⁸ lu⁵/ 勞，與「驢」諧音。\n30. 和尚擎雨遮 — 無法無天 /hoi⁵ sion⁷ gia⁵ hao⁶ zia¹ — bho⁵ huab⁴ bho⁵ tin¹/ 法，與「髮」諧音。\n31. 橄欖尻川 — 坐毋恬 /gan¹ na² ka¹ cng¹ — zê⁶ m⁶ diam⁷/ 屁股像橄榄一般尖，坐不住。恬，静、定。\n32. 火燒豬頭 — 熟面熟面 /hoi² sio¹ du¹ tao⁵ — sêg⁸ ming⁷ sêg⁸ ming⁷/\n33. 六月芥菜 — 假有心 /lag⁸ ghoih⁸ gua³ cai³ — gê² u⁶ sim¹/\n34. 十月芥菜 — 大䀌心 /zab⁸ ghoih⁸ gua³ cai³ — dua⁷ gêg⁴ sim¹/ 䀌，與「激」諧音。\n35. 六月蕃薯 — 雙死 /lag⁸ ghoih⁸ huang¹ zu⁵ — sang¹ si²/ 雙，與「鬆」諧音。\n36. 阿媽生諸母囝 — 生菇 /a¹ ma² sên¹ za¹ bhao² gian² — sên¹ gao¹/ 生菇，發霉。菇，與「姑」諧音。\n37. 老人跤纏 — 又長又臭 /lao⁶ nang⁵ ka¹ din⁵ — ui⁶ dng⁵ ui⁶ cao³/ 講話囉嗦像老人纏足一樣\n38. 老人食豬跤 — 試味 /lao⁶ nang⁵ ziah⁸ du¹ ka¹ — ci³ bhi⁷/ 嘗試下而已\n39. 老婆跋落水 — 淒涼 /lao⁶ pua⁵ buah⁸ lo² zui² — ci¹ liang⁵/ 跋，絆倒。淒，與「妻」諧音。\n40. 老婆其阿兄 — 痴哥 /lao⁶ pua⁵ gai⁵ a¹ hian¹ — ci¹ go¹/ 痴，與「妻」諧音。\n41. 菜頭粿熱單爿 — 自作多情 /cai³ tao⁵ goi² riah⁸ duan¹ bain⁵ — zu⁶ zag⁴ do¹ cêng⁵/ 菜頭粿，蘿蔔糕。热单爿，切片下鍋油煎，但只煎單邊，上焦下嫩。一頭熱（悅），單戀。\n42. 龍眼核拭尻川 — 賽道行 /nging¹ ain² hug⁸ cih⁴ ka¹ cng¹ — sai³ dao⁶ hang⁵/ 「龍眼核拭尻川」比喻有難度的事情，看各家誰本領強了。\n43. 水仙不開花 — 裝蒜 /zui² siang¹ bug⁴ kui¹ hoi¹ — zng¹ sng³/\n44. 大炮拍麻雀 — 騙伊驚 /dua⁷ pao³ pah⁴ mua⁵ ziah⁴ — piang³ i¹ gian¹/\n45. 有錢買蠓香，無錢買蠓罩 — 會算無會除 /u⁶ zin⁵ bhoi² mang² hion¹, bho⁵ zin⁵ bhoi² mang² dan³ — oi⁶ sng³ bhoi⁶ du⁵/\n46. 天頂滴鳥屎 — 無好相覓 /tin¹ dêng² dig⁴ ziao² sai² — mo² sion¹ coi⁷/\n47. 六月薄殼 — 假大頭 /lag⁸ ghoih⁸ boh⁸ kag⁴ — gê² dua⁷ tao⁵/ 大頭，一種比薄殼略大的小貝類海鮮。假大頭，愛充大頭。\n48. 七角錢二人分 — 毋三毋四 /cig⁴ gag⁴ zin⁵ no⁶ nang⁵ bng¹ — m⁶ san¹ m⁶ si³/\n49. 十二碗圓食賰一粒 — 假客氣 /zab⁸ ri⁶ liab⁸ in⁵ ziah⁸ cung⁵ zêg⁸ liab⁸ — gê² kêh⁴ ki⁷/ 圓，丸子。賰，剩下。\n50. 狗母蛇 — 假靈 /gao² bho² zua⁵ — gê² lêng⁵/ 靈，與「龍」諧音。\n51. 兄獨目弟缺喙 — 大無好樣，細無好相 /hian¹ dog⁸ mag⁸ di⁶ koih⁴ cui³ — dua⁷ bho⁵ ho² ion⁷, soi³ bho⁵ ho² sion³/\n52. 山螟咬尾 — 食家己 /suan¹ mê¹ ga⁶ bhoi² — ziah⁸ ga¹ gi⁷/\n53. 風吹牆頭草 — 就勢倚勢 /hong¹ coi¹ ciong⁵ tao⁵ cao² — ziu⁶ si³ ua² si³/\n54. 老鼠跋落粟倉 — 倒好 /ngiao² cu² buah⁸ lo² cêg⁴ cng¹ — do³ ho²/\n55. 老鼠心肝 — 頭食頭搬 /ngiao² cu² sim¹ guan¹ — tao⁵ ziah⁸ tao⁵ buan⁵/\n56. 孥囝拍炮 — 又驚又好 /nao⁵ gian² pah⁴ pao⁷ — ui⁶ gian¹ ui⁶ hao⁷/\n57. 五行缺一 — 欠金 /ngao⁶ hêng⁵ koih⁴ ig⁴ — kiang³ gim¹/\n58. 茂生進酒 — 厚情 /mao⁶ sêng¹ zing³ ziu² — gao⁶ cêng⁵/\n59. 食人雞肉還人豬肉 — 物來物去 /ziah⁸ nang⁷ goi¹ nê² hain⁵ nang⁷ du¹ nê² — moih⁸ lai⁵ moih⁸ ko³/\n60. 刀截蕹菜 — 二頭空 /do¹ zoi² êng³ cai³ — no⁶ tao⁵ kong¹/\n61. 三個半錢 — 趕勢 /san¹ gai⁵ buan³ zin⁵ — guan² si³/ 勢，與「四」諧音。\n62. 隔暝皇帝 — 無權勢 /gêh⁴ mê⁵ huang⁵ di⁷ — bho⁵ kuang⁵ si³/\n63. 大肚水蛙 — 假鮭 /dua⁷ dao² zui² goi¹ — gê² guai¹/ 水蛙，青蛙。鮭，河魨。\n64. 五月龍船 — 相鬥 /ngao⁶ ghoih⁸ lêng⁵ zung⁵ — sion¹ dao³/\n65. 燈籠照路 — 目前光 /dêng¹ lang⁵ zio³ lao⁷ — mag⁸ zain⁵ gng¹/ 比喻目光短淺\n66. 暗室穿針 — 難過 /am³ sig⁴ cng¹ zam¹ — nang⁵ goi³/\n67. 嫁諸母囝娶新婦 — 出入平安 /gê³ za¹ bhao² gian² cua⁷ sing¹ bu⁶ — cug⁴ rib⁸ pêng⁵ ang¹/ 安，與「翁」諧音。\n68. 過關送文憑 — 做人情 /goi³ guan¹ sang³ bhung⁵ pêng⁵ — zo³ nang⁵ zian⁵/\n69. 火燒草料場 — 事出有因 /hoi² sio¹ cao² liao⁷ dion⁵ — su⁷ cu⁷ u⁶ ing¹/ 因，與「煙」諧音。\n70. 黑白電視 — 無彩 /hêg⁴ bêh⁸ dian⁶ si⁶ — bho⁵ cain²/ 無彩，可惜。\n71. 小郎遇著雨 — 積惡 /sio² nng⁵ ngo⁶ dioh⁴ hao⁶ — zêg⁴ ag⁴/ 小郎，女子稱呼丈夫的弟弟。積惡，可憐；罪惡。積，與「叔」諧音。惡，與「沃」諧音。\n\n### 🙂禮貌用語(li² mao⁶ êng³ ngo²)\n\n1. 汝食饱未 /lu² ziah⁸ ba² bhoi⁷/ 你吃飽了嗎\n2. 汝愛去底地 /lu² ain³ ku³ di⁷ dê⁷/ 你要去哪裏\n3. 汝好 /lu² ho²/ 你好\n4. 㩼謝 /zoi⁷ sia⁷/ 多謝\n5. 寬行 /kuan¹ gian⁵/ 慢走\n6. 寬駛 /kuan¹ sai²/ 慢點開車\n7. 对毋住 /dui³ m⁶ zu⁶/ 对不起\n8. 对毋起 /dui³ m⁶ ki²/ 对不起\n9. 無相干 /bho⁵ siang¹ gang¹/ 沒關係\n10. 毋知頭 /m⁶ zai¹ tao⁵/ 不是故意的\n11. 先這呾 /sain¹ zion² dan³/ 回頭再聊 \n12. 萬事應想 /mang⁷ su⁷ êng³ sion⁶/ 萬事如意\n13. 生理大趁 /sêng¹ li² dua⁷ tang⁷/ 生意興隆\n14. 新年大趁 /sing¹ ni⁵ dua⁷ tang⁷/ 新年大賺\n15. 新年合想 /sing¹ ni⁵ gah⁴ sion⁶/ 新年如意\n16. 大吉大利 /dai⁶ gig⁴ dai⁶ li⁶/\n\n### 🤐粗話(cao¹ oi⁷)\n\n1. 咒誓 /ziu³ zua⁷/ 發誓、詛咒\n2. 痟 /siao²/ 神經錯亂\n3. 神經 /sing⁵ gêng¹/\n4. 腦孬 /nao² mo³/ 腦子壞了\n5. 破脑囝 /puah⁸ nao² gian²/ 弱智\n6. 肚痛 /dao² tian³/ 「問候」別人是否肚子痛所以一直在叫。\n7. 鬼叫 /gui² gio⁷/ 「問候」別人是否聽到鬼在叫。\n8. 哭 cang¹ 哭 nain⁵ // 又哭又喊，吵死人了。\n9. 哭父死母 /kao³ bê⁶ si² bho²/ 「問候」別人是否父母過世所以一直在哭叫。\n10. 咋死人 /zag⁴ si² nang⁵/ 吵死了\n11. 鬼囝 /gui² gian²/ 小鬼\n12. 鬼卒囝 /gui² zug⁴ gian²/ 小鬼\n13. 鬼然然 /gui² riang⁵ riang⁵/ 像鬼一樣\n14. 鬼囉作禍 /gui² lo⁷ zo³ ho³/ 鬼在作祟、作怪\n15. 妖怪精 /iao¹ guai³ zian¹/\n16. 去死掉掉 /ku³ si² diao³ diao³/\n17. 散哭父 /suan⁷ kao³ bê⁶/ 散，到處。\n18. 吐屎 /tao³ sai²/ 亂說\n19. 卵屎人 /lang⁶ sai² nang⁵/ 屌絲，沒前途的人。\n20. 卵屎話 /lang⁶ sai² oi⁷/ 廢話\n21. 臭喙卵面 /cao³ cui³ lang⁶ ming⁷/ 亂說、討人厭。\n22. 關汝卵事 /guang¹ lu² lang⁶ dai⁷/ 與你何干\n23. 膣精 /zi¹ zian¹/ 多管閒事\n24. 臭膣 /cao³ zi¹/ 臭婊子\n25. 豺狗 /sai² gao²/ 狗腿子\n26. 怪卵 /guai³ lang⁶/ 古怪\n27. 無卵 /bho⁵ lang⁶/ 沒膽量\n28. 無腦 /bho⁵ nao²/ 沒腦子\n29. 𠀾好 /bhoi⁶ ho²/ 咒別人倒霉\n30. 痞囝 /pai² gian²/ 痞子、流氓。\n31. 肏母囝 /pu² bho² gian²/\n32. 早死囝 /za² si² gian²/\n33. 短命囝 /dê² mian⁷ gian²/、/dêng² mian⁷ gian²/\n34. 破家囝 /pua⁷ gê¹ gian²/ 败家子\n35. 內仙囝  /lai⁶ siang¹ gian²/ 難伺候\n36. 十惡囝 /zab⁸ ag⁴ gian²/ 十惡不赦\n37. 棺材囝 /gua¹ ca⁵ gian²/\n38. 痴哥囝 /ci¹ go¹ gian²/ 色狼\n39. 吐血死囝 /tao³ hoih⁴ si² gian²/\n40. 替人死囝 /toi⁵ nang⁵ si² gian²/\n41. 半路死囝 /buan³ lao⁷ si² gian²/\n42. 祭屎祭䷀ /zi³ sai² zi³ hê⁷/ 亂吃東西\n43. 乞鬼侵著 /koh⁴ gui² cin⁵ dioh⁴/ 鬼上身了。乞，給。侵，本讀 /cim⁵/，音變爲 /cin⁵/，附身。\n\n### 🧨娛樂(ngo⁵ log⁸)\n\n1. 耍遊戲 /sng² iu⁵ hi³/ 玩遊戲\n2. ䷀箭 /diong³ zin³/ 射箭\n3. ䷀珠 /diong³ zu¹/ 打彈珠\n4. 彈槍 /duan⁷ ciong¹/ 開槍\n5. 跳索 /tiao³ soh⁴/ 跳繩\n6. 踏孔 /dah⁸ kong²/ 捉迷藏\n7. 泅水 /siu⁵ zui²/ 游泳\n8. 釣魚 /dio³ hu⁵/\n9. 掠魚 /liah⁸ hu⁵/ 抓魚\n10. 行棋 /gian⁵ gi⁵/ 下棋\n11. 放風箏 /bang³ hong¹ zêng¹/\n12. 拍連炮 /pah⁴ liang⁵ pao³/ 放鞭炮\n13. 扣人囝 /kob⁴ nang⁵ gian²/ 人囝，也叫公仔紙、洋畫，舊時供兒童玩樂用的紙牌。\n14. 沃花 /ag⁴ hoi¹/ 澆花\n15. 做戲 /zo³ hi³/ 演戲劇\n\n### ⛩ 神明(sing⁵ mêng⁵)\n\n1. 天地父母 // 天地，原始信仰。\n2. 月娘 // 月球，原始信仰。\n3. 媽祖 // 原名林默，南海保護神，在甲子天后宮有供。\n4. 七聖娘 // 又稱七星娘娘、七聖夫人，是織女神分化出的七位仙女，是兒童保護神。\n5. 觀音娘 // 觀音菩薩\n6. 慈悲娘 // 即普悲觀音，觀音菩薩化身之一（傳說觀音菩薩有三十三化身），普遍施給眾生慈悲。\n7. 註生娘 // 全稱「大慈大悲救苦救難送子娘娘」，主管懷孕與生育。\n8. 佛祖 // 釋迦牟尼佛，姓喬達摩，名悉達多，古印度思想家、教育家、宗教改革家，佛教的創始人。\n9. 達摩祖師 // 南天竺人或波斯人，將佛教禪宗帶入中國，爲中國禪宗之開創者。\n10. 元天上帝 // 玄武大帝，象徵北極星與二十八宿中的北宮玄武，爲統理北方之道教大神。\n11. 水仙大帝 // 水仙尊王，海神之一，媽祖的從神之一。\n12. 汾陽王帝 // 郭子儀，華州鄭縣（今陝西渭南市華州區）人，唐朝名將，平定安史之亂，封汾陽郡王。此人富貴壽考，權極一時，甲子天后宮媽祖廟有供之。\n13. 王公 // 指隴尾王爺、王爺公，名鄒普勝，麻城花橋（今屬湖北）人，元末農民起義軍將領，陳友諒軍師。朱元璋建立明朝後流浪到甲子地區，爲甲子地區改造「風水」等，今甲子隴尾王爺廟有供之，大年初四在此求「落馬簽」。\n14. 關公 // 關羽，河東郡解縣（今山西省運城市鹽湖區解州鎮）人，三國時期名將，與劉備、張飛桃園三結義。又稱伽藍老爺、伽藍尊者，是寺廟、道場守護神，也有稱之爲武財神。\n15. 八仙公 // 傳說中的八位仙人，爲漢鍾離、張果老、韓湘子、鐵拐李、曹國舅、呂洞賓、藍采和、何仙姑八人。\n16. 伯公 // 福德老爺、土地公。\n17. 五穀公 // 神農大帝，相傳其發明耒耜，教民耕種五穀，並能以百草為民治病。農曆十月十五拜之。\n18. 城隍公 // 古代城鎮保護神。\n19. 皇帝公 // 南宋小皇帝趙昰，曾流亡到甲子待渡山。\n20. 灶公 // 灶君，主掌廚房和飲食的神。\n21. 百姓公 // 無主死者，集中掩埋於百姓公墓，稱爲百姓公(媽)，其中多喪於 1943 年的大飢荒，其時僅甲子一鎮亡者就近 2 萬人，慘絕。\n22. 地主爺 // 住宅的守護靈。\n23. 財神爺 // 常指陝西終南山的玄壇真君趙公明，也指關聖帝君關羽。\n24. 三山國王 // 指現揭西縣河婆鎮北面的三座山——巾山、明山、獨山的三位山神。\n\n## 風俗(hong¹ sioh⁸)\n\n1. 大年初一：食齋菜（菠薐菜、粉絲、菜頭丸、豆腐乾）。\n2. 人日(正月初七)：食七樣菜（厚合、蒜仔、芥藍、高麗菜、真珠菜、香菜、大菜芯）。\n3. 元宵(正月十五)：食蔗。\n4. 三月初三：食青草飯（雞屎藤、伸筋藤、苦刺心、臭草心、蠟裏葉、四方枝苦楝葉）。\n5. 清明：食硬殼餅，掃墓掛紙。\n6. 佛誕(四月初八)：食飯茶。\n7. 端午：食梔粽、梔粿，洗午時水。\n8. 七月初七：出花園。\n9. 中秋：食月餅、芋頭、蔗。\n10. 重陽(九月初九)：食雞湯。\n11. 冬節：食冬節丸、羊肉。\n12. 三十夜、廿九夜：食團圓飯、送壓腰錢（dêh⁴ io¹ zin⁵, 壓歲錢）。\n\n## 歷史(lêg⁸ su²)\n\n1. 甲子的名號是因爲港後有六十塊大石頭，應了干支紀年法一甲子的數目，故名。\n2. 漢文帝時曾派遣大臣陸賈（約公元前240年～公元前170年）到南越國，期間命令將士調查海岸線，到過甲子門。\n3. 三國時，吳侯孫權派遣將軍衛溫（？～231年）攻打福建、琉球和台灣（夷州），被風雨刮到甲子門。\n4. 南宋乾道五年(1169)，承奉郎致仕范有仁建順濟橋，橋從大膽山腳(今東宮社轄區)跨越瀛江到後庭（今甲東鎮雨亭村轄區）。\n\n    ![順濟橋（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）](gahzi-oi-hung-lui-ci-biao/Untitled%2084.png)\n\n5. 宋嘉定甲申年(1224)，南宋承奉郎范良臣（范有仁之孫）登腹石山，因山對面可見甲子門奇石十八，屹立如人，遂刻「登瀛」二字於石，取十八學士登瀛洲之義。\n6. 1276 年，元兵攻陷南宋京城臨安，南宋擁立幼帝趙昰，從福州乘船經福建沿海入廣東，於冬十二月抵甲子門腹石山（後人爲紀念此事，更山名爲待渡山），范良臣給軍食三日，留帝像登瀛石上。\n7. 1277 年正月，漁民鄭復組織義兵509人乘船護送宋帝昺及隨臣去崖門。途中在現珠海橫琴島和澳門與元兵相遇，十六日宋室全軍覆滅，陸秀夫背幼帝昺投海自盡，鄭復等在激戰中全部士兵犧牲。\n8. 明永樂六年(1408)，順濟橋被拆。因「指揮花茂奉旨建甲子所，慮倭寇泊海易渡，拆之以為城基。」\n9. 明嘉靖三十九年(1560)，八萬洞資首黃啓薦扎寨惠來冰山頭（今邦山村）攻陷甲子所城，城中居民移至龍溪都（今惠來隆江以南）為逃避倭禍而暫居，該城之難民，慘遭殺害者甚眾，婦女被擄掠，有的全家罹難。\n10. 明隆慶二年(1568)，倭寇入侵甲子，千戶馬壽麻痹輕敵，城被攻陷，甲子和龍溪都一帶受害慘重。馬壽因失職罪下獄，死於獄中。\n11. 明隆慶四年(1570)，大旱，入春至初夏，天無滴雨，時又常遭賊寇蹂躪，田園拋荒，赤地千里，人民苦不堪言。\n12. 明隆慶四年(1570)九月，曾作倭寇嚮導之海寇楊老復，率賊眾攻陷甲子所城，擄掠男女上船，千戶董（佚名）戰死。次日，船遇颱風，賊與被擄者均溺死。\n13. 隆慶五年(1571)七月，海盜林道乾（又名林鳳，惠來人），於龍溪都一帶擄民劫捨，後聞朝廷將派兵進剿，遂遠循至甲子一帶搶劫，攻破新寨，劫擄李棠，其妻卓氏攜二子上船換夫歸，遂投海殉節。後朝廷封為「南海夫人」。\n14. 明萬曆二十六年(1598)，湯顯祖作《牡丹亭》，其第六齣中有詞句「榕樹梢頭訪古台，下看甲子海門開。越王歌舞今何在？時有鷓鴣飛去來。」\n15. 明萬曆二十八年(1600)八月二十三日，惠來及甲子一帶地震。\n16. 明萬曆三十三年(1605)三月，惠來及甲子一帶地震，七月初三至初七颱風暴雨，沿海田舍淹沒。\n17. 明萬曆三十五年(1607)，參將張萬紀、守備胡文烜在待渡山下建宋帝亭，即進食亭。\n18. 明萬曆四十二年(1620)春正月，海盜袁八老余黨林新老入甲子沃，把總金允武出戰死之。\n19. 明天啓七年(1627)三月，海寇入甲子門，守備葉台死亡。\n20. 明崇禎八年(1635)，海寇劉香攻陷甲子，擄去守道洪雲蒸。閩粵大兵突至，洪遇害，後劉香被擄伏誅。\n21. 明崇禎十四年(1641)十二月十四日夜，惠來地震，波及甲子。\n22. 民國32年(1943，癸未年)，甲子乃至整個海陸豐地區、潮汕地區遭遇大飢荒，時兵災、旱災、蝗災和瘟疫，餓殍遍野，僅甲子一鎮亡者就近 2 萬，佔當時鎮人口逾 45%。\n23. 1966年，中國大陸爆發文化大革命，「破四舊」。次年，有360年歷史的進食亭被炸毀！\n24. 2004年夏～2005年秋，甲子諸賢達捐資重建了進食亭。\n25. 2013年12月29日凌晨，廣東警方出動3000多人的警力對有「毒品村」之稱的甲西鎮博社村開展清繳行動，當天繳獲近3噸冰毒，抓捕180多名涉毒犯罪嫌疑人，原村委書記蔡東家名列其中。\n\n## 建置(giang³ di³)\n\n1. 秦以前：屬南越國\n2. 秦：屬南海郡之博羅縣\n3. 漢：屬博羅縣\n4. 三國：屬博羅縣\n5. 晉：咸和六年（326）析博羅，置海豐縣，屬东官郡\n6. 宋：屬海豐縣\n7. 齊：屬海豐縣\n8. 梁：屬海豐縣\n9. 陳：屬海豐縣\n10. 隋：海豐縣屬循州\n11. 唐：海豐縣屬循州。武德五年（622）析置安陸縣；貞觀元年（627）復歸海豐縣。\n12. 五代：大寶元年（958）海豐縣属祯州。\n13. 宋：海豐縣屬祯州。天禧五年（1021）屬惠州。\n14. 元：海豐縣屬惠州路。\n15. 明：海豐縣屬惠州府。洪武二十七年(1394)，置甲子守禦千戸所，隸屬碣石衛。嘉靖三年（1524）海豐划出龍溪都、潮州府析出潮陽縣合置惠來縣。\n\n    ![甲子所城範圍（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）](gahzi-oi-hung-lui-ci-biao/Untitled%2085.png)\n    \n16. 清：海豐縣屬惠州府。雍正九年（1731）海豐划出石帆（甲子屬石帆都）、吉康、坊廓3都置陸豐縣，並裁甲子所設立甲子巡檢司。\n17. 中華民國：陸豐縣屬潮循道。\n18. 中華人民共和國：1957年甲子鎮劃出甲東鎮、甲西鎮（取甲子之東、甲子之西義）；1958年鎮改爲人民公社，陸豐縣屬汕頭地區；1983年陸豐屬惠陽地區；1980年成立甲子鎮人民政府；1988年陸豐縣改屬汕尾市；1995年陸豐撤縣建市。\n\n## 拼音方案(pêng³ im¹ huang¹ uan³)\n\n### 聲母表(sian¹ bho² biao²)\n\n格式：`聲母 [國際音標] 例字`\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png)\n\n### 韻母表(ung¹ bho² biao²)\n\n格式：`韻母 [國際音標] 例字 / 入聲韻 [國際音標] 例字`\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png)\n\n### 聲調(sian¹ diao⁶)\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png)\n\n### 變調(biang³ diao⁶)\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png)\n\n## 地圖(di⁷ dao⁵)\n\n![三甲地區（來源：騰訊地圖）](gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg)\n\n","slug":"language/min/gahzi-oi-hung-lui-ci-biao","published":1,"updated":"2022-01-05T13:46:50.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5qxxlgl00441n9kf5pl6kip","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><strong>!!! 注意：本辭表已收錄在典合網中進行維護，請轉閱：<a href=\"https://dicthub.cn/dicts/kahtsi-ue\">https://dicthub.cn/dicts/kahtsi-ue</a> !!!</strong></p>\n<h2 id=\"序言-su⁶-ngiang⁵\"><a href=\"#序言-su⁶-ngiang⁵\" class=\"headerlink\" title=\"序言(su⁶ ngiang⁵)\"></a>序言(su⁶ ngiang⁵)</h2><p>甲子鎮處在陸豐市，與惠來縣交界，語言文化上偏惠來（其實五百年前與惠來交界處同屬海豐縣）。甲子話是三甲地區（甲子、甲西、甲東三鎮）通行的語言，是甲子地方文化的重要載體之一。在學術上，甲子話被歸入粵東閩南語潮汕話片。 </p>\n<p>甲子話保留了好㩼中古乃至上古的漢語詞彙，比如：汝、諸母、新婦、箸、鼎、匏桸、雅、翹楚等等，還有極具地方特色的表達，比如：𨑨迌、走漆、理唔直、孤獨死相等等。然而無會寫甚至無會呾甲子話的人實在㩼，其中不少是受過義務教育其。 有鑑於此，本人草創此表，力求詞雅正且其音形義有所考據，權當拋磚引玉，歡迎大家儂做蜀討論改進。 </p>\n<p>另附本表主要參考資料：</p>\n<ol>\n<li>《潮汕方言詞考釋》（林倫倫）</li>\n<li>《海豐話分類辭表》（羅志海、鍾顯坤）</li>\n<li><a href=\"https://www.mogher.com/baike\">《潮典》</a> </li>\n<li>《新潮汕字典》（張曉山）</li>\n<li><a href=\"https://twblg.dict.edu.tw/holodict%5C_new/index.html\">《台灣閩南語常用詞辭典》</a> </li>\n<li><a href=\"https://xiaoxue.iis.sinica.edu.tw/minyu\">《小學堂閩語》</a></li>\n</ol>\n<p>阿華<br>2020年10月成稿，12月修訂</p>\n<span id=\"more\"></span>\n\n<h2 id=\"總表-zong²-biao²\"><a href=\"#總表-zong²-biao²\" class=\"headerlink\" title=\"總表(zong² biao²)\"></a>總表(zong² biao²)</h2><h3 id=\"🤵稱謂-ceng¹-ui⁶\"><a href=\"#🤵稱謂-ceng¹-ui⁶\" class=\"headerlink\" title=\"🤵稱謂(cêng¹ ui⁶)\"></a>🤵稱謂(cêng¹ ui⁶)</h3><ol>\n<li>我 /ua²/</li>\n<li>汝 /lu²/ 你</li>\n<li>伊 /i¹/ 他/她/它</li>\n<li>恁 /ning²/ 你們</li>\n<li>伊人 /i¹ nang⁷/ 他們</li>\n<li>家己 /ga¹ gi⁷/ 自己</li>\n<li>人家 /nang⁵ gê¹/ 別人</li>\n<li>諸夫 /za¹ bao¹/ 男人、男子</li>\n<li>諸母 /za¹ bhao²/ 女人</li>\n<li>諸娘 /zu¹ nion⁵/ 女子</li>\n<li>大人 /dua⁷ nang⁷/</li>\n<li>老人 /lao⁶ nang⁵/</li>\n<li>後生囝 /hao⁶ sên¹ gian²/ 年輕人</li>\n<li>孥囝 /nao⁵ gian²/、/nong⁶ gian²/ 小孩子</li>\n<li>諸夫囝 /za¹ bao¹ gian²/ 男孩子、兒子</li>\n<li>諸母囝 /za¹ bhao² gian²/ 女孩子、女兒</li>\n<li>諸娘囝 /zu¹ nion⁵ gian²/ 年輕女子</li>\n<li>阿公 /a¹ gong¹/ 爺爺</li>\n<li>阿媽 /a¹ ma²/ 奶奶</li>\n<li>媽人 /ma² nang⁵/ 婦女</li>\n<li>媽祖 /ma² zao²/ 原名林默，南海保護神</li>\n<li>爸爸 /ba¹ ba¹/ 爸爸</li>\n<li>媽媽 /ma¹ ma¹/</li>\n<li>父母 /bê⁶ bho²/</li>\n<li>兄 /hian¹/ 哥哥</li>\n<li>弟 /di⁶/ 弟弟</li>\n<li>姐 /zê²/ 姐姐</li>\n<li>妹 /moi⁷/ 妹妹</li>\n<li>姊妹 /zi² moi⁷/ 姐妹</li>\n<li>叔伯兄弟 /zêh⁴ bêh⁴ hian¹ di⁶/ 堂兄弟</li>\n<li>同沿 /dang⁵ iang⁵/ 同輩、同儕</li>\n<li>翁 /ang¹/ 丈夫</li>\n<li>母 /bhao²/ 妻子</li>\n<li>翁姐 /ang¹ zia²/ 夫妻</li>\n<li>新婦 /sing¹ bu⁶/ 媳婦</li>\n<li>大家 /dua⁷ gê¹/ 丈夫的母親、家婆</li>\n<li>大家官 /dua⁷ gê¹ guan¹/ 丈夫的父親、家公</li>\n<li>丈人 /dion⁶ nang⁵/ 岳父</li>\n<li>丈母 /dion⁶ m²/ 岳母</li>\n<li>妻舅 /ci¹ gu⁶/ 妻子的兄弟</li>\n<li>妻姨 /ci¹ i⁵/ 妻子的姐妹</li>\n<li>伯 /bêh⁴/ 伯伯</li>\n<li>姆 /m²/ 伯父的妻子</li>\n<li>叔 /zêh⁴/ 叔叔</li>\n<li>嬸 /sim²/ 叔父的妻子</li>\n<li>舅 /gu⁶/ 舅舅</li>\n<li>妗 /gim⁶/ 舅父的妻子</li>\n<li>姑 /gao¹/ 父親的姐妹、姑姑</li>\n<li>姑丈 /gou¹ dion⁶/ 姑姑的丈夫</li>\n<li>姨 /i⁵/ 母親的姐妹；母親</li>\n<li>姨丈 /i⁵ dion⁶/ 母親的姐妹的丈夫</li>\n<li>先生 /sing¹ sên¹/</li>\n<li>學生 /hag⁴ sêng¹/</li>\n<li>師父 /sai¹ bê⁶/ 工匠師傅</li>\n<li>師父 /su¹ hu⁶/ 出家人、和尚</li>\n<li>和尚 /hoi⁵ sion⁷/、/hua⁵ siang⁶/</li>\n<li>腳色 /ka¹ siao³/ 人手、幫手</li>\n<li>青暝囝 /cên¹ mên⁵ gian²/ 瞎子</li>\n</ol>\n<h3 id=\"🦶身體-sing¹-ti²\"><a href=\"#🦶身體-sing¹-ti²\" class=\"headerlink\" title=\"🦶身體(sing¹ ti²)\"></a>🦶身體(sing¹ ti²)</h3><ol>\n<li>頭毛 /tao⁵ mo⁵/ 頭髮</li>\n<li>頭神 /tao⁵ sing⁵/ 思維、記憶的能力</li>\n<li>頭碗骨 /tao⁵ uan² gug⁴/ 頭蓋骨</li>\n<li>旋 /zng⁷/ 頭髮呈漩渦狀的地方</li>\n<li>囟 /sing³/ 嬰兒頭頂骨未合縫處</li>\n<li>額頭 /hia² tao⁵/</li>\n<li>面 /ming⁷/ 臉</li>\n<li>頰溝 /gih⁴ gao¹/ 腮</li>\n<li>痣 /gi³/</li>\n<li>目 /mag⁸/ 眼睛</li>\n<li>目仁 /mag⁸ ring⁵/ 眼珠子</li>\n<li>目汁 /mag⁸ zab⁴/ 眼淚</li>\n<li>眉 /bhai⁵/ 眉毛</li>\n<li>耳 /hin⁶/ 耳朵</li>\n<li>耳空、耳孔 /hin⁶ kang¹/</li>\n<li>鼻 /pin⁷/ 鼻子</li>\n<li>鼻空、鼻孔 /pin⁷ kang¹/</li>\n<li>喙、嘴 /cui⁷/ 嘴巴</li>\n<li>䶕牙 /bha³ ghê⁵/ 龅牙</li>\n<li>涎 /nua⁶/ 唾液</li>\n<li>痰 /tam⁵/</li>\n<li>頷 /am⁶/ 脖子</li>\n<li>下頦 /ê⁶ hai⁵/ 下巴</li>\n<li>喙後肚 /cui⁷ ao⁶ dao²/ 下巴後面柔軟處</li>\n<li>鬚 /ciu¹/ 鬍鬚</li>\n<li>嚨喉 /na⁵ ao⁵/ 喉嚨</li>\n<li>手 /ciu²/</li>\n<li>正手 /zian³ ciu²/ 右手</li>\n<li>倒手 /do³ ciu²/ 左手</li>\n<li>胳囊跤 /goh⁴ lang⁵ ka¹/ 腋下</li>\n<li>手後曲 /ciu² ao⁶ kiao¹/ 手肘</li>\n<li>手模 /ciu² bhao⁵/ 手印</li>\n<li>腡 /lê⁵/ 圓形手指紋</li>\n<li>指頭公 /zain² tao⁵ gong¹/ 大拇指</li>\n<li>尾指囝 /bhoi² zain² gian²/ 小指</li>\n<li>胸 /hêng¹/</li>\n<li>嬭、奶 /nê¹/</li>\n<li>𩩍篱 /pian¹ li⁵/ 肋骨</li>\n<li>肚臍 /dao² zai⁵/</li>\n<li>背脊 /ba¹ ziah⁴/ 脊背</li>\n<li>腰 /io¹/</li>\n<li>跤、骹、腳 /ka¹/</li>\n<li>跤頭趺 /ka¹ tao⁵ u⁶/ 膝蓋</li>\n<li>大跤腿 /dua⁷ ka¹ tui²/ 大腿</li>\n<li>跤腸肚 /ka¹ dng⁵ dao²/ 小腿後部肌肉凸出處</li>\n<li>跤後蹬 /ka¹ ao⁶ dên¹/ 腳後跟</li>\n<li>跤盤 /ka¹ buan⁵/ 腳板</li>\n<li>跤目 /ka¹ mag⁸/ 腳踝</li>\n<li>跤指公 /ka¹ zain² gong¹/ 腳大拇趾</li>\n<li>跤液 /ka¹ sio²/ 腳汗</li>\n<li>卵 /lang⁶/ 陰莖、屌、勢</li>\n<li>卵鳥 /lang⁶ ziao²/ 陰莖、屌、勢</li>\n<li>卵脬 /lang⁶ pa¹/ 精囊</li>\n<li>卵核 /lang⁶ hug⁸/ 睪丸</li>\n<li>膣 /zi¹/ 女陰</li>\n<li>膣眉 /zi¹ bhai¹/ 女陰</li>\n<li>尻川 /ka¹ cng¹/ 屁股</li>\n<li>雞母皮 /goi¹ bho² poi⁵/ 雞皮疙瘩</li>\n<li>汗 /guan⁷/</li>\n<li>垢圿 /gao² goih⁴/ 體表污垢</li>\n</ol>\n<h3 id=\"🍵飲食-im²-ziah⁸\"><a href=\"#🍵飲食-im²-ziah⁸\" class=\"headerlink\" title=\"🍵飲食(im² ziah⁸)\"></a>🍵飲食(im² ziah⁸)</h3><ol>\n<li>食 /ziah⁸/ 吃、喝、抽</li>\n<li>祭 /zi³/ 狼吞虎咽；坐享其成</li>\n<li>咬 /ga⁶/</li>\n<li>哺 /bao⁷/ 咀嚼</li>\n<li>吞 /tung¹/</li>\n<li>舐 /zi⁶/ 舔</li>\n<li>含 /gam⁵/</li>\n<li>啜 /coih⁴/ 喝</li>\n<li>啉 /lim⁵/ 小口喝</li>\n<li>灌 /guang¹/ 大口喝</li>\n<li>吸 /kib⁴/</li>\n<li>搵 /ung³/ 蘸</li>\n<li>買鹹 /moi² giam⁵/ 買菜</li>\n<li>食透早 /ziah⁸ tao⁷ za²/ 吃早飯</li>\n<li>食眠起 /ziah⁸ mng⁵ ki²/ 吃早飯</li>\n<li>食晝 /ziah⁸ dao³/ 吃午飯</li>\n<li>食當晝 /ziah⁸ dêng¹ dao³/ 吃午飯</li>\n<li>食夜昏、食暝昏 /ziah⁸ mê⁵ hng⁵/ 吃晚飯</li>\n<li>飯 /bng⁷/</li>\n<li>米 /bhi²/</li>\n<li>糜 /moi⁵/ 粥</li>\n<li>飲 /am²/ 米湯</li>\n<li>配 /poi³/ 菜</li>\n<li>菜式 /cai³ sêg⁴/</li>\n<li>粿、餜 /goi²/</li>\n<li>丸、圓 /in⁵/</li>\n<li>油䭔 /iu⁵ zui¹/ 一種油炸食品</li>\n<li>汰米 /tua⁷ bhi²/ 淘米</li>\n<li>熬 /ngao⁵/ 長時間煮。～糜。</li>\n<li>煲 /bu⁵/ 煮、熬。～藥。</li>\n<li>潘 /png¹/ 餿水</li>\n<li>油 /iu⁵/</li>\n<li>鹽 /iam⁵/</li>\n<li>醋 /cao³/</li>\n<li>豉油 /si⁷ iu⁵/ 醬油</li>\n<li>豆汁 /dao⁷ zab⁴/ 醬油</li>\n<li>雞卵 /goi¹ nng⁶/ 雞蛋</li>\n<li>豬肉 /du¹ nêg⁸/</li>\n<li>澀肉 /siab⁴ nêg⁸/、/siab⁴ bhah⁴/ 瘦肉。澀，少油。</li>\n<li>肉脞 /nêg⁸ co³/ 肉末</li>\n<li>烏糖 /ao¹ tng⁵/ 紅糖、黑糖</li>\n<li>赤砂糖 /ciah⁴ sua¹ tng⁵/</li>\n<li>白砂糖 /bêh⁸ sua¹ tng⁵/</li>\n<li>薰 /hung¹/ 香菸</li>\n<li>茶 /dê⁵/</li>\n<li>酒 /ziu²/</li>\n<li>淖 /cioh⁴/ 粥稀</li>\n<li>凊 /cing³/ 飯菜涼了</li>\n<li>燒 /sio¹/ 熱呼呼</li>\n<li>燒烘燒烘 /sio¹ hang¹ sio¹ hang¹/ 熱呼呼</li>\n<li>芳 /pang¹/ 香</li>\n<li>甘 /gam¹/</li>\n<li>甜 /diam⁵/</li>\n<li>鹹 /giam⁵/</li>\n<li>薟 /hiam¹/ 辛辣</li>\n<li>䭕 /zian²/ 清淡</li>\n<li>臊 /co¹/ 腥</li>\n<li>臭 /cao³/</li>\n</ol>\n<h3 id=\"👔穿戴-ceng⁷-dua³\"><a href=\"#👔穿戴-ceng⁷-dua³\" class=\"headerlink\" title=\"👔穿戴(cêng⁷ dua³)\"></a>👔穿戴(cêng⁷ dua³)</h3><ol>\n<li>帽 /bho⁷/</li>\n<li>目鏡 /mah⁸ gian³/ 眼鏡</li>\n<li>圍巾 /ui⁵ ging¹/</li>\n<li>頷幔 /am⁶ muan¹/ 披肩</li>\n<li>衫褲 /san¹ kao³/ 衣服</li>\n<li>西裝 /sai¹ zuang¹/</li>\n<li>褸 /lao¹/ 大衣</li>\n<li>葵笠 /goi⁵ loih⁸/ 斗笠，竹編成的圓錐形大帽子。</li>\n<li>羊毛衫 /ion⁵ mo⁵ san¹/</li>\n<li>長䘼衫 /dng⁵ ng² san¹/ 長袖衫</li>\n<li>短䘼衫 /dê² ng² san¹/ 短袖衫</li>\n<li>貼身衫 /dah⁴ sing¹ san¹/ 貼身的上衣</li>\n<li>䘥囝 /gah⁴ gian²/ 無袖內衣</li>\n<li>底衫 /doi² san¹/ 內衣</li>\n<li>肚綰 /dao² guan⁶/ 肚兜</li>\n<li>長褲 /dng⁵ kao³/</li>\n<li>短褲 /dê² kao³/</li>\n<li>褲頭 /kao³ tao⁵/ 短褲、內褲</li>\n<li>褲橛 /kao³ goi²/ 短褲、內褲</li>\n<li>三角褲 /san¹ gag⁴ kao³/</li>\n<li>裙 /gung⁵/</li>\n<li>圍裙 /ui⁵ gung⁵/</li>\n<li>文胸 /bhung⁵ hêng¹/ 胸罩</li>\n<li>奶帕、嬭帕 /nê¹ pê³/ 胸罩</li>\n<li>皮帶 /poi⁵ dua³/</li>\n<li>手囊 /ciu² lob⁴/ 套袖</li>\n<li>手鐲 /ciu² sio²/</li>\n<li>鞋拖 /tua¹ oi⁵/ 拖鞋</li>\n<li>波鞋 /bo¹ oi⁵/ 球鞋。波，英文 ball 的音譯。</li>\n<li>釘鞋 /dêng¹ oi⁵/ 運動鞋的一種</li>\n<li>皮鞋 /poi⁵ oi⁵/</li>\n<li>高跟鞋 /gao¹ ging¹ oi⁵/</li>\n<li>靴 /hia¹/</li>\n<li>襪 /ghoih⁸/</li>\n<li>布 /bao³/</li>\n<li>襊 /zoi⁷/ 折痕</li>\n<li>頷領 /am⁶ nia²/ 領子</li>\n<li>褲袋 /kao³ dê⁷/ 位於褲子的口袋</li>\n<li>衫袋 /san¹ dê⁷/ 位於上衣的口袋</li>\n<li>暗袋 /am³ dê⁷/ 內側袋</li>\n<li>內裏 /lai⁶ li²/ 衣物不露出在外的裏層</li>\n<li>鈕 /liu²/ 鈕扣</li>\n<li>針 /zam¹/</li>\n<li>線 /suan³/</li>\n<li>拉鍊 /la¹ liang³/</li>\n<li>穿 /cêng⁷/</li>\n<li>褪 /tng⁷/ 脱</li>\n<li>紩 /tin⁷/ 縫</li>\n<li>補 /bao²/</li>\n<li>車衫褲 /cia¹ san¹ kao³/ 用縫紉機縫衣服</li>\n</ol>\n<h3 id=\"🎏物件-mi²-gian⁶、mian⁶\"><a href=\"#🎏物件-mi²-gian⁶、mian⁶\" class=\"headerlink\" title=\"🎏物件(mi² gian⁶、mian⁶)\"></a>🎏物件(mi² gian⁶、mian⁶)</h3><ol>\n<li><p>眠牀 /mng⁵ cng⁵/ 牀</p>\n</li>\n<li><p>鋪 /pao¹/ 牀</p>\n</li>\n<li><p>高低牀 /gao¹ di¹ cng⁵/ 上下鋪</p>\n</li>\n<li><p>蓆 /cioh⁸/</p>\n</li>\n<li><p>簟 /diam⁶/ 竹席</p>\n</li>\n<li><p>毡 /ziang¹/</p>\n</li>\n<li><p>被 /poi⁶/</p>\n</li>\n<li><p>棉被 /mi⁵ poi⁶/</p>\n</li>\n<li><p>被單 /poi⁶ duan¹/</p>\n</li>\n<li><p>枕頭 /zim² tao⁵/</p>\n</li>\n<li><p>枕頭囊 /zim² tao⁵ lob⁴/ 枕套</p>\n</li>\n<li><p>蠓罩、蚊罩 /mang² da³/ 蚊帳</p>\n</li>\n<li><p>蠓熏、蚊熏 /mang² hung¹/ 蚊香</p>\n</li>\n<li><p>窗罩 /têng¹ zao⁶/</p>\n</li>\n<li><p>口罩 /kao² zao⁶/</p>\n</li>\n<li><p>壁櫥 /biah⁴ du⁵/</p>\n</li>\n<li><p>椅 /in²/</p>\n</li>\n<li><p>桌 /doh⁴/</p>\n</li>\n<li><p>櫃 /gui⁷/</p>\n</li>\n<li><p>架 /gê³/</p>\n</li>\n<li><p>盒 /ab⁸/</p>\n</li>\n<li><p>籃 /na⁵/</p>\n</li>\n<li><p>瓶 /bang⁵/</p>\n</li>\n<li><p>鎖頭 /so² tao⁵/</p>\n</li>\n<li><p>鎖匙 /so² si⁵/ 鑰匙</p>\n</li>\n<li><p>葉疊 /iab² diab⁸/ 合葉</p>\n</li>\n<li><p>牙簽 /ghê⁵ ciam¹/</p>\n</li>\n<li><p>茶盤 /dê⁵ buan⁵/</p>\n</li>\n<li><p>茶壺 /dê⁵ hu⁵/</p>\n</li>\n<li><p>沖罐 /cong¹ guang³/ 茶壺</p>\n</li>\n<li><p>茶杯 /dê⁵ boi¹/</p>\n</li>\n<li><p>茶几 /dê⁵ gi²/</p>\n</li>\n<li><p>熏咬 /hung¹ ga⁶/ 煙斗</p>\n</li>\n<li><p>熏碟 /hung¹ dih⁸/ 煙灰缸</p>\n</li>\n<li><p>熱壺 /riag⁸ hu⁵/ 熱水瓶</p>\n</li>\n<li><p>熨斗 /ug⁴ dao²/</p>\n</li>\n<li><p>電燈 /diang⁶ dêng¹/</p>\n</li>\n<li><p>電泡 /diang⁶ pa⁶/</p>\n</li>\n<li><p>燈籠 /dêng¹ lang⁵/</p>\n</li>\n<li><p>燈火 /dêng¹ hoi²/ 電燈；燈光</p>\n</li>\n<li><p>風箏 /hong¹ zêng¹/</p>\n</li>\n<li><p>米甕 /bhi² ang³/ 米缸</p>\n</li>\n<li><p>水䀇 /zui² gao²/ 大型儲水器</p>\n</li>\n<li><p>跤桶 /ka¹ tang²/ 原指洗腳桶，後泛指洗衣盆，也可用來給小孩洗澡。</p>\n</li>\n<li><p>面盆 /ming⁷ png⁵/ 臉盆</p>\n</li>\n<li><p>瓠桸 /bu⁵ hia¹/ 水瓢</p>\n</li>\n<li><p>口㼦 /kao² gong²/ 漱口杯</p>\n</li>\n<li><p>碗 /uan²/</p>\n</li>\n<li><p>盤 /buan⁵/</p>\n</li>\n<li><p>碟 /dih⁸/</p>\n</li>\n<li><p>甌 /ao¹/ 大碗</p>\n</li>\n<li><p>箸 /du⁷/ 筷子</p>\n</li>\n<li><p>湯匙 /tng¹ si⁵/</p>\n</li>\n<li><p>調羹 /tiao⁵ gên¹/ 喝粥用的小勺子；湯匙</p>\n</li>\n<li><p>糜匙 /moi⁵ si⁵/ 舀粥用的勺子</p>\n</li>\n<li><p>飯匙 /bng⁷ si⁵/ 飯勺</p>\n</li>\n<li><p>飯添 /bng⁷ tin¹/ 飯勺</p>\n</li>\n<li><p>鼎 /dian²/ 鍋</p>\n</li>\n<li><p>鼎㧕 /dian² liu⁶/ 鍋鏟。㧕，存疑。</p>\n</li>\n<li><p>鼎蓋 /dian² kain³/ 鍋蓋</p>\n</li>\n<li><p>菜刀 /cai³ do¹/</p>\n</li>\n<li><p>瓜刨 /goi¹ pao⁵/</p>\n</li>\n<li><p>砧 /diam¹/</p>\n</li>\n<li><p>篩 /tai¹/</p>\n</li>\n<li><p>筅 /cain²/ 刷子</p>\n</li>\n<li><p>菜篩 /cai³ tai¹/</p>\n</li>\n<li><p>鉸刀 /ga¹ do¹/ 剪刀</p>\n</li>\n<li><p>螺絲批 /lo⁵ si¹ poi¹/ 螺絲刀</p>\n</li>\n<li><p>螺絲釘 /lo⁵ si¹ dêng¹/</p>\n</li>\n<li><p>旋螺絲 /suag⁸ lo⁵ si¹/ 擰螺絲</p>\n</li>\n<li><p>鐵錘 /tih⁴ tui⁵/</p>\n</li>\n<li><p>鉸夾 /ga¹ giab⁸/ 鉗子</p>\n</li>\n<li><p>扳手 /bang² ciu²/</p>\n</li>\n<li><p>電筆 /diang⁶ big⁴/ 測電筆</p>\n</li>\n<li><p>烏膠布 /ao¹ ga¹ bao³/ 電工膠帶</p>\n</li>\n<li><p>黏紙 /niam⁵ zua²/ 透明膠帶</p>\n</li>\n<li><p>布拖 /bao³ tu¹/ 拖把</p>\n</li>\n<li><p>掃帚 /sao³ siu²/ 掃把</p>\n</li>\n<li><p>畚斗 /bng³ dao²/ 垃圾鏟</p>\n</li>\n<li><p>畚箕 /bng³ gi¹/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled.png\" alt></p>\n</li>\n<li><p>梯 /tui¹/</p>\n</li>\n<li><p>吸石 /hiab⁴ zioh⁸/ 磁鐵、磁石</p>\n</li>\n<li><p>箠 /coi⁵/ 鞭子，可用來教育孩子。</p>\n</li>\n<li><p>火箠 /hoi² coi⁵/ 火筷子，夾爐中煤炭或通火的用具。</p>\n</li>\n<li><p>角畢 /gag⁴ big⁴/ 皮箱</p>\n</li>\n<li><p>樹嬭 /ciu⁷ ni⁵/ 橡皮、橡膠。嬭，樹之乳膠。</p>\n</li>\n<li><p>嬭漱 /ni⁵ ciu³/ 橡皮擦</p>\n</li>\n<li><p>毛筆 /mo⁵ big⁴/</p>\n</li>\n<li><p>鋼筆 /gng³ big⁴/</p>\n</li>\n<li><p>鉛筆 /iang⁵ big⁴/</p>\n</li>\n<li><p>鉛筆旋 /iang⁵ big⁴ suag⁸/ 卷筆刀、筆刨</p>\n</li>\n<li><p>模 /bhao⁵/ 模子</p>\n</li>\n<li><p>㨹 /zoi⁷/ 裂縫、痕跡</p>\n</li>\n<li><p>離衣機 /li⁵ i¹ gi¹/ 洗衣機</p>\n</li>\n</ol>\n<h3 id=\"🏠建築-giang³-dog⁴\"><a href=\"#🏠建築-giang³-dog⁴\" class=\"headerlink\" title=\"🏠建築(giang³ dog⁴)\"></a>🏠建築(giang³ dog⁴)</h3><ol>\n<li>茨、厝 /cu³/ 房子、家</li>\n<li>寮 /liao⁵/ 简陋小屋</li>\n<li>瓦茨 /hia⁶ cu³/ 瓦舍</li>\n<li>茨手 /cu³ ciu²/ 潮汕民居天井旁兩間廂房的名稱。</li>\n<li>兩間直 /no⁶ gain¹ dig⁸/ 傳統民居，兩房。</li>\n<li>獨腳靴 /dog⁸ ka¹ hia¹/ 傳統民居，一聽一茨手一房。</li>\n<li>下山虎 /hia⁶ suan¹ haon²/ 傳統民居，三合院，一廳二房二茨手。</li>\n<li>四點金 /si³ diam² gim¹/ 傳統民居，四合院，中軸爲前廳天井後聽，兩廳兩旁各有一房。</li>\n<li>竹竿茨 /dêg⁴ go¹ cu³/ 傳統民居，廚房客廳住房天井排列成狹長的空間，如竹竿。</li>\n<li>駟馬拖車 /si³ mê² tua¹ cia¹/ 傳統民居，在四點金上縱加一廳，橫加兩房，三廳二天丼。</li>\n<li>茨邊 /cu³ bin¹/ 鄰居</li>\n<li>起茨 /ki² cu³/ 蓋房子</li>\n<li>租茨 /zao¹ cu³/ 租房子</li>\n<li>搬茨 /buan⁵ cu³/ 搬家</li>\n<li>入新茨 /rib⁸ sing¹ cu³/ 搬入新家</li>\n<li>客廳 /kêh⁴ tian¹/</li>\n<li>客房 /kêh⁴ bang⁵/</li>\n<li>廚房 /dao⁵ bang⁵/</li>\n<li>浴室 /êg⁸ sig⁴/</li>\n<li>洗浴 /soi² êg⁸/ 洗澡</li>\n<li>廁所 /cê³ so²/</li>\n<li>屎壑 /sai² hag⁸/ 茅廁</li>\n<li>門窗 /mng⁵ têng¹/</li>\n<li>門閂 /mng⁵ cuan³/</li>\n<li>門楣 /mng⁵ bhai⁵/</li>\n<li>門橂 /mng⁵ dain⁶/ 門檻</li>\n<li>門扇後 /mng⁵ sin³ ao⁶/ 門後</li>\n<li>柱 /tiao⁶/</li>\n<li>牆壁 /cion⁵ biah⁴/</li>\n<li>庭、埕 /dian⁵/ 寬闊平地，可曬鹽、曬穀。</li>\n<li>临檐 /lim⁵ zin⁵/ 檐廊</li>\n<li>塗角 /tao⁵ gag⁴/ 土磚</li>\n<li>磚 /zng¹/</li>\n<li>廟 /bhio⁷/</li>\n<li>亭 /dêng⁵/</li>\n<li>祠堂 /su⁵ dng⁵/</li>\n<li>庵寺 /am¹ zin⁷/ 尼寺、僧寺的通稱。</li>\n<li>學校 /hag⁸ hao⁶/</li>\n<li>醫院 /ui¹ in⁷/</li>\n<li>鎮府 /ding³ hu²/ 鎮政府</li>\n<li>舖囝 /pao³ gian²/ 小賣部</li>\n</ol>\n<h3 id=\"🛵交通-gao¹-tong¹\"><a href=\"#🛵交通-gao¹-tong¹\" class=\"headerlink\" title=\"🛵交通(gao¹ tong¹)\"></a>🛵交通(gao¹ tong¹)</h3><ol>\n<li>腳車、跤車 /ka¹ cia¹/ 腳踏車、自行車</li>\n<li>摩托 /mo⁵ toh⁸/ 摩托，英文 motorcycle 音譯省。</li>\n<li>三輪車 /san¹ lung⁵ cia¹/</li>\n<li>的士 /dêg⁴ si⁶/ 計程車、出租車。的士，英文 taxi 音譯。</li>\n<li>小車 /sio² cia¹/ 小汽車</li>\n<li>麵包車 /min⁷ bao¹ cia¹/</li>\n<li>公交車 /gong¹ gao¹ cia¹/</li>\n<li>大巴 /dua⁷ ba¹/ 巴，英文 bus 音譯。</li>\n<li>車站 /cia¹ zam⁶/</li>\n<li>輪船 /lung⁵ zung⁵/</li>\n<li>龍船 /lêng⁵ zung⁵/ 龍舟</li>\n<li>火車 /hoi² cia¹/</li>\n<li>地鐵 /di⁷ tih⁴/</li>\n<li>高鐵 /gao¹ tih⁴/</li>\n<li>飛機 /boi¹ gi¹/</li>\n<li>行路 /gian⁵ lao⁷/ 走路</li>\n<li>踏腳車 /dah⁸ ka¹ cia¹/ 騎自行車</li>\n<li>駛車 /sai² cia¹/ 開車</li>\n<li>撐船 /tên¹ zung⁵/</li>\n<li>載客 /zai³ kêh⁴/</li>\n<li>拗䷀囝 /ao² gag⁴ gian²/ 摩托車司機。拗，載；扛。</li>\n<li>落車 /lo² cia¹/ 下車</li>\n<li>碼頭 /bhê² tao⁵/</li>\n<li>涵空、涵孔 /am⁵ kang¹/ 涵洞、涵管、地下水道</li>\n<li>橋墩 /gio⁵ dun¹/ 橋梁下面的圓柱狀基石</li>\n</ol>\n<h3 id=\"🐒眾生-zeng³-sen¹\"><a href=\"#🐒眾生-zeng³-sen¹\" class=\"headerlink\" title=\"🐒眾生(zêng³ sên¹)\"></a>🐒眾生(zêng³ sên¹)</h3><ol>\n<li><p>眾生 /zêng³ sên¹/ 牲畜</p>\n</li>\n<li><p>禽兽 /kim⁵ siu⁶/</p>\n</li>\n<li><p>害蟲 /hai⁷ tang⁵/</p>\n</li>\n<li><p>豬豭 /du¹ go¹/ 配種的公豬，也比喻好色之徒。</p>\n</li>\n<li><p>豬槽 /du¹ zo⁵/</p>\n</li>\n<li><p>羊牢 /ion⁵ lo⁵/</p>\n</li>\n<li><p>雞翁 /goi¹ ang¹/ 雄雞</p>\n</li>\n<li><p>雞母 /goi¹ bho²/ 母雞</p>\n</li>\n<li><p>鴨囝 /ah⁴ gian²/ 小鴨子</p>\n</li>\n<li><p>鵝 /gho⁵/</p>\n</li>\n<li><p>貓牯 /ngiao¹ gao²/ 母貓</p>\n</li>\n<li><p>鳥 /ziao²/</p>\n</li>\n<li><p>燕囝 /in³ gian²/ 小燕子</p>\n</li>\n<li><p>鶴 /hoh⁸/</p>\n</li>\n<li><p>鷹 /êng¹/</p>\n</li>\n<li><p>白鴿 /bêh⁸ gab⁴/</p>\n</li>\n<li><p>白鷺鷥 /bêh⁸ lao⁷ si¹/</p>\n</li>\n<li><p>鸚哥 /êng¹ go¹/ 鸚鵡</p>\n</li>\n<li><p>麻雀 /mua⁵ ziah⁴/</p>\n</li>\n<li><p>蝠婆 /big⁴ bo⁵/ 蝙蝠</p>\n</li>\n<li><p>蛇 /zua⁵/</p>\n</li>\n<li><p>雨傘節 /hao⁶ suan³ zag⁴/ 一种毒蛇。</p>\n</li>\n<li><p>狗母蛇 /gao² bho² zua⁵/ 蛇舅母、石龍子、四腳蛇，蜥蜴的一種</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%201.png\" alt></p>\n</li>\n<li><p>兩棲動物 /liang² ci¹ dong⁶ moih⁸/</p>\n</li>\n<li><p>蟾蜍 /ziong¹ zu⁵/</p>\n</li>\n<li><p>蛤虯 /gab⁴ giu²/ 青蛙</p>\n</li>\n<li><p>蛤蛙 /gab⁴ guai¹/ 蝌蚪</p>\n</li>\n<li><p>蚼蟻 /gao² hia⁶/ 螞蟻</p>\n</li>\n<li><p>白蟻 /bêh⁸ hia⁶/</p>\n</li>\n<li><p>蜜蜂 /bhig⁸ pang¹/</p>\n</li>\n<li><p>虎頭蜂 /hao² tao⁵ pang¹/ 黄蜂</p>\n</li>\n<li><p>龜 /gu¹/ 烏龜或像烏龜的昆蟲</p>\n</li>\n<li><p>金龜 /gim¹ gu¹/ 金龜子</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%202.png\" alt></p>\n</li>\n<li><p>鱉 /bih⁴/</p>\n</li>\n<li><p>土蚓 /dao⁶ ung²/ 蚯蚓</p>\n</li>\n<li><p>蜈蚣 /gê⁵ gang¹/</p>\n</li>\n<li><p>火金蛄 /hoi² gim¹ gao¹/ 螢火蟲</p>\n</li>\n<li><p>牛屎龜 /ghu⁵ sai² gu¹/ 屎殼郎、蜣螂</p>\n</li>\n<li><p>烏點龜 /ao¹ diam² gu¹/ 七星瓢蟲</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%203.png\" alt></p>\n</li>\n<li><p>紅新娘 /ang⁵ sing¹ nion⁵/ 紅姬緣椿象</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%204.png\" alt></p>\n</li>\n<li><p>山蛚 /sua¹ lê⁷/ 蟬；多指<a href=\"http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14818\">蚱蝉</a></p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%205.png\" alt></p>\n</li>\n<li><p>蝘悲蟬 /iam⁶ bi¹ sung⁵/ <a href=\"http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14817\">蟪蛄</a></p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/image.jpg\" alt=\"gahzi-oi-hung-lui-ci-biao/image.jpg\"></p>\n</li>\n<li><p>蟋蟀 /tih⁴ sug⁴/ 又稱烏龍。</p>\n</li>\n<li><p>䷀ // 螽斯、莎蟲、紡織娘、蟈蟈。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%206.png\" alt></p>\n</li>\n<li><p>草猴 // 稻蝦</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%207.png\" alt></p>\n</li>\n<li><p>䷀ // 金盾龜金花蟲</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%208.png\" alt></p>\n</li>\n<li><p>草蜢 /cao² mên²/ 螞蚱、蚱蜢。</p>\n</li>\n<li><p>螳螂、螳蜋 /tang⁵ lang⁵/</p>\n</li>\n<li><p>神螂 /sing⁵ lang⁵/ 壁虎，蜥蜴的一種。</p>\n</li>\n<li><p>蛤蚧蛇 /gab⁴ gai³ zua⁵/ 大壁虎，蜥蜴的一種。</p>\n</li>\n<li><p>土猴 /dao⁶ gao⁵/ 螻蛄</p>\n</li>\n<li><p>蝶、蜨 /iah⁸/ 蝴蝶</p>\n</li>\n<li><p>山螟 /suan¹ mê¹/ 蜻蜓</p>\n</li>\n<li><p>米龜 /bhi² gu¹/ 米象，蛀食稻穀、麥粒等米糧爲生。</p>\n</li>\n<li><p>蛀蟲 /zu³ tang⁵/</p>\n</li>\n<li><p>蛓毛蟲 /ci³ mo⁵ tang⁵/ 毛毛蟲</p>\n</li>\n<li><p>流鼻螺 /lao⁵ pin⁷ lê⁵/ 蝸牛</p>\n</li>\n<li><p>戶蠅 /hao⁵ sing⁵/ 蒼蠅</p>\n</li>\n<li><p>枯蠅 /gao¹ sing⁵/ 介殼蟲</p>\n</li>\n<li><p>蠓、蚊 /mang²/</p>\n</li>\n<li><p>蝨母 /sag⁴ bho²/ 蝨子</p>\n</li>\n<li><p>曱甴、虼蚻 /ga¹ zuah⁸/ 蟑螂</p>\n</li>\n<li><p>蜈蜞 /ghao⁵ ki⁵/ 水蛭，喜歡吸血人畜血液。</p>\n</li>\n</ol>\n<h3 id=\"🐳水產-zui²-suan²\"><a href=\"#🐳水產-zui²-suan²\" class=\"headerlink\" title=\"🐳水產(zui² suan²)\"></a>🐳水產(zui² suan²)</h3><ol>\n<li><p>䭕水魚 /zian² zui² hu⁵/ 淡水魚</p>\n</li>\n<li><p>鹹水魚 /giam⁵ zui² hu⁵/ 海水魚</p>\n</li>\n<li><p>刣魚 /tai⁵ hu⁵/ 宰魚</p>\n</li>\n<li><p>魚春 /hu⁵ cung¹/ 魚卵。屈大均《廣東新語》：「粵方言凡禽魚卵皆為春。唐時吳君貢魚春子，即魚子也。」 </p>\n</li>\n<li><p>魚鱗 /hu⁵ lang⁵/</p>\n</li>\n<li><p>魚鰾 /hu⁵ pio⁶/</p>\n</li>\n<li><p>魚鰓 /hu⁵ ci¹/</p>\n</li>\n<li><p>魚刺 /hu⁵ ci³/</p>\n</li>\n<li><p>鯁 /gên²/ 魚刺在喉</p>\n</li>\n<li><p>馬鮫 /mê² ga¹/</p>\n</li>\n<li><p>鯧 /cion¹/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%209.png\" alt></p>\n</li>\n<li><p>鰇魚 /riu⁵ hu⁵/ 魷魚</p>\n</li>\n<li><p>墨斗 /bhag⁸ dao²/、/mag⁸ dao²/ 墨魚</p>\n</li>\n<li><p>絲丁魚 /si¹ dêng⁶ hu⁵/ 龍頭魚、硬魚、橂魚(殿魚)、豆腐魚</p>\n</li>\n<li><p>狗母魚 // 蝦虎魚、狗魽仔魚、九甘魚</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2010.png\" alt></p>\n</li>\n<li><p>白目噯 /ain²/</p>\n</li>\n<li><p>狗母囝 // 身體透明，似魩仔鱼，有淡水和海水兩種</p>\n</li>\n<li><p>鰻魚 /muan⁵ hu⁵/</p>\n</li>\n<li><p>花仙魚 /hoi¹ siang¹ hu⁵/ 鮐魚</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2011.png\" alt></p>\n</li>\n<li><p>鸚哥魚 /êng¹ go¹ hu⁵/ 洛神項鰭魚、紅姑娘、紅新娘、碼頭魚</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2012.png\" alt></p>\n</li>\n<li><p>癩瘑魚 /na³ go¹ hu⁵/、/lai³ go¹ hu⁵/ 多齒蛇鯔，俗稱「那哥魚」，常用於製魚丸。</p>\n</li>\n<li><p>娘愛魚 /nion⁵ ain¹ hu⁵/ 泥猛魚、褐篮子鱼、臭肚鱼。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2013.png\" alt></p>\n</li>\n<li><p>䷀囝 /dêg⁸ gian²/ 又稱迪仔、綠鰭馬面魨、剝皮魚。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2014.png\" alt></p>\n</li>\n<li><p>䱛囝 /oig⁸ gian²/ 䱛仔、䱛魚</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2015.png\" alt></p>\n</li>\n<li><p>金龍䱛 /gim¹ lêng⁵ oig⁸/ 金龍魚、黃花魚，狀似䱛魚但個頭大、嘴圓、體黃。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2016.png\" alt></p>\n</li>\n<li><p>福壽魚 /hog⁴ siu⁶ hu⁵/ 羅非魚</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2017.png\" alt></p>\n</li>\n<li><p>鮭魚 /guai¹ hu⁵/ 河魨，俗稱「乖魚」，常指黃鰭東方魨。</p>\n</li>\n<li><p>黃牆 /ng⁵ cion⁵/ 黃鰭鯛</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2018.png\" alt></p>\n</li>\n<li><p>軟甘 /nng² gang¹/ 杜氏鰤、油甘，體側有黃色縱帶。 </p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2019.png\" alt></p>\n</li>\n<li><p>沙尖 /sua¹ ziam¹/ 多鱗鱚、沙鯪、北方稱沙丁魚。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2020.png\" alt></p>\n</li>\n<li><p>龍箭 /lang⁷ zin⁷/ 鯪魚 ，淡水魚，可用於做罐頭魚。</p>\n</li>\n<li><p>石剎 /zio² sag⁴/ 又稱烏雞，松鯛。</p>\n</li>\n<li><p>淡角魚 /dam⁶ gag⁴ hu⁵/ 鯒魚、辮子魚</p>\n</li>\n<li><p>烏魚 /ao¹ hu⁵/ 又稱烏頭，鯔魚。</p>\n</li>\n<li><p>烏前魚 /ao¹ zain⁵ hu⁵/</p>\n</li>\n<li><p>塗虱 /tao⁵ sag⁴/ 鬍子鯰</p>\n</li>\n<li><p>龍舌 /lêng⁵ zi²/ 龍利魚</p>\n</li>\n<li><p>巴浪 /ba¹ lang¹/ 藍圓鯵</p>\n</li>\n<li><p>鯇魚 /uang² hu⁵/ 草魚</p>\n</li>\n<li><p>姑魚 /gao¹ hu⁵/ 金色小沙丁魚</p>\n</li>\n<li><p>鯽魚 /zig⁴ hu⁵/</p>\n</li>\n<li><p>秋刀魚 /ciu¹ do¹ hu⁵/</p>\n</li>\n<li><p>紅目鰱 /ang⁵ mag⁸ liang⁵/ 紅目大眼鯛</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2021.png\" alt></p>\n</li>\n<li><p>田鱔 /cang⁵ cuan⁶/ 鱔魚、黃鱔</p>\n</li>\n<li><p>白帶魚 /bêh⁸ dua³ hu⁵/ 鞭魚、裙帶魚、海刀魚</p>\n</li>\n<li><p>鰐魚 /ngag⁸ hu⁵/</p>\n</li>\n<li><p>鯊魚 /sua¹ hu⁵/</p>\n</li>\n<li><p>鯨魚 /kêng⁵ hu⁵/</p>\n</li>\n<li><p>紅哥鯉 /ang⁵ go¹ li²/ 金線魚</p>\n</li>\n<li><p>蝦 /hê⁵/</p>\n</li>\n<li><p>蟹 /hoi⁶/</p>\n</li>\n<li><p>三目蠘 /san¹ mag⁸ cih⁸/ 紅星梭子蟹、三目蟹</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2022.png\" alt></p>\n</li>\n<li><p>海哲 /hai² diag⁴/</p>\n</li>\n<li><p>蠔、蚝、蚵 /o⁵/ 牡蠣</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2023.png\" alt></p>\n</li>\n<li><p>紅肉 /ang⁵ nê²/ 紅肉藍蛤</p>\n</li>\n<li><p>蚶 /ham¹/</p>\n</li>\n<li><p>蜆 /hain⁶/</p>\n</li>\n<li><p>青匙 /cên¹ si⁵/ 綠殼菜蛤、翡翠貽貝</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2024.png\" alt></p>\n</li>\n<li><p>花蛤 /hoi¹ gab⁴/ 菲律賓簾蛤、花甲</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2025.png\" alt></p>\n</li>\n<li><p>車白 /cia¹ bêh⁸/ 文蛤，邊緣弧度較花蛤圓。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2026.png\" alt></p>\n</li>\n<li><p>青蛤 /cên¹ gab⁴/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2027.png\" alt></p>\n</li>\n<li><p>毛蚶 /mo⁵ ham¹/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2028.png\" alt></p>\n</li>\n<li><p>薄殼 /bo² kag⁴/ 尋氏肌蛤、海蛔、海瓜子</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2029.png\" alt></p>\n</li>\n<li><p>指甲螳 /zain² gah⁴ tang⁵/ 又稱指甲蚌hong²，蟶sêng³子。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2030.png\" alt></p>\n</li>\n<li><p>田螺 /cang⁵ lê⁵/</p>\n</li>\n<li><p>尖螺 /ziang¹ lê⁵/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2031.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"🌾-蔬菜-so¹-cai³\"><a href=\"#🌾-蔬菜-so¹-cai³\" class=\"headerlink\" title=\"🌾 蔬菜(so¹ cai³)\"></a>🌾 蔬菜(so¹ cai³)</h3><ol>\n<li><p>五穀 /ngao⁶ gag⁴/</p>\n</li>\n<li><p>稻 /diu⁶/</p>\n</li>\n<li><p>粟 /cêg⁴/ 稻粒</p>\n</li>\n<li><p>麥 /mê²/</p>\n</li>\n<li><p>秫米 /zu² bhi²/ 糯米</p>\n</li>\n<li><p>薏米 /in³ bhi²/</p>\n</li>\n<li><p>薏仁 /in³ ring⁵/ 玉米</p>\n</li>\n<li><p>蕃薯 /huang¹ zu⁵/、/hang¹ zu⁵/</p>\n</li>\n<li><p>馬鈴薯 /mê² lêng¹ zu⁵/ 土豆</p>\n</li>\n<li><p>黃豆 /ng⁵ dao⁷/ 大豆、菽</p>\n</li>\n<li><p>綠豆 /lê² dao⁷/</p>\n</li>\n<li><p>烏豆 /ao¹ dao⁷/ 黑豆</p>\n</li>\n<li><p>赤豆 /ciah⁴ dao⁷/ 紅小豆</p>\n</li>\n<li><p>荷目豆 /ho⁵ mag⁸ dao⁷/ 荷蘭豆、豌豆</p>\n</li>\n<li><p>地豆 /di⁷ dao⁷/ 花生</p>\n</li>\n<li><p>豆仁 /dao⁷ ring⁵/ 花生米</p>\n</li>\n<li><p>油麻 /iu⁵ mua⁵/ 芝麻</p>\n</li>\n<li><p>菜豆 /cai³ dao⁷/ 常指四季豆</p>\n</li>\n<li><p>茄 /gio⁵/</p>\n</li>\n<li><p>苦瓜 /kao² goi¹/</p>\n</li>\n<li><p>角瓜 /gag⁴ goi¹/ 稜角絲瓜</p>\n</li>\n<li><p>秋瓜 /ciu¹ goi¹/ 絲瓜</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2032.png\" alt></p>\n</li>\n<li><p>嬭瓜、奶瓜 /nê¹ goi¹/ 木瓜</p>\n</li>\n<li><p>蓮藕 /nain⁵ nao⁶/</p>\n</li>\n<li><p>菠薐菜 /boi¹ lêng⁵ cai³/ 菠菜</p>\n</li>\n<li><p>蕹菜 /êng³ cai³/ 空心菜</p>\n</li>\n<li><p>春菜 /cung¹ cai³/ 長葉芥菜</p>\n</li>\n<li><p>菜花 /cai³ hoi¹/ 花椰菜</p>\n</li>\n<li><p>芥菜 /gua³ cai³/ 大芥菜、包心芥菜</p>\n</li>\n<li><p>芥藍 /gêg⁴ na⁵/</p>\n</li>\n<li><p>菜頭 /cai³ tao⁵/ 白蘿蔔</p>\n</li>\n<li><p>紅菜頭 /ang⁵ cai³ tao⁵/ 紅蘿蔔</p>\n</li>\n<li><p>薺蔥、錢蔥 /zin⁵ cang¹/ 荸薺</p>\n</li>\n<li><p>韭菜 /gu² cai³/</p>\n</li>\n<li><p>芫荽 /iang¹ sui¹/ 香菜</p>\n</li>\n<li><p>芳菜 /pang¹ cai³/</p>\n</li>\n<li><p>厚合 /gao⁶ hah⁸/ 厚皮菜、莙薘菜、葉用甜菜</p>\n</li>\n<li><p>九層塔 /gao² zang⁵ tah³/ 金不換、羅勒</p>\n</li>\n<li><p>萵菜 /oi¹ cai³/ 皺葉萵苣、生菜</p>\n</li>\n<li><p>劍菜 /giam³ cai³/ 油麥菜</p>\n</li>\n<li><p>上海青 /siang⁶ hai² cên¹/ 青菜的一種</p>\n</li>\n<li><p>芹菜 /king⁵ cai³/</p>\n</li>\n<li><p>津白 /gian¹ bêh⁸/ 又稱紹菜、黃芽白，天津盛產，是大白菜的一種。以下是大白菜的不同品種。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2033.png\" alt></p>\n<p>天津大白菜</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2034.png\" alt></p>\n<p>大白菜</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2035.png\" alt></p>\n<p>娃娃菜</p>\n</li>\n<li><p>高麗菜 /go¹ lê⁵ cai³/ 捲心菜、包菜、結球甘藍</p>\n</li>\n<li><p>菜花 /cai³ hoi¹/ 花椰菜</p>\n</li>\n<li><p>茼蒿 /dang⁵ o¹/</p>\n</li>\n<li><p>枸杞菜 /gao² gi² cai³/</p>\n</li>\n<li><p>真珠菜 /zing¹ zu¹ cai³/ 珍珠花菜、白苞蒿</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2036.png\" alt></p>\n</li>\n<li><p>薟椒 /hiam¹ tsio¹/ 辣椒</p>\n</li>\n<li><p>生果 /cên¹ goi²/ 水果</p>\n</li>\n<li><p>荔果 /nai⁶ goi²/ 荔枝</p>\n</li>\n<li><p>龍眼 /nging⁵ ain²/</p>\n</li>\n<li><p>桑垂 /siong¹ sui⁵/ 桑葚</p>\n</li>\n<li><p>草莓 /cao² bhoi⁵/</p>\n</li>\n<li><p>刺菠 /ci³ bo¹/ 蛇莓、覆盆子</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2037.png\" alt></p>\n</li>\n<li><p>弓蕉 /gêng¹ zio¹/ 香蕉</p>\n</li>\n<li><p>米蕉 /bhi² zio¹/</p>\n</li>\n<li><p>鳥梨 /ziao² lai⁵/</p>\n</li>\n<li><p>檨 /suain⁷/ 芒果</p>\n</li>\n<li><p>菝囝 /bag⁸ gian²/ 番石榴</p>\n</li>\n<li><p>西瓜 /si¹ goi¹/</p>\n</li>\n<li><p>香櫞 /hion¹ ng⁵/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2038.png\" alt></p>\n</li>\n<li><p>柚 /iu⁷/</p>\n</li>\n<li><p>柑 /gan¹/ 柑橘</p>\n</li>\n<li><p>桔 /gig⁴/</p>\n</li>\n<li><p>橙 /cêng⁵/</p>\n</li>\n<li><p>菠蘿 /bo¹ lo⁵/</p>\n</li>\n<li><p>油甘 /iu⁵ gam¹/ 餘甘果，先苦後甜，齒留餘甘。</p>\n</li>\n<li><p>番茄 /huang¹ gio⁵/</p>\n</li>\n<li><p>青竹梅 /cên¹ dêg⁴ bhoi⁵/</p>\n</li>\n<li><p>李 /li²/</p>\n</li>\n<li><p>棗 /zo²/</p>\n</li>\n<li><p>蔗 /zia³/ 甘蔗</p>\n</li>\n</ol>\n<h3 id=\"🌿草藥-cao²-ioh⁸\"><a href=\"#🌿草藥-cao²-ioh⁸\" class=\"headerlink\" title=\"🌿草藥 /cao² ioh⁸/\"></a>🌿草藥 /cao² ioh⁸/</h3><ol>\n<li><p>艾 /hia³/ 艾草 </p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2039.png\" alt></p>\n</li>\n<li><p>草粿草 /cao² goi² cao²/ 仙草</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2040.png\" alt></p>\n</li>\n<li><p>策草 /cêg⁴ cao²/ 又稱抹(bhuah⁴)草、廣防風、防風草，甲子地區神位常年插此草。策 ，大概是指其像馬鞭。</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2041.png\" alt></p>\n</li>\n<li><p>青菭 /cên¹ ti⁵/ 青苔</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2042.png\" alt></p>\n</li>\n<li><p>薄荷 /bo⁵ ho³/、/bon⁵ hon³/</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2043.png\" alt></p>\n</li>\n<li><p>金銀花 /gim¹ nging⁵ hoi¹/</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2044.png\" alt></p>\n</li>\n<li><p>午時花 /ngao² si⁵ hoi¹/</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2045.png\" alt></p>\n</li>\n<li><p>四季春 /si³ kui³ cung¹/ 四季春花</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2046.png\" alt></p>\n</li>\n<li><p>葉下紅 /hio² ê⁶ ang⁵/ 一點紅</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2047.png\" alt></p>\n</li>\n<li><p>臭草花 /cao³ cao² hoi¹/ 五色梅、馬纓丹</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2048.png\" alt></p>\n</li>\n<li><p>飛天蜈蚣 /boi¹ tin¹ ghê⁵ gang¹/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2049.png\" alt></p>\n</li>\n<li><p>金雞脫殼 /gim¹ goi¹ tug⁴ kag⁴/</p>\n</li>\n<li><p>路跤菊 /lao⁷ ka¹ gêg⁴/ 路邊菊</p>\n</li>\n<li><p>臘裏葉 /lah⁸ li² hioh⁸/ 金邊紅桑</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2050.png\" alt></p>\n</li>\n<li><p>芒囝筍 /mang⁵ gian² sung²/ 芒草的嫩芽</p>\n</li>\n<li><p>竹菜 /dêg⁴ cai³/ 竹葉草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2051.png\" alt></p>\n</li>\n<li><p>葛菜 /guah⁴ cai³/ 野葛菜，可食。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2052.png\" alt></p>\n</li>\n<li><p>烏規菜 /ao¹ gui¹ cai³/ 龍葵</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2053.png\" alt></p>\n</li>\n<li><p>豬母菜 /du¹ bho² cai³/ 馬齒莧</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2054.png\" alt></p>\n</li>\n<li><p>刺莧 /ci³ hain⁷/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2055.png\" alt></p>\n</li>\n<li><p>苦刺 /kao² ci³/ 白簕</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2056.png\" alt></p>\n</li>\n<li><p>苦草 /kao² cao²/ 豨薟草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2057.png\" alt></p>\n</li>\n<li><p>兩公根 /liang² gong¹ ging¹/ 崩大碗</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2058.png\" alt></p>\n</li>\n<li><p>鋪地錦 /pao¹ di⁷ gim²/ 滿天星</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2059.png\" alt></p>\n</li>\n<li><p>雞屎藤 /goi¹ sai² ding⁵/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2060.png\" alt></p>\n</li>\n<li><p>伸筋藤 /cung¹ ging¹ ding⁵/ 蔓九節</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2061.png\" alt></p>\n</li>\n<li><p>無頭藤 /bho⁵ tao⁵ ding⁵/ 寄生於其他植物之上</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2062.png\" alt></p>\n</li>\n<li><p>酒甕囝 /ziu² ang³ gian²/</p>\n</li>\n<li><p>盐酸鸡囝 /iam⁵ sng¹ goi¹ gian²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2063.png\" alt></p>\n</li>\n<li><p>見笑草 /giang³ siao³ cao²/ 含羞草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2064.png\" alt></p>\n</li>\n<li><p>燈籠草 /dêng¹ lang⁵ cao²/ 其果子稱爲「姑娘果」</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2065.png\" alt></p>\n</li>\n<li><p>車前草 /cia¹ zain⁵ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2066.png\" alt></p>\n</li>\n<li><p>馬鞭草 /bhê² bin¹ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2067.png\" alt></p>\n</li>\n<li><p>蟋蟀草 /tig⁴ sug⁴ cao²/ 烏龍草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2068.png\" alt></p>\n</li>\n<li><p>蒲公英 /pu⁵ gong¹ êng¹/</p>\n</li>\n<li><p>鸭舌草 /ah³ zih⁸ cao²/ 苦菜</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2069.png\" alt></p>\n</li>\n<li><p>魚腥草 /hu⁵ co³ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2070.png\" alt></p>\n</li>\n<li><p>益母草 /iah⁴ bho² cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2071.png\" alt></p>\n</li>\n<li><p>龍膽草 /lêng⁵ dan² cao²/ 苦地膽草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2072.png\" alt></p>\n</li>\n<li><p>奶汁草 /nê¹ zab⁴ cao²/ 乳汁草，草折斷會有白色液體流出。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2073.png\" alt></p>\n</li>\n<li><p>虎耳草 /haon² hin⁶ cao³/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2074.png\" alt></p>\n</li>\n<li><p>大號奶汁草 /dua⁷ ho⁷ nê¹ zab⁴ cao³/ 蠔割草、飛揚草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2075.png\" alt></p>\n</li>\n<li><p>貓毛兒 /ngiao¹ mo⁵ ri⁵/ 金絲草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2076.png\" alt></p>\n</li>\n<li><p>貓鬚草 /ngiao¹ ciu¹ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2077.png\" alt></p>\n</li>\n<li><p>鹅囝香 /gho⁵ gian² hiang¹/ 鹅不食草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2078.png\" alt></p>\n</li>\n<li><p>白花蛇舌草 /bêh⁸ hoi¹ zua⁵ zih⁸ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2079.png\" alt></p>\n</li>\n<li><p>白花蟛蜞草 /bêh⁸ hoi¹ pen⁵ ki⁵ cao²/、/bêh⁸ hoi¹ mua⁵ ki⁵ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2080.png\" alt></p>\n</li>\n<li><p>四方枝苦楝 /si³ bang¹ gi¹ kao² nai⁷/ 鬼針草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2081.png\" alt></p>\n</li>\n<li><p>苦楝 /kao² nai⁷/ 苦楝樹</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2082.png\" alt></p>\n</li>\n<li><p>挨礱被哺 /oi⁵ lang⁵ bi⁶ bu⁶/ 磨盤草、磨礱草、挨礱地堵，其果實似磨盤和礱。礱，磨谷農具。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2083.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"🏮時節-si⁵-zoih⁴\"><a href=\"#🏮時節-si⁵-zoih⁴\" class=\"headerlink\" title=\"🏮時節(si⁵ zoih⁴)\"></a>🏮時節(si⁵ zoih⁴)</h3><ol>\n<li>今年 /gim¹ ni⁵/</li>\n<li>舊年 /gu⁷ ni⁵/ 去年</li>\n<li>前年 /zain³ ni⁵/、/zung³ ni⁵/</li>\n<li>下年 /ê⁶ ni⁵/ 明年</li>\n<li>熱天時 /ruah⁸ tin¹ si⁵/ 夏天</li>\n<li>寒天時 /guan⁵ tin¹ si⁵/ 冬天</li>\n<li>凝天時 /ngang⁵ tin¹ si⁵/ 冬天</li>\n<li>春夏秋冬 /cung¹ hê⁶ ciu¹ dang¹/</li>\n<li>老歷 /lao⁶ lê²/ 農曆</li>\n<li>新曆 /sing¹ lê²/ 公曆</li>\n<li>今日 /gim¹ rig⁸/</li>\n<li>明日 /mêng⁵ rig⁸/</li>\n<li>今旦日 /gian² rig⁸/ 今天</li>\n<li>明旦日 /man³ rig⁸/ 明天</li>\n<li>明眠起 /ma³ mng⁵ ki²/ 明天</li>\n<li>昨日 /za¹ rig⁸/</li>\n<li>前日 /zain⁵ rig⁸/、/zoh⁸ rig⁸/</li>\n<li>後日 /ao⁶ rig⁸/</li>\n<li>大前日 /dua⁷ zain⁵ rig⁸/、/dua⁷ zoh⁸ rig⁸/</li>\n<li>大後日 /dua⁷ ao⁶ rig⁸/</li>\n<li>天光 /tin¹ gng¹/ 天亮</li>\n<li>透早 /tao³ za²/ 黎明</li>\n<li>眠起 /mng⁵ ki²/ 早晨</li>\n<li>日時 /rig⁸ si⁷/ 白天</li>\n<li>早晝 /za² dao³/ 上午</li>\n<li>中晝 /dêng¹ dao³/ 中午</li>\n<li>中晝時 /dêng¹ dao³ si⁵/ 中午</li>\n<li>下晝 /ê⁶ dao³/ 下午</li>\n<li>下旰 /ê⁶ gua³/ 下午</li>\n<li>暗頭 /am³ tao⁵/ 傍晚</li>\n<li>暗頭時 /am³ tao⁵ si⁵/ 傍晚</li>\n<li>下昏 /ê⁶ hng⁵/ 晚上</li>\n<li>下昏時 /ê⁶ hng⁵ si⁵/、/êng² si⁵/ 晚上</li>\n<li>下昏囝 /êng² gian²/ 晚上</li>\n<li>暗時 /am³ si⁷/ 晚上</li>\n<li>暝時、夜時 /mê⁵ si⁷/ 晚上</li>\n<li>暝昏、夜昏 /mê⁵ hng⁵/ 晚上</li>\n<li>暝昏時、夜昏時 /mê⁵ hng⁵ si⁵/、/mêng² si⁵/ 晚上</li>\n<li>暝昏囝 /mêng² gian²/ 晚上</li>\n<li>半暝、半夜 /buan³ mê⁵/</li>\n<li>時分秒 /si⁵ hung⁵ miao²/</li>\n<li>個字 /gai⁵ ri⁷/ 五分鐘</li>\n<li>兩個字久 /no⁶ gai⁵ ri⁷ gu²/ 十分鐘</li>\n<li>頭前 /tao⁵ zain⁵/ 之前</li>\n<li>頭陣 /tao⁵ zung⁵/ 剛才</li>\n<li>下 /ê⁶ miag⁸/、/ê⁶ mig⁸/ 剛才</li>\n<li>一頃 /zêg⁸ kuang³/ 一會兒</li>\n<li>一頃頭 /zêg⁸ kuang³ tao⁵/ 一下子</li>\n<li>煞尾 /suah⁴ bhoi²/ 最後</li>\n<li>今 /dan¹/ 現在</li>\n<li>逐日 /dag⁸ rig⁸/ 每天</li>\n<li>逐暝 /dag⁸ mê⁵/ 每晚</li>\n<li>通日 /tang³ rig⁸/ 整天</li>\n<li>半日 /buan³ rig⁸/</li>\n<li>隔日 /gêh⁴ rig⁸/</li>\n<li>隔暝、隔夜 /gêh⁴ mê⁵/</li>\n<li>別日 /bag⁸ rig⁸/ 改天</li>\n<li>即時 /ziag⁴ si⁵/ 立刻、馬上</li>\n<li>平常時 /pêng⁵ sion⁵ si⁵/ 平時</li>\n<li>一日通通 /zêg⁸ rig⁸ tang³ tang³/ 一整天</li>\n<li>七早八早 /cig⁴ za² boih⁴ za²/ 一大早</li>\n<li>七早蒙流 /cig⁴ za² mo⁵ liu⁵/ 一大早</li>\n<li>烏暗天地 /ao¹ am³ tin¹ di¹/ 天昏地暗</li>\n<li>立春 /lib⁸ cung¹/</li>\n<li>雨水 /u² sui²/</li>\n<li>驚蟄 /gêng¹ dêg8/</li>\n<li>春分 /cung¹ hung¹/</li>\n<li>清明 /cêng¹ mêng⁵/</li>\n<li>谷雨 /gog⁴ u²/</li>\n<li>立夏 /lib⁸ hê⁶/</li>\n<li>小滿 /sio² muan²/</li>\n<li>芒種 /mang⁵ zêng²/</li>\n<li>夏至 /hê⁶ zi³/</li>\n<li>小暑 /siao² su²/</li>\n<li>大暑 /dai⁶ su²/</li>\n<li>立秋 /lib⁸ ciu¹/</li>\n<li>處暑 /cu³ su²/</li>\n<li>白露 /bêh⁸ lao⁷/</li>\n<li>秋分 /ciu¹ hung¹/</li>\n<li>寒露 /guan⁵ lao⁷/</li>\n<li>霜降 /sang¹ gang³/</li>\n<li>立冬 /lib⁸ dang¹/</li>\n<li>小雪 /siao² soh⁴/</li>\n<li>大雪 /dai⁶ soh⁴/</li>\n<li>冬至 /dang¹ zi³/</li>\n<li>小寒 /siao² hang⁵/</li>\n<li>大寒 /dai⁶ hang⁵/</li>\n<li>時年八節 /si⁵ ni⁵ boih⁴ zoih⁴/ 一年四季八個節，最早的八節指立春、春分、立夏、夏至、立秋、秋分、立冬和冬至。而在甲子時年八節指元宵、春分、清明、五月節、七月半、秋分、八月半、冬節，過此八節要拜祖，除春分、秋分外的節還需要拜神。<ul>\n<li>四時，四季、春夏秋冬。</li>\n<li>年，甲骨文象人負禾之形，會穀物豐收之意，古時禾穀一年一熟，於是「年」被（引申）用作周年之年。【爾雅•釋天】夏曰歲，商曰祀，周日年，唐虞曰載。古時一度流行歲星（即木星、朱比特星，公轉週期爲 398.88 天）紀年，故一年又稱一歲。</li>\n<li>時年，一年四季。</li>\n<li>節，中國曆法把一年分為二十四段，每段的開始即爲節。早期只有春分、秋分、夏至、冬至四節，後又加入立春、立夏、立秋、立冬，形成八節，再來後逐漸形成了二十四節。「節」早期是天文曆法上的概念，與氣候相關，後又逐漸加入了紀念或慶祝的元素。</li>\n</ul>\n</li>\n<li>元宵節 /nguang⁵ siao¹ zoih⁴/</li>\n<li>公忌節 /gong¹ gi⁷ zoih⁴/ 春分和秋分，祭拜先祖，但不拜神。</li>\n<li>清明節 /cêng¹ mêng⁵ zoih⁴/</li>\n<li>五月節 /ngao⁶ ghoih⁸ zoih⁴/ 端午節</li>\n<li>七月半 /cig⁴ ghoih⁸ buan³/ 中元節、鬼節</li>\n<li>八月半 /boih⁴ ghoih⁸ buan³/ 中秋節</li>\n<li>冬節 /dang¹ zoih⁴/ 冬至節的簡稱。</li>\n<li>廿九暝、廿九夜 /rig⁸ gao² mê⁵/ 除夕（小月）</li>\n<li>三十暝、三十夜 /san¹ zab⁸ mê⁵/ 除夕（大月）</li>\n<li>春節 /cung¹ zoih⁴/</li>\n<li>重陽 /ciang⁵ iang⁵/、/dêng⁵ iang⁵/</li>\n<li>國慶節 /gog⁴ kêng³ zoih⁴/</li>\n<li>勞動節 /lao⁵ dong⁶ zoih⁴/</li>\n<li>婦女節 /hu⁶ nng² zoih⁴/</li>\n<li>兒童節 /ri⁵ tong⁵ zoih⁴/</li>\n<li>教師節 /ga³ su¹ zoih⁴/</li>\n<li>做節 /zo³ zoih⁴/ 過節日</li>\n<li>做壽 /zo³ siu⁶/ 過壽辰</li>\n<li>做生日 /zo³ sên¹ rig⁸/ 過生日</li>\n<li>公忌 /gong¹ gi⁷/ 先祖忌日</li>\n<li>拜公忌 /bai³ gong¹ gi⁷/ 在忌日祭拜先祖</li>\n<li>拜祖 // 祭拜先祖</li>\n<li>拜老爺 // 拜神</li>\n<li>假日 /gia² rig⁸/</li>\n<li>放假 /bang³ gia²/、/bang³ gian²/</li>\n<li>暑假 /su² gia²/</li>\n<li>寒假 /hang⁵ gia²/</li>\n</ol>\n<h3 id=\"🌀天時-tin¹-si⁵\"><a href=\"#🌀天時-tin¹-si⁵\" class=\"headerlink\" title=\"🌀天時(tin¹ si⁵)\"></a>🌀天時(tin¹ si⁵)</h3><ol>\n<li>晴 /zên⁵/ 晴朗</li>\n<li>出日 /cug⁴ rig⁸/ 太陽出來了</li>\n<li>透堂白日 /tao³ dng⁵ bêh⁸ rig⁸/ 大白天</li>\n<li>烏陰天 /ao¹ im¹ tin¹/ 陰天</li>\n<li>透風 /tao³ hong¹/ 刮大風</li>\n<li>風颱 /hong¹ tai¹/ 颱風</li>\n<li>南風天 /nang¹ hong¹ tin¹/ 刮南風，濕氣加重</li>\n<li>轉南風 /dng² nang¹ hong¹/ 南風天來了</li>\n<li>透南風 /tao³ nang¹ hong¹/ 刮南風，伍佰有一 Live 同名。</li>\n<li>蒙煙天 /mong⁵ iang¹ tin¹/ 霧霾天</li>\n<li>落雨 /lo² hao⁶/ 下雨</li>\n<li>一陣雨 /zêg⁸ zung⁵ hao⁶/</li>\n<li>日頭雨 /rig⁸ tao⁵ hao⁶/ 一邊下雨，一邊出太陽</li>\n<li>烏寒雨 /ao¹ guan⁵ hao⁶/ 天時烏陰落寒雨</li>\n<li>爍焰 /sih⁴ iam⁶/ 閃電</li>\n<li>敲雷 /ka³ lui⁵/ 打雷</li>\n<li>冷空氣 /lêng² kong¹ ki⁷/</li>\n<li>落雪 /lo² soh⁴/ 下雪</li>\n<li>落雹 /lo² pag⁸/ 下冰雹</li>\n<li>旱 /uan⁶/ 乾旱</li>\n<li>寒 /guan⁵/ 寒冷</li>\n<li>冷 /lêng²/ 寒冷</li>\n<li>凝 /ngang⁵/ 寒冷</li>\n<li>熱 /ruah⁸/</li>\n<li>翕熱 /hib⁴ ruah⁸/ 悶熱</li>\n<li>乾燥 /gang¹ cao³/</li>\n<li>濕 /sib⁴/ 濕潤</li>\n<li>涼 /liang⁵/ 涼爽</li>\n</ol>\n<h3 id=\"🌛天文-tiang¹-bhung⁵\"><a href=\"#🌛天文-tiang¹-bhung⁵\" class=\"headerlink\" title=\"🌛天文(tiang¹ bhung⁵)\"></a>🌛天文(tiang¹ bhung⁵)</h3><ol>\n<li>天頂 /tin¹ dêng²/ 天上</li>\n<li>日頭 /rig⁸ tao⁵/ 太陽</li>\n<li>蝕日 /sih⁸ rig⁸/ 日食</li>\n<li>狗齧日 /gao² na² rig⁸/ 天狗食日</li>\n<li>西照日 /sai¹ zio³ rig⁸/ 夕陽</li>\n<li>月娘 /ghoih⁸ nion⁵/ 月亮</li>\n<li>月眉 /ghoih⁸ bhai⁵/ 弦月</li>\n<li>蝕月 /sih⁸ ghoih⁸/ 月食</li>\n<li>河溪 /ho⁵ koi¹/ 銀河、天河</li>\n<li>落屎星 /lo² sai² cên¹/ 流星</li>\n<li>星宿 /cên¹ siu³/</li>\n</ol>\n<h3 id=\"⛰️地理-di⁷-li²\"><a href=\"#⛰️地理-di⁷-li²\" class=\"headerlink\" title=\"⛰️地理(di⁷ li²)\"></a>⛰️地理(di⁷ li²)</h3><ol>\n<li>中央 /diong¹ iang¹/ 中間</li>\n<li>內底 /lai⁶ doi²/ 裏面</li>\n<li>外口 /ghua⁷ kao²/、/la¹ kao²/ 外面</li>\n<li>頭頂 /tao⁵ dêng²/ 上面</li>\n<li>下跤 /ê⁶ ka¹/ 下面</li>\n<li>下底 /ê⁶ doi²/ 下面</li>\n<li>正手爿 /ziang³ ciu² bain⁵/ 左邊</li>\n<li>倒手爿 /do³ ciu² bain⁵/ 右邊</li>\n<li>頭前 /tao⁵ zain⁵/ 前面</li>\n<li>後底 /ao⁶ doi²/ 後面</li>\n<li>後壁 /ao⁶ biah⁴/ 後面</li>\n<li>對面 /dui³ ming⁷/</li>\n<li>隔壁 /gêh⁴ biah⁴/</li>\n<li>鄰近 /lim¹ ging⁶/</li>\n<li>塗跤 /tao⁵ ka¹/</li>\n<li>番爿 /huang¹ bain⁵/</li>\n<li>北爿 /bag⁴ bain⁵/</li>\n<li>東南西北 /dang¹ nam⁵ sai¹ bag⁴/</li>\n<li>地盤 /di⁷ buan⁵/</li>\n<li>領域 /nia² oig⁸/</li>\n<li>境內 /gêng² lai⁶/</li>\n<li>世界 /si³ gai³/</li>\n<li>宇宙 /u² diu²/</li>\n<li>全球 /cuang¹ giu⁵/</li>\n<li>天涯 /tiang¹ ngai⁵/</li>\n<li>山頂 /suan¹ dêng²/</li>\n<li>山跤 /suan¹ ka¹/</li>\n<li>外地 /ghua⁷ dê³/</li>\n<li>本地 /bng² di⁷/</li>\n<li>別地 /bag⁸ dê³/ 外地</li>\n<li>別地地 /bag⁸ di⁷ dê³/ 外地</li>\n<li>塗 /tao⁵/ 泥</li>\n<li>塗膏 /tao⁵ go¹/ 泥巴</li>\n<li>石頭 /zioh⁸ tao⁵/</li>\n<li>田園 /cang⁵ hng⁵/</li>\n<li>溪墘 /koi¹ gin⁵/ 溪邊</li>\n<li>草埔 /cao² bao¹/ 草坪</li>\n<li>崎 /gia⁶/ 小山坡</li>\n<li>坑 /kên/ 山谷、溪谷。</li>\n<li>嶺 /nia²/ 有路可通的山頂</li>\n<li>岑 /ngim⁵/、/cam⁵/ 小而高的山</li>\n<li>墟 /hu¹/ 大土山</li>\n<li>壩 /ba³/ 沙灘、沙洲。</li>\n<li>潭 /tam⁵/ 深水池</li>\n<li>溪 /koi¹/</li>\n<li>江 /gang¹/</li>\n<li>河 /ho⁵/</li>\n<li>湖 /ao⁵/</li>\n<li>海 /hai²/</li>\n<li>海拔 /hai² buag⁸/</li>\n<li>洲 /ziu¹/</li>\n<li>港 /gang²/</li>\n<li>灣 /uang¹/</li>\n<li>溝 /gao¹/</li>\n<li>渠 /ku⁵/ 水道，特指人工開的河道。</li>\n<li>浦 /pao²/ 水邊或江河入海處</li>\n<li>澳 /o³/ 海邊彎曲且可停泊船隻的地方</li>\n<li>汕 /suan³/ 河流沖刷或沖刷而積成的沙灘</li>\n<li>汕頭 /suan¹ tao⁵/</li>\n<li>汕尾 /suan³ bhoi²/</li>\n<li>海湧 /hai² êng²/ 海浪。湧，波浪。</li>\n<li>東濠湧 /dang¹ hao⁵ cong¹/ 地名，在廣州越秀。濠，溝渠。湧，河流分叉處。</li>\n<li>湧泉相報 /iong³ zuan⁵ siang¹ bo³/ 湧，水冒出。</li>\n<li>庭、埕 /dian⁵/ 院子、宽阔处</li>\n<li>礦物 /kuang³ moih⁸/</li>\n<li>化石 /hoi³ zioh⁸/</li>\n<li>原油 /nguang¹ iu⁵/</li>\n<li>燃料 /riang⁵ liao⁷/</li>\n<li>金屬 /gim¹ siog⁸/</li>\n<li>金銀財寶 /gim¹ nging⁵ cai⁵ bo²/</li>\n<li>鋼鐵 /gng³ tih⁴/</li>\n<li>蘇打 /so³ da²/ 英文 soda 的音譯，常指小蘇打，即碳酸氫鈉。</li>\n<li>蘇州 /sao¹ ziu¹/</li>\n<li>蠟 /la²/</li>\n<li>硫磺 /liu⁵ ng⁵/</li>\n<li>砒霜 /bi¹ sng¹/</li>\n<li>砂石 /sua¹ zioh⁸/</li>\n<li>大理石 /dai⁶ li² zioh⁸/</li>\n<li>碳 /tuan³/</li>\n<li>水銀 /zui² nging⁵/</li>\n<li>水龍水 /zui² lêng⁵ zui²/ 自來水</li>\n<li>地牛換肩 /di⁷ ghu⁵ uang⁷ gain¹/ 地震</li>\n<li>許婆寮 /kao² pua⁵ liao⁵/ 今可和村</li>\n<li>北輋 /bag⁴ sia⁵/ 今博社村</li>\n<li>四捻石 /si³ niam³ zio²/ 四片石</li>\n<li>甲子八景：六十甲子欄、潮來人字水、雙帆跨海島、五馬渡江邊、仙人踏石積、海甲蓮花山、西峯古寺、雷廟天堂。（《陸豐縣誌》卷之二疆域四 P21）</li>\n<li>擎天石：位於甲秀書院的側邊的一塊巨石。《陸豐縣誌》記載：在甲子所北門內峙立聳拔高出雉堞丈余，中開一痕，俗謂雷打石。胡文烜銘其上曰：「天開甲子，巨石臨門，一聲霹靂，振動乾坤 ……」。字大如鬥，余銘苔蝕莫辨。（《陸豐縣誌》卷之二古蹟十二 ）</li>\n<li>甲秀書院：甲秀書院位於陸豐縣甲子鎮北門內。甲秀書院建於明代，歷來為粵東文人會萃講學之所。至今院內仍保存著不少歷代的石碑石刻。解放后，人民政府在此興辦中學。</li>\n<li>福源寺：座落於甲子鎮北郊雨亭路，原名「復元寺」，又稱「蓮花山草庵」。據傳，福源寺建於宋代。因歷史久遠，原址僅遺存牆基。1990年由光茂法師主持重建。經過10多年的建造，先後建成天王殿、大雄寶殿、觀音殿、地藏殿、鐘樓、鼓樓和禪房等，重塑了諸位菩薩聖像。寺區佔地面積1.2萬多平方米，建築面積3000多平方米。</li>\n<li>南海夫人廟：位於甲子鎮城西社區環城路東。明萬曆元年（1573），李棠中舉後爲其妻卓氏而建的紀念祠，御史鄧練題匾「南海夫人」，故稱南海夫人廟。</li>\n<li>烈士墓</li>\n</ol>\n<h3 id=\"📐計量-goi³-liang⁶\"><a href=\"#📐計量-goi³-liang⁶\" class=\"headerlink\" title=\"📐計量(goi³ liang⁶)\"></a>📐計量(goi³ liang⁶)</h3><ol>\n<li>〇、零 /lêng⁵/、/lang⁵/</li>\n<li>一、壹 /zêg⁸/、/ig⁴/</li>\n<li>二、贰 /no⁶/、/ri⁶/</li>\n<li>三、叁 /san¹/、/sam¹/</li>\n<li>四、肆 /si³/、/su³/</li>\n<li>五、伍 /ngao⁶/、/u²/</li>\n<li>六、陆 /lag⁸/</li>\n<li>七、柒 /cig⁴/</li>\n<li>八、捌 /boih⁴/、/bag⁴/</li>\n<li>九、玖 /gao²/、/giu²/</li>\n<li>十、拾 /zab⁸/</li>\n<li>百、佰 /bêh⁴/</li>\n<li>千、仟 /cain¹/、/ciang¹/</li>\n<li>萬 /mang⁷/</li>\n<li>億 /êg⁸/</li>\n<li>一二個 /zêg⁸ no² gai⁵/</li>\n<li>二十六 /ri⁸ ab⁸ lag⁸/、/ri⁸ zab⁸ lag⁸/</li>\n<li>廿六號 /rig⁸ lag⁸ ho⁷/ 二十六號</li>\n<li>五十外個 /ngao⁶ zab⁸ ghua⁷ gai⁵/</li>\n<li>一百空八 /zêg⁸ bêh⁴ kang³ boih⁴/ 一百零八</li>\n<li>第一 /doi⁷ ig⁴/</li>\n<li>第二 /doi⁷ ri⁶/</li>\n<li>第三 /doi⁷ san¹/</li>\n<li>一個人 /zêg⁸ gai⁵ nang⁵/</li>\n<li>一爿花 /zêg⁸ bain⁵ hoi¹/ 一片花瓣</li>\n<li>一蕊花 /zêg⁸ lui² hoi¹/ 一朵花</li>\n<li>一葩花 /zêg⁸ pa¹ hoi¹/ 一朵花</li>\n<li>一枝花 /zêg⁸ gi¹ hoi¹/</li>\n<li>一縛花 /zêg⁸ ba² hoi¹/ 一束花</li>\n<li>一叢樹 /zêg⁸ zang⁵ hoi¹/ 一棵樹</li>\n<li>一簇頭毛 /zêg⁸ cog⁴ tao⁵ mo⁵/ 一撮頭髮</li>\n<li>一粒糖 /zêg⁸ liab⁸ tng⁵/</li>\n<li>一隻車 /zêg⁸ ziah⁴ cia¹/ 一輛車</li>\n<li>一架車 /zêg⁸ gê³ cia¹/ 一輛車</li>\n<li>一杯茶 /zêg⁸ boi¹ dê⁵/</li>\n<li>一碗水 /zêg⁸ uan² zui²/</li>\n<li>一喙水、一嘴水 /zêg⁸ cui³ zui²/ 一口水</li>\n<li>一條弓蕉 /zêg⁸ diao⁵ gêng¹ zio¹/ 一條香蕉</li>\n<li>一本書 /zêg⁸ bng² zu¹/</li>\n<li>一枝手機 /zêg⁸ gi¹ ciu² gi¹/ 一隻手機</li>\n<li>一枝鎖匙 /zêg⁸ gi¹ so² si⁵/ 一把鑰匙</li>\n<li>一個銀 /zêg⁸ gai⁵ nging⁵/ 一塊錢</li>\n<li>一領被 /zêg⁸ nia² poi⁶/ 一席被子</li>\n<li>一個鋪 /zêg⁸ gai⁵ pao¹/ 一張床</li>\n<li>一個鐘頭 /zêg⁸ gai⁵ zêng¹ tao⁵/ 一個小時</li>\n<li>一副衫褲 /zêg⁸ hu³ san¹ kao³/ 一套衣服</li>\n<li>一腰裙 /zêg⁸ io¹ gung⁵/ 一件裙子</li>\n<li>一尾魚 /zêg⁸ bhoi² hu⁵/ 一條魚</li>\n<li>一墩物件 /zêg⁸ dung¹ mi² gian⁶/ 一堆東西</li>\n<li>一橛蔗 /zêg⁸ goi² zia³/ 一截甘蔗</li>\n<li>一葩電火 /zêg⁸ pa¹ diang⁶ hoi²/ 一盞電燈</li>\n<li>一跤箸、一腳箸 /zêg⁸ ka¹ du⁷/ 一隻筷子</li>\n<li>一雙箸 /zêg⁸ sang¹ du⁷/ 一雙筷子</li>\n<li>一腹火 /zêg⁸ bag⁴ hoi²/ 一肚子火</li>\n<li>一脬屎 /zêg⁸ bu⁵ sai²/ 一坨屎</li>\n<li>一脬尿 /zêg⁸ bu⁵ rio⁷/ 一泡尿</li>\n<li>一逝路 /zêg⁸ zua⁷ lao⁷/ 一趟路</li>\n<li>一丸塗 /zêg⁸ uang⁵ tao⁵/ 一團泥土</li>\n<li>一過 /zêg⁸ goi³/ 一次</li>\n</ol>\n<h3 id=\"🧭-指代-zi²-toi³\"><a href=\"#🧭-指代-zi²-toi³\" class=\"headerlink\" title=\"🧭 指代(zi² toi³)\"></a>🧭 指代(zi² toi³)</h3><ol>\n<li>只 /zi²/ 這，近指。</li>\n<li>許 /hi²/ 那，遠指。</li>\n<li>者、這 /zê²/、/zia²/ 這，近指。</li>\n<li>遐 /hê²/、/hia²/ 那，遠指。</li>\n<li>底個 /di⁷ gai⁵/ 哪個</li>\n<li>者個 /zê² gai⁷/、/zia² gai⁷/ 這個</li>\n<li>遐個 /hê² gai⁷/、/hia² gai⁷/ 那個</li>\n<li>怎樣 /za³ ion⁷/、/zion²/</li>\n<li>乜樣 /mig⁴ ion⁷/ 怎樣</li>\n<li>底樣 /di⁷ ion⁷/ 怎樣</li>\n<li>怎生 /za³ sên¹/、/zai¹ sên¹/怎樣</li>\n<li>怎樣生 /zion² sên¹/ 怎樣</li>\n<li>怎樣然 /zion² ni⁵/、/zo⁵ ni⁵/ 怎麼、幹啥</li>\n<li>怎樣麼 /zion² mo⁷/、/ziom²/</li>\n<li>者樣 /zê² ion⁷/、/zion¹/</li>\n<li>遐樣 /hê² ion⁷/、/hion¹/</li>\n<li>者樣生 /zion¹ sên¹/ 這樣</li>\n<li>遐樣生 /hion¹ sên¹/ 那樣</li>\n<li>底搭 /di⁷ dah⁴/ 哪裏</li>\n<li>者搭 /zê² dah⁴/ 這裏</li>\n<li>遐搭 /hê² dah⁴/ 那裏</li>\n<li>底地 /di⁷ dê³/ 哪裏</li>\n<li>者地方 /zê² ding¹/ 這裏</li>\n<li>遐地方 /hê² ding¹/ 那裏</li>\n<li>底囝 /di⁷ gian²/ 哪兒</li>\n<li>者囝 /zê gian²/ 這兒</li>\n<li>遐囝 /hê² gian²/ 那兒</li>\n<li>底人 /di⁷ nang⁵/、/diang⁶/、/di⁷ diang⁶/ 誰</li>\n<li>底位 /di⁷ ui⁷/ 哪位</li>\n<li>者位 /zê² ui⁷/</li>\n<li>遐位 /hê² ui⁷/ 那位</li>\n<li>底時 /di⁷ si⁵/ 什麼時候</li>\n<li>底當時 /diang⁶ si⁵/ 什麼時候</li>\n<li>者時 /zê² si⁵/</li>\n<li>遐時 /hê² si⁵/ 那時</li>\n<li>乜事 /mig⁴ su⁷/ 什麼事情</li>\n<li>若㩼 /rioh⁸ zoi⁷/、/rua⁷ zoi⁷/ 多少</li>\n<li>幾 /gui²/</li>\n<li>豈是 /ka³ si⁷/ 是否是</li>\n<li>敢是 /gam² si⁷/ 是否是</li>\n</ol>\n<h3 id=\"🏃‍♀️動詞-dong⁶-su⁵\"><a href=\"#🏃‍♀️動詞-dong⁶-su⁵\" class=\"headerlink\" title=\"🏃‍♀️動詞(dong⁶ su⁵)\"></a>🏃‍♀️動詞(dong⁶ su⁵)</h3><p><strong>第一部分</strong></p>\n<ol>\n<li>會 /oi⁶/</li>\n<li>無會、袂、𠀾 /bhoi⁶/ 不會</li>\n<li>未 /bhoi⁷/ 沒有（事情還沒做）</li>\n<li>無 /bho⁵/ 沒有</li>\n<li>有 /u⁶/</li>\n<li>好 /ho²/</li>\n<li>毋好、孬 /mo²/ 不好</li>\n<li>欲 /bhêh⁴/ 要</li>\n<li>毋、唔 /m⁶/ 不要</li>\n<li>欲毋 /bhêh⁴ m⁶/、/bhên⁶/ 要不要</li>\n<li>愛 /ain³/ 要</li>\n<li>無愛 /bho⁵ ain³/ 不要</li>\n<li>毋愛、勿、嫑 /main³/ 不要</li>\n<li>用 /êng⁶/ 需要</li>\n<li>免 /miang²/ 不需要</li>\n<li>肯 /kêng²/、/kiang²/ 願意</li>\n<li>毋肯 /m⁶ kêng²/、/m⁶ kiang²/ 不願意</li>\n<li>架勢是 /gê³ si³ si⁷/ 看這情形是。例如：舖關了，架勢是去做節了。 </li>\n</ol>\n<p><strong>第二部分 頭、喙</strong></p>\n<ol>\n<li>dag⁴ 頭 // 點頭</li>\n<li>搖頭 /io⁵ tao⁵/</li>\n<li>攲頭 /ki¹ tao⁵/ 歪頭</li>\n<li>呾 /dan³/ 說</li>\n<li>參詳 // 商量</li>\n<li>學古 /oh⁴ gao²/ 講故事</li>\n<li>罵 /mê⁷/</li>\n<li>詏 /a³/ 爭辯</li>\n<li>冤家 /uang¹ gê¹/ 吵架</li>\n<li>恬 /diam⁷/ 閉嘴、安靜</li>\n<li>咬 /ga⁶/</li>\n<li>哺 /bao⁷/ 咀嚼</li>\n<li>唵 /am⁶/ 將食物放進嘴巴</li>\n<li>喷 /pung³/ 散射</li>\n<li>啡痰 /pui³ tam⁵/ 吐痰</li>\n<li>歕 /bung⁵/ 吹氣</li>\n<li>嗾？ /zag⁸/ 呛到、岔到 </li>\n</ol>\n<p><strong>第三部分 目、心</strong></p>\n<ol>\n<li>睇 /toi²/ 看</li>\n<li>看詳睇 /kang³ siang⁵ toi²/ 仔細看</li>\n<li>經心 /gêng¹ sim¹/ 用心</li>\n<li>經心衋事 // 操心</li>\n<li>經破頭腦 // 想破頭 </li>\n</ol>\n<p><strong>第四部分 手、跤</strong></p>\n<ol>\n<li>揨 /dian¹/ 觸、碰</li>\n<li>拍 /pah⁴/ 打</li>\n<li>舂 /cêng⁵/ 用力打</li>\n<li>/dng⁷/ 打</li>\n<li>刜 /hug⁴/ 揮、打</li>\n<li>剚、倳 /sai⁷/ 打</li>\n<li>抶 /diag⁴/ 用鞭、杖或竹板打。～手</li>\n<li>摔 /sug⁴/ 抽打、鞭打</li>\n<li>拗折 /a² zi²/ 折斷</li>\n<li>盖 /kain³/ 由上往下覆。～頭</li>\n<li>掃 /sao³/ 迅速掠過。～面</li>\n<li>揞 /an¹/ 掩。～面</li>\n<li>diu³ 竹囝</li>\n<li>擎 /gia⁵/ 舉、握、拿</li>\n<li>𢭪 /kioh⁴/ 撿、拾</li>\n<li>挈 /kioh⁸/ 取、拿</li>\n<li>摜 /guan⁶/ 提</li>\n<li>厾 /doh⁴/ 戳</li>\n<li>割 /guah⁴/</li>\n<li>殺 /suah⁴/</li>\n<li>斬 /zam²/</li>\n<li>斫 /dog⁴/ 剁</li>\n<li>宰 /zai²/ 殺</li>\n<li>刣 /tai⁵/ 殺</li>\n<li>拭 /cig⁴/ 擦</li>\n<li>濡 /ru⁵/ 用濕布擦或用拖把拖</li>\n<li>爬 /bê⁵/ 搔(癢)</li>\n<li>掊 /boi²/ 扒開</li>\n<li>揂 /ciu⁵/ 拉引繩子</li>\n<li>𠡒 /dui²/ 用力拉</li>\n<li>捏 /dên⁶/ 掐</li>\n<li>漱牙 /ciu³ ghê⁵/ 刷牙</li>\n<li>跋 /buah⁸/ 摔倒</li>\n<li>踏 /dah⁴/ 踩</li>\n<li>踢 /tag⁴/</li>\n<li>去 /ku³/、/ka³/</li>\n<li>轉 /dng²/ 回來</li>\n<li>綴 /doi³/ 跟著；縫合。</li>\n<li>修理 /siu¹ li²/、/su¹ li²/</li>\n<li>泊車 /pag⁴ cia¹/ 停車。泊，粵語音譯英文 park 得來，停車的意思。</li>\n</ol>\n<p><strong>第五部分</strong></p>\n<ol>\n<li>曳、𤆬 /cua⁷/ 帶、領</li>\n<li>娶 /cua⁷/ 取婦</li>\n<li>徙 /sua²/ 移動</li>\n<li>歇 /hiah⁴/ 放置、休息</li>\n<li>煩惱 /huang⁵ lo²/ 擔心</li>\n<li>相信 /sion¹ siang³/、/siang¹ sing⁷/ 相信</li>\n<li>相輔 /sion³ hu⁶/ 幫忙</li>\n<li>排比 /bai⁵ bi²/ 安排</li>\n<li>含包 /ham⁵ bao¹/ 包含</li>\n<li>拚頭前 /bian³ tao⁵ zain⁵/ 爭先</li>\n<li>輸服 /su¹ hog⁸/ 佩服</li>\n<li>䷀䷀ /dag⁴ nng⁷/ 浪費</li>\n<li>䷀落 /ga¹ lao⁵/ 掉落</li>\n<li>沕 /bhih⁴/ 躲藏</li>\n<li>支 /zin¹/ 預付</li>\n<li>圖賴 /tu⁵ tai²/ 耍賴</li>\n<li>放惰 /bang¹ dua⁶/ 懶得</li>\n</ol>\n<h3 id=\"🧜‍♀️形容-heng⁵-iong⁵\"><a href=\"#🧜‍♀️形容-heng⁵-iong⁵\" class=\"headerlink\" title=\"🧜‍♀️形容(hêng⁵ iong⁵)\"></a>🧜‍♀️形容(hêng⁵ iong⁵)</h3><ol>\n<li>媠 /sui²/ 好、漂亮</li>\n<li>雅 /ngia²/ 正、漂亮</li>\n<li>生好 /sên¹ ho²/ 漂亮、好看</li>\n<li>䆀 /bhai²/ 差、醜陋</li>\n<li>好 /ho²/</li>\n<li>痞、歹 /pai²/</li>\n<li>大細 /dua⁷ soi³/ 大小</li>\n<li>㩼少 /zoi⁷ zio²/ 多少</li>\n<li>加加減減 /gê¹ gê¹ giam² giam²/ 多多少少</li>\n<li>稀罕 // 稀少，罕見。</li>\n<li>賤 /la¹ zuan⁷/ 繁多，低賤。物以稀為貴，多則賤。</li>\n<li>猛慢 /mê² mang⁷/ 快慢、早晚。猛，快。</li>\n<li>肥 /bui⁵/ 胖</li>\n<li>肥腯肥腯 /bui⁵ tuh⁸ bui⁵ tuh⁸/ 胖嘟嘟</li>\n<li>㾪 /sang²/ 瘦</li>\n<li>㾪猴 /sang² gao⁵/ 瘦得跟猴子一樣</li>\n<li>㾪脯皺 /sang² bao² niao³/ 又瘦又缺水又褶皺，形容飢瘦。</li>\n<li>懸下 /guai⁵/ 高低</li>\n<li>早 /za²/</li>\n<li>晏 /uang³/ 晚</li>\n<li>粗 /cao¹/</li>\n<li>幼 /iun³/ 細</li>\n<li>粗殘 /cao¹ cang⁵/ 粗魯</li>\n<li>仔細 /zu² soi⁷/ 小心</li>\n<li>芳 /pang¹/ 香</li>\n<li>臭 /cao³/</li>\n<li>僫 /oh⁴/ 困難</li>\n<li>易 /goi⁷/ 容易</li>\n<li>闊 /kuah⁴/ 寬</li>\n<li>狹 /oih⁸/ 窄</li>\n<li>光 /gng¹/ 亮</li>\n<li>暗 /am³/</li>\n<li>恬 /diam⁷/ 安靜</li>\n<li>吵 /cao¹/ 吵鬧</li>\n<li>吵吵著 /cao¹ cao¹ dioh⁴/ 吵吵鬧鬧的</li>\n<li>飽 /ba²/</li>\n<li>枵 /iao¹/ 餓</li>\n<li>橂 /dain⁷/ 堅實、堅硬</li>\n<li>軟 /nam³/ 軟弱。本字不明，訓用「軟」。</li>\n<li>韌 /rung⁷/ 堅強；不容易斷裂。</li>\n<li>脆 /cê³/ 脆弱；容易斷裂。</li>\n<li>聰明 /cong¹ mêng⁵/</li>\n<li>愚蠢 /ngo⁵ cung²/</li>\n<li>戇 /gong³/ 愚笨</li>\n<li>賰 /cung⁵/ 剩餘</li>\n<li>欠 /kiam³/ 缺少</li>\n<li>清 // 清晰、乾淨</li>\n<li>雾 /bhu⁷/ 模糊</li>\n<li>清氣 /cêng¹ ki³/ 乾淨</li>\n<li>清氣相 /cêng¹ ki³ sion³/ 乾淨的樣子</li>\n<li>垃圾 /lah⁴ sab⁴/ 骯臟</li>\n<li>垃圾相 /lah⁴ sab⁴ sion³/ 骯臟的樣子</li>\n<li>無沙無圾 /bho⁵ sua¹ bho⁵ sab⁴/ 一塵不染</li>\n<li>灱 /da¹/ 乾燥</li>\n<li>㴷 /dam⁵/ 濕潤</li>\n<li>落雨㴷渧 /lo² hao⁶ dam⁵ di³/ 下雨濕漉漉的樣子</li>\n<li>著 /dioh⁸/ 對、正確</li>\n<li>毋著 /m⁷ dioh⁸/ 不對</li>\n<li>錯 /co³/</li>\n<li>熟 /sêg⁸/</li>\n<li>生 /cên¹/ (瓜果等)未成熟</li>\n<li>臭生 /cao³ cên¹/ 未煮熟或瓜果未成熟</li>\n<li>臭酸 /cao³ sng¹/ 食物變質</li>\n<li>黐黐 /ti¹ ti¹/ 黏稠</li>\n<li>切要 /ciag⁴ iao³/ 要緊</li>\n<li>無要緊 /bho⁵ iao³ ging²/ 不要緊</li>\n<li>大扮</li>\n<li>咸澀</li>\n<li>力相 // 努力</li>\n<li>惰 /duan⁶/ 懶惰</li>\n<li>鬧熱 /nao⁶ ria²/ 熱鬧</li>\n<li>活神 // 精神好，灵活</li>\n<li>健 /gian⁷/ 身體好</li>\n<li>碩㦙 /sêg⁴ ngo³/ 聰明和愚蠢</li>\n<li>夠力 /gao³ lag⁸/ 厲害</li>\n<li>夠強 /gao³ kiang³/ 厲害</li>\n<li>夠衰 /gao³ soi¹/ 好慘</li>\n<li>緊要 /ging² iao³/ 要緊</li>\n<li>切要 /ciag⁴ iao³/ 要緊</li>\n<li>癩瘑糜烂 //</li>\n<li>枝毛小節、枝毛細節 // 無關緊要</li>\n<li>偪側 /bêg⁴ cêg⁴/ 心中有氣，煩躁不安。</li>\n<li>生分 /cên¹ hung⁷/ 陌生、疏遠</li>\n<li>無影無跡 // 沒有根據</li>\n<li>一生跪跋 /zêg⁸ sên¹ gui⁶ buah⁸/ 一生坎坷</li>\n</ol>\n<h3 id=\"🐴副詞-hu³-su⁵\"><a href=\"#🐴副詞-hu³-su⁵\" class=\"headerlink\" title=\"🐴副詞(hu³ su⁵)\"></a>🐴副詞(hu³ su⁵)</h3><ol>\n<li>好 /hoh⁴/ 表示程度深。例如：好㩼人 // 好多人。</li>\n<li>死 /si²/ 表示程度特別深。例如：死㩼人 // 超級多人。死雅 // 超漂亮的。</li>\n<li>若 /rua⁷/ 多麼。例如：若雅 // 多麼漂亮。</li>\n<li>者 /zia²/ 這麼。例如：者細 // 這麼小。</li>\n<li>遐 /hia²/ 那麼。例如：遐好 // 那麼好。</li>\n<li>上好 /siang⁶ ho²/ 最好。</li>\n<li>上減 /siang⁶ giam²/ 最少。</li>\n<li>上加 /siang⁶ gê¹/ 最多。</li>\n<li>較 /ga³/ 比較地。例如：伊較厲害 // 他比較厲害。</li>\n<li>曾 /bhah⁴/ 曾經。例如：我毋曾來過 // 我不曾來過。</li>\n<li>攏總 /long² zong²/ 全部。例如：攏總 100 銀 // 總共 100 塊。</li>\n<li>煞 /sua⁵/ 竟然。例如：汝煞毋知 // 你竟然不知道。</li>\n<li>顛倒 /ding¹ do³/ 反而。例如：六月顛倒來落雪 // 六月反而下起雪。</li>\n<li>做蜀 /zo³ zêg⁸/ 一起。例如：做蜀 ka³ // 一起去。</li>\n</ol>\n<h3 id=\"😲象聲詞-siang⁶-sian¹-su⁵\"><a href=\"#😲象聲詞-siang⁶-sian¹-su⁵\" class=\"headerlink\" title=\"😲象聲詞(siang⁶ sian¹ su⁵)\"></a>😲象聲詞(siang⁶ sian¹ su⁵)</h3><ol>\n<li>喏 /no⁷/ 使人注意某物</li>\n<li>囉、咯 /lo⁷/ 表示事情完成</li>\n<li>/hoin⁷/ 呼人</li>\n<li>/oin⁷/ 應人</li>\n<li>喂 /uê⁷/ 打招呼。</li>\n<li>啊 /a⁷/ 加強語氣</li>\n<li>呀 /ia⁷/ 表示贊同</li>\n<li>喔、噢 /o⁷/ 表示醒悟、驚訝或了解</li>\n<li>哇 /ua⁷/ 表示驚訝</li>\n<li>嗯 /ng⁷/ 表示同意或了解</li>\n<li>哼 /hng²/ 表示不滿</li>\n<li>哎、噯 /ai⁷/ 嘆氣</li>\n<li>嗐 /hai⁷/ 嘆氣，比「哎」重些。</li>\n<li>/ho⁷～/、/o⁷～/ 長吁，含有一種無力、操碎了心的感覺。</li>\n</ol>\n<h3 id=\"🙃俗語-siog⁸-ngo²\"><a href=\"#🙃俗語-siog⁸-ngo²\" class=\"headerlink\" title=\"🙃俗語(siog⁸ ngo²)\"></a>🙃俗語(siog⁸ ngo²)</h3><ol>\n<li>哇浪、我卵 /ua² lang⁶/ 哇噻</li>\n<li>我無閒 /ua² bho⁵ ain⁵/ 我沒空</li>\n<li>走街邊 /zao² goi¹ bin¹/ 擺地攤</li>\n<li>汝愛去怎樣麼緊 /lu² ain³ ku³ zion² mo⁷ ging⁷/ 你趕著去幹嗎</li>\n<li>勿者樣生 /mai³ zion¹ sên¹/ 不要這樣</li>\n<li>知收煞 /zai¹ siu¹ suah⁴/ 適時停手</li>\n<li>毋別世代 /m⁶ bhag⁴ si³ dê³/ 不懂事</li>\n<li>無變 /bho⁵ biang³/ 沒有辦法</li>\n<li>堵著無變 /du² dioh⁴ bho⁵ biang³/ 碰到沒有辦法</li>\n<li>無理路 /bho⁵ li² lao⁷/ 無道理。路，道。</li>\n<li>無奈何 /bho⁵ da¹ ua⁵/ 無可奈何</li>\n<li>無奈寫作不得已 /bho⁵ nai⁶ sia² zo³ bug⁴ dêg⁴ in²/ </li>\n<li>呾死無會變 /dan⁵ si² bhoi⁶ bin³/ 冥頑不靈</li>\n<li>橂過石部 /dain⁷ goi³ zio² bao⁶/ 比石頭還硬</li>\n<li>三斗油麻倒無一粒落耳 /san¹ dao² iu⁵ mua⁵ do³ bho⁵ zêg⁸ liab⁴ lo² hin⁶/ 怎麼說都聽不進去</li>\n<li>瀉衰人 /sia³ soi¹ nang⁵/ 丟人、令人蒙羞</li>\n<li>見笑 /giang³ siao³/ 丟人、令人蒙羞</li>\n<li>雙目囥著褲底 /sang¹ mag⁸ kng³ dioh⁴ kao³ doi²/ 看不見</li>\n<li>無目睇 /bho⁵ mag⁸ toin³/ 不想看</li>\n<li>鴨囝聽雷 /ah⁴ gian² tian¹ lui⁵/ 聽不懂</li>\n<li>戅過隻鴨 /gong⁵ goi³ ziah⁴ ah⁴/ 比鴨子還戇</li>\n<li>一樣糜飯飼千外樣人 /zêg⁸ ion⁷ moi⁵ bng⁷ ci⁷ cain¹ ghua⁷ ion⁷ nang⁵/ 社會人各種各樣</li>\n<li>暗過魂宫 /am³ goi³ hung⁵ gêng¹/ 比陰間還暗</li>\n<li>三更想，半暝反 /san¹ gên¹ sion⁶, buan³ mê⁵ huang²/ 思來想去，反反覆覆。</li>\n<li>過跤事知歇 /goi¹ ka¹ su⁷ zai¹ hiah⁴/ 過去的事情就不要計較了</li>\n<li>無會少禮 /bhoi⁶ siao² li²/ 不害臊</li>\n<li>刣雞教猴 /tai⁵ goi¹ ga³ gao⁵/ 殺雞儆猴</li>\n<li>勞生拚死 /lu⁵ sên¹ bian³ si²/ 拚死拚活</li>\n<li>食呾會，躕人強 /ziah⁸ dan³ oi⁶, du⁵ nang⁵ kiang³/ 能吃會說還很頑皮</li>\n<li>勿踟躕我 /mai³ di¹ du⁵ ua⁷/ 別纏我，使得我不知所措。</li>\n<li>老過伯爺 /lao⁶ goi³ bêh⁴ ia⁵/ 比土地公還年長</li>\n<li>平樣平樣 /pên⁵ ion⁷ pên⁵ ion⁷/ 一模一樣</li>\n<li>假力洗茶渣 /gê² lag⁸ soi² dê⁵ za¹/ 該做的不做，做了不該做的。</li>\n<li>死無命凝 /si² bho⁵ mian⁷ ngang⁵/ 冷死了</li>\n<li>富到流油 /bu⁷ gao³ lao⁵ iu⁵/ 很富有</li>\n<li>人熟禮毋熟 /nang⁵ sêg⁸ li² m⁶ sêg⁸/ 雖然人很熟，但還是要講禮。</li>\n<li>熟人免行生禮 /sêg⁸ nang⁵ miang² gian⁵ cên¹ loi²/</li>\n<li>千人千般苦，無人苦平樣 /cain¹ nang⁵ cain¹ buan¹ kao², bho⁵ nang⁷ kao² pên⁵ ion⁷/ 各有各的煩惱</li>\n<li>蟹有橂奅，人有碩㦙 /hoi⁶ u⁶ dain⁷ pan³, nang⁵ u⁶ sêg⁴ nga³/ 有人聰明有人愚笨。橂，堅實。奅，中空。碩，學問高、聰明。㦙，愚笨。</li>\n<li>鳥飛會落毛，人行有跤跡 /ziao² boi¹ oi⁶ lo² mo⁵, nang⁵ gian⁵ u⁶ ka¹ ziah⁴/ 做過了的事總會留痕跡</li>\n<li>客情好過吊頷鬼 /kêh⁴ cêng⁵ ho² goi³ diao³ am⁶ gui²/ 吊死鬼熱情地勸人上吊好代替自己，比喻虛情假意。</li>\n<li>貓兒無葷無著茨，鴨囝無粟無會過暝 /ngiao¹ ri⁵ bho⁵ hung¹ bho⁵ dioh⁴ cu⁷, ah⁴ gian² bho⁵ cêg⁴ bhoi⁶ goi³ mê⁵/ 小貓沒有葷菜就不在家，小鴨沒有稻粒就不過夜。</li>\n<li>衰雞無會食粟 /soi¹ goi¹ bhoi⁶ ziah⁸ cêg⁴/ 如病雞般吃不下飯</li>\n<li>無會死大破相 /bhoi⁶ si² dua⁷ pua³ sion³/ 不死也會頭破血流</li>\n<li>十八棚頭做到透 /zab⁸ boih⁴ bên⁵ tao⁵ zo³ gao³ tao³/ 指每種事都嘗試，貶義。十八棚頭，指十八齣溫州南戲。</li>\n<li>無跤蟹 /bho⁵ ga¹ hoi⁶/ 孤立無援</li>\n<li>大細目 /dua⁷ soi³ mag⁸/ 偏心</li>\n<li>平安當大趁 /pêng⁵ ang¹ dng¹ dua⁷ tang⁷/ 平安無疾就當作是大賺一筆了</li>\n<li>大人彎，孥囝直 /dua⁷ nang⁷ uain¹, nao⁵ gian² dig⁸/ 大人說話拐彎抹角，小孩子則是直來直去。</li>\n<li>錢囝毋使使大錢 /zin⁵ gian² m⁶ sai² sai² dua⁷ zin⁵/ 小錢不花，久了就得要花大錢了。</li>\n<li>未學行，先學飛 /bhoi⁷ oh⁸ gian², sain¹ oh⁸ boi¹/ 還沒學走路就要學飛了，基礎未打好。</li>\n<li>一人主張，毋如二人參詳 /zêg⁸ nang⁷ zu² ziang¹, m⁶ ru⁵ no⁶ nang⁷ cam¹ ciang⁵/ 自作主張不如多個人一起商量</li>\n<li>通街市獵無 /tong¹ goi¹ ci⁶ lah⁸ bho⁵/ 整條街都找不到。獵，尋找。</li>\n<li>喙尖舌囝利 /cui³ ziamvi/ 牙尖嘴利</li>\n<li>九月狗吶日，無用諸娘理毋直 /gao² goi² gao² nah⁴ rig⁸, bho⁵ êng⁷ zu¹ nion⁵ li² m⁶ dig⁸/ 九月份開始晝短夜長，沒用的婦女家務事搞不定了。</li>\n<li>茶薄人情厚，茶厚有禮貌 /dê⁵ bo² nang⁵ cêng⁵ gao⁶, dê⁵ gao⁶ u⁶ li² mao⁶/</li>\n<li>三十歲無妻是孩童 /san¹ zab⁸ hoi³ bho⁵ ci¹ si⁶ hai⁵ tong⁵/</li>\n<li>目汁是財，愈哭愈來 /mag⁸ zab⁴ si⁶ cai⁵, ru² kao³ ru⁶ lai⁵/</li>\n<li>呾破無酒食 /dan³ pua³ bho⁵ ziu² ziah⁸/ 師傅教徒弟，徒弟設酒宴款待，師傅酒後授予秘方。之後徒弟不再宴請師傅。</li>\n<li>軟過豆腐 /nam³ goi³ dao⁷ hu⁷/</li>\n<li>車大炮 /cia¹ dua⁷ pao³/ 吹牛</li>\n<li>樹大分椏，囝大分家 /ciu⁷ dua⁷ bng¹ a¹, gian² dua⁷ bng¹ ga¹/ </li>\n<li>閒過仙 /ain⁵ goi³ siang¹/ 比神仙還閒</li>\n<li>雙目望無一寸長 /sang¹ mag⁸ mo⁷ bho⁵ zêg⁸ cung³ dng⁵/ 鼠目寸光</li>\n<li>一鼠二牛三虎四兔五龍六蛇七馬八羊九猴十雞十一狗十二豬 /ig⁴ cu² ri⁶ ghu⁵ san¹ haon² si³ tao³ ngao⁶ lêng⁵ lag⁸ zua⁵ cig⁴ bhê² boih⁴ ion⁵ gao² gao⁵ zab⁸ goi¹ zab⁸ ig⁴ gao² zab⁸ ri⁶ du¹/</li>\n<li>差豬差狗，不如家己走 /cê¹ du¹ cê¹ gao², bug⁴ ru⁵ ga¹ gi⁷ zao²/ 求人不如求己</li>\n<li>後生擔石，老人食藥 /hao⁶ sên¹ dan¹ zioh⁸, lao⁶ nang⁵ ziah⁸ ioh⁸/ 年少積勞，年老吃藥</li>\n<li>疑心生暗鬼 /ghi⁵ sim¹ sên¹ am³ gui²/ 因多疑而產生各種幻覺和錯誤判斷</li>\n<li>羊尾短短，遮毋著羊尻川 /ion⁵ bhoi² dê² dê², zia¹ m⁶ dioh⁴ ion⁵ ka¹ cng¹/ 自己的缺點尷尬能自己找個遮醜的就很好了，別去取笑別人的不堪。</li>\n<li>愛母著刻苦 /ain³ bhao² dioh⁴ kag⁴ kao²/ 要老婆就要努力了</li>\n<li>無好家神通外鬼 /bho⁵ ho² gê¹ sing⁵ tong¹ ghua⁷ gui²/</li>\n<li>How do you do，好事來堵 /hao³ su⁷ lai³ du²/ 嗨，要搞事情我不怕你。好事，喜歡搞事情。堵，應對、抵抗。</li>\n<li>秋瓜棚下無好人 /ciu¹ goi¹ bên⁵ ê⁶ bho⁵ ho² nang⁵/ 秋瓜，絲瓜。</li>\n<li>三跤椅囝毋知䆀 /san¹ ka¹ in² gian² m⁶ zai¹ bhai²/ 坐著少了一腿的椅子竟然不知道壞了，比喻身處困境而不自知。</li>\n</ol>\n<h3 id=\"🤣歇後語-hiah⁴-ao⁶-ngo²\"><a href=\"#🤣歇後語-hiah⁴-ao⁶-ngo²\" class=\"headerlink\" title=\"🤣歇後語(hiah⁴ ao⁶ ngo²)\"></a>🤣歇後語(hiah⁴ ao⁶ ngo²)</h3><ol>\n<li>柴目狗耳 — 假靈 /ca⁵ mag⁸ gao² hin⁶ — gê² lêng⁵/ 目雕的眼睛看不見，狗一般耳朵卻很靈，聽風是雨。</li>\n<li>雞跤長鴨跤短 — 有懸下 /goi¹ ka¹ dng⁵ ah⁴ ka¹ dê² — u⁶ guain⁵ gê⁶/ 雞腳長，鴨腳短，有高有矮。</li>\n<li>爐底碳 — 塊塊通 /lao⁵ doi² tuan³ — dê⁷ dê⁷ tang³/ 百事通</li>\n<li>孥囝食奶 — 坐亭 /nao⁶ gian² ziah⁸ nê¹ — zê⁶ dêng⁵/ 亭，直。</li>\n<li>菜頭面刺無血 — 面皮厚 /cai³ tao⁵ ming¹ ci³ bho⁵ hoih⁴ — ming¹ poi⁵ gao⁶/</li>\n<li>褪褲放屁 — 假工夫 /tng³ kao³ bang³ pui³ — gê² gang¹ hu¹/</li>\n<li>竹葉包沙 — 假壯 /dêg⁴ hio² bao¹ sua¹ — gê² zang³/ 壯，與「粽」諧音。</li>\n<li>元宵燈籠 — 一肚火 /nguang⁵ siao¹ dêng¹ lang⁵ — zêg⁸ dao² hoi²/</li>\n<li>半天吊燈籠 —四搭无向 /buan³ tin¹ diao³ dêng¹ lang⁵ — si³ dah⁴ bho⁵ hiang³/</li>\n<li>青暝睒鏡 — 無望 /cên¹ mên⁵ iam² gian³ — bho⁵ mo⁷/</li>\n<li>青暝睇天 — 張樣張相 /cên¹ mên⁵ toi² tin¹ — dion¹ ion⁷ dion¹ sion⁷/</li>\n<li>青暝點燈 — 照舊 /cên¹ mên⁵ diam² dêng¹ — zio³ gu⁷/ 對青暝人來說，點不點燈，一切照舊。</li>\n<li>青暝掠魚 — 散摸 /cên¹ mên⁵ liah⁸ hu⁵ — suan³ mong⁵/</li>\n<li>青暝娶母 — 稱重 /cên¹ mên⁵ cua⁷ bhao² — cing³ dang⁶/</li>\n<li>青暝擎手電 — 各人各人善 /cên¹ mên⁵ gia⁵ ciu² diang⁶ — gag⁴ nang⁵ gag⁴ nang⁵ siang⁶/</li>\n<li>青暝睇電影 — 聽聲 /cên¹ mên⁵ toi² diang⁶ ian² — tian¹ sian¹/</li>\n<li>啞人食苦瓜 — 有苦難言 /ê² nang⁵ ziah⁸ kao² goi¹ — u⁶ kao² nang⁵ ngiang⁵/</li>\n<li>啞囝食黃連 — 有苦難言 /ê² gian² ziah⁸ ng⁵ nain⁵ — u⁶ kao² nang⁵ ngiang⁵/</li>\n<li>閻羅王嫁諸母囝 — 鬼正敢愛 /ngiam⁵ lo⁵ uang⁵ gê³ za¹ bhao² gian² — gui² zian³ gan² ain³/</li>\n<li>閻羅王請人 — 鬼正敢食  /ngiam⁵ lo⁵ uang⁵ cian² nang⁵ — gui² zian³ gan² ziah⁸/</li>\n<li>閻羅王賣假貨 — 騙鬼 /ngiam⁵ lo⁵ uang⁵ bhoi⁷ gê² hoi⁷ — piang³ gui²/</li>\n<li>閻羅王出告示 — 無句人話 /ngiam⁵ lo⁵ uang⁵ cug⁴ go³ si⁷ — bho⁵ gu³ nang⁵ oi⁷/</li>\n<li>鬼簿無名 — 免死 /gui² pao⁶ bho⁵ mian⁵ — miang² si²/</li>\n<li>醫生開了棺材舖 — 死活都愛錢 /ui¹ sên¹ kui¹ liao² gua¹ ca⁵ pao⁷ — si² ua² do¹ ain³ zin⁵/</li>\n<li>身長棺材短 — 屈死人 /sing¹ dng⁵ gua¹ ca⁵ dê² — kug⁴ si² nang⁵/</li>\n<li>棺材頭畫老虎 — 驚死人 /gua¹ ca⁵ tao⁵ oi⁷ lao⁶ haon² — gian¹ si² nang⁵/</li>\n<li>歪喙和尚 — 唸無一句正經 /uain¹ cui³ hoi⁵ sion⁷ — niam⁷ bho⁵ zêg⁸ gu³ zian³ gêng⁵/</li>\n<li>師公和尚 — 毋同道 /sai¹ gong¹ hoi⁵ sion⁷ — m⁶ dang⁵ dao⁶/</li>\n<li>和尚抹粉 — 白勞 /hoi⁵ sion⁷ bhuah⁴ hung² — bêh⁸ lu⁵/ 勞，與「驢」諧音。</li>\n<li>和尚擎雨遮 — 無法無天 /hoi⁵ sion⁷ gia⁵ hao⁶ zia¹ — bho⁵ huab⁴ bho⁵ tin¹/ 法，與「髮」諧音。</li>\n<li>橄欖尻川 — 坐毋恬 /gan¹ na² ka¹ cng¹ — zê⁶ m⁶ diam⁷/ 屁股像橄榄一般尖，坐不住。恬，静、定。</li>\n<li>火燒豬頭 — 熟面熟面 /hoi² sio¹ du¹ tao⁵ — sêg⁸ ming⁷ sêg⁸ ming⁷/</li>\n<li>六月芥菜 — 假有心 /lag⁸ ghoih⁸ gua³ cai³ — gê² u⁶ sim¹/</li>\n<li>十月芥菜 — 大䀌心 /zab⁸ ghoih⁸ gua³ cai³ — dua⁷ gêg⁴ sim¹/ 䀌，與「激」諧音。</li>\n<li>六月蕃薯 — 雙死 /lag⁸ ghoih⁸ huang¹ zu⁵ — sang¹ si²/ 雙，與「鬆」諧音。</li>\n<li>阿媽生諸母囝 — 生菇 /a¹ ma² sên¹ za¹ bhao² gian² — sên¹ gao¹/ 生菇，發霉。菇，與「姑」諧音。</li>\n<li>老人跤纏 — 又長又臭 /lao⁶ nang⁵ ka¹ din⁵ — ui⁶ dng⁵ ui⁶ cao³/ 講話囉嗦像老人纏足一樣</li>\n<li>老人食豬跤 — 試味 /lao⁶ nang⁵ ziah⁸ du¹ ka¹ — ci³ bhi⁷/ 嘗試下而已</li>\n<li>老婆跋落水 — 淒涼 /lao⁶ pua⁵ buah⁸ lo² zui² — ci¹ liang⁵/ 跋，絆倒。淒，與「妻」諧音。</li>\n<li>老婆其阿兄 — 痴哥 /lao⁶ pua⁵ gai⁵ a¹ hian¹ — ci¹ go¹/ 痴，與「妻」諧音。</li>\n<li>菜頭粿熱單爿 — 自作多情 /cai³ tao⁵ goi² riah⁸ duan¹ bain⁵ — zu⁶ zag⁴ do¹ cêng⁵/ 菜頭粿，蘿蔔糕。热单爿，切片下鍋油煎，但只煎單邊，上焦下嫩。一頭熱（悅），單戀。</li>\n<li>龍眼核拭尻川 — 賽道行 /nging¹ ain² hug⁸ cih⁴ ka¹ cng¹ — sai³ dao⁶ hang⁵/ 「龍眼核拭尻川」比喻有難度的事情，看各家誰本領強了。</li>\n<li>水仙不開花 — 裝蒜 /zui² siang¹ bug⁴ kui¹ hoi¹ — zng¹ sng³/</li>\n<li>大炮拍麻雀 — 騙伊驚 /dua⁷ pao³ pah⁴ mua⁵ ziah⁴ — piang³ i¹ gian¹/</li>\n<li>有錢買蠓香，無錢買蠓罩 — 會算無會除 /u⁶ zin⁵ bhoi² mang² hion¹, bho⁵ zin⁵ bhoi² mang² dan³ — oi⁶ sng³ bhoi⁶ du⁵/</li>\n<li>天頂滴鳥屎 — 無好相覓 /tin¹ dêng² dig⁴ ziao² sai² — mo² sion¹ coi⁷/</li>\n<li>六月薄殼 — 假大頭 /lag⁸ ghoih⁸ boh⁸ kag⁴ — gê² dua⁷ tao⁵/ 大頭，一種比薄殼略大的小貝類海鮮。假大頭，愛充大頭。</li>\n<li>七角錢二人分 — 毋三毋四 /cig⁴ gag⁴ zin⁵ no⁶ nang⁵ bng¹ — m⁶ san¹ m⁶ si³/</li>\n<li>十二碗圓食賰一粒 — 假客氣 /zab⁸ ri⁶ liab⁸ in⁵ ziah⁸ cung⁵ zêg⁸ liab⁸ — gê² kêh⁴ ki⁷/ 圓，丸子。賰，剩下。</li>\n<li>狗母蛇 — 假靈 /gao² bho² zua⁵ — gê² lêng⁵/ 靈，與「龍」諧音。</li>\n<li>兄獨目弟缺喙 — 大無好樣，細無好相 /hian¹ dog⁸ mag⁸ di⁶ koih⁴ cui³ — dua⁷ bho⁵ ho² ion⁷, soi³ bho⁵ ho² sion³/</li>\n<li>山螟咬尾 — 食家己 /suan¹ mê¹ ga⁶ bhoi² — ziah⁸ ga¹ gi⁷/</li>\n<li>風吹牆頭草 — 就勢倚勢 /hong¹ coi¹ ciong⁵ tao⁵ cao² — ziu⁶ si³ ua² si³/</li>\n<li>老鼠跋落粟倉 — 倒好 /ngiao² cu² buah⁸ lo² cêg⁴ cng¹ — do³ ho²/</li>\n<li>老鼠心肝 — 頭食頭搬 /ngiao² cu² sim¹ guan¹ — tao⁵ ziah⁸ tao⁵ buan⁵/</li>\n<li>孥囝拍炮 — 又驚又好 /nao⁵ gian² pah⁴ pao⁷ — ui⁶ gian¹ ui⁶ hao⁷/</li>\n<li>五行缺一 — 欠金 /ngao⁶ hêng⁵ koih⁴ ig⁴ — kiang³ gim¹/</li>\n<li>茂生進酒 — 厚情 /mao⁶ sêng¹ zing³ ziu² — gao⁶ cêng⁵/</li>\n<li>食人雞肉還人豬肉 — 物來物去 /ziah⁸ nang⁷ goi¹ nê² hain⁵ nang⁷ du¹ nê² — moih⁸ lai⁵ moih⁸ ko³/</li>\n<li>刀截蕹菜 — 二頭空 /do¹ zoi² êng³ cai³ — no⁶ tao⁵ kong¹/</li>\n<li>三個半錢 — 趕勢 /san¹ gai⁵ buan³ zin⁵ — guan² si³/ 勢，與「四」諧音。</li>\n<li>隔暝皇帝 — 無權勢 /gêh⁴ mê⁵ huang⁵ di⁷ — bho⁵ kuang⁵ si³/</li>\n<li>大肚水蛙 — 假鮭 /dua⁷ dao² zui² goi¹ — gê² guai¹/ 水蛙，青蛙。鮭，河魨。</li>\n<li>五月龍船 — 相鬥 /ngao⁶ ghoih⁸ lêng⁵ zung⁵ — sion¹ dao³/</li>\n<li>燈籠照路 — 目前光 /dêng¹ lang⁵ zio³ lao⁷ — mag⁸ zain⁵ gng¹/ 比喻目光短淺</li>\n<li>暗室穿針 — 難過 /am³ sig⁴ cng¹ zam¹ — nang⁵ goi³/</li>\n<li>嫁諸母囝娶新婦 — 出入平安 /gê³ za¹ bhao² gian² cua⁷ sing¹ bu⁶ — cug⁴ rib⁸ pêng⁵ ang¹/ 安，與「翁」諧音。</li>\n<li>過關送文憑 — 做人情 /goi³ guan¹ sang³ bhung⁵ pêng⁵ — zo³ nang⁵ zian⁵/</li>\n<li>火燒草料場 — 事出有因 /hoi² sio¹ cao² liao⁷ dion⁵ — su⁷ cu⁷ u⁶ ing¹/ 因，與「煙」諧音。</li>\n<li>黑白電視 — 無彩 /hêg⁴ bêh⁸ dian⁶ si⁶ — bho⁵ cain²/ 無彩，可惜。</li>\n<li>小郎遇著雨 — 積惡 /sio² nng⁵ ngo⁶ dioh⁴ hao⁶ — zêg⁴ ag⁴/ 小郎，女子稱呼丈夫的弟弟。積惡，可憐；罪惡。積，與「叔」諧音。惡，與「沃」諧音。</li>\n</ol>\n<h3 id=\"🙂禮貌用語-li²-mao⁶-eng³-ngo²\"><a href=\"#🙂禮貌用語-li²-mao⁶-eng³-ngo²\" class=\"headerlink\" title=\"🙂禮貌用語(li² mao⁶ êng³ ngo²)\"></a>🙂禮貌用語(li² mao⁶ êng³ ngo²)</h3><ol>\n<li>汝食饱未 /lu² ziah⁸ ba² bhoi⁷/ 你吃飽了嗎</li>\n<li>汝愛去底地 /lu² ain³ ku³ di⁷ dê⁷/ 你要去哪裏</li>\n<li>汝好 /lu² ho²/ 你好</li>\n<li>㩼謝 /zoi⁷ sia⁷/ 多謝</li>\n<li>寬行 /kuan¹ gian⁵/ 慢走</li>\n<li>寬駛 /kuan¹ sai²/ 慢點開車</li>\n<li>对毋住 /dui³ m⁶ zu⁶/ 对不起</li>\n<li>对毋起 /dui³ m⁶ ki²/ 对不起</li>\n<li>無相干 /bho⁵ siang¹ gang¹/ 沒關係</li>\n<li>毋知頭 /m⁶ zai¹ tao⁵/ 不是故意的</li>\n<li>先這呾 /sain¹ zion² dan³/ 回頭再聊 </li>\n<li>萬事應想 /mang⁷ su⁷ êng³ sion⁶/ 萬事如意</li>\n<li>生理大趁 /sêng¹ li² dua⁷ tang⁷/ 生意興隆</li>\n<li>新年大趁 /sing¹ ni⁵ dua⁷ tang⁷/ 新年大賺</li>\n<li>新年合想 /sing¹ ni⁵ gah⁴ sion⁶/ 新年如意</li>\n<li>大吉大利 /dai⁶ gig⁴ dai⁶ li⁶/</li>\n</ol>\n<h3 id=\"🤐粗話-cao¹-oi⁷\"><a href=\"#🤐粗話-cao¹-oi⁷\" class=\"headerlink\" title=\"🤐粗話(cao¹ oi⁷)\"></a>🤐粗話(cao¹ oi⁷)</h3><ol>\n<li>咒誓 /ziu³ zua⁷/ 發誓、詛咒</li>\n<li>痟 /siao²/ 神經錯亂</li>\n<li>神經 /sing⁵ gêng¹/</li>\n<li>腦孬 /nao² mo³/ 腦子壞了</li>\n<li>破脑囝 /puah⁸ nao² gian²/ 弱智</li>\n<li>肚痛 /dao² tian³/ 「問候」別人是否肚子痛所以一直在叫。</li>\n<li>鬼叫 /gui² gio⁷/ 「問候」別人是否聽到鬼在叫。</li>\n<li>哭 cang¹ 哭 nain⁵ // 又哭又喊，吵死人了。</li>\n<li>哭父死母 /kao³ bê⁶ si² bho²/ 「問候」別人是否父母過世所以一直在哭叫。</li>\n<li>咋死人 /zag⁴ si² nang⁵/ 吵死了</li>\n<li>鬼囝 /gui² gian²/ 小鬼</li>\n<li>鬼卒囝 /gui² zug⁴ gian²/ 小鬼</li>\n<li>鬼然然 /gui² riang⁵ riang⁵/ 像鬼一樣</li>\n<li>鬼囉作禍 /gui² lo⁷ zo³ ho³/ 鬼在作祟、作怪</li>\n<li>妖怪精 /iao¹ guai³ zian¹/</li>\n<li>去死掉掉 /ku³ si² diao³ diao³/</li>\n<li>散哭父 /suan⁷ kao³ bê⁶/ 散，到處。</li>\n<li>吐屎 /tao³ sai²/ 亂說</li>\n<li>卵屎人 /lang⁶ sai² nang⁵/ 屌絲，沒前途的人。</li>\n<li>卵屎話 /lang⁶ sai² oi⁷/ 廢話</li>\n<li>臭喙卵面 /cao³ cui³ lang⁶ ming⁷/ 亂說、討人厭。</li>\n<li>關汝卵事 /guang¹ lu² lang⁶ dai⁷/ 與你何干</li>\n<li>膣精 /zi¹ zian¹/ 多管閒事</li>\n<li>臭膣 /cao³ zi¹/ 臭婊子</li>\n<li>豺狗 /sai² gao²/ 狗腿子</li>\n<li>怪卵 /guai³ lang⁶/ 古怪</li>\n<li>無卵 /bho⁵ lang⁶/ 沒膽量</li>\n<li>無腦 /bho⁵ nao²/ 沒腦子</li>\n<li>𠀾好 /bhoi⁶ ho²/ 咒別人倒霉</li>\n<li>痞囝 /pai² gian²/ 痞子、流氓。</li>\n<li>肏母囝 /pu² bho² gian²/</li>\n<li>早死囝 /za² si² gian²/</li>\n<li>短命囝 /dê² mian⁷ gian²/、/dêng² mian⁷ gian²/</li>\n<li>破家囝 /pua⁷ gê¹ gian²/ 败家子</li>\n<li>內仙囝  /lai⁶ siang¹ gian²/ 難伺候</li>\n<li>十惡囝 /zab⁸ ag⁴ gian²/ 十惡不赦</li>\n<li>棺材囝 /gua¹ ca⁵ gian²/</li>\n<li>痴哥囝 /ci¹ go¹ gian²/ 色狼</li>\n<li>吐血死囝 /tao³ hoih⁴ si² gian²/</li>\n<li>替人死囝 /toi⁵ nang⁵ si² gian²/</li>\n<li>半路死囝 /buan³ lao⁷ si² gian²/</li>\n<li>祭屎祭䷀ /zi³ sai² zi³ hê⁷/ 亂吃東西</li>\n<li>乞鬼侵著 /koh⁴ gui² cin⁵ dioh⁴/ 鬼上身了。乞，給。侵，本讀 /cim⁵/，音變爲 /cin⁵/，附身。</li>\n</ol>\n<h3 id=\"🧨娛樂-ngo⁵-log⁸\"><a href=\"#🧨娛樂-ngo⁵-log⁸\" class=\"headerlink\" title=\"🧨娛樂(ngo⁵ log⁸)\"></a>🧨娛樂(ngo⁵ log⁸)</h3><ol>\n<li>耍遊戲 /sng² iu⁵ hi³/ 玩遊戲</li>\n<li>䷀箭 /diong³ zin³/ 射箭</li>\n<li>䷀珠 /diong³ zu¹/ 打彈珠</li>\n<li>彈槍 /duan⁷ ciong¹/ 開槍</li>\n<li>跳索 /tiao³ soh⁴/ 跳繩</li>\n<li>踏孔 /dah⁸ kong²/ 捉迷藏</li>\n<li>泅水 /siu⁵ zui²/ 游泳</li>\n<li>釣魚 /dio³ hu⁵/</li>\n<li>掠魚 /liah⁸ hu⁵/ 抓魚</li>\n<li>行棋 /gian⁵ gi⁵/ 下棋</li>\n<li>放風箏 /bang³ hong¹ zêng¹/</li>\n<li>拍連炮 /pah⁴ liang⁵ pao³/ 放鞭炮</li>\n<li>扣人囝 /kob⁴ nang⁵ gian²/ 人囝，也叫公仔紙、洋畫，舊時供兒童玩樂用的紙牌。</li>\n<li>沃花 /ag⁴ hoi¹/ 澆花</li>\n<li>做戲 /zo³ hi³/ 演戲劇</li>\n</ol>\n<h3 id=\"⛩-神明-sing⁵-meng⁵\"><a href=\"#⛩-神明-sing⁵-meng⁵\" class=\"headerlink\" title=\"⛩ 神明(sing⁵ mêng⁵)\"></a>⛩ 神明(sing⁵ mêng⁵)</h3><ol>\n<li>天地父母 // 天地，原始信仰。</li>\n<li>月娘 // 月球，原始信仰。</li>\n<li>媽祖 // 原名林默，南海保護神，在甲子天后宮有供。</li>\n<li>七聖娘 // 又稱七星娘娘、七聖夫人，是織女神分化出的七位仙女，是兒童保護神。</li>\n<li>觀音娘 // 觀音菩薩</li>\n<li>慈悲娘 // 即普悲觀音，觀音菩薩化身之一（傳說觀音菩薩有三十三化身），普遍施給眾生慈悲。</li>\n<li>註生娘 // 全稱「大慈大悲救苦救難送子娘娘」，主管懷孕與生育。</li>\n<li>佛祖 // 釋迦牟尼佛，姓喬達摩，名悉達多，古印度思想家、教育家、宗教改革家，佛教的創始人。</li>\n<li>達摩祖師 // 南天竺人或波斯人，將佛教禪宗帶入中國，爲中國禪宗之開創者。</li>\n<li>元天上帝 // 玄武大帝，象徵北極星與二十八宿中的北宮玄武，爲統理北方之道教大神。</li>\n<li>水仙大帝 // 水仙尊王，海神之一，媽祖的從神之一。</li>\n<li>汾陽王帝 // 郭子儀，華州鄭縣（今陝西渭南市華州區）人，唐朝名將，平定安史之亂，封汾陽郡王。此人富貴壽考，權極一時，甲子天后宮媽祖廟有供之。</li>\n<li>王公 // 指隴尾王爺、王爺公，名鄒普勝，麻城花橋（今屬湖北）人，元末農民起義軍將領，陳友諒軍師。朱元璋建立明朝後流浪到甲子地區，爲甲子地區改造「風水」等，今甲子隴尾王爺廟有供之，大年初四在此求「落馬簽」。</li>\n<li>關公 // 關羽，河東郡解縣（今山西省運城市鹽湖區解州鎮）人，三國時期名將，與劉備、張飛桃園三結義。又稱伽藍老爺、伽藍尊者，是寺廟、道場守護神，也有稱之爲武財神。</li>\n<li>八仙公 // 傳說中的八位仙人，爲漢鍾離、張果老、韓湘子、鐵拐李、曹國舅、呂洞賓、藍采和、何仙姑八人。</li>\n<li>伯公 // 福德老爺、土地公。</li>\n<li>五穀公 // 神農大帝，相傳其發明耒耜，教民耕種五穀，並能以百草為民治病。農曆十月十五拜之。</li>\n<li>城隍公 // 古代城鎮保護神。</li>\n<li>皇帝公 // 南宋小皇帝趙昰，曾流亡到甲子待渡山。</li>\n<li>灶公 // 灶君，主掌廚房和飲食的神。</li>\n<li>百姓公 // 無主死者，集中掩埋於百姓公墓，稱爲百姓公(媽)，其中多喪於 1943 年的大飢荒，其時僅甲子一鎮亡者就近 2 萬人，慘絕。</li>\n<li>地主爺 // 住宅的守護靈。</li>\n<li>財神爺 // 常指陝西終南山的玄壇真君趙公明，也指關聖帝君關羽。</li>\n<li>三山國王 // 指現揭西縣河婆鎮北面的三座山——巾山、明山、獨山的三位山神。</li>\n</ol>\n<h2 id=\"風俗-hong¹-sioh⁸\"><a href=\"#風俗-hong¹-sioh⁸\" class=\"headerlink\" title=\"風俗(hong¹ sioh⁸)\"></a>風俗(hong¹ sioh⁸)</h2><ol>\n<li>大年初一：食齋菜（菠薐菜、粉絲、菜頭丸、豆腐乾）。</li>\n<li>人日(正月初七)：食七樣菜（厚合、蒜仔、芥藍、高麗菜、真珠菜、香菜、大菜芯）。</li>\n<li>元宵(正月十五)：食蔗。</li>\n<li>三月初三：食青草飯（雞屎藤、伸筋藤、苦刺心、臭草心、蠟裏葉、四方枝苦楝葉）。</li>\n<li>清明：食硬殼餅，掃墓掛紙。</li>\n<li>佛誕(四月初八)：食飯茶。</li>\n<li>端午：食梔粽、梔粿，洗午時水。</li>\n<li>七月初七：出花園。</li>\n<li>中秋：食月餅、芋頭、蔗。</li>\n<li>重陽(九月初九)：食雞湯。</li>\n<li>冬節：食冬節丸、羊肉。</li>\n<li>三十夜、廿九夜：食團圓飯、送壓腰錢（dêh⁴ io¹ zin⁵, 壓歲錢）。</li>\n</ol>\n<h2 id=\"歷史-leg⁸-su²\"><a href=\"#歷史-leg⁸-su²\" class=\"headerlink\" title=\"歷史(lêg⁸ su²)\"></a>歷史(lêg⁸ su²)</h2><ol>\n<li><p>甲子的名號是因爲港後有六十塊大石頭，應了干支紀年法一甲子的數目，故名。</p>\n</li>\n<li><p>漢文帝時曾派遣大臣陸賈（約公元前240年～公元前170年）到南越國，期間命令將士調查海岸線，到過甲子門。</p>\n</li>\n<li><p>三國時，吳侯孫權派遣將軍衛溫（？～231年）攻打福建、琉球和台灣（夷州），被風雨刮到甲子門。</p>\n</li>\n<li><p>南宋乾道五年(1169)，承奉郎致仕范有仁建順濟橋，橋從大膽山腳(今東宮社轄區)跨越瀛江到後庭（今甲東鎮雨亭村轄區）。</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2084.png\" alt=\"順濟橋（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）\"></p>\n</li>\n<li><p>宋嘉定甲申年(1224)，南宋承奉郎范良臣（范有仁之孫）登腹石山，因山對面可見甲子門奇石十八，屹立如人，遂刻「登瀛」二字於石，取十八學士登瀛洲之義。</p>\n</li>\n<li><p>1276 年，元兵攻陷南宋京城臨安，南宋擁立幼帝趙昰，從福州乘船經福建沿海入廣東，於冬十二月抵甲子門腹石山（後人爲紀念此事，更山名爲待渡山），范良臣給軍食三日，留帝像登瀛石上。</p>\n</li>\n<li><p>1277 年正月，漁民鄭復組織義兵509人乘船護送宋帝昺及隨臣去崖門。途中在現珠海橫琴島和澳門與元兵相遇，十六日宋室全軍覆滅，陸秀夫背幼帝昺投海自盡，鄭復等在激戰中全部士兵犧牲。</p>\n</li>\n<li><p>明永樂六年(1408)，順濟橋被拆。因「指揮花茂奉旨建甲子所，慮倭寇泊海易渡，拆之以為城基。」</p>\n</li>\n<li><p>明嘉靖三十九年(1560)，八萬洞資首黃啓薦扎寨惠來冰山頭（今邦山村）攻陷甲子所城，城中居民移至龍溪都（今惠來隆江以南）為逃避倭禍而暫居，該城之難民，慘遭殺害者甚眾，婦女被擄掠，有的全家罹難。</p>\n</li>\n<li><p>明隆慶二年(1568)，倭寇入侵甲子，千戶馬壽麻痹輕敵，城被攻陷，甲子和龍溪都一帶受害慘重。馬壽因失職罪下獄，死於獄中。</p>\n</li>\n<li><p>明隆慶四年(1570)，大旱，入春至初夏，天無滴雨，時又常遭賊寇蹂躪，田園拋荒，赤地千里，人民苦不堪言。</p>\n</li>\n<li><p>明隆慶四年(1570)九月，曾作倭寇嚮導之海寇楊老復，率賊眾攻陷甲子所城，擄掠男女上船，千戶董（佚名）戰死。次日，船遇颱風，賊與被擄者均溺死。</p>\n</li>\n<li><p>隆慶五年(1571)七月，海盜林道乾（又名林鳳，惠來人），於龍溪都一帶擄民劫捨，後聞朝廷將派兵進剿，遂遠循至甲子一帶搶劫，攻破新寨，劫擄李棠，其妻卓氏攜二子上船換夫歸，遂投海殉節。後朝廷封為「南海夫人」。</p>\n</li>\n<li><p>明萬曆二十六年(1598)，湯顯祖作《牡丹亭》，其第六齣中有詞句「榕樹梢頭訪古台，下看甲子海門開。越王歌舞今何在？時有鷓鴣飛去來。」</p>\n</li>\n<li><p>明萬曆二十八年(1600)八月二十三日，惠來及甲子一帶地震。</p>\n</li>\n<li><p>明萬曆三十三年(1605)三月，惠來及甲子一帶地震，七月初三至初七颱風暴雨，沿海田舍淹沒。</p>\n</li>\n<li><p>明萬曆三十五年(1607)，參將張萬紀、守備胡文烜在待渡山下建宋帝亭，即進食亭。</p>\n</li>\n<li><p>明萬曆四十二年(1620)春正月，海盜袁八老余黨林新老入甲子沃，把總金允武出戰死之。</p>\n</li>\n<li><p>明天啓七年(1627)三月，海寇入甲子門，守備葉台死亡。</p>\n</li>\n<li><p>明崇禎八年(1635)，海寇劉香攻陷甲子，擄去守道洪雲蒸。閩粵大兵突至，洪遇害，後劉香被擄伏誅。</p>\n</li>\n<li><p>明崇禎十四年(1641)十二月十四日夜，惠來地震，波及甲子。</p>\n</li>\n<li><p>民國32年(1943，癸未年)，甲子乃至整個海陸豐地區、潮汕地區遭遇大飢荒，時兵災、旱災、蝗災和瘟疫，餓殍遍野，僅甲子一鎮亡者就近 2 萬，佔當時鎮人口逾 45%。</p>\n</li>\n<li><p>1966年，中國大陸爆發文化大革命，「破四舊」。次年，有360年歷史的進食亭被炸毀！</p>\n</li>\n<li><p>2004年夏～2005年秋，甲子諸賢達捐資重建了進食亭。</p>\n</li>\n<li><p>2013年12月29日凌晨，廣東警方出動3000多人的警力對有「毒品村」之稱的甲西鎮博社村開展清繳行動，當天繳獲近3噸冰毒，抓捕180多名涉毒犯罪嫌疑人，原村委書記蔡東家名列其中。</p>\n</li>\n</ol>\n<h2 id=\"建置-giang³-di³\"><a href=\"#建置-giang³-di³\" class=\"headerlink\" title=\"建置(giang³ di³)\"></a>建置(giang³ di³)</h2><ol>\n<li><p>秦以前：屬南越國</p>\n</li>\n<li><p>秦：屬南海郡之博羅縣</p>\n</li>\n<li><p>漢：屬博羅縣</p>\n</li>\n<li><p>三國：屬博羅縣</p>\n</li>\n<li><p>晉：咸和六年（326）析博羅，置海豐縣，屬东官郡</p>\n</li>\n<li><p>宋：屬海豐縣</p>\n</li>\n<li><p>齊：屬海豐縣</p>\n</li>\n<li><p>梁：屬海豐縣</p>\n</li>\n<li><p>陳：屬海豐縣</p>\n</li>\n<li><p>隋：海豐縣屬循州</p>\n</li>\n<li><p>唐：海豐縣屬循州。武德五年（622）析置安陸縣；貞觀元年（627）復歸海豐縣。</p>\n</li>\n<li><p>五代：大寶元年（958）海豐縣属祯州。</p>\n</li>\n<li><p>宋：海豐縣屬祯州。天禧五年（1021）屬惠州。</p>\n</li>\n<li><p>元：海豐縣屬惠州路。</p>\n</li>\n<li><p>明：海豐縣屬惠州府。洪武二十七年(1394)，置甲子守禦千戸所，隸屬碣石衛。嘉靖三年（1524）海豐划出龍溪都、潮州府析出潮陽縣合置惠來縣。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2085.png\" alt=\"甲子所城範圍（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）\"></p>\n</li>\n<li><p>清：海豐縣屬惠州府。雍正九年（1731）海豐划出石帆（甲子屬石帆都）、吉康、坊廓3都置陸豐縣，並裁甲子所設立甲子巡檢司。</p>\n</li>\n<li><p>中華民國：陸豐縣屬潮循道。</p>\n</li>\n<li><p>中華人民共和國：1957年甲子鎮劃出甲東鎮、甲西鎮（取甲子之東、甲子之西義）；1958年鎮改爲人民公社，陸豐縣屬汕頭地區；1983年陸豐屬惠陽地區；1980年成立甲子鎮人民政府；1988年陸豐縣改屬汕尾市；1995年陸豐撤縣建市。</p>\n</li>\n</ol>\n<h2 id=\"拼音方案-peng³-im¹-huang¹-uan³\"><a href=\"#拼音方案-peng³-im¹-huang¹-uan³\" class=\"headerlink\" title=\"拼音方案(pêng³ im¹ huang¹ uan³)\"></a>拼音方案(pêng³ im¹ huang¹ uan³)</h2><h3 id=\"聲母表-sian¹-bho²-biao²\"><a href=\"#聲母表-sian¹-bho²-biao²\" class=\"headerlink\" title=\"聲母表(sian¹ bho² biao²)\"></a>聲母表(sian¹ bho² biao²)</h3><p>格式：<code>聲母 [國際音標] 例字</code></p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png\" alt></p>\n<h3 id=\"韻母表-ung¹-bho²-biao²\"><a href=\"#韻母表-ung¹-bho²-biao²\" class=\"headerlink\" title=\"韻母表(ung¹ bho² biao²)\"></a>韻母表(ung¹ bho² biao²)</h3><p>格式：<code>韻母 [國際音標] 例字 / 入聲韻 [國際音標] 例字</code></p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png\" alt></p>\n<h3 id=\"聲調-sian¹-diao⁶\"><a href=\"#聲調-sian¹-diao⁶\" class=\"headerlink\" title=\"聲調(sian¹ diao⁶)\"></a>聲調(sian¹ diao⁶)</h3><p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png\" alt></p>\n<h3 id=\"變調-biang³-diao⁶\"><a href=\"#變調-biang³-diao⁶\" class=\"headerlink\" title=\"變調(biang³ diao⁶)\"></a>變調(biang³ diao⁶)</h3><p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png\" alt></p>\n<h2 id=\"地圖-di⁷-dao⁵\"><a href=\"#地圖-di⁷-dao⁵\" class=\"headerlink\" title=\"地圖(di⁷ dao⁵)\"></a>地圖(di⁷ dao⁵)</h2><p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg\" alt=\"三甲地區（來源：騰訊地圖）\"></p>\n","site":{"data":{}},"excerpt":"<p><strong>!!! 注意：本辭表已收錄在典合網中進行維護，請轉閱：<a href=\"https://dicthub.cn/dicts/kahtsi-ue\">https://dicthub.cn/dicts/kahtsi-ue</a> !!!</strong></p>\n<h2 id=\"序言-su⁶-ngiang⁵\"><a href=\"#序言-su⁶-ngiang⁵\" class=\"headerlink\" title=\"序言(su⁶ ngiang⁵)\"></a>序言(su⁶ ngiang⁵)</h2><p>甲子鎮處在陸豐市，與惠來縣交界，語言文化上偏惠來（其實五百年前與惠來交界處同屬海豐縣）。甲子話是三甲地區（甲子、甲西、甲東三鎮）通行的語言，是甲子地方文化的重要載體之一。在學術上，甲子話被歸入粵東閩南語潮汕話片。 </p>\n<p>甲子話保留了好㩼中古乃至上古的漢語詞彙，比如：汝、諸母、新婦、箸、鼎、匏桸、雅、翹楚等等，還有極具地方特色的表達，比如：𨑨迌、走漆、理唔直、孤獨死相等等。然而無會寫甚至無會呾甲子話的人實在㩼，其中不少是受過義務教育其。 有鑑於此，本人草創此表，力求詞雅正且其音形義有所考據，權當拋磚引玉，歡迎大家儂做蜀討論改進。 </p>\n<p>另附本表主要參考資料：</p>\n<ol>\n<li>《潮汕方言詞考釋》（林倫倫）</li>\n<li>《海豐話分類辭表》（羅志海、鍾顯坤）</li>\n<li><a href=\"https://www.mogher.com/baike\">《潮典》</a> </li>\n<li>《新潮汕字典》（張曉山）</li>\n<li><a href=\"https://twblg.dict.edu.tw/holodict%5C_new/index.html\">《台灣閩南語常用詞辭典》</a> </li>\n<li><a href=\"https://xiaoxue.iis.sinica.edu.tw/minyu\">《小學堂閩語》</a></li>\n</ol>\n<p>阿華<br>2020年10月成稿，12月修訂</p>","more":"<h2 id=\"總表-zong²-biao²\"><a href=\"#總表-zong²-biao²\" class=\"headerlink\" title=\"總表(zong² biao²)\"></a>總表(zong² biao²)</h2><h3 id=\"🤵稱謂-ceng¹-ui⁶\"><a href=\"#🤵稱謂-ceng¹-ui⁶\" class=\"headerlink\" title=\"🤵稱謂(cêng¹ ui⁶)\"></a>🤵稱謂(cêng¹ ui⁶)</h3><ol>\n<li>我 /ua²/</li>\n<li>汝 /lu²/ 你</li>\n<li>伊 /i¹/ 他/她/它</li>\n<li>恁 /ning²/ 你們</li>\n<li>伊人 /i¹ nang⁷/ 他們</li>\n<li>家己 /ga¹ gi⁷/ 自己</li>\n<li>人家 /nang⁵ gê¹/ 別人</li>\n<li>諸夫 /za¹ bao¹/ 男人、男子</li>\n<li>諸母 /za¹ bhao²/ 女人</li>\n<li>諸娘 /zu¹ nion⁵/ 女子</li>\n<li>大人 /dua⁷ nang⁷/</li>\n<li>老人 /lao⁶ nang⁵/</li>\n<li>後生囝 /hao⁶ sên¹ gian²/ 年輕人</li>\n<li>孥囝 /nao⁵ gian²/、/nong⁶ gian²/ 小孩子</li>\n<li>諸夫囝 /za¹ bao¹ gian²/ 男孩子、兒子</li>\n<li>諸母囝 /za¹ bhao² gian²/ 女孩子、女兒</li>\n<li>諸娘囝 /zu¹ nion⁵ gian²/ 年輕女子</li>\n<li>阿公 /a¹ gong¹/ 爺爺</li>\n<li>阿媽 /a¹ ma²/ 奶奶</li>\n<li>媽人 /ma² nang⁵/ 婦女</li>\n<li>媽祖 /ma² zao²/ 原名林默，南海保護神</li>\n<li>爸爸 /ba¹ ba¹/ 爸爸</li>\n<li>媽媽 /ma¹ ma¹/</li>\n<li>父母 /bê⁶ bho²/</li>\n<li>兄 /hian¹/ 哥哥</li>\n<li>弟 /di⁶/ 弟弟</li>\n<li>姐 /zê²/ 姐姐</li>\n<li>妹 /moi⁷/ 妹妹</li>\n<li>姊妹 /zi² moi⁷/ 姐妹</li>\n<li>叔伯兄弟 /zêh⁴ bêh⁴ hian¹ di⁶/ 堂兄弟</li>\n<li>同沿 /dang⁵ iang⁵/ 同輩、同儕</li>\n<li>翁 /ang¹/ 丈夫</li>\n<li>母 /bhao²/ 妻子</li>\n<li>翁姐 /ang¹ zia²/ 夫妻</li>\n<li>新婦 /sing¹ bu⁶/ 媳婦</li>\n<li>大家 /dua⁷ gê¹/ 丈夫的母親、家婆</li>\n<li>大家官 /dua⁷ gê¹ guan¹/ 丈夫的父親、家公</li>\n<li>丈人 /dion⁶ nang⁵/ 岳父</li>\n<li>丈母 /dion⁶ m²/ 岳母</li>\n<li>妻舅 /ci¹ gu⁶/ 妻子的兄弟</li>\n<li>妻姨 /ci¹ i⁵/ 妻子的姐妹</li>\n<li>伯 /bêh⁴/ 伯伯</li>\n<li>姆 /m²/ 伯父的妻子</li>\n<li>叔 /zêh⁴/ 叔叔</li>\n<li>嬸 /sim²/ 叔父的妻子</li>\n<li>舅 /gu⁶/ 舅舅</li>\n<li>妗 /gim⁶/ 舅父的妻子</li>\n<li>姑 /gao¹/ 父親的姐妹、姑姑</li>\n<li>姑丈 /gou¹ dion⁶/ 姑姑的丈夫</li>\n<li>姨 /i⁵/ 母親的姐妹；母親</li>\n<li>姨丈 /i⁵ dion⁶/ 母親的姐妹的丈夫</li>\n<li>先生 /sing¹ sên¹/</li>\n<li>學生 /hag⁴ sêng¹/</li>\n<li>師父 /sai¹ bê⁶/ 工匠師傅</li>\n<li>師父 /su¹ hu⁶/ 出家人、和尚</li>\n<li>和尚 /hoi⁵ sion⁷/、/hua⁵ siang⁶/</li>\n<li>腳色 /ka¹ siao³/ 人手、幫手</li>\n<li>青暝囝 /cên¹ mên⁵ gian²/ 瞎子</li>\n</ol>\n<h3 id=\"🦶身體-sing¹-ti²\"><a href=\"#🦶身體-sing¹-ti²\" class=\"headerlink\" title=\"🦶身體(sing¹ ti²)\"></a>🦶身體(sing¹ ti²)</h3><ol>\n<li>頭毛 /tao⁵ mo⁵/ 頭髮</li>\n<li>頭神 /tao⁵ sing⁵/ 思維、記憶的能力</li>\n<li>頭碗骨 /tao⁵ uan² gug⁴/ 頭蓋骨</li>\n<li>旋 /zng⁷/ 頭髮呈漩渦狀的地方</li>\n<li>囟 /sing³/ 嬰兒頭頂骨未合縫處</li>\n<li>額頭 /hia² tao⁵/</li>\n<li>面 /ming⁷/ 臉</li>\n<li>頰溝 /gih⁴ gao¹/ 腮</li>\n<li>痣 /gi³/</li>\n<li>目 /mag⁸/ 眼睛</li>\n<li>目仁 /mag⁸ ring⁵/ 眼珠子</li>\n<li>目汁 /mag⁸ zab⁴/ 眼淚</li>\n<li>眉 /bhai⁵/ 眉毛</li>\n<li>耳 /hin⁶/ 耳朵</li>\n<li>耳空、耳孔 /hin⁶ kang¹/</li>\n<li>鼻 /pin⁷/ 鼻子</li>\n<li>鼻空、鼻孔 /pin⁷ kang¹/</li>\n<li>喙、嘴 /cui⁷/ 嘴巴</li>\n<li>䶕牙 /bha³ ghê⁵/ 龅牙</li>\n<li>涎 /nua⁶/ 唾液</li>\n<li>痰 /tam⁵/</li>\n<li>頷 /am⁶/ 脖子</li>\n<li>下頦 /ê⁶ hai⁵/ 下巴</li>\n<li>喙後肚 /cui⁷ ao⁶ dao²/ 下巴後面柔軟處</li>\n<li>鬚 /ciu¹/ 鬍鬚</li>\n<li>嚨喉 /na⁵ ao⁵/ 喉嚨</li>\n<li>手 /ciu²/</li>\n<li>正手 /zian³ ciu²/ 右手</li>\n<li>倒手 /do³ ciu²/ 左手</li>\n<li>胳囊跤 /goh⁴ lang⁵ ka¹/ 腋下</li>\n<li>手後曲 /ciu² ao⁶ kiao¹/ 手肘</li>\n<li>手模 /ciu² bhao⁵/ 手印</li>\n<li>腡 /lê⁵/ 圓形手指紋</li>\n<li>指頭公 /zain² tao⁵ gong¹/ 大拇指</li>\n<li>尾指囝 /bhoi² zain² gian²/ 小指</li>\n<li>胸 /hêng¹/</li>\n<li>嬭、奶 /nê¹/</li>\n<li>𩩍篱 /pian¹ li⁵/ 肋骨</li>\n<li>肚臍 /dao² zai⁵/</li>\n<li>背脊 /ba¹ ziah⁴/ 脊背</li>\n<li>腰 /io¹/</li>\n<li>跤、骹、腳 /ka¹/</li>\n<li>跤頭趺 /ka¹ tao⁵ u⁶/ 膝蓋</li>\n<li>大跤腿 /dua⁷ ka¹ tui²/ 大腿</li>\n<li>跤腸肚 /ka¹ dng⁵ dao²/ 小腿後部肌肉凸出處</li>\n<li>跤後蹬 /ka¹ ao⁶ dên¹/ 腳後跟</li>\n<li>跤盤 /ka¹ buan⁵/ 腳板</li>\n<li>跤目 /ka¹ mag⁸/ 腳踝</li>\n<li>跤指公 /ka¹ zain² gong¹/ 腳大拇趾</li>\n<li>跤液 /ka¹ sio²/ 腳汗</li>\n<li>卵 /lang⁶/ 陰莖、屌、勢</li>\n<li>卵鳥 /lang⁶ ziao²/ 陰莖、屌、勢</li>\n<li>卵脬 /lang⁶ pa¹/ 精囊</li>\n<li>卵核 /lang⁶ hug⁸/ 睪丸</li>\n<li>膣 /zi¹/ 女陰</li>\n<li>膣眉 /zi¹ bhai¹/ 女陰</li>\n<li>尻川 /ka¹ cng¹/ 屁股</li>\n<li>雞母皮 /goi¹ bho² poi⁵/ 雞皮疙瘩</li>\n<li>汗 /guan⁷/</li>\n<li>垢圿 /gao² goih⁴/ 體表污垢</li>\n</ol>\n<h3 id=\"🍵飲食-im²-ziah⁸\"><a href=\"#🍵飲食-im²-ziah⁸\" class=\"headerlink\" title=\"🍵飲食(im² ziah⁸)\"></a>🍵飲食(im² ziah⁸)</h3><ol>\n<li>食 /ziah⁸/ 吃、喝、抽</li>\n<li>祭 /zi³/ 狼吞虎咽；坐享其成</li>\n<li>咬 /ga⁶/</li>\n<li>哺 /bao⁷/ 咀嚼</li>\n<li>吞 /tung¹/</li>\n<li>舐 /zi⁶/ 舔</li>\n<li>含 /gam⁵/</li>\n<li>啜 /coih⁴/ 喝</li>\n<li>啉 /lim⁵/ 小口喝</li>\n<li>灌 /guang¹/ 大口喝</li>\n<li>吸 /kib⁴/</li>\n<li>搵 /ung³/ 蘸</li>\n<li>買鹹 /moi² giam⁵/ 買菜</li>\n<li>食透早 /ziah⁸ tao⁷ za²/ 吃早飯</li>\n<li>食眠起 /ziah⁸ mng⁵ ki²/ 吃早飯</li>\n<li>食晝 /ziah⁸ dao³/ 吃午飯</li>\n<li>食當晝 /ziah⁸ dêng¹ dao³/ 吃午飯</li>\n<li>食夜昏、食暝昏 /ziah⁸ mê⁵ hng⁵/ 吃晚飯</li>\n<li>飯 /bng⁷/</li>\n<li>米 /bhi²/</li>\n<li>糜 /moi⁵/ 粥</li>\n<li>飲 /am²/ 米湯</li>\n<li>配 /poi³/ 菜</li>\n<li>菜式 /cai³ sêg⁴/</li>\n<li>粿、餜 /goi²/</li>\n<li>丸、圓 /in⁵/</li>\n<li>油䭔 /iu⁵ zui¹/ 一種油炸食品</li>\n<li>汰米 /tua⁷ bhi²/ 淘米</li>\n<li>熬 /ngao⁵/ 長時間煮。～糜。</li>\n<li>煲 /bu⁵/ 煮、熬。～藥。</li>\n<li>潘 /png¹/ 餿水</li>\n<li>油 /iu⁵/</li>\n<li>鹽 /iam⁵/</li>\n<li>醋 /cao³/</li>\n<li>豉油 /si⁷ iu⁵/ 醬油</li>\n<li>豆汁 /dao⁷ zab⁴/ 醬油</li>\n<li>雞卵 /goi¹ nng⁶/ 雞蛋</li>\n<li>豬肉 /du¹ nêg⁸/</li>\n<li>澀肉 /siab⁴ nêg⁸/、/siab⁴ bhah⁴/ 瘦肉。澀，少油。</li>\n<li>肉脞 /nêg⁸ co³/ 肉末</li>\n<li>烏糖 /ao¹ tng⁵/ 紅糖、黑糖</li>\n<li>赤砂糖 /ciah⁴ sua¹ tng⁵/</li>\n<li>白砂糖 /bêh⁸ sua¹ tng⁵/</li>\n<li>薰 /hung¹/ 香菸</li>\n<li>茶 /dê⁵/</li>\n<li>酒 /ziu²/</li>\n<li>淖 /cioh⁴/ 粥稀</li>\n<li>凊 /cing³/ 飯菜涼了</li>\n<li>燒 /sio¹/ 熱呼呼</li>\n<li>燒烘燒烘 /sio¹ hang¹ sio¹ hang¹/ 熱呼呼</li>\n<li>芳 /pang¹/ 香</li>\n<li>甘 /gam¹/</li>\n<li>甜 /diam⁵/</li>\n<li>鹹 /giam⁵/</li>\n<li>薟 /hiam¹/ 辛辣</li>\n<li>䭕 /zian²/ 清淡</li>\n<li>臊 /co¹/ 腥</li>\n<li>臭 /cao³/</li>\n</ol>\n<h3 id=\"👔穿戴-ceng⁷-dua³\"><a href=\"#👔穿戴-ceng⁷-dua³\" class=\"headerlink\" title=\"👔穿戴(cêng⁷ dua³)\"></a>👔穿戴(cêng⁷ dua³)</h3><ol>\n<li>帽 /bho⁷/</li>\n<li>目鏡 /mah⁸ gian³/ 眼鏡</li>\n<li>圍巾 /ui⁵ ging¹/</li>\n<li>頷幔 /am⁶ muan¹/ 披肩</li>\n<li>衫褲 /san¹ kao³/ 衣服</li>\n<li>西裝 /sai¹ zuang¹/</li>\n<li>褸 /lao¹/ 大衣</li>\n<li>葵笠 /goi⁵ loih⁸/ 斗笠，竹編成的圓錐形大帽子。</li>\n<li>羊毛衫 /ion⁵ mo⁵ san¹/</li>\n<li>長䘼衫 /dng⁵ ng² san¹/ 長袖衫</li>\n<li>短䘼衫 /dê² ng² san¹/ 短袖衫</li>\n<li>貼身衫 /dah⁴ sing¹ san¹/ 貼身的上衣</li>\n<li>䘥囝 /gah⁴ gian²/ 無袖內衣</li>\n<li>底衫 /doi² san¹/ 內衣</li>\n<li>肚綰 /dao² guan⁶/ 肚兜</li>\n<li>長褲 /dng⁵ kao³/</li>\n<li>短褲 /dê² kao³/</li>\n<li>褲頭 /kao³ tao⁵/ 短褲、內褲</li>\n<li>褲橛 /kao³ goi²/ 短褲、內褲</li>\n<li>三角褲 /san¹ gag⁴ kao³/</li>\n<li>裙 /gung⁵/</li>\n<li>圍裙 /ui⁵ gung⁵/</li>\n<li>文胸 /bhung⁵ hêng¹/ 胸罩</li>\n<li>奶帕、嬭帕 /nê¹ pê³/ 胸罩</li>\n<li>皮帶 /poi⁵ dua³/</li>\n<li>手囊 /ciu² lob⁴/ 套袖</li>\n<li>手鐲 /ciu² sio²/</li>\n<li>鞋拖 /tua¹ oi⁵/ 拖鞋</li>\n<li>波鞋 /bo¹ oi⁵/ 球鞋。波，英文 ball 的音譯。</li>\n<li>釘鞋 /dêng¹ oi⁵/ 運動鞋的一種</li>\n<li>皮鞋 /poi⁵ oi⁵/</li>\n<li>高跟鞋 /gao¹ ging¹ oi⁵/</li>\n<li>靴 /hia¹/</li>\n<li>襪 /ghoih⁸/</li>\n<li>布 /bao³/</li>\n<li>襊 /zoi⁷/ 折痕</li>\n<li>頷領 /am⁶ nia²/ 領子</li>\n<li>褲袋 /kao³ dê⁷/ 位於褲子的口袋</li>\n<li>衫袋 /san¹ dê⁷/ 位於上衣的口袋</li>\n<li>暗袋 /am³ dê⁷/ 內側袋</li>\n<li>內裏 /lai⁶ li²/ 衣物不露出在外的裏層</li>\n<li>鈕 /liu²/ 鈕扣</li>\n<li>針 /zam¹/</li>\n<li>線 /suan³/</li>\n<li>拉鍊 /la¹ liang³/</li>\n<li>穿 /cêng⁷/</li>\n<li>褪 /tng⁷/ 脱</li>\n<li>紩 /tin⁷/ 縫</li>\n<li>補 /bao²/</li>\n<li>車衫褲 /cia¹ san¹ kao³/ 用縫紉機縫衣服</li>\n</ol>\n<h3 id=\"🎏物件-mi²-gian⁶、mian⁶\"><a href=\"#🎏物件-mi²-gian⁶、mian⁶\" class=\"headerlink\" title=\"🎏物件(mi² gian⁶、mian⁶)\"></a>🎏物件(mi² gian⁶、mian⁶)</h3><ol>\n<li><p>眠牀 /mng⁵ cng⁵/ 牀</p>\n</li>\n<li><p>鋪 /pao¹/ 牀</p>\n</li>\n<li><p>高低牀 /gao¹ di¹ cng⁵/ 上下鋪</p>\n</li>\n<li><p>蓆 /cioh⁸/</p>\n</li>\n<li><p>簟 /diam⁶/ 竹席</p>\n</li>\n<li><p>毡 /ziang¹/</p>\n</li>\n<li><p>被 /poi⁶/</p>\n</li>\n<li><p>棉被 /mi⁵ poi⁶/</p>\n</li>\n<li><p>被單 /poi⁶ duan¹/</p>\n</li>\n<li><p>枕頭 /zim² tao⁵/</p>\n</li>\n<li><p>枕頭囊 /zim² tao⁵ lob⁴/ 枕套</p>\n</li>\n<li><p>蠓罩、蚊罩 /mang² da³/ 蚊帳</p>\n</li>\n<li><p>蠓熏、蚊熏 /mang² hung¹/ 蚊香</p>\n</li>\n<li><p>窗罩 /têng¹ zao⁶/</p>\n</li>\n<li><p>口罩 /kao² zao⁶/</p>\n</li>\n<li><p>壁櫥 /biah⁴ du⁵/</p>\n</li>\n<li><p>椅 /in²/</p>\n</li>\n<li><p>桌 /doh⁴/</p>\n</li>\n<li><p>櫃 /gui⁷/</p>\n</li>\n<li><p>架 /gê³/</p>\n</li>\n<li><p>盒 /ab⁸/</p>\n</li>\n<li><p>籃 /na⁵/</p>\n</li>\n<li><p>瓶 /bang⁵/</p>\n</li>\n<li><p>鎖頭 /so² tao⁵/</p>\n</li>\n<li><p>鎖匙 /so² si⁵/ 鑰匙</p>\n</li>\n<li><p>葉疊 /iab² diab⁸/ 合葉</p>\n</li>\n<li><p>牙簽 /ghê⁵ ciam¹/</p>\n</li>\n<li><p>茶盤 /dê⁵ buan⁵/</p>\n</li>\n<li><p>茶壺 /dê⁵ hu⁵/</p>\n</li>\n<li><p>沖罐 /cong¹ guang³/ 茶壺</p>\n</li>\n<li><p>茶杯 /dê⁵ boi¹/</p>\n</li>\n<li><p>茶几 /dê⁵ gi²/</p>\n</li>\n<li><p>熏咬 /hung¹ ga⁶/ 煙斗</p>\n</li>\n<li><p>熏碟 /hung¹ dih⁸/ 煙灰缸</p>\n</li>\n<li><p>熱壺 /riag⁸ hu⁵/ 熱水瓶</p>\n</li>\n<li><p>熨斗 /ug⁴ dao²/</p>\n</li>\n<li><p>電燈 /diang⁶ dêng¹/</p>\n</li>\n<li><p>電泡 /diang⁶ pa⁶/</p>\n</li>\n<li><p>燈籠 /dêng¹ lang⁵/</p>\n</li>\n<li><p>燈火 /dêng¹ hoi²/ 電燈；燈光</p>\n</li>\n<li><p>風箏 /hong¹ zêng¹/</p>\n</li>\n<li><p>米甕 /bhi² ang³/ 米缸</p>\n</li>\n<li><p>水䀇 /zui² gao²/ 大型儲水器</p>\n</li>\n<li><p>跤桶 /ka¹ tang²/ 原指洗腳桶，後泛指洗衣盆，也可用來給小孩洗澡。</p>\n</li>\n<li><p>面盆 /ming⁷ png⁵/ 臉盆</p>\n</li>\n<li><p>瓠桸 /bu⁵ hia¹/ 水瓢</p>\n</li>\n<li><p>口㼦 /kao² gong²/ 漱口杯</p>\n</li>\n<li><p>碗 /uan²/</p>\n</li>\n<li><p>盤 /buan⁵/</p>\n</li>\n<li><p>碟 /dih⁸/</p>\n</li>\n<li><p>甌 /ao¹/ 大碗</p>\n</li>\n<li><p>箸 /du⁷/ 筷子</p>\n</li>\n<li><p>湯匙 /tng¹ si⁵/</p>\n</li>\n<li><p>調羹 /tiao⁵ gên¹/ 喝粥用的小勺子；湯匙</p>\n</li>\n<li><p>糜匙 /moi⁵ si⁵/ 舀粥用的勺子</p>\n</li>\n<li><p>飯匙 /bng⁷ si⁵/ 飯勺</p>\n</li>\n<li><p>飯添 /bng⁷ tin¹/ 飯勺</p>\n</li>\n<li><p>鼎 /dian²/ 鍋</p>\n</li>\n<li><p>鼎㧕 /dian² liu⁶/ 鍋鏟。㧕，存疑。</p>\n</li>\n<li><p>鼎蓋 /dian² kain³/ 鍋蓋</p>\n</li>\n<li><p>菜刀 /cai³ do¹/</p>\n</li>\n<li><p>瓜刨 /goi¹ pao⁵/</p>\n</li>\n<li><p>砧 /diam¹/</p>\n</li>\n<li><p>篩 /tai¹/</p>\n</li>\n<li><p>筅 /cain²/ 刷子</p>\n</li>\n<li><p>菜篩 /cai³ tai¹/</p>\n</li>\n<li><p>鉸刀 /ga¹ do¹/ 剪刀</p>\n</li>\n<li><p>螺絲批 /lo⁵ si¹ poi¹/ 螺絲刀</p>\n</li>\n<li><p>螺絲釘 /lo⁵ si¹ dêng¹/</p>\n</li>\n<li><p>旋螺絲 /suag⁸ lo⁵ si¹/ 擰螺絲</p>\n</li>\n<li><p>鐵錘 /tih⁴ tui⁵/</p>\n</li>\n<li><p>鉸夾 /ga¹ giab⁸/ 鉗子</p>\n</li>\n<li><p>扳手 /bang² ciu²/</p>\n</li>\n<li><p>電筆 /diang⁶ big⁴/ 測電筆</p>\n</li>\n<li><p>烏膠布 /ao¹ ga¹ bao³/ 電工膠帶</p>\n</li>\n<li><p>黏紙 /niam⁵ zua²/ 透明膠帶</p>\n</li>\n<li><p>布拖 /bao³ tu¹/ 拖把</p>\n</li>\n<li><p>掃帚 /sao³ siu²/ 掃把</p>\n</li>\n<li><p>畚斗 /bng³ dao²/ 垃圾鏟</p>\n</li>\n<li><p>畚箕 /bng³ gi¹/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled.png\" alt></p>\n</li>\n<li><p>梯 /tui¹/</p>\n</li>\n<li><p>吸石 /hiab⁴ zioh⁸/ 磁鐵、磁石</p>\n</li>\n<li><p>箠 /coi⁵/ 鞭子，可用來教育孩子。</p>\n</li>\n<li><p>火箠 /hoi² coi⁵/ 火筷子，夾爐中煤炭或通火的用具。</p>\n</li>\n<li><p>角畢 /gag⁴ big⁴/ 皮箱</p>\n</li>\n<li><p>樹嬭 /ciu⁷ ni⁵/ 橡皮、橡膠。嬭，樹之乳膠。</p>\n</li>\n<li><p>嬭漱 /ni⁵ ciu³/ 橡皮擦</p>\n</li>\n<li><p>毛筆 /mo⁵ big⁴/</p>\n</li>\n<li><p>鋼筆 /gng³ big⁴/</p>\n</li>\n<li><p>鉛筆 /iang⁵ big⁴/</p>\n</li>\n<li><p>鉛筆旋 /iang⁵ big⁴ suag⁸/ 卷筆刀、筆刨</p>\n</li>\n<li><p>模 /bhao⁵/ 模子</p>\n</li>\n<li><p>㨹 /zoi⁷/ 裂縫、痕跡</p>\n</li>\n<li><p>離衣機 /li⁵ i¹ gi¹/ 洗衣機</p>\n</li>\n</ol>\n<h3 id=\"🏠建築-giang³-dog⁴\"><a href=\"#🏠建築-giang³-dog⁴\" class=\"headerlink\" title=\"🏠建築(giang³ dog⁴)\"></a>🏠建築(giang³ dog⁴)</h3><ol>\n<li>茨、厝 /cu³/ 房子、家</li>\n<li>寮 /liao⁵/ 简陋小屋</li>\n<li>瓦茨 /hia⁶ cu³/ 瓦舍</li>\n<li>茨手 /cu³ ciu²/ 潮汕民居天井旁兩間廂房的名稱。</li>\n<li>兩間直 /no⁶ gain¹ dig⁸/ 傳統民居，兩房。</li>\n<li>獨腳靴 /dog⁸ ka¹ hia¹/ 傳統民居，一聽一茨手一房。</li>\n<li>下山虎 /hia⁶ suan¹ haon²/ 傳統民居，三合院，一廳二房二茨手。</li>\n<li>四點金 /si³ diam² gim¹/ 傳統民居，四合院，中軸爲前廳天井後聽，兩廳兩旁各有一房。</li>\n<li>竹竿茨 /dêg⁴ go¹ cu³/ 傳統民居，廚房客廳住房天井排列成狹長的空間，如竹竿。</li>\n<li>駟馬拖車 /si³ mê² tua¹ cia¹/ 傳統民居，在四點金上縱加一廳，橫加兩房，三廳二天丼。</li>\n<li>茨邊 /cu³ bin¹/ 鄰居</li>\n<li>起茨 /ki² cu³/ 蓋房子</li>\n<li>租茨 /zao¹ cu³/ 租房子</li>\n<li>搬茨 /buan⁵ cu³/ 搬家</li>\n<li>入新茨 /rib⁸ sing¹ cu³/ 搬入新家</li>\n<li>客廳 /kêh⁴ tian¹/</li>\n<li>客房 /kêh⁴ bang⁵/</li>\n<li>廚房 /dao⁵ bang⁵/</li>\n<li>浴室 /êg⁸ sig⁴/</li>\n<li>洗浴 /soi² êg⁸/ 洗澡</li>\n<li>廁所 /cê³ so²/</li>\n<li>屎壑 /sai² hag⁸/ 茅廁</li>\n<li>門窗 /mng⁵ têng¹/</li>\n<li>門閂 /mng⁵ cuan³/</li>\n<li>門楣 /mng⁵ bhai⁵/</li>\n<li>門橂 /mng⁵ dain⁶/ 門檻</li>\n<li>門扇後 /mng⁵ sin³ ao⁶/ 門後</li>\n<li>柱 /tiao⁶/</li>\n<li>牆壁 /cion⁵ biah⁴/</li>\n<li>庭、埕 /dian⁵/ 寬闊平地，可曬鹽、曬穀。</li>\n<li>临檐 /lim⁵ zin⁵/ 檐廊</li>\n<li>塗角 /tao⁵ gag⁴/ 土磚</li>\n<li>磚 /zng¹/</li>\n<li>廟 /bhio⁷/</li>\n<li>亭 /dêng⁵/</li>\n<li>祠堂 /su⁵ dng⁵/</li>\n<li>庵寺 /am¹ zin⁷/ 尼寺、僧寺的通稱。</li>\n<li>學校 /hag⁸ hao⁶/</li>\n<li>醫院 /ui¹ in⁷/</li>\n<li>鎮府 /ding³ hu²/ 鎮政府</li>\n<li>舖囝 /pao³ gian²/ 小賣部</li>\n</ol>\n<h3 id=\"🛵交通-gao¹-tong¹\"><a href=\"#🛵交通-gao¹-tong¹\" class=\"headerlink\" title=\"🛵交通(gao¹ tong¹)\"></a>🛵交通(gao¹ tong¹)</h3><ol>\n<li>腳車、跤車 /ka¹ cia¹/ 腳踏車、自行車</li>\n<li>摩托 /mo⁵ toh⁸/ 摩托，英文 motorcycle 音譯省。</li>\n<li>三輪車 /san¹ lung⁵ cia¹/</li>\n<li>的士 /dêg⁴ si⁶/ 計程車、出租車。的士，英文 taxi 音譯。</li>\n<li>小車 /sio² cia¹/ 小汽車</li>\n<li>麵包車 /min⁷ bao¹ cia¹/</li>\n<li>公交車 /gong¹ gao¹ cia¹/</li>\n<li>大巴 /dua⁷ ba¹/ 巴，英文 bus 音譯。</li>\n<li>車站 /cia¹ zam⁶/</li>\n<li>輪船 /lung⁵ zung⁵/</li>\n<li>龍船 /lêng⁵ zung⁵/ 龍舟</li>\n<li>火車 /hoi² cia¹/</li>\n<li>地鐵 /di⁷ tih⁴/</li>\n<li>高鐵 /gao¹ tih⁴/</li>\n<li>飛機 /boi¹ gi¹/</li>\n<li>行路 /gian⁵ lao⁷/ 走路</li>\n<li>踏腳車 /dah⁸ ka¹ cia¹/ 騎自行車</li>\n<li>駛車 /sai² cia¹/ 開車</li>\n<li>撐船 /tên¹ zung⁵/</li>\n<li>載客 /zai³ kêh⁴/</li>\n<li>拗䷀囝 /ao² gag⁴ gian²/ 摩托車司機。拗，載；扛。</li>\n<li>落車 /lo² cia¹/ 下車</li>\n<li>碼頭 /bhê² tao⁵/</li>\n<li>涵空、涵孔 /am⁵ kang¹/ 涵洞、涵管、地下水道</li>\n<li>橋墩 /gio⁵ dun¹/ 橋梁下面的圓柱狀基石</li>\n</ol>\n<h3 id=\"🐒眾生-zeng³-sen¹\"><a href=\"#🐒眾生-zeng³-sen¹\" class=\"headerlink\" title=\"🐒眾生(zêng³ sên¹)\"></a>🐒眾生(zêng³ sên¹)</h3><ol>\n<li><p>眾生 /zêng³ sên¹/ 牲畜</p>\n</li>\n<li><p>禽兽 /kim⁵ siu⁶/</p>\n</li>\n<li><p>害蟲 /hai⁷ tang⁵/</p>\n</li>\n<li><p>豬豭 /du¹ go¹/ 配種的公豬，也比喻好色之徒。</p>\n</li>\n<li><p>豬槽 /du¹ zo⁵/</p>\n</li>\n<li><p>羊牢 /ion⁵ lo⁵/</p>\n</li>\n<li><p>雞翁 /goi¹ ang¹/ 雄雞</p>\n</li>\n<li><p>雞母 /goi¹ bho²/ 母雞</p>\n</li>\n<li><p>鴨囝 /ah⁴ gian²/ 小鴨子</p>\n</li>\n<li><p>鵝 /gho⁵/</p>\n</li>\n<li><p>貓牯 /ngiao¹ gao²/ 母貓</p>\n</li>\n<li><p>鳥 /ziao²/</p>\n</li>\n<li><p>燕囝 /in³ gian²/ 小燕子</p>\n</li>\n<li><p>鶴 /hoh⁸/</p>\n</li>\n<li><p>鷹 /êng¹/</p>\n</li>\n<li><p>白鴿 /bêh⁸ gab⁴/</p>\n</li>\n<li><p>白鷺鷥 /bêh⁸ lao⁷ si¹/</p>\n</li>\n<li><p>鸚哥 /êng¹ go¹/ 鸚鵡</p>\n</li>\n<li><p>麻雀 /mua⁵ ziah⁴/</p>\n</li>\n<li><p>蝠婆 /big⁴ bo⁵/ 蝙蝠</p>\n</li>\n<li><p>蛇 /zua⁵/</p>\n</li>\n<li><p>雨傘節 /hao⁶ suan³ zag⁴/ 一种毒蛇。</p>\n</li>\n<li><p>狗母蛇 /gao² bho² zua⁵/ 蛇舅母、石龍子、四腳蛇，蜥蜴的一種</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%201.png\" alt></p>\n</li>\n<li><p>兩棲動物 /liang² ci¹ dong⁶ moih⁸/</p>\n</li>\n<li><p>蟾蜍 /ziong¹ zu⁵/</p>\n</li>\n<li><p>蛤虯 /gab⁴ giu²/ 青蛙</p>\n</li>\n<li><p>蛤蛙 /gab⁴ guai¹/ 蝌蚪</p>\n</li>\n<li><p>蚼蟻 /gao² hia⁶/ 螞蟻</p>\n</li>\n<li><p>白蟻 /bêh⁸ hia⁶/</p>\n</li>\n<li><p>蜜蜂 /bhig⁸ pang¹/</p>\n</li>\n<li><p>虎頭蜂 /hao² tao⁵ pang¹/ 黄蜂</p>\n</li>\n<li><p>龜 /gu¹/ 烏龜或像烏龜的昆蟲</p>\n</li>\n<li><p>金龜 /gim¹ gu¹/ 金龜子</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%202.png\" alt></p>\n</li>\n<li><p>鱉 /bih⁴/</p>\n</li>\n<li><p>土蚓 /dao⁶ ung²/ 蚯蚓</p>\n</li>\n<li><p>蜈蚣 /gê⁵ gang¹/</p>\n</li>\n<li><p>火金蛄 /hoi² gim¹ gao¹/ 螢火蟲</p>\n</li>\n<li><p>牛屎龜 /ghu⁵ sai² gu¹/ 屎殼郎、蜣螂</p>\n</li>\n<li><p>烏點龜 /ao¹ diam² gu¹/ 七星瓢蟲</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%203.png\" alt></p>\n</li>\n<li><p>紅新娘 /ang⁵ sing¹ nion⁵/ 紅姬緣椿象</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%204.png\" alt></p>\n</li>\n<li><p>山蛚 /sua¹ lê⁷/ 蟬；多指<a href=\"http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14818\">蚱蝉</a></p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%205.png\" alt></p>\n</li>\n<li><p>蝘悲蟬 /iam⁶ bi¹ sung⁵/ <a href=\"http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14817\">蟪蛄</a></p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/image.jpg\" alt=\"gahzi-oi-hung-lui-ci-biao/image.jpg\"></p>\n</li>\n<li><p>蟋蟀 /tih⁴ sug⁴/ 又稱烏龍。</p>\n</li>\n<li><p>䷀ // 螽斯、莎蟲、紡織娘、蟈蟈。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%206.png\" alt></p>\n</li>\n<li><p>草猴 // 稻蝦</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%207.png\" alt></p>\n</li>\n<li><p>䷀ // 金盾龜金花蟲</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%208.png\" alt></p>\n</li>\n<li><p>草蜢 /cao² mên²/ 螞蚱、蚱蜢。</p>\n</li>\n<li><p>螳螂、螳蜋 /tang⁵ lang⁵/</p>\n</li>\n<li><p>神螂 /sing⁵ lang⁵/ 壁虎，蜥蜴的一種。</p>\n</li>\n<li><p>蛤蚧蛇 /gab⁴ gai³ zua⁵/ 大壁虎，蜥蜴的一種。</p>\n</li>\n<li><p>土猴 /dao⁶ gao⁵/ 螻蛄</p>\n</li>\n<li><p>蝶、蜨 /iah⁸/ 蝴蝶</p>\n</li>\n<li><p>山螟 /suan¹ mê¹/ 蜻蜓</p>\n</li>\n<li><p>米龜 /bhi² gu¹/ 米象，蛀食稻穀、麥粒等米糧爲生。</p>\n</li>\n<li><p>蛀蟲 /zu³ tang⁵/</p>\n</li>\n<li><p>蛓毛蟲 /ci³ mo⁵ tang⁵/ 毛毛蟲</p>\n</li>\n<li><p>流鼻螺 /lao⁵ pin⁷ lê⁵/ 蝸牛</p>\n</li>\n<li><p>戶蠅 /hao⁵ sing⁵/ 蒼蠅</p>\n</li>\n<li><p>枯蠅 /gao¹ sing⁵/ 介殼蟲</p>\n</li>\n<li><p>蠓、蚊 /mang²/</p>\n</li>\n<li><p>蝨母 /sag⁴ bho²/ 蝨子</p>\n</li>\n<li><p>曱甴、虼蚻 /ga¹ zuah⁸/ 蟑螂</p>\n</li>\n<li><p>蜈蜞 /ghao⁵ ki⁵/ 水蛭，喜歡吸血人畜血液。</p>\n</li>\n</ol>\n<h3 id=\"🐳水產-zui²-suan²\"><a href=\"#🐳水產-zui²-suan²\" class=\"headerlink\" title=\"🐳水產(zui² suan²)\"></a>🐳水產(zui² suan²)</h3><ol>\n<li><p>䭕水魚 /zian² zui² hu⁵/ 淡水魚</p>\n</li>\n<li><p>鹹水魚 /giam⁵ zui² hu⁵/ 海水魚</p>\n</li>\n<li><p>刣魚 /tai⁵ hu⁵/ 宰魚</p>\n</li>\n<li><p>魚春 /hu⁵ cung¹/ 魚卵。屈大均《廣東新語》：「粵方言凡禽魚卵皆為春。唐時吳君貢魚春子，即魚子也。」 </p>\n</li>\n<li><p>魚鱗 /hu⁵ lang⁵/</p>\n</li>\n<li><p>魚鰾 /hu⁵ pio⁶/</p>\n</li>\n<li><p>魚鰓 /hu⁵ ci¹/</p>\n</li>\n<li><p>魚刺 /hu⁵ ci³/</p>\n</li>\n<li><p>鯁 /gên²/ 魚刺在喉</p>\n</li>\n<li><p>馬鮫 /mê² ga¹/</p>\n</li>\n<li><p>鯧 /cion¹/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%209.png\" alt></p>\n</li>\n<li><p>鰇魚 /riu⁵ hu⁵/ 魷魚</p>\n</li>\n<li><p>墨斗 /bhag⁸ dao²/、/mag⁸ dao²/ 墨魚</p>\n</li>\n<li><p>絲丁魚 /si¹ dêng⁶ hu⁵/ 龍頭魚、硬魚、橂魚(殿魚)、豆腐魚</p>\n</li>\n<li><p>狗母魚 // 蝦虎魚、狗魽仔魚、九甘魚</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2010.png\" alt></p>\n</li>\n<li><p>白目噯 /ain²/</p>\n</li>\n<li><p>狗母囝 // 身體透明，似魩仔鱼，有淡水和海水兩種</p>\n</li>\n<li><p>鰻魚 /muan⁵ hu⁵/</p>\n</li>\n<li><p>花仙魚 /hoi¹ siang¹ hu⁵/ 鮐魚</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2011.png\" alt></p>\n</li>\n<li><p>鸚哥魚 /êng¹ go¹ hu⁵/ 洛神項鰭魚、紅姑娘、紅新娘、碼頭魚</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2012.png\" alt></p>\n</li>\n<li><p>癩瘑魚 /na³ go¹ hu⁵/、/lai³ go¹ hu⁵/ 多齒蛇鯔，俗稱「那哥魚」，常用於製魚丸。</p>\n</li>\n<li><p>娘愛魚 /nion⁵ ain¹ hu⁵/ 泥猛魚、褐篮子鱼、臭肚鱼。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2013.png\" alt></p>\n</li>\n<li><p>䷀囝 /dêg⁸ gian²/ 又稱迪仔、綠鰭馬面魨、剝皮魚。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2014.png\" alt></p>\n</li>\n<li><p>䱛囝 /oig⁸ gian²/ 䱛仔、䱛魚</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2015.png\" alt></p>\n</li>\n<li><p>金龍䱛 /gim¹ lêng⁵ oig⁸/ 金龍魚、黃花魚，狀似䱛魚但個頭大、嘴圓、體黃。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2016.png\" alt></p>\n</li>\n<li><p>福壽魚 /hog⁴ siu⁶ hu⁵/ 羅非魚</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2017.png\" alt></p>\n</li>\n<li><p>鮭魚 /guai¹ hu⁵/ 河魨，俗稱「乖魚」，常指黃鰭東方魨。</p>\n</li>\n<li><p>黃牆 /ng⁵ cion⁵/ 黃鰭鯛</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2018.png\" alt></p>\n</li>\n<li><p>軟甘 /nng² gang¹/ 杜氏鰤、油甘，體側有黃色縱帶。 </p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2019.png\" alt></p>\n</li>\n<li><p>沙尖 /sua¹ ziam¹/ 多鱗鱚、沙鯪、北方稱沙丁魚。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2020.png\" alt></p>\n</li>\n<li><p>龍箭 /lang⁷ zin⁷/ 鯪魚 ，淡水魚，可用於做罐頭魚。</p>\n</li>\n<li><p>石剎 /zio² sag⁴/ 又稱烏雞，松鯛。</p>\n</li>\n<li><p>淡角魚 /dam⁶ gag⁴ hu⁵/ 鯒魚、辮子魚</p>\n</li>\n<li><p>烏魚 /ao¹ hu⁵/ 又稱烏頭，鯔魚。</p>\n</li>\n<li><p>烏前魚 /ao¹ zain⁵ hu⁵/</p>\n</li>\n<li><p>塗虱 /tao⁵ sag⁴/ 鬍子鯰</p>\n</li>\n<li><p>龍舌 /lêng⁵ zi²/ 龍利魚</p>\n</li>\n<li><p>巴浪 /ba¹ lang¹/ 藍圓鯵</p>\n</li>\n<li><p>鯇魚 /uang² hu⁵/ 草魚</p>\n</li>\n<li><p>姑魚 /gao¹ hu⁵/ 金色小沙丁魚</p>\n</li>\n<li><p>鯽魚 /zig⁴ hu⁵/</p>\n</li>\n<li><p>秋刀魚 /ciu¹ do¹ hu⁵/</p>\n</li>\n<li><p>紅目鰱 /ang⁵ mag⁸ liang⁵/ 紅目大眼鯛</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2021.png\" alt></p>\n</li>\n<li><p>田鱔 /cang⁵ cuan⁶/ 鱔魚、黃鱔</p>\n</li>\n<li><p>白帶魚 /bêh⁸ dua³ hu⁵/ 鞭魚、裙帶魚、海刀魚</p>\n</li>\n<li><p>鰐魚 /ngag⁸ hu⁵/</p>\n</li>\n<li><p>鯊魚 /sua¹ hu⁵/</p>\n</li>\n<li><p>鯨魚 /kêng⁵ hu⁵/</p>\n</li>\n<li><p>紅哥鯉 /ang⁵ go¹ li²/ 金線魚</p>\n</li>\n<li><p>蝦 /hê⁵/</p>\n</li>\n<li><p>蟹 /hoi⁶/</p>\n</li>\n<li><p>三目蠘 /san¹ mag⁸ cih⁸/ 紅星梭子蟹、三目蟹</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2022.png\" alt></p>\n</li>\n<li><p>海哲 /hai² diag⁴/</p>\n</li>\n<li><p>蠔、蚝、蚵 /o⁵/ 牡蠣</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2023.png\" alt></p>\n</li>\n<li><p>紅肉 /ang⁵ nê²/ 紅肉藍蛤</p>\n</li>\n<li><p>蚶 /ham¹/</p>\n</li>\n<li><p>蜆 /hain⁶/</p>\n</li>\n<li><p>青匙 /cên¹ si⁵/ 綠殼菜蛤、翡翠貽貝</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2024.png\" alt></p>\n</li>\n<li><p>花蛤 /hoi¹ gab⁴/ 菲律賓簾蛤、花甲</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2025.png\" alt></p>\n</li>\n<li><p>車白 /cia¹ bêh⁸/ 文蛤，邊緣弧度較花蛤圓。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2026.png\" alt></p>\n</li>\n<li><p>青蛤 /cên¹ gab⁴/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2027.png\" alt></p>\n</li>\n<li><p>毛蚶 /mo⁵ ham¹/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2028.png\" alt></p>\n</li>\n<li><p>薄殼 /bo² kag⁴/ 尋氏肌蛤、海蛔、海瓜子</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2029.png\" alt></p>\n</li>\n<li><p>指甲螳 /zain² gah⁴ tang⁵/ 又稱指甲蚌hong²，蟶sêng³子。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2030.png\" alt></p>\n</li>\n<li><p>田螺 /cang⁵ lê⁵/</p>\n</li>\n<li><p>尖螺 /ziang¹ lê⁵/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2031.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"🌾-蔬菜-so¹-cai³\"><a href=\"#🌾-蔬菜-so¹-cai³\" class=\"headerlink\" title=\"🌾 蔬菜(so¹ cai³)\"></a>🌾 蔬菜(so¹ cai³)</h3><ol>\n<li><p>五穀 /ngao⁶ gag⁴/</p>\n</li>\n<li><p>稻 /diu⁶/</p>\n</li>\n<li><p>粟 /cêg⁴/ 稻粒</p>\n</li>\n<li><p>麥 /mê²/</p>\n</li>\n<li><p>秫米 /zu² bhi²/ 糯米</p>\n</li>\n<li><p>薏米 /in³ bhi²/</p>\n</li>\n<li><p>薏仁 /in³ ring⁵/ 玉米</p>\n</li>\n<li><p>蕃薯 /huang¹ zu⁵/、/hang¹ zu⁵/</p>\n</li>\n<li><p>馬鈴薯 /mê² lêng¹ zu⁵/ 土豆</p>\n</li>\n<li><p>黃豆 /ng⁵ dao⁷/ 大豆、菽</p>\n</li>\n<li><p>綠豆 /lê² dao⁷/</p>\n</li>\n<li><p>烏豆 /ao¹ dao⁷/ 黑豆</p>\n</li>\n<li><p>赤豆 /ciah⁴ dao⁷/ 紅小豆</p>\n</li>\n<li><p>荷目豆 /ho⁵ mag⁸ dao⁷/ 荷蘭豆、豌豆</p>\n</li>\n<li><p>地豆 /di⁷ dao⁷/ 花生</p>\n</li>\n<li><p>豆仁 /dao⁷ ring⁵/ 花生米</p>\n</li>\n<li><p>油麻 /iu⁵ mua⁵/ 芝麻</p>\n</li>\n<li><p>菜豆 /cai³ dao⁷/ 常指四季豆</p>\n</li>\n<li><p>茄 /gio⁵/</p>\n</li>\n<li><p>苦瓜 /kao² goi¹/</p>\n</li>\n<li><p>角瓜 /gag⁴ goi¹/ 稜角絲瓜</p>\n</li>\n<li><p>秋瓜 /ciu¹ goi¹/ 絲瓜</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2032.png\" alt></p>\n</li>\n<li><p>嬭瓜、奶瓜 /nê¹ goi¹/ 木瓜</p>\n</li>\n<li><p>蓮藕 /nain⁵ nao⁶/</p>\n</li>\n<li><p>菠薐菜 /boi¹ lêng⁵ cai³/ 菠菜</p>\n</li>\n<li><p>蕹菜 /êng³ cai³/ 空心菜</p>\n</li>\n<li><p>春菜 /cung¹ cai³/ 長葉芥菜</p>\n</li>\n<li><p>菜花 /cai³ hoi¹/ 花椰菜</p>\n</li>\n<li><p>芥菜 /gua³ cai³/ 大芥菜、包心芥菜</p>\n</li>\n<li><p>芥藍 /gêg⁴ na⁵/</p>\n</li>\n<li><p>菜頭 /cai³ tao⁵/ 白蘿蔔</p>\n</li>\n<li><p>紅菜頭 /ang⁵ cai³ tao⁵/ 紅蘿蔔</p>\n</li>\n<li><p>薺蔥、錢蔥 /zin⁵ cang¹/ 荸薺</p>\n</li>\n<li><p>韭菜 /gu² cai³/</p>\n</li>\n<li><p>芫荽 /iang¹ sui¹/ 香菜</p>\n</li>\n<li><p>芳菜 /pang¹ cai³/</p>\n</li>\n<li><p>厚合 /gao⁶ hah⁸/ 厚皮菜、莙薘菜、葉用甜菜</p>\n</li>\n<li><p>九層塔 /gao² zang⁵ tah³/ 金不換、羅勒</p>\n</li>\n<li><p>萵菜 /oi¹ cai³/ 皺葉萵苣、生菜</p>\n</li>\n<li><p>劍菜 /giam³ cai³/ 油麥菜</p>\n</li>\n<li><p>上海青 /siang⁶ hai² cên¹/ 青菜的一種</p>\n</li>\n<li><p>芹菜 /king⁵ cai³/</p>\n</li>\n<li><p>津白 /gian¹ bêh⁸/ 又稱紹菜、黃芽白，天津盛產，是大白菜的一種。以下是大白菜的不同品種。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2033.png\" alt></p>\n<p>天津大白菜</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2034.png\" alt></p>\n<p>大白菜</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2035.png\" alt></p>\n<p>娃娃菜</p>\n</li>\n<li><p>高麗菜 /go¹ lê⁵ cai³/ 捲心菜、包菜、結球甘藍</p>\n</li>\n<li><p>菜花 /cai³ hoi¹/ 花椰菜</p>\n</li>\n<li><p>茼蒿 /dang⁵ o¹/</p>\n</li>\n<li><p>枸杞菜 /gao² gi² cai³/</p>\n</li>\n<li><p>真珠菜 /zing¹ zu¹ cai³/ 珍珠花菜、白苞蒿</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2036.png\" alt></p>\n</li>\n<li><p>薟椒 /hiam¹ tsio¹/ 辣椒</p>\n</li>\n<li><p>生果 /cên¹ goi²/ 水果</p>\n</li>\n<li><p>荔果 /nai⁶ goi²/ 荔枝</p>\n</li>\n<li><p>龍眼 /nging⁵ ain²/</p>\n</li>\n<li><p>桑垂 /siong¹ sui⁵/ 桑葚</p>\n</li>\n<li><p>草莓 /cao² bhoi⁵/</p>\n</li>\n<li><p>刺菠 /ci³ bo¹/ 蛇莓、覆盆子</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2037.png\" alt></p>\n</li>\n<li><p>弓蕉 /gêng¹ zio¹/ 香蕉</p>\n</li>\n<li><p>米蕉 /bhi² zio¹/</p>\n</li>\n<li><p>鳥梨 /ziao² lai⁵/</p>\n</li>\n<li><p>檨 /suain⁷/ 芒果</p>\n</li>\n<li><p>菝囝 /bag⁸ gian²/ 番石榴</p>\n</li>\n<li><p>西瓜 /si¹ goi¹/</p>\n</li>\n<li><p>香櫞 /hion¹ ng⁵/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2038.png\" alt></p>\n</li>\n<li><p>柚 /iu⁷/</p>\n</li>\n<li><p>柑 /gan¹/ 柑橘</p>\n</li>\n<li><p>桔 /gig⁴/</p>\n</li>\n<li><p>橙 /cêng⁵/</p>\n</li>\n<li><p>菠蘿 /bo¹ lo⁵/</p>\n</li>\n<li><p>油甘 /iu⁵ gam¹/ 餘甘果，先苦後甜，齒留餘甘。</p>\n</li>\n<li><p>番茄 /huang¹ gio⁵/</p>\n</li>\n<li><p>青竹梅 /cên¹ dêg⁴ bhoi⁵/</p>\n</li>\n<li><p>李 /li²/</p>\n</li>\n<li><p>棗 /zo²/</p>\n</li>\n<li><p>蔗 /zia³/ 甘蔗</p>\n</li>\n</ol>\n<h3 id=\"🌿草藥-cao²-ioh⁸\"><a href=\"#🌿草藥-cao²-ioh⁸\" class=\"headerlink\" title=\"🌿草藥 /cao² ioh⁸/\"></a>🌿草藥 /cao² ioh⁸/</h3><ol>\n<li><p>艾 /hia³/ 艾草 </p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2039.png\" alt></p>\n</li>\n<li><p>草粿草 /cao² goi² cao²/ 仙草</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2040.png\" alt></p>\n</li>\n<li><p>策草 /cêg⁴ cao²/ 又稱抹(bhuah⁴)草、廣防風、防風草，甲子地區神位常年插此草。策 ，大概是指其像馬鞭。</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2041.png\" alt></p>\n</li>\n<li><p>青菭 /cên¹ ti⁵/ 青苔</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2042.png\" alt></p>\n</li>\n<li><p>薄荷 /bo⁵ ho³/、/bon⁵ hon³/</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2043.png\" alt></p>\n</li>\n<li><p>金銀花 /gim¹ nging⁵ hoi¹/</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2044.png\" alt></p>\n</li>\n<li><p>午時花 /ngao² si⁵ hoi¹/</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2045.png\" alt></p>\n</li>\n<li><p>四季春 /si³ kui³ cung¹/ 四季春花</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2046.png\" alt></p>\n</li>\n<li><p>葉下紅 /hio² ê⁶ ang⁵/ 一點紅</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2047.png\" alt></p>\n</li>\n<li><p>臭草花 /cao³ cao² hoi¹/ 五色梅、馬纓丹</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2048.png\" alt></p>\n</li>\n<li><p>飛天蜈蚣 /boi¹ tin¹ ghê⁵ gang¹/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2049.png\" alt></p>\n</li>\n<li><p>金雞脫殼 /gim¹ goi¹ tug⁴ kag⁴/</p>\n</li>\n<li><p>路跤菊 /lao⁷ ka¹ gêg⁴/ 路邊菊</p>\n</li>\n<li><p>臘裏葉 /lah⁸ li² hioh⁸/ 金邊紅桑</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2050.png\" alt></p>\n</li>\n<li><p>芒囝筍 /mang⁵ gian² sung²/ 芒草的嫩芽</p>\n</li>\n<li><p>竹菜 /dêg⁴ cai³/ 竹葉草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2051.png\" alt></p>\n</li>\n<li><p>葛菜 /guah⁴ cai³/ 野葛菜，可食。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2052.png\" alt></p>\n</li>\n<li><p>烏規菜 /ao¹ gui¹ cai³/ 龍葵</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2053.png\" alt></p>\n</li>\n<li><p>豬母菜 /du¹ bho² cai³/ 馬齒莧</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2054.png\" alt></p>\n</li>\n<li><p>刺莧 /ci³ hain⁷/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2055.png\" alt></p>\n</li>\n<li><p>苦刺 /kao² ci³/ 白簕</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2056.png\" alt></p>\n</li>\n<li><p>苦草 /kao² cao²/ 豨薟草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2057.png\" alt></p>\n</li>\n<li><p>兩公根 /liang² gong¹ ging¹/ 崩大碗</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2058.png\" alt></p>\n</li>\n<li><p>鋪地錦 /pao¹ di⁷ gim²/ 滿天星</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2059.png\" alt></p>\n</li>\n<li><p>雞屎藤 /goi¹ sai² ding⁵/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2060.png\" alt></p>\n</li>\n<li><p>伸筋藤 /cung¹ ging¹ ding⁵/ 蔓九節</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2061.png\" alt></p>\n</li>\n<li><p>無頭藤 /bho⁵ tao⁵ ding⁵/ 寄生於其他植物之上</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2062.png\" alt></p>\n</li>\n<li><p>酒甕囝 /ziu² ang³ gian²/</p>\n</li>\n<li><p>盐酸鸡囝 /iam⁵ sng¹ goi¹ gian²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2063.png\" alt></p>\n</li>\n<li><p>見笑草 /giang³ siao³ cao²/ 含羞草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2064.png\" alt></p>\n</li>\n<li><p>燈籠草 /dêng¹ lang⁵ cao²/ 其果子稱爲「姑娘果」</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2065.png\" alt></p>\n</li>\n<li><p>車前草 /cia¹ zain⁵ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2066.png\" alt></p>\n</li>\n<li><p>馬鞭草 /bhê² bin¹ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2067.png\" alt></p>\n</li>\n<li><p>蟋蟀草 /tig⁴ sug⁴ cao²/ 烏龍草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2068.png\" alt></p>\n</li>\n<li><p>蒲公英 /pu⁵ gong¹ êng¹/</p>\n</li>\n<li><p>鸭舌草 /ah³ zih⁸ cao²/ 苦菜</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2069.png\" alt></p>\n</li>\n<li><p>魚腥草 /hu⁵ co³ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2070.png\" alt></p>\n</li>\n<li><p>益母草 /iah⁴ bho² cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2071.png\" alt></p>\n</li>\n<li><p>龍膽草 /lêng⁵ dan² cao²/ 苦地膽草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2072.png\" alt></p>\n</li>\n<li><p>奶汁草 /nê¹ zab⁴ cao²/ 乳汁草，草折斷會有白色液體流出。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2073.png\" alt></p>\n</li>\n<li><p>虎耳草 /haon² hin⁶ cao³/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2074.png\" alt></p>\n</li>\n<li><p>大號奶汁草 /dua⁷ ho⁷ nê¹ zab⁴ cao³/ 蠔割草、飛揚草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2075.png\" alt></p>\n</li>\n<li><p>貓毛兒 /ngiao¹ mo⁵ ri⁵/ 金絲草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2076.png\" alt></p>\n</li>\n<li><p>貓鬚草 /ngiao¹ ciu¹ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2077.png\" alt></p>\n</li>\n<li><p>鹅囝香 /gho⁵ gian² hiang¹/ 鹅不食草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2078.png\" alt></p>\n</li>\n<li><p>白花蛇舌草 /bêh⁸ hoi¹ zua⁵ zih⁸ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2079.png\" alt></p>\n</li>\n<li><p>白花蟛蜞草 /bêh⁸ hoi¹ pen⁵ ki⁵ cao²/、/bêh⁸ hoi¹ mua⁵ ki⁵ cao²/</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2080.png\" alt></p>\n</li>\n<li><p>四方枝苦楝 /si³ bang¹ gi¹ kao² nai⁷/ 鬼針草</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2081.png\" alt></p>\n</li>\n<li><p>苦楝 /kao² nai⁷/ 苦楝樹</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2082.png\" alt></p>\n</li>\n<li><p>挨礱被哺 /oi⁵ lang⁵ bi⁶ bu⁶/ 磨盤草、磨礱草、挨礱地堵，其果實似磨盤和礱。礱，磨谷農具。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2083.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"🏮時節-si⁵-zoih⁴\"><a href=\"#🏮時節-si⁵-zoih⁴\" class=\"headerlink\" title=\"🏮時節(si⁵ zoih⁴)\"></a>🏮時節(si⁵ zoih⁴)</h3><ol>\n<li>今年 /gim¹ ni⁵/</li>\n<li>舊年 /gu⁷ ni⁵/ 去年</li>\n<li>前年 /zain³ ni⁵/、/zung³ ni⁵/</li>\n<li>下年 /ê⁶ ni⁵/ 明年</li>\n<li>熱天時 /ruah⁸ tin¹ si⁵/ 夏天</li>\n<li>寒天時 /guan⁵ tin¹ si⁵/ 冬天</li>\n<li>凝天時 /ngang⁵ tin¹ si⁵/ 冬天</li>\n<li>春夏秋冬 /cung¹ hê⁶ ciu¹ dang¹/</li>\n<li>老歷 /lao⁶ lê²/ 農曆</li>\n<li>新曆 /sing¹ lê²/ 公曆</li>\n<li>今日 /gim¹ rig⁸/</li>\n<li>明日 /mêng⁵ rig⁸/</li>\n<li>今旦日 /gian² rig⁸/ 今天</li>\n<li>明旦日 /man³ rig⁸/ 明天</li>\n<li>明眠起 /ma³ mng⁵ ki²/ 明天</li>\n<li>昨日 /za¹ rig⁸/</li>\n<li>前日 /zain⁵ rig⁸/、/zoh⁸ rig⁸/</li>\n<li>後日 /ao⁶ rig⁸/</li>\n<li>大前日 /dua⁷ zain⁵ rig⁸/、/dua⁷ zoh⁸ rig⁸/</li>\n<li>大後日 /dua⁷ ao⁶ rig⁸/</li>\n<li>天光 /tin¹ gng¹/ 天亮</li>\n<li>透早 /tao³ za²/ 黎明</li>\n<li>眠起 /mng⁵ ki²/ 早晨</li>\n<li>日時 /rig⁸ si⁷/ 白天</li>\n<li>早晝 /za² dao³/ 上午</li>\n<li>中晝 /dêng¹ dao³/ 中午</li>\n<li>中晝時 /dêng¹ dao³ si⁵/ 中午</li>\n<li>下晝 /ê⁶ dao³/ 下午</li>\n<li>下旰 /ê⁶ gua³/ 下午</li>\n<li>暗頭 /am³ tao⁵/ 傍晚</li>\n<li>暗頭時 /am³ tao⁵ si⁵/ 傍晚</li>\n<li>下昏 /ê⁶ hng⁵/ 晚上</li>\n<li>下昏時 /ê⁶ hng⁵ si⁵/、/êng² si⁵/ 晚上</li>\n<li>下昏囝 /êng² gian²/ 晚上</li>\n<li>暗時 /am³ si⁷/ 晚上</li>\n<li>暝時、夜時 /mê⁵ si⁷/ 晚上</li>\n<li>暝昏、夜昏 /mê⁵ hng⁵/ 晚上</li>\n<li>暝昏時、夜昏時 /mê⁵ hng⁵ si⁵/、/mêng² si⁵/ 晚上</li>\n<li>暝昏囝 /mêng² gian²/ 晚上</li>\n<li>半暝、半夜 /buan³ mê⁵/</li>\n<li>時分秒 /si⁵ hung⁵ miao²/</li>\n<li>個字 /gai⁵ ri⁷/ 五分鐘</li>\n<li>兩個字久 /no⁶ gai⁵ ri⁷ gu²/ 十分鐘</li>\n<li>頭前 /tao⁵ zain⁵/ 之前</li>\n<li>頭陣 /tao⁵ zung⁵/ 剛才</li>\n<li>下 /ê⁶ miag⁸/、/ê⁶ mig⁸/ 剛才</li>\n<li>一頃 /zêg⁸ kuang³/ 一會兒</li>\n<li>一頃頭 /zêg⁸ kuang³ tao⁵/ 一下子</li>\n<li>煞尾 /suah⁴ bhoi²/ 最後</li>\n<li>今 /dan¹/ 現在</li>\n<li>逐日 /dag⁸ rig⁸/ 每天</li>\n<li>逐暝 /dag⁸ mê⁵/ 每晚</li>\n<li>通日 /tang³ rig⁸/ 整天</li>\n<li>半日 /buan³ rig⁸/</li>\n<li>隔日 /gêh⁴ rig⁸/</li>\n<li>隔暝、隔夜 /gêh⁴ mê⁵/</li>\n<li>別日 /bag⁸ rig⁸/ 改天</li>\n<li>即時 /ziag⁴ si⁵/ 立刻、馬上</li>\n<li>平常時 /pêng⁵ sion⁵ si⁵/ 平時</li>\n<li>一日通通 /zêg⁸ rig⁸ tang³ tang³/ 一整天</li>\n<li>七早八早 /cig⁴ za² boih⁴ za²/ 一大早</li>\n<li>七早蒙流 /cig⁴ za² mo⁵ liu⁵/ 一大早</li>\n<li>烏暗天地 /ao¹ am³ tin¹ di¹/ 天昏地暗</li>\n<li>立春 /lib⁸ cung¹/</li>\n<li>雨水 /u² sui²/</li>\n<li>驚蟄 /gêng¹ dêg8/</li>\n<li>春分 /cung¹ hung¹/</li>\n<li>清明 /cêng¹ mêng⁵/</li>\n<li>谷雨 /gog⁴ u²/</li>\n<li>立夏 /lib⁸ hê⁶/</li>\n<li>小滿 /sio² muan²/</li>\n<li>芒種 /mang⁵ zêng²/</li>\n<li>夏至 /hê⁶ zi³/</li>\n<li>小暑 /siao² su²/</li>\n<li>大暑 /dai⁶ su²/</li>\n<li>立秋 /lib⁸ ciu¹/</li>\n<li>處暑 /cu³ su²/</li>\n<li>白露 /bêh⁸ lao⁷/</li>\n<li>秋分 /ciu¹ hung¹/</li>\n<li>寒露 /guan⁵ lao⁷/</li>\n<li>霜降 /sang¹ gang³/</li>\n<li>立冬 /lib⁸ dang¹/</li>\n<li>小雪 /siao² soh⁴/</li>\n<li>大雪 /dai⁶ soh⁴/</li>\n<li>冬至 /dang¹ zi³/</li>\n<li>小寒 /siao² hang⁵/</li>\n<li>大寒 /dai⁶ hang⁵/</li>\n<li>時年八節 /si⁵ ni⁵ boih⁴ zoih⁴/ 一年四季八個節，最早的八節指立春、春分、立夏、夏至、立秋、秋分、立冬和冬至。而在甲子時年八節指元宵、春分、清明、五月節、七月半、秋分、八月半、冬節，過此八節要拜祖，除春分、秋分外的節還需要拜神。<ul>\n<li>四時，四季、春夏秋冬。</li>\n<li>年，甲骨文象人負禾之形，會穀物豐收之意，古時禾穀一年一熟，於是「年」被（引申）用作周年之年。【爾雅•釋天】夏曰歲，商曰祀，周日年，唐虞曰載。古時一度流行歲星（即木星、朱比特星，公轉週期爲 398.88 天）紀年，故一年又稱一歲。</li>\n<li>時年，一年四季。</li>\n<li>節，中國曆法把一年分為二十四段，每段的開始即爲節。早期只有春分、秋分、夏至、冬至四節，後又加入立春、立夏、立秋、立冬，形成八節，再來後逐漸形成了二十四節。「節」早期是天文曆法上的概念，與氣候相關，後又逐漸加入了紀念或慶祝的元素。</li>\n</ul>\n</li>\n<li>元宵節 /nguang⁵ siao¹ zoih⁴/</li>\n<li>公忌節 /gong¹ gi⁷ zoih⁴/ 春分和秋分，祭拜先祖，但不拜神。</li>\n<li>清明節 /cêng¹ mêng⁵ zoih⁴/</li>\n<li>五月節 /ngao⁶ ghoih⁸ zoih⁴/ 端午節</li>\n<li>七月半 /cig⁴ ghoih⁸ buan³/ 中元節、鬼節</li>\n<li>八月半 /boih⁴ ghoih⁸ buan³/ 中秋節</li>\n<li>冬節 /dang¹ zoih⁴/ 冬至節的簡稱。</li>\n<li>廿九暝、廿九夜 /rig⁸ gao² mê⁵/ 除夕（小月）</li>\n<li>三十暝、三十夜 /san¹ zab⁸ mê⁵/ 除夕（大月）</li>\n<li>春節 /cung¹ zoih⁴/</li>\n<li>重陽 /ciang⁵ iang⁵/、/dêng⁵ iang⁵/</li>\n<li>國慶節 /gog⁴ kêng³ zoih⁴/</li>\n<li>勞動節 /lao⁵ dong⁶ zoih⁴/</li>\n<li>婦女節 /hu⁶ nng² zoih⁴/</li>\n<li>兒童節 /ri⁵ tong⁵ zoih⁴/</li>\n<li>教師節 /ga³ su¹ zoih⁴/</li>\n<li>做節 /zo³ zoih⁴/ 過節日</li>\n<li>做壽 /zo³ siu⁶/ 過壽辰</li>\n<li>做生日 /zo³ sên¹ rig⁸/ 過生日</li>\n<li>公忌 /gong¹ gi⁷/ 先祖忌日</li>\n<li>拜公忌 /bai³ gong¹ gi⁷/ 在忌日祭拜先祖</li>\n<li>拜祖 // 祭拜先祖</li>\n<li>拜老爺 // 拜神</li>\n<li>假日 /gia² rig⁸/</li>\n<li>放假 /bang³ gia²/、/bang³ gian²/</li>\n<li>暑假 /su² gia²/</li>\n<li>寒假 /hang⁵ gia²/</li>\n</ol>\n<h3 id=\"🌀天時-tin¹-si⁵\"><a href=\"#🌀天時-tin¹-si⁵\" class=\"headerlink\" title=\"🌀天時(tin¹ si⁵)\"></a>🌀天時(tin¹ si⁵)</h3><ol>\n<li>晴 /zên⁵/ 晴朗</li>\n<li>出日 /cug⁴ rig⁸/ 太陽出來了</li>\n<li>透堂白日 /tao³ dng⁵ bêh⁸ rig⁸/ 大白天</li>\n<li>烏陰天 /ao¹ im¹ tin¹/ 陰天</li>\n<li>透風 /tao³ hong¹/ 刮大風</li>\n<li>風颱 /hong¹ tai¹/ 颱風</li>\n<li>南風天 /nang¹ hong¹ tin¹/ 刮南風，濕氣加重</li>\n<li>轉南風 /dng² nang¹ hong¹/ 南風天來了</li>\n<li>透南風 /tao³ nang¹ hong¹/ 刮南風，伍佰有一 Live 同名。</li>\n<li>蒙煙天 /mong⁵ iang¹ tin¹/ 霧霾天</li>\n<li>落雨 /lo² hao⁶/ 下雨</li>\n<li>一陣雨 /zêg⁸ zung⁵ hao⁶/</li>\n<li>日頭雨 /rig⁸ tao⁵ hao⁶/ 一邊下雨，一邊出太陽</li>\n<li>烏寒雨 /ao¹ guan⁵ hao⁶/ 天時烏陰落寒雨</li>\n<li>爍焰 /sih⁴ iam⁶/ 閃電</li>\n<li>敲雷 /ka³ lui⁵/ 打雷</li>\n<li>冷空氣 /lêng² kong¹ ki⁷/</li>\n<li>落雪 /lo² soh⁴/ 下雪</li>\n<li>落雹 /lo² pag⁸/ 下冰雹</li>\n<li>旱 /uan⁶/ 乾旱</li>\n<li>寒 /guan⁵/ 寒冷</li>\n<li>冷 /lêng²/ 寒冷</li>\n<li>凝 /ngang⁵/ 寒冷</li>\n<li>熱 /ruah⁸/</li>\n<li>翕熱 /hib⁴ ruah⁸/ 悶熱</li>\n<li>乾燥 /gang¹ cao³/</li>\n<li>濕 /sib⁴/ 濕潤</li>\n<li>涼 /liang⁵/ 涼爽</li>\n</ol>\n<h3 id=\"🌛天文-tiang¹-bhung⁵\"><a href=\"#🌛天文-tiang¹-bhung⁵\" class=\"headerlink\" title=\"🌛天文(tiang¹ bhung⁵)\"></a>🌛天文(tiang¹ bhung⁵)</h3><ol>\n<li>天頂 /tin¹ dêng²/ 天上</li>\n<li>日頭 /rig⁸ tao⁵/ 太陽</li>\n<li>蝕日 /sih⁸ rig⁸/ 日食</li>\n<li>狗齧日 /gao² na² rig⁸/ 天狗食日</li>\n<li>西照日 /sai¹ zio³ rig⁸/ 夕陽</li>\n<li>月娘 /ghoih⁸ nion⁵/ 月亮</li>\n<li>月眉 /ghoih⁸ bhai⁵/ 弦月</li>\n<li>蝕月 /sih⁸ ghoih⁸/ 月食</li>\n<li>河溪 /ho⁵ koi¹/ 銀河、天河</li>\n<li>落屎星 /lo² sai² cên¹/ 流星</li>\n<li>星宿 /cên¹ siu³/</li>\n</ol>\n<h3 id=\"⛰️地理-di⁷-li²\"><a href=\"#⛰️地理-di⁷-li²\" class=\"headerlink\" title=\"⛰️地理(di⁷ li²)\"></a>⛰️地理(di⁷ li²)</h3><ol>\n<li>中央 /diong¹ iang¹/ 中間</li>\n<li>內底 /lai⁶ doi²/ 裏面</li>\n<li>外口 /ghua⁷ kao²/、/la¹ kao²/ 外面</li>\n<li>頭頂 /tao⁵ dêng²/ 上面</li>\n<li>下跤 /ê⁶ ka¹/ 下面</li>\n<li>下底 /ê⁶ doi²/ 下面</li>\n<li>正手爿 /ziang³ ciu² bain⁵/ 左邊</li>\n<li>倒手爿 /do³ ciu² bain⁵/ 右邊</li>\n<li>頭前 /tao⁵ zain⁵/ 前面</li>\n<li>後底 /ao⁶ doi²/ 後面</li>\n<li>後壁 /ao⁶ biah⁴/ 後面</li>\n<li>對面 /dui³ ming⁷/</li>\n<li>隔壁 /gêh⁴ biah⁴/</li>\n<li>鄰近 /lim¹ ging⁶/</li>\n<li>塗跤 /tao⁵ ka¹/</li>\n<li>番爿 /huang¹ bain⁵/</li>\n<li>北爿 /bag⁴ bain⁵/</li>\n<li>東南西北 /dang¹ nam⁵ sai¹ bag⁴/</li>\n<li>地盤 /di⁷ buan⁵/</li>\n<li>領域 /nia² oig⁸/</li>\n<li>境內 /gêng² lai⁶/</li>\n<li>世界 /si³ gai³/</li>\n<li>宇宙 /u² diu²/</li>\n<li>全球 /cuang¹ giu⁵/</li>\n<li>天涯 /tiang¹ ngai⁵/</li>\n<li>山頂 /suan¹ dêng²/</li>\n<li>山跤 /suan¹ ka¹/</li>\n<li>外地 /ghua⁷ dê³/</li>\n<li>本地 /bng² di⁷/</li>\n<li>別地 /bag⁸ dê³/ 外地</li>\n<li>別地地 /bag⁸ di⁷ dê³/ 外地</li>\n<li>塗 /tao⁵/ 泥</li>\n<li>塗膏 /tao⁵ go¹/ 泥巴</li>\n<li>石頭 /zioh⁸ tao⁵/</li>\n<li>田園 /cang⁵ hng⁵/</li>\n<li>溪墘 /koi¹ gin⁵/ 溪邊</li>\n<li>草埔 /cao² bao¹/ 草坪</li>\n<li>崎 /gia⁶/ 小山坡</li>\n<li>坑 /kên/ 山谷、溪谷。</li>\n<li>嶺 /nia²/ 有路可通的山頂</li>\n<li>岑 /ngim⁵/、/cam⁵/ 小而高的山</li>\n<li>墟 /hu¹/ 大土山</li>\n<li>壩 /ba³/ 沙灘、沙洲。</li>\n<li>潭 /tam⁵/ 深水池</li>\n<li>溪 /koi¹/</li>\n<li>江 /gang¹/</li>\n<li>河 /ho⁵/</li>\n<li>湖 /ao⁵/</li>\n<li>海 /hai²/</li>\n<li>海拔 /hai² buag⁸/</li>\n<li>洲 /ziu¹/</li>\n<li>港 /gang²/</li>\n<li>灣 /uang¹/</li>\n<li>溝 /gao¹/</li>\n<li>渠 /ku⁵/ 水道，特指人工開的河道。</li>\n<li>浦 /pao²/ 水邊或江河入海處</li>\n<li>澳 /o³/ 海邊彎曲且可停泊船隻的地方</li>\n<li>汕 /suan³/ 河流沖刷或沖刷而積成的沙灘</li>\n<li>汕頭 /suan¹ tao⁵/</li>\n<li>汕尾 /suan³ bhoi²/</li>\n<li>海湧 /hai² êng²/ 海浪。湧，波浪。</li>\n<li>東濠湧 /dang¹ hao⁵ cong¹/ 地名，在廣州越秀。濠，溝渠。湧，河流分叉處。</li>\n<li>湧泉相報 /iong³ zuan⁵ siang¹ bo³/ 湧，水冒出。</li>\n<li>庭、埕 /dian⁵/ 院子、宽阔处</li>\n<li>礦物 /kuang³ moih⁸/</li>\n<li>化石 /hoi³ zioh⁸/</li>\n<li>原油 /nguang¹ iu⁵/</li>\n<li>燃料 /riang⁵ liao⁷/</li>\n<li>金屬 /gim¹ siog⁸/</li>\n<li>金銀財寶 /gim¹ nging⁵ cai⁵ bo²/</li>\n<li>鋼鐵 /gng³ tih⁴/</li>\n<li>蘇打 /so³ da²/ 英文 soda 的音譯，常指小蘇打，即碳酸氫鈉。</li>\n<li>蘇州 /sao¹ ziu¹/</li>\n<li>蠟 /la²/</li>\n<li>硫磺 /liu⁵ ng⁵/</li>\n<li>砒霜 /bi¹ sng¹/</li>\n<li>砂石 /sua¹ zioh⁸/</li>\n<li>大理石 /dai⁶ li² zioh⁸/</li>\n<li>碳 /tuan³/</li>\n<li>水銀 /zui² nging⁵/</li>\n<li>水龍水 /zui² lêng⁵ zui²/ 自來水</li>\n<li>地牛換肩 /di⁷ ghu⁵ uang⁷ gain¹/ 地震</li>\n<li>許婆寮 /kao² pua⁵ liao⁵/ 今可和村</li>\n<li>北輋 /bag⁴ sia⁵/ 今博社村</li>\n<li>四捻石 /si³ niam³ zio²/ 四片石</li>\n<li>甲子八景：六十甲子欄、潮來人字水、雙帆跨海島、五馬渡江邊、仙人踏石積、海甲蓮花山、西峯古寺、雷廟天堂。（《陸豐縣誌》卷之二疆域四 P21）</li>\n<li>擎天石：位於甲秀書院的側邊的一塊巨石。《陸豐縣誌》記載：在甲子所北門內峙立聳拔高出雉堞丈余，中開一痕，俗謂雷打石。胡文烜銘其上曰：「天開甲子，巨石臨門，一聲霹靂，振動乾坤 ……」。字大如鬥，余銘苔蝕莫辨。（《陸豐縣誌》卷之二古蹟十二 ）</li>\n<li>甲秀書院：甲秀書院位於陸豐縣甲子鎮北門內。甲秀書院建於明代，歷來為粵東文人會萃講學之所。至今院內仍保存著不少歷代的石碑石刻。解放后，人民政府在此興辦中學。</li>\n<li>福源寺：座落於甲子鎮北郊雨亭路，原名「復元寺」，又稱「蓮花山草庵」。據傳，福源寺建於宋代。因歷史久遠，原址僅遺存牆基。1990年由光茂法師主持重建。經過10多年的建造，先後建成天王殿、大雄寶殿、觀音殿、地藏殿、鐘樓、鼓樓和禪房等，重塑了諸位菩薩聖像。寺區佔地面積1.2萬多平方米，建築面積3000多平方米。</li>\n<li>南海夫人廟：位於甲子鎮城西社區環城路東。明萬曆元年（1573），李棠中舉後爲其妻卓氏而建的紀念祠，御史鄧練題匾「南海夫人」，故稱南海夫人廟。</li>\n<li>烈士墓</li>\n</ol>\n<h3 id=\"📐計量-goi³-liang⁶\"><a href=\"#📐計量-goi³-liang⁶\" class=\"headerlink\" title=\"📐計量(goi³ liang⁶)\"></a>📐計量(goi³ liang⁶)</h3><ol>\n<li>〇、零 /lêng⁵/、/lang⁵/</li>\n<li>一、壹 /zêg⁸/、/ig⁴/</li>\n<li>二、贰 /no⁶/、/ri⁶/</li>\n<li>三、叁 /san¹/、/sam¹/</li>\n<li>四、肆 /si³/、/su³/</li>\n<li>五、伍 /ngao⁶/、/u²/</li>\n<li>六、陆 /lag⁸/</li>\n<li>七、柒 /cig⁴/</li>\n<li>八、捌 /boih⁴/、/bag⁴/</li>\n<li>九、玖 /gao²/、/giu²/</li>\n<li>十、拾 /zab⁸/</li>\n<li>百、佰 /bêh⁴/</li>\n<li>千、仟 /cain¹/、/ciang¹/</li>\n<li>萬 /mang⁷/</li>\n<li>億 /êg⁸/</li>\n<li>一二個 /zêg⁸ no² gai⁵/</li>\n<li>二十六 /ri⁸ ab⁸ lag⁸/、/ri⁸ zab⁸ lag⁸/</li>\n<li>廿六號 /rig⁸ lag⁸ ho⁷/ 二十六號</li>\n<li>五十外個 /ngao⁶ zab⁸ ghua⁷ gai⁵/</li>\n<li>一百空八 /zêg⁸ bêh⁴ kang³ boih⁴/ 一百零八</li>\n<li>第一 /doi⁷ ig⁴/</li>\n<li>第二 /doi⁷ ri⁶/</li>\n<li>第三 /doi⁷ san¹/</li>\n<li>一個人 /zêg⁸ gai⁵ nang⁵/</li>\n<li>一爿花 /zêg⁸ bain⁵ hoi¹/ 一片花瓣</li>\n<li>一蕊花 /zêg⁸ lui² hoi¹/ 一朵花</li>\n<li>一葩花 /zêg⁸ pa¹ hoi¹/ 一朵花</li>\n<li>一枝花 /zêg⁸ gi¹ hoi¹/</li>\n<li>一縛花 /zêg⁸ ba² hoi¹/ 一束花</li>\n<li>一叢樹 /zêg⁸ zang⁵ hoi¹/ 一棵樹</li>\n<li>一簇頭毛 /zêg⁸ cog⁴ tao⁵ mo⁵/ 一撮頭髮</li>\n<li>一粒糖 /zêg⁸ liab⁸ tng⁵/</li>\n<li>一隻車 /zêg⁸ ziah⁴ cia¹/ 一輛車</li>\n<li>一架車 /zêg⁸ gê³ cia¹/ 一輛車</li>\n<li>一杯茶 /zêg⁸ boi¹ dê⁵/</li>\n<li>一碗水 /zêg⁸ uan² zui²/</li>\n<li>一喙水、一嘴水 /zêg⁸ cui³ zui²/ 一口水</li>\n<li>一條弓蕉 /zêg⁸ diao⁵ gêng¹ zio¹/ 一條香蕉</li>\n<li>一本書 /zêg⁸ bng² zu¹/</li>\n<li>一枝手機 /zêg⁸ gi¹ ciu² gi¹/ 一隻手機</li>\n<li>一枝鎖匙 /zêg⁸ gi¹ so² si⁵/ 一把鑰匙</li>\n<li>一個銀 /zêg⁸ gai⁵ nging⁵/ 一塊錢</li>\n<li>一領被 /zêg⁸ nia² poi⁶/ 一席被子</li>\n<li>一個鋪 /zêg⁸ gai⁵ pao¹/ 一張床</li>\n<li>一個鐘頭 /zêg⁸ gai⁵ zêng¹ tao⁵/ 一個小時</li>\n<li>一副衫褲 /zêg⁸ hu³ san¹ kao³/ 一套衣服</li>\n<li>一腰裙 /zêg⁸ io¹ gung⁵/ 一件裙子</li>\n<li>一尾魚 /zêg⁸ bhoi² hu⁵/ 一條魚</li>\n<li>一墩物件 /zêg⁸ dung¹ mi² gian⁶/ 一堆東西</li>\n<li>一橛蔗 /zêg⁸ goi² zia³/ 一截甘蔗</li>\n<li>一葩電火 /zêg⁸ pa¹ diang⁶ hoi²/ 一盞電燈</li>\n<li>一跤箸、一腳箸 /zêg⁸ ka¹ du⁷/ 一隻筷子</li>\n<li>一雙箸 /zêg⁸ sang¹ du⁷/ 一雙筷子</li>\n<li>一腹火 /zêg⁸ bag⁴ hoi²/ 一肚子火</li>\n<li>一脬屎 /zêg⁸ bu⁵ sai²/ 一坨屎</li>\n<li>一脬尿 /zêg⁸ bu⁵ rio⁷/ 一泡尿</li>\n<li>一逝路 /zêg⁸ zua⁷ lao⁷/ 一趟路</li>\n<li>一丸塗 /zêg⁸ uang⁵ tao⁵/ 一團泥土</li>\n<li>一過 /zêg⁸ goi³/ 一次</li>\n</ol>\n<h3 id=\"🧭-指代-zi²-toi³\"><a href=\"#🧭-指代-zi²-toi³\" class=\"headerlink\" title=\"🧭 指代(zi² toi³)\"></a>🧭 指代(zi² toi³)</h3><ol>\n<li>只 /zi²/ 這，近指。</li>\n<li>許 /hi²/ 那，遠指。</li>\n<li>者、這 /zê²/、/zia²/ 這，近指。</li>\n<li>遐 /hê²/、/hia²/ 那，遠指。</li>\n<li>底個 /di⁷ gai⁵/ 哪個</li>\n<li>者個 /zê² gai⁷/、/zia² gai⁷/ 這個</li>\n<li>遐個 /hê² gai⁷/、/hia² gai⁷/ 那個</li>\n<li>怎樣 /za³ ion⁷/、/zion²/</li>\n<li>乜樣 /mig⁴ ion⁷/ 怎樣</li>\n<li>底樣 /di⁷ ion⁷/ 怎樣</li>\n<li>怎生 /za³ sên¹/、/zai¹ sên¹/怎樣</li>\n<li>怎樣生 /zion² sên¹/ 怎樣</li>\n<li>怎樣然 /zion² ni⁵/、/zo⁵ ni⁵/ 怎麼、幹啥</li>\n<li>怎樣麼 /zion² mo⁷/、/ziom²/</li>\n<li>者樣 /zê² ion⁷/、/zion¹/</li>\n<li>遐樣 /hê² ion⁷/、/hion¹/</li>\n<li>者樣生 /zion¹ sên¹/ 這樣</li>\n<li>遐樣生 /hion¹ sên¹/ 那樣</li>\n<li>底搭 /di⁷ dah⁴/ 哪裏</li>\n<li>者搭 /zê² dah⁴/ 這裏</li>\n<li>遐搭 /hê² dah⁴/ 那裏</li>\n<li>底地 /di⁷ dê³/ 哪裏</li>\n<li>者地方 /zê² ding¹/ 這裏</li>\n<li>遐地方 /hê² ding¹/ 那裏</li>\n<li>底囝 /di⁷ gian²/ 哪兒</li>\n<li>者囝 /zê gian²/ 這兒</li>\n<li>遐囝 /hê² gian²/ 那兒</li>\n<li>底人 /di⁷ nang⁵/、/diang⁶/、/di⁷ diang⁶/ 誰</li>\n<li>底位 /di⁷ ui⁷/ 哪位</li>\n<li>者位 /zê² ui⁷/</li>\n<li>遐位 /hê² ui⁷/ 那位</li>\n<li>底時 /di⁷ si⁵/ 什麼時候</li>\n<li>底當時 /diang⁶ si⁵/ 什麼時候</li>\n<li>者時 /zê² si⁵/</li>\n<li>遐時 /hê² si⁵/ 那時</li>\n<li>乜事 /mig⁴ su⁷/ 什麼事情</li>\n<li>若㩼 /rioh⁸ zoi⁷/、/rua⁷ zoi⁷/ 多少</li>\n<li>幾 /gui²/</li>\n<li>豈是 /ka³ si⁷/ 是否是</li>\n<li>敢是 /gam² si⁷/ 是否是</li>\n</ol>\n<h3 id=\"🏃‍♀️動詞-dong⁶-su⁵\"><a href=\"#🏃‍♀️動詞-dong⁶-su⁵\" class=\"headerlink\" title=\"🏃‍♀️動詞(dong⁶ su⁵)\"></a>🏃‍♀️動詞(dong⁶ su⁵)</h3><p><strong>第一部分</strong></p>\n<ol>\n<li>會 /oi⁶/</li>\n<li>無會、袂、𠀾 /bhoi⁶/ 不會</li>\n<li>未 /bhoi⁷/ 沒有（事情還沒做）</li>\n<li>無 /bho⁵/ 沒有</li>\n<li>有 /u⁶/</li>\n<li>好 /ho²/</li>\n<li>毋好、孬 /mo²/ 不好</li>\n<li>欲 /bhêh⁴/ 要</li>\n<li>毋、唔 /m⁶/ 不要</li>\n<li>欲毋 /bhêh⁴ m⁶/、/bhên⁶/ 要不要</li>\n<li>愛 /ain³/ 要</li>\n<li>無愛 /bho⁵ ain³/ 不要</li>\n<li>毋愛、勿、嫑 /main³/ 不要</li>\n<li>用 /êng⁶/ 需要</li>\n<li>免 /miang²/ 不需要</li>\n<li>肯 /kêng²/、/kiang²/ 願意</li>\n<li>毋肯 /m⁶ kêng²/、/m⁶ kiang²/ 不願意</li>\n<li>架勢是 /gê³ si³ si⁷/ 看這情形是。例如：舖關了，架勢是去做節了。 </li>\n</ol>\n<p><strong>第二部分 頭、喙</strong></p>\n<ol>\n<li>dag⁴ 頭 // 點頭</li>\n<li>搖頭 /io⁵ tao⁵/</li>\n<li>攲頭 /ki¹ tao⁵/ 歪頭</li>\n<li>呾 /dan³/ 說</li>\n<li>參詳 // 商量</li>\n<li>學古 /oh⁴ gao²/ 講故事</li>\n<li>罵 /mê⁷/</li>\n<li>詏 /a³/ 爭辯</li>\n<li>冤家 /uang¹ gê¹/ 吵架</li>\n<li>恬 /diam⁷/ 閉嘴、安靜</li>\n<li>咬 /ga⁶/</li>\n<li>哺 /bao⁷/ 咀嚼</li>\n<li>唵 /am⁶/ 將食物放進嘴巴</li>\n<li>喷 /pung³/ 散射</li>\n<li>啡痰 /pui³ tam⁵/ 吐痰</li>\n<li>歕 /bung⁵/ 吹氣</li>\n<li>嗾？ /zag⁸/ 呛到、岔到 </li>\n</ol>\n<p><strong>第三部分 目、心</strong></p>\n<ol>\n<li>睇 /toi²/ 看</li>\n<li>看詳睇 /kang³ siang⁵ toi²/ 仔細看</li>\n<li>經心 /gêng¹ sim¹/ 用心</li>\n<li>經心衋事 // 操心</li>\n<li>經破頭腦 // 想破頭 </li>\n</ol>\n<p><strong>第四部分 手、跤</strong></p>\n<ol>\n<li>揨 /dian¹/ 觸、碰</li>\n<li>拍 /pah⁴/ 打</li>\n<li>舂 /cêng⁵/ 用力打</li>\n<li>/dng⁷/ 打</li>\n<li>刜 /hug⁴/ 揮、打</li>\n<li>剚、倳 /sai⁷/ 打</li>\n<li>抶 /diag⁴/ 用鞭、杖或竹板打。～手</li>\n<li>摔 /sug⁴/ 抽打、鞭打</li>\n<li>拗折 /a² zi²/ 折斷</li>\n<li>盖 /kain³/ 由上往下覆。～頭</li>\n<li>掃 /sao³/ 迅速掠過。～面</li>\n<li>揞 /an¹/ 掩。～面</li>\n<li>diu³ 竹囝</li>\n<li>擎 /gia⁵/ 舉、握、拿</li>\n<li>𢭪 /kioh⁴/ 撿、拾</li>\n<li>挈 /kioh⁸/ 取、拿</li>\n<li>摜 /guan⁶/ 提</li>\n<li>厾 /doh⁴/ 戳</li>\n<li>割 /guah⁴/</li>\n<li>殺 /suah⁴/</li>\n<li>斬 /zam²/</li>\n<li>斫 /dog⁴/ 剁</li>\n<li>宰 /zai²/ 殺</li>\n<li>刣 /tai⁵/ 殺</li>\n<li>拭 /cig⁴/ 擦</li>\n<li>濡 /ru⁵/ 用濕布擦或用拖把拖</li>\n<li>爬 /bê⁵/ 搔(癢)</li>\n<li>掊 /boi²/ 扒開</li>\n<li>揂 /ciu⁵/ 拉引繩子</li>\n<li>𠡒 /dui²/ 用力拉</li>\n<li>捏 /dên⁶/ 掐</li>\n<li>漱牙 /ciu³ ghê⁵/ 刷牙</li>\n<li>跋 /buah⁸/ 摔倒</li>\n<li>踏 /dah⁴/ 踩</li>\n<li>踢 /tag⁴/</li>\n<li>去 /ku³/、/ka³/</li>\n<li>轉 /dng²/ 回來</li>\n<li>綴 /doi³/ 跟著；縫合。</li>\n<li>修理 /siu¹ li²/、/su¹ li²/</li>\n<li>泊車 /pag⁴ cia¹/ 停車。泊，粵語音譯英文 park 得來，停車的意思。</li>\n</ol>\n<p><strong>第五部分</strong></p>\n<ol>\n<li>曳、𤆬 /cua⁷/ 帶、領</li>\n<li>娶 /cua⁷/ 取婦</li>\n<li>徙 /sua²/ 移動</li>\n<li>歇 /hiah⁴/ 放置、休息</li>\n<li>煩惱 /huang⁵ lo²/ 擔心</li>\n<li>相信 /sion¹ siang³/、/siang¹ sing⁷/ 相信</li>\n<li>相輔 /sion³ hu⁶/ 幫忙</li>\n<li>排比 /bai⁵ bi²/ 安排</li>\n<li>含包 /ham⁵ bao¹/ 包含</li>\n<li>拚頭前 /bian³ tao⁵ zain⁵/ 爭先</li>\n<li>輸服 /su¹ hog⁸/ 佩服</li>\n<li>䷀䷀ /dag⁴ nng⁷/ 浪費</li>\n<li>䷀落 /ga¹ lao⁵/ 掉落</li>\n<li>沕 /bhih⁴/ 躲藏</li>\n<li>支 /zin¹/ 預付</li>\n<li>圖賴 /tu⁵ tai²/ 耍賴</li>\n<li>放惰 /bang¹ dua⁶/ 懶得</li>\n</ol>\n<h3 id=\"🧜‍♀️形容-heng⁵-iong⁵\"><a href=\"#🧜‍♀️形容-heng⁵-iong⁵\" class=\"headerlink\" title=\"🧜‍♀️形容(hêng⁵ iong⁵)\"></a>🧜‍♀️形容(hêng⁵ iong⁵)</h3><ol>\n<li>媠 /sui²/ 好、漂亮</li>\n<li>雅 /ngia²/ 正、漂亮</li>\n<li>生好 /sên¹ ho²/ 漂亮、好看</li>\n<li>䆀 /bhai²/ 差、醜陋</li>\n<li>好 /ho²/</li>\n<li>痞、歹 /pai²/</li>\n<li>大細 /dua⁷ soi³/ 大小</li>\n<li>㩼少 /zoi⁷ zio²/ 多少</li>\n<li>加加減減 /gê¹ gê¹ giam² giam²/ 多多少少</li>\n<li>稀罕 // 稀少，罕見。</li>\n<li>賤 /la¹ zuan⁷/ 繁多，低賤。物以稀為貴，多則賤。</li>\n<li>猛慢 /mê² mang⁷/ 快慢、早晚。猛，快。</li>\n<li>肥 /bui⁵/ 胖</li>\n<li>肥腯肥腯 /bui⁵ tuh⁸ bui⁵ tuh⁸/ 胖嘟嘟</li>\n<li>㾪 /sang²/ 瘦</li>\n<li>㾪猴 /sang² gao⁵/ 瘦得跟猴子一樣</li>\n<li>㾪脯皺 /sang² bao² niao³/ 又瘦又缺水又褶皺，形容飢瘦。</li>\n<li>懸下 /guai⁵/ 高低</li>\n<li>早 /za²/</li>\n<li>晏 /uang³/ 晚</li>\n<li>粗 /cao¹/</li>\n<li>幼 /iun³/ 細</li>\n<li>粗殘 /cao¹ cang⁵/ 粗魯</li>\n<li>仔細 /zu² soi⁷/ 小心</li>\n<li>芳 /pang¹/ 香</li>\n<li>臭 /cao³/</li>\n<li>僫 /oh⁴/ 困難</li>\n<li>易 /goi⁷/ 容易</li>\n<li>闊 /kuah⁴/ 寬</li>\n<li>狹 /oih⁸/ 窄</li>\n<li>光 /gng¹/ 亮</li>\n<li>暗 /am³/</li>\n<li>恬 /diam⁷/ 安靜</li>\n<li>吵 /cao¹/ 吵鬧</li>\n<li>吵吵著 /cao¹ cao¹ dioh⁴/ 吵吵鬧鬧的</li>\n<li>飽 /ba²/</li>\n<li>枵 /iao¹/ 餓</li>\n<li>橂 /dain⁷/ 堅實、堅硬</li>\n<li>軟 /nam³/ 軟弱。本字不明，訓用「軟」。</li>\n<li>韌 /rung⁷/ 堅強；不容易斷裂。</li>\n<li>脆 /cê³/ 脆弱；容易斷裂。</li>\n<li>聰明 /cong¹ mêng⁵/</li>\n<li>愚蠢 /ngo⁵ cung²/</li>\n<li>戇 /gong³/ 愚笨</li>\n<li>賰 /cung⁵/ 剩餘</li>\n<li>欠 /kiam³/ 缺少</li>\n<li>清 // 清晰、乾淨</li>\n<li>雾 /bhu⁷/ 模糊</li>\n<li>清氣 /cêng¹ ki³/ 乾淨</li>\n<li>清氣相 /cêng¹ ki³ sion³/ 乾淨的樣子</li>\n<li>垃圾 /lah⁴ sab⁴/ 骯臟</li>\n<li>垃圾相 /lah⁴ sab⁴ sion³/ 骯臟的樣子</li>\n<li>無沙無圾 /bho⁵ sua¹ bho⁵ sab⁴/ 一塵不染</li>\n<li>灱 /da¹/ 乾燥</li>\n<li>㴷 /dam⁵/ 濕潤</li>\n<li>落雨㴷渧 /lo² hao⁶ dam⁵ di³/ 下雨濕漉漉的樣子</li>\n<li>著 /dioh⁸/ 對、正確</li>\n<li>毋著 /m⁷ dioh⁸/ 不對</li>\n<li>錯 /co³/</li>\n<li>熟 /sêg⁸/</li>\n<li>生 /cên¹/ (瓜果等)未成熟</li>\n<li>臭生 /cao³ cên¹/ 未煮熟或瓜果未成熟</li>\n<li>臭酸 /cao³ sng¹/ 食物變質</li>\n<li>黐黐 /ti¹ ti¹/ 黏稠</li>\n<li>切要 /ciag⁴ iao³/ 要緊</li>\n<li>無要緊 /bho⁵ iao³ ging²/ 不要緊</li>\n<li>大扮</li>\n<li>咸澀</li>\n<li>力相 // 努力</li>\n<li>惰 /duan⁶/ 懶惰</li>\n<li>鬧熱 /nao⁶ ria²/ 熱鬧</li>\n<li>活神 // 精神好，灵活</li>\n<li>健 /gian⁷/ 身體好</li>\n<li>碩㦙 /sêg⁴ ngo³/ 聰明和愚蠢</li>\n<li>夠力 /gao³ lag⁸/ 厲害</li>\n<li>夠強 /gao³ kiang³/ 厲害</li>\n<li>夠衰 /gao³ soi¹/ 好慘</li>\n<li>緊要 /ging² iao³/ 要緊</li>\n<li>切要 /ciag⁴ iao³/ 要緊</li>\n<li>癩瘑糜烂 //</li>\n<li>枝毛小節、枝毛細節 // 無關緊要</li>\n<li>偪側 /bêg⁴ cêg⁴/ 心中有氣，煩躁不安。</li>\n<li>生分 /cên¹ hung⁷/ 陌生、疏遠</li>\n<li>無影無跡 // 沒有根據</li>\n<li>一生跪跋 /zêg⁸ sên¹ gui⁶ buah⁸/ 一生坎坷</li>\n</ol>\n<h3 id=\"🐴副詞-hu³-su⁵\"><a href=\"#🐴副詞-hu³-su⁵\" class=\"headerlink\" title=\"🐴副詞(hu³ su⁵)\"></a>🐴副詞(hu³ su⁵)</h3><ol>\n<li>好 /hoh⁴/ 表示程度深。例如：好㩼人 // 好多人。</li>\n<li>死 /si²/ 表示程度特別深。例如：死㩼人 // 超級多人。死雅 // 超漂亮的。</li>\n<li>若 /rua⁷/ 多麼。例如：若雅 // 多麼漂亮。</li>\n<li>者 /zia²/ 這麼。例如：者細 // 這麼小。</li>\n<li>遐 /hia²/ 那麼。例如：遐好 // 那麼好。</li>\n<li>上好 /siang⁶ ho²/ 最好。</li>\n<li>上減 /siang⁶ giam²/ 最少。</li>\n<li>上加 /siang⁶ gê¹/ 最多。</li>\n<li>較 /ga³/ 比較地。例如：伊較厲害 // 他比較厲害。</li>\n<li>曾 /bhah⁴/ 曾經。例如：我毋曾來過 // 我不曾來過。</li>\n<li>攏總 /long² zong²/ 全部。例如：攏總 100 銀 // 總共 100 塊。</li>\n<li>煞 /sua⁵/ 竟然。例如：汝煞毋知 // 你竟然不知道。</li>\n<li>顛倒 /ding¹ do³/ 反而。例如：六月顛倒來落雪 // 六月反而下起雪。</li>\n<li>做蜀 /zo³ zêg⁸/ 一起。例如：做蜀 ka³ // 一起去。</li>\n</ol>\n<h3 id=\"😲象聲詞-siang⁶-sian¹-su⁵\"><a href=\"#😲象聲詞-siang⁶-sian¹-su⁵\" class=\"headerlink\" title=\"😲象聲詞(siang⁶ sian¹ su⁵)\"></a>😲象聲詞(siang⁶ sian¹ su⁵)</h3><ol>\n<li>喏 /no⁷/ 使人注意某物</li>\n<li>囉、咯 /lo⁷/ 表示事情完成</li>\n<li>/hoin⁷/ 呼人</li>\n<li>/oin⁷/ 應人</li>\n<li>喂 /uê⁷/ 打招呼。</li>\n<li>啊 /a⁷/ 加強語氣</li>\n<li>呀 /ia⁷/ 表示贊同</li>\n<li>喔、噢 /o⁷/ 表示醒悟、驚訝或了解</li>\n<li>哇 /ua⁷/ 表示驚訝</li>\n<li>嗯 /ng⁷/ 表示同意或了解</li>\n<li>哼 /hng²/ 表示不滿</li>\n<li>哎、噯 /ai⁷/ 嘆氣</li>\n<li>嗐 /hai⁷/ 嘆氣，比「哎」重些。</li>\n<li>/ho⁷～/、/o⁷～/ 長吁，含有一種無力、操碎了心的感覺。</li>\n</ol>\n<h3 id=\"🙃俗語-siog⁸-ngo²\"><a href=\"#🙃俗語-siog⁸-ngo²\" class=\"headerlink\" title=\"🙃俗語(siog⁸ ngo²)\"></a>🙃俗語(siog⁸ ngo²)</h3><ol>\n<li>哇浪、我卵 /ua² lang⁶/ 哇噻</li>\n<li>我無閒 /ua² bho⁵ ain⁵/ 我沒空</li>\n<li>走街邊 /zao² goi¹ bin¹/ 擺地攤</li>\n<li>汝愛去怎樣麼緊 /lu² ain³ ku³ zion² mo⁷ ging⁷/ 你趕著去幹嗎</li>\n<li>勿者樣生 /mai³ zion¹ sên¹/ 不要這樣</li>\n<li>知收煞 /zai¹ siu¹ suah⁴/ 適時停手</li>\n<li>毋別世代 /m⁶ bhag⁴ si³ dê³/ 不懂事</li>\n<li>無變 /bho⁵ biang³/ 沒有辦法</li>\n<li>堵著無變 /du² dioh⁴ bho⁵ biang³/ 碰到沒有辦法</li>\n<li>無理路 /bho⁵ li² lao⁷/ 無道理。路，道。</li>\n<li>無奈何 /bho⁵ da¹ ua⁵/ 無可奈何</li>\n<li>無奈寫作不得已 /bho⁵ nai⁶ sia² zo³ bug⁴ dêg⁴ in²/ </li>\n<li>呾死無會變 /dan⁵ si² bhoi⁶ bin³/ 冥頑不靈</li>\n<li>橂過石部 /dain⁷ goi³ zio² bao⁶/ 比石頭還硬</li>\n<li>三斗油麻倒無一粒落耳 /san¹ dao² iu⁵ mua⁵ do³ bho⁵ zêg⁸ liab⁴ lo² hin⁶/ 怎麼說都聽不進去</li>\n<li>瀉衰人 /sia³ soi¹ nang⁵/ 丟人、令人蒙羞</li>\n<li>見笑 /giang³ siao³/ 丟人、令人蒙羞</li>\n<li>雙目囥著褲底 /sang¹ mag⁸ kng³ dioh⁴ kao³ doi²/ 看不見</li>\n<li>無目睇 /bho⁵ mag⁸ toin³/ 不想看</li>\n<li>鴨囝聽雷 /ah⁴ gian² tian¹ lui⁵/ 聽不懂</li>\n<li>戅過隻鴨 /gong⁵ goi³ ziah⁴ ah⁴/ 比鴨子還戇</li>\n<li>一樣糜飯飼千外樣人 /zêg⁸ ion⁷ moi⁵ bng⁷ ci⁷ cain¹ ghua⁷ ion⁷ nang⁵/ 社會人各種各樣</li>\n<li>暗過魂宫 /am³ goi³ hung⁵ gêng¹/ 比陰間還暗</li>\n<li>三更想，半暝反 /san¹ gên¹ sion⁶, buan³ mê⁵ huang²/ 思來想去，反反覆覆。</li>\n<li>過跤事知歇 /goi¹ ka¹ su⁷ zai¹ hiah⁴/ 過去的事情就不要計較了</li>\n<li>無會少禮 /bhoi⁶ siao² li²/ 不害臊</li>\n<li>刣雞教猴 /tai⁵ goi¹ ga³ gao⁵/ 殺雞儆猴</li>\n<li>勞生拚死 /lu⁵ sên¹ bian³ si²/ 拚死拚活</li>\n<li>食呾會，躕人強 /ziah⁸ dan³ oi⁶, du⁵ nang⁵ kiang³/ 能吃會說還很頑皮</li>\n<li>勿踟躕我 /mai³ di¹ du⁵ ua⁷/ 別纏我，使得我不知所措。</li>\n<li>老過伯爺 /lao⁶ goi³ bêh⁴ ia⁵/ 比土地公還年長</li>\n<li>平樣平樣 /pên⁵ ion⁷ pên⁵ ion⁷/ 一模一樣</li>\n<li>假力洗茶渣 /gê² lag⁸ soi² dê⁵ za¹/ 該做的不做，做了不該做的。</li>\n<li>死無命凝 /si² bho⁵ mian⁷ ngang⁵/ 冷死了</li>\n<li>富到流油 /bu⁷ gao³ lao⁵ iu⁵/ 很富有</li>\n<li>人熟禮毋熟 /nang⁵ sêg⁸ li² m⁶ sêg⁸/ 雖然人很熟，但還是要講禮。</li>\n<li>熟人免行生禮 /sêg⁸ nang⁵ miang² gian⁵ cên¹ loi²/</li>\n<li>千人千般苦，無人苦平樣 /cain¹ nang⁵ cain¹ buan¹ kao², bho⁵ nang⁷ kao² pên⁵ ion⁷/ 各有各的煩惱</li>\n<li>蟹有橂奅，人有碩㦙 /hoi⁶ u⁶ dain⁷ pan³, nang⁵ u⁶ sêg⁴ nga³/ 有人聰明有人愚笨。橂，堅實。奅，中空。碩，學問高、聰明。㦙，愚笨。</li>\n<li>鳥飛會落毛，人行有跤跡 /ziao² boi¹ oi⁶ lo² mo⁵, nang⁵ gian⁵ u⁶ ka¹ ziah⁴/ 做過了的事總會留痕跡</li>\n<li>客情好過吊頷鬼 /kêh⁴ cêng⁵ ho² goi³ diao³ am⁶ gui²/ 吊死鬼熱情地勸人上吊好代替自己，比喻虛情假意。</li>\n<li>貓兒無葷無著茨，鴨囝無粟無會過暝 /ngiao¹ ri⁵ bho⁵ hung¹ bho⁵ dioh⁴ cu⁷, ah⁴ gian² bho⁵ cêg⁴ bhoi⁶ goi³ mê⁵/ 小貓沒有葷菜就不在家，小鴨沒有稻粒就不過夜。</li>\n<li>衰雞無會食粟 /soi¹ goi¹ bhoi⁶ ziah⁸ cêg⁴/ 如病雞般吃不下飯</li>\n<li>無會死大破相 /bhoi⁶ si² dua⁷ pua³ sion³/ 不死也會頭破血流</li>\n<li>十八棚頭做到透 /zab⁸ boih⁴ bên⁵ tao⁵ zo³ gao³ tao³/ 指每種事都嘗試，貶義。十八棚頭，指十八齣溫州南戲。</li>\n<li>無跤蟹 /bho⁵ ga¹ hoi⁶/ 孤立無援</li>\n<li>大細目 /dua⁷ soi³ mag⁸/ 偏心</li>\n<li>平安當大趁 /pêng⁵ ang¹ dng¹ dua⁷ tang⁷/ 平安無疾就當作是大賺一筆了</li>\n<li>大人彎，孥囝直 /dua⁷ nang⁷ uain¹, nao⁵ gian² dig⁸/ 大人說話拐彎抹角，小孩子則是直來直去。</li>\n<li>錢囝毋使使大錢 /zin⁵ gian² m⁶ sai² sai² dua⁷ zin⁵/ 小錢不花，久了就得要花大錢了。</li>\n<li>未學行，先學飛 /bhoi⁷ oh⁸ gian², sain¹ oh⁸ boi¹/ 還沒學走路就要學飛了，基礎未打好。</li>\n<li>一人主張，毋如二人參詳 /zêg⁸ nang⁷ zu² ziang¹, m⁶ ru⁵ no⁶ nang⁷ cam¹ ciang⁵/ 自作主張不如多個人一起商量</li>\n<li>通街市獵無 /tong¹ goi¹ ci⁶ lah⁸ bho⁵/ 整條街都找不到。獵，尋找。</li>\n<li>喙尖舌囝利 /cui³ ziamvi/ 牙尖嘴利</li>\n<li>九月狗吶日，無用諸娘理毋直 /gao² goi² gao² nah⁴ rig⁸, bho⁵ êng⁷ zu¹ nion⁵ li² m⁶ dig⁸/ 九月份開始晝短夜長，沒用的婦女家務事搞不定了。</li>\n<li>茶薄人情厚，茶厚有禮貌 /dê⁵ bo² nang⁵ cêng⁵ gao⁶, dê⁵ gao⁶ u⁶ li² mao⁶/</li>\n<li>三十歲無妻是孩童 /san¹ zab⁸ hoi³ bho⁵ ci¹ si⁶ hai⁵ tong⁵/</li>\n<li>目汁是財，愈哭愈來 /mag⁸ zab⁴ si⁶ cai⁵, ru² kao³ ru⁶ lai⁵/</li>\n<li>呾破無酒食 /dan³ pua³ bho⁵ ziu² ziah⁸/ 師傅教徒弟，徒弟設酒宴款待，師傅酒後授予秘方。之後徒弟不再宴請師傅。</li>\n<li>軟過豆腐 /nam³ goi³ dao⁷ hu⁷/</li>\n<li>車大炮 /cia¹ dua⁷ pao³/ 吹牛</li>\n<li>樹大分椏，囝大分家 /ciu⁷ dua⁷ bng¹ a¹, gian² dua⁷ bng¹ ga¹/ </li>\n<li>閒過仙 /ain⁵ goi³ siang¹/ 比神仙還閒</li>\n<li>雙目望無一寸長 /sang¹ mag⁸ mo⁷ bho⁵ zêg⁸ cung³ dng⁵/ 鼠目寸光</li>\n<li>一鼠二牛三虎四兔五龍六蛇七馬八羊九猴十雞十一狗十二豬 /ig⁴ cu² ri⁶ ghu⁵ san¹ haon² si³ tao³ ngao⁶ lêng⁵ lag⁸ zua⁵ cig⁴ bhê² boih⁴ ion⁵ gao² gao⁵ zab⁸ goi¹ zab⁸ ig⁴ gao² zab⁸ ri⁶ du¹/</li>\n<li>差豬差狗，不如家己走 /cê¹ du¹ cê¹ gao², bug⁴ ru⁵ ga¹ gi⁷ zao²/ 求人不如求己</li>\n<li>後生擔石，老人食藥 /hao⁶ sên¹ dan¹ zioh⁸, lao⁶ nang⁵ ziah⁸ ioh⁸/ 年少積勞，年老吃藥</li>\n<li>疑心生暗鬼 /ghi⁵ sim¹ sên¹ am³ gui²/ 因多疑而產生各種幻覺和錯誤判斷</li>\n<li>羊尾短短，遮毋著羊尻川 /ion⁵ bhoi² dê² dê², zia¹ m⁶ dioh⁴ ion⁵ ka¹ cng¹/ 自己的缺點尷尬能自己找個遮醜的就很好了，別去取笑別人的不堪。</li>\n<li>愛母著刻苦 /ain³ bhao² dioh⁴ kag⁴ kao²/ 要老婆就要努力了</li>\n<li>無好家神通外鬼 /bho⁵ ho² gê¹ sing⁵ tong¹ ghua⁷ gui²/</li>\n<li>How do you do，好事來堵 /hao³ su⁷ lai³ du²/ 嗨，要搞事情我不怕你。好事，喜歡搞事情。堵，應對、抵抗。</li>\n<li>秋瓜棚下無好人 /ciu¹ goi¹ bên⁵ ê⁶ bho⁵ ho² nang⁵/ 秋瓜，絲瓜。</li>\n<li>三跤椅囝毋知䆀 /san¹ ka¹ in² gian² m⁶ zai¹ bhai²/ 坐著少了一腿的椅子竟然不知道壞了，比喻身處困境而不自知。</li>\n</ol>\n<h3 id=\"🤣歇後語-hiah⁴-ao⁶-ngo²\"><a href=\"#🤣歇後語-hiah⁴-ao⁶-ngo²\" class=\"headerlink\" title=\"🤣歇後語(hiah⁴ ao⁶ ngo²)\"></a>🤣歇後語(hiah⁴ ao⁶ ngo²)</h3><ol>\n<li>柴目狗耳 — 假靈 /ca⁵ mag⁸ gao² hin⁶ — gê² lêng⁵/ 目雕的眼睛看不見，狗一般耳朵卻很靈，聽風是雨。</li>\n<li>雞跤長鴨跤短 — 有懸下 /goi¹ ka¹ dng⁵ ah⁴ ka¹ dê² — u⁶ guain⁵ gê⁶/ 雞腳長，鴨腳短，有高有矮。</li>\n<li>爐底碳 — 塊塊通 /lao⁵ doi² tuan³ — dê⁷ dê⁷ tang³/ 百事通</li>\n<li>孥囝食奶 — 坐亭 /nao⁶ gian² ziah⁸ nê¹ — zê⁶ dêng⁵/ 亭，直。</li>\n<li>菜頭面刺無血 — 面皮厚 /cai³ tao⁵ ming¹ ci³ bho⁵ hoih⁴ — ming¹ poi⁵ gao⁶/</li>\n<li>褪褲放屁 — 假工夫 /tng³ kao³ bang³ pui³ — gê² gang¹ hu¹/</li>\n<li>竹葉包沙 — 假壯 /dêg⁴ hio² bao¹ sua¹ — gê² zang³/ 壯，與「粽」諧音。</li>\n<li>元宵燈籠 — 一肚火 /nguang⁵ siao¹ dêng¹ lang⁵ — zêg⁸ dao² hoi²/</li>\n<li>半天吊燈籠 —四搭无向 /buan³ tin¹ diao³ dêng¹ lang⁵ — si³ dah⁴ bho⁵ hiang³/</li>\n<li>青暝睒鏡 — 無望 /cên¹ mên⁵ iam² gian³ — bho⁵ mo⁷/</li>\n<li>青暝睇天 — 張樣張相 /cên¹ mên⁵ toi² tin¹ — dion¹ ion⁷ dion¹ sion⁷/</li>\n<li>青暝點燈 — 照舊 /cên¹ mên⁵ diam² dêng¹ — zio³ gu⁷/ 對青暝人來說，點不點燈，一切照舊。</li>\n<li>青暝掠魚 — 散摸 /cên¹ mên⁵ liah⁸ hu⁵ — suan³ mong⁵/</li>\n<li>青暝娶母 — 稱重 /cên¹ mên⁵ cua⁷ bhao² — cing³ dang⁶/</li>\n<li>青暝擎手電 — 各人各人善 /cên¹ mên⁵ gia⁵ ciu² diang⁶ — gag⁴ nang⁵ gag⁴ nang⁵ siang⁶/</li>\n<li>青暝睇電影 — 聽聲 /cên¹ mên⁵ toi² diang⁶ ian² — tian¹ sian¹/</li>\n<li>啞人食苦瓜 — 有苦難言 /ê² nang⁵ ziah⁸ kao² goi¹ — u⁶ kao² nang⁵ ngiang⁵/</li>\n<li>啞囝食黃連 — 有苦難言 /ê² gian² ziah⁸ ng⁵ nain⁵ — u⁶ kao² nang⁵ ngiang⁵/</li>\n<li>閻羅王嫁諸母囝 — 鬼正敢愛 /ngiam⁵ lo⁵ uang⁵ gê³ za¹ bhao² gian² — gui² zian³ gan² ain³/</li>\n<li>閻羅王請人 — 鬼正敢食  /ngiam⁵ lo⁵ uang⁵ cian² nang⁵ — gui² zian³ gan² ziah⁸/</li>\n<li>閻羅王賣假貨 — 騙鬼 /ngiam⁵ lo⁵ uang⁵ bhoi⁷ gê² hoi⁷ — piang³ gui²/</li>\n<li>閻羅王出告示 — 無句人話 /ngiam⁵ lo⁵ uang⁵ cug⁴ go³ si⁷ — bho⁵ gu³ nang⁵ oi⁷/</li>\n<li>鬼簿無名 — 免死 /gui² pao⁶ bho⁵ mian⁵ — miang² si²/</li>\n<li>醫生開了棺材舖 — 死活都愛錢 /ui¹ sên¹ kui¹ liao² gua¹ ca⁵ pao⁷ — si² ua² do¹ ain³ zin⁵/</li>\n<li>身長棺材短 — 屈死人 /sing¹ dng⁵ gua¹ ca⁵ dê² — kug⁴ si² nang⁵/</li>\n<li>棺材頭畫老虎 — 驚死人 /gua¹ ca⁵ tao⁵ oi⁷ lao⁶ haon² — gian¹ si² nang⁵/</li>\n<li>歪喙和尚 — 唸無一句正經 /uain¹ cui³ hoi⁵ sion⁷ — niam⁷ bho⁵ zêg⁸ gu³ zian³ gêng⁵/</li>\n<li>師公和尚 — 毋同道 /sai¹ gong¹ hoi⁵ sion⁷ — m⁶ dang⁵ dao⁶/</li>\n<li>和尚抹粉 — 白勞 /hoi⁵ sion⁷ bhuah⁴ hung² — bêh⁸ lu⁵/ 勞，與「驢」諧音。</li>\n<li>和尚擎雨遮 — 無法無天 /hoi⁵ sion⁷ gia⁵ hao⁶ zia¹ — bho⁵ huab⁴ bho⁵ tin¹/ 法，與「髮」諧音。</li>\n<li>橄欖尻川 — 坐毋恬 /gan¹ na² ka¹ cng¹ — zê⁶ m⁶ diam⁷/ 屁股像橄榄一般尖，坐不住。恬，静、定。</li>\n<li>火燒豬頭 — 熟面熟面 /hoi² sio¹ du¹ tao⁵ — sêg⁸ ming⁷ sêg⁸ ming⁷/</li>\n<li>六月芥菜 — 假有心 /lag⁸ ghoih⁸ gua³ cai³ — gê² u⁶ sim¹/</li>\n<li>十月芥菜 — 大䀌心 /zab⁸ ghoih⁸ gua³ cai³ — dua⁷ gêg⁴ sim¹/ 䀌，與「激」諧音。</li>\n<li>六月蕃薯 — 雙死 /lag⁸ ghoih⁸ huang¹ zu⁵ — sang¹ si²/ 雙，與「鬆」諧音。</li>\n<li>阿媽生諸母囝 — 生菇 /a¹ ma² sên¹ za¹ bhao² gian² — sên¹ gao¹/ 生菇，發霉。菇，與「姑」諧音。</li>\n<li>老人跤纏 — 又長又臭 /lao⁶ nang⁵ ka¹ din⁵ — ui⁶ dng⁵ ui⁶ cao³/ 講話囉嗦像老人纏足一樣</li>\n<li>老人食豬跤 — 試味 /lao⁶ nang⁵ ziah⁸ du¹ ka¹ — ci³ bhi⁷/ 嘗試下而已</li>\n<li>老婆跋落水 — 淒涼 /lao⁶ pua⁵ buah⁸ lo² zui² — ci¹ liang⁵/ 跋，絆倒。淒，與「妻」諧音。</li>\n<li>老婆其阿兄 — 痴哥 /lao⁶ pua⁵ gai⁵ a¹ hian¹ — ci¹ go¹/ 痴，與「妻」諧音。</li>\n<li>菜頭粿熱單爿 — 自作多情 /cai³ tao⁵ goi² riah⁸ duan¹ bain⁵ — zu⁶ zag⁴ do¹ cêng⁵/ 菜頭粿，蘿蔔糕。热单爿，切片下鍋油煎，但只煎單邊，上焦下嫩。一頭熱（悅），單戀。</li>\n<li>龍眼核拭尻川 — 賽道行 /nging¹ ain² hug⁸ cih⁴ ka¹ cng¹ — sai³ dao⁶ hang⁵/ 「龍眼核拭尻川」比喻有難度的事情，看各家誰本領強了。</li>\n<li>水仙不開花 — 裝蒜 /zui² siang¹ bug⁴ kui¹ hoi¹ — zng¹ sng³/</li>\n<li>大炮拍麻雀 — 騙伊驚 /dua⁷ pao³ pah⁴ mua⁵ ziah⁴ — piang³ i¹ gian¹/</li>\n<li>有錢買蠓香，無錢買蠓罩 — 會算無會除 /u⁶ zin⁵ bhoi² mang² hion¹, bho⁵ zin⁵ bhoi² mang² dan³ — oi⁶ sng³ bhoi⁶ du⁵/</li>\n<li>天頂滴鳥屎 — 無好相覓 /tin¹ dêng² dig⁴ ziao² sai² — mo² sion¹ coi⁷/</li>\n<li>六月薄殼 — 假大頭 /lag⁸ ghoih⁸ boh⁸ kag⁴ — gê² dua⁷ tao⁵/ 大頭，一種比薄殼略大的小貝類海鮮。假大頭，愛充大頭。</li>\n<li>七角錢二人分 — 毋三毋四 /cig⁴ gag⁴ zin⁵ no⁶ nang⁵ bng¹ — m⁶ san¹ m⁶ si³/</li>\n<li>十二碗圓食賰一粒 — 假客氣 /zab⁸ ri⁶ liab⁸ in⁵ ziah⁸ cung⁵ zêg⁸ liab⁸ — gê² kêh⁴ ki⁷/ 圓，丸子。賰，剩下。</li>\n<li>狗母蛇 — 假靈 /gao² bho² zua⁵ — gê² lêng⁵/ 靈，與「龍」諧音。</li>\n<li>兄獨目弟缺喙 — 大無好樣，細無好相 /hian¹ dog⁸ mag⁸ di⁶ koih⁴ cui³ — dua⁷ bho⁵ ho² ion⁷, soi³ bho⁵ ho² sion³/</li>\n<li>山螟咬尾 — 食家己 /suan¹ mê¹ ga⁶ bhoi² — ziah⁸ ga¹ gi⁷/</li>\n<li>風吹牆頭草 — 就勢倚勢 /hong¹ coi¹ ciong⁵ tao⁵ cao² — ziu⁶ si³ ua² si³/</li>\n<li>老鼠跋落粟倉 — 倒好 /ngiao² cu² buah⁸ lo² cêg⁴ cng¹ — do³ ho²/</li>\n<li>老鼠心肝 — 頭食頭搬 /ngiao² cu² sim¹ guan¹ — tao⁵ ziah⁸ tao⁵ buan⁵/</li>\n<li>孥囝拍炮 — 又驚又好 /nao⁵ gian² pah⁴ pao⁷ — ui⁶ gian¹ ui⁶ hao⁷/</li>\n<li>五行缺一 — 欠金 /ngao⁶ hêng⁵ koih⁴ ig⁴ — kiang³ gim¹/</li>\n<li>茂生進酒 — 厚情 /mao⁶ sêng¹ zing³ ziu² — gao⁶ cêng⁵/</li>\n<li>食人雞肉還人豬肉 — 物來物去 /ziah⁸ nang⁷ goi¹ nê² hain⁵ nang⁷ du¹ nê² — moih⁸ lai⁵ moih⁸ ko³/</li>\n<li>刀截蕹菜 — 二頭空 /do¹ zoi² êng³ cai³ — no⁶ tao⁵ kong¹/</li>\n<li>三個半錢 — 趕勢 /san¹ gai⁵ buan³ zin⁵ — guan² si³/ 勢，與「四」諧音。</li>\n<li>隔暝皇帝 — 無權勢 /gêh⁴ mê⁵ huang⁵ di⁷ — bho⁵ kuang⁵ si³/</li>\n<li>大肚水蛙 — 假鮭 /dua⁷ dao² zui² goi¹ — gê² guai¹/ 水蛙，青蛙。鮭，河魨。</li>\n<li>五月龍船 — 相鬥 /ngao⁶ ghoih⁸ lêng⁵ zung⁵ — sion¹ dao³/</li>\n<li>燈籠照路 — 目前光 /dêng¹ lang⁵ zio³ lao⁷ — mag⁸ zain⁵ gng¹/ 比喻目光短淺</li>\n<li>暗室穿針 — 難過 /am³ sig⁴ cng¹ zam¹ — nang⁵ goi³/</li>\n<li>嫁諸母囝娶新婦 — 出入平安 /gê³ za¹ bhao² gian² cua⁷ sing¹ bu⁶ — cug⁴ rib⁸ pêng⁵ ang¹/ 安，與「翁」諧音。</li>\n<li>過關送文憑 — 做人情 /goi³ guan¹ sang³ bhung⁵ pêng⁵ — zo³ nang⁵ zian⁵/</li>\n<li>火燒草料場 — 事出有因 /hoi² sio¹ cao² liao⁷ dion⁵ — su⁷ cu⁷ u⁶ ing¹/ 因，與「煙」諧音。</li>\n<li>黑白電視 — 無彩 /hêg⁴ bêh⁸ dian⁶ si⁶ — bho⁵ cain²/ 無彩，可惜。</li>\n<li>小郎遇著雨 — 積惡 /sio² nng⁵ ngo⁶ dioh⁴ hao⁶ — zêg⁴ ag⁴/ 小郎，女子稱呼丈夫的弟弟。積惡，可憐；罪惡。積，與「叔」諧音。惡，與「沃」諧音。</li>\n</ol>\n<h3 id=\"🙂禮貌用語-li²-mao⁶-eng³-ngo²\"><a href=\"#🙂禮貌用語-li²-mao⁶-eng³-ngo²\" class=\"headerlink\" title=\"🙂禮貌用語(li² mao⁶ êng³ ngo²)\"></a>🙂禮貌用語(li² mao⁶ êng³ ngo²)</h3><ol>\n<li>汝食饱未 /lu² ziah⁸ ba² bhoi⁷/ 你吃飽了嗎</li>\n<li>汝愛去底地 /lu² ain³ ku³ di⁷ dê⁷/ 你要去哪裏</li>\n<li>汝好 /lu² ho²/ 你好</li>\n<li>㩼謝 /zoi⁷ sia⁷/ 多謝</li>\n<li>寬行 /kuan¹ gian⁵/ 慢走</li>\n<li>寬駛 /kuan¹ sai²/ 慢點開車</li>\n<li>对毋住 /dui³ m⁶ zu⁶/ 对不起</li>\n<li>对毋起 /dui³ m⁶ ki²/ 对不起</li>\n<li>無相干 /bho⁵ siang¹ gang¹/ 沒關係</li>\n<li>毋知頭 /m⁶ zai¹ tao⁵/ 不是故意的</li>\n<li>先這呾 /sain¹ zion² dan³/ 回頭再聊 </li>\n<li>萬事應想 /mang⁷ su⁷ êng³ sion⁶/ 萬事如意</li>\n<li>生理大趁 /sêng¹ li² dua⁷ tang⁷/ 生意興隆</li>\n<li>新年大趁 /sing¹ ni⁵ dua⁷ tang⁷/ 新年大賺</li>\n<li>新年合想 /sing¹ ni⁵ gah⁴ sion⁶/ 新年如意</li>\n<li>大吉大利 /dai⁶ gig⁴ dai⁶ li⁶/</li>\n</ol>\n<h3 id=\"🤐粗話-cao¹-oi⁷\"><a href=\"#🤐粗話-cao¹-oi⁷\" class=\"headerlink\" title=\"🤐粗話(cao¹ oi⁷)\"></a>🤐粗話(cao¹ oi⁷)</h3><ol>\n<li>咒誓 /ziu³ zua⁷/ 發誓、詛咒</li>\n<li>痟 /siao²/ 神經錯亂</li>\n<li>神經 /sing⁵ gêng¹/</li>\n<li>腦孬 /nao² mo³/ 腦子壞了</li>\n<li>破脑囝 /puah⁸ nao² gian²/ 弱智</li>\n<li>肚痛 /dao² tian³/ 「問候」別人是否肚子痛所以一直在叫。</li>\n<li>鬼叫 /gui² gio⁷/ 「問候」別人是否聽到鬼在叫。</li>\n<li>哭 cang¹ 哭 nain⁵ // 又哭又喊，吵死人了。</li>\n<li>哭父死母 /kao³ bê⁶ si² bho²/ 「問候」別人是否父母過世所以一直在哭叫。</li>\n<li>咋死人 /zag⁴ si² nang⁵/ 吵死了</li>\n<li>鬼囝 /gui² gian²/ 小鬼</li>\n<li>鬼卒囝 /gui² zug⁴ gian²/ 小鬼</li>\n<li>鬼然然 /gui² riang⁵ riang⁵/ 像鬼一樣</li>\n<li>鬼囉作禍 /gui² lo⁷ zo³ ho³/ 鬼在作祟、作怪</li>\n<li>妖怪精 /iao¹ guai³ zian¹/</li>\n<li>去死掉掉 /ku³ si² diao³ diao³/</li>\n<li>散哭父 /suan⁷ kao³ bê⁶/ 散，到處。</li>\n<li>吐屎 /tao³ sai²/ 亂說</li>\n<li>卵屎人 /lang⁶ sai² nang⁵/ 屌絲，沒前途的人。</li>\n<li>卵屎話 /lang⁶ sai² oi⁷/ 廢話</li>\n<li>臭喙卵面 /cao³ cui³ lang⁶ ming⁷/ 亂說、討人厭。</li>\n<li>關汝卵事 /guang¹ lu² lang⁶ dai⁷/ 與你何干</li>\n<li>膣精 /zi¹ zian¹/ 多管閒事</li>\n<li>臭膣 /cao³ zi¹/ 臭婊子</li>\n<li>豺狗 /sai² gao²/ 狗腿子</li>\n<li>怪卵 /guai³ lang⁶/ 古怪</li>\n<li>無卵 /bho⁵ lang⁶/ 沒膽量</li>\n<li>無腦 /bho⁵ nao²/ 沒腦子</li>\n<li>𠀾好 /bhoi⁶ ho²/ 咒別人倒霉</li>\n<li>痞囝 /pai² gian²/ 痞子、流氓。</li>\n<li>肏母囝 /pu² bho² gian²/</li>\n<li>早死囝 /za² si² gian²/</li>\n<li>短命囝 /dê² mian⁷ gian²/、/dêng² mian⁷ gian²/</li>\n<li>破家囝 /pua⁷ gê¹ gian²/ 败家子</li>\n<li>內仙囝  /lai⁶ siang¹ gian²/ 難伺候</li>\n<li>十惡囝 /zab⁸ ag⁴ gian²/ 十惡不赦</li>\n<li>棺材囝 /gua¹ ca⁵ gian²/</li>\n<li>痴哥囝 /ci¹ go¹ gian²/ 色狼</li>\n<li>吐血死囝 /tao³ hoih⁴ si² gian²/</li>\n<li>替人死囝 /toi⁵ nang⁵ si² gian²/</li>\n<li>半路死囝 /buan³ lao⁷ si² gian²/</li>\n<li>祭屎祭䷀ /zi³ sai² zi³ hê⁷/ 亂吃東西</li>\n<li>乞鬼侵著 /koh⁴ gui² cin⁵ dioh⁴/ 鬼上身了。乞，給。侵，本讀 /cim⁵/，音變爲 /cin⁵/，附身。</li>\n</ol>\n<h3 id=\"🧨娛樂-ngo⁵-log⁸\"><a href=\"#🧨娛樂-ngo⁵-log⁸\" class=\"headerlink\" title=\"🧨娛樂(ngo⁵ log⁸)\"></a>🧨娛樂(ngo⁵ log⁸)</h3><ol>\n<li>耍遊戲 /sng² iu⁵ hi³/ 玩遊戲</li>\n<li>䷀箭 /diong³ zin³/ 射箭</li>\n<li>䷀珠 /diong³ zu¹/ 打彈珠</li>\n<li>彈槍 /duan⁷ ciong¹/ 開槍</li>\n<li>跳索 /tiao³ soh⁴/ 跳繩</li>\n<li>踏孔 /dah⁸ kong²/ 捉迷藏</li>\n<li>泅水 /siu⁵ zui²/ 游泳</li>\n<li>釣魚 /dio³ hu⁵/</li>\n<li>掠魚 /liah⁸ hu⁵/ 抓魚</li>\n<li>行棋 /gian⁵ gi⁵/ 下棋</li>\n<li>放風箏 /bang³ hong¹ zêng¹/</li>\n<li>拍連炮 /pah⁴ liang⁵ pao³/ 放鞭炮</li>\n<li>扣人囝 /kob⁴ nang⁵ gian²/ 人囝，也叫公仔紙、洋畫，舊時供兒童玩樂用的紙牌。</li>\n<li>沃花 /ag⁴ hoi¹/ 澆花</li>\n<li>做戲 /zo³ hi³/ 演戲劇</li>\n</ol>\n<h3 id=\"⛩-神明-sing⁵-meng⁵\"><a href=\"#⛩-神明-sing⁵-meng⁵\" class=\"headerlink\" title=\"⛩ 神明(sing⁵ mêng⁵)\"></a>⛩ 神明(sing⁵ mêng⁵)</h3><ol>\n<li>天地父母 // 天地，原始信仰。</li>\n<li>月娘 // 月球，原始信仰。</li>\n<li>媽祖 // 原名林默，南海保護神，在甲子天后宮有供。</li>\n<li>七聖娘 // 又稱七星娘娘、七聖夫人，是織女神分化出的七位仙女，是兒童保護神。</li>\n<li>觀音娘 // 觀音菩薩</li>\n<li>慈悲娘 // 即普悲觀音，觀音菩薩化身之一（傳說觀音菩薩有三十三化身），普遍施給眾生慈悲。</li>\n<li>註生娘 // 全稱「大慈大悲救苦救難送子娘娘」，主管懷孕與生育。</li>\n<li>佛祖 // 釋迦牟尼佛，姓喬達摩，名悉達多，古印度思想家、教育家、宗教改革家，佛教的創始人。</li>\n<li>達摩祖師 // 南天竺人或波斯人，將佛教禪宗帶入中國，爲中國禪宗之開創者。</li>\n<li>元天上帝 // 玄武大帝，象徵北極星與二十八宿中的北宮玄武，爲統理北方之道教大神。</li>\n<li>水仙大帝 // 水仙尊王，海神之一，媽祖的從神之一。</li>\n<li>汾陽王帝 // 郭子儀，華州鄭縣（今陝西渭南市華州區）人，唐朝名將，平定安史之亂，封汾陽郡王。此人富貴壽考，權極一時，甲子天后宮媽祖廟有供之。</li>\n<li>王公 // 指隴尾王爺、王爺公，名鄒普勝，麻城花橋（今屬湖北）人，元末農民起義軍將領，陳友諒軍師。朱元璋建立明朝後流浪到甲子地區，爲甲子地區改造「風水」等，今甲子隴尾王爺廟有供之，大年初四在此求「落馬簽」。</li>\n<li>關公 // 關羽，河東郡解縣（今山西省運城市鹽湖區解州鎮）人，三國時期名將，與劉備、張飛桃園三結義。又稱伽藍老爺、伽藍尊者，是寺廟、道場守護神，也有稱之爲武財神。</li>\n<li>八仙公 // 傳說中的八位仙人，爲漢鍾離、張果老、韓湘子、鐵拐李、曹國舅、呂洞賓、藍采和、何仙姑八人。</li>\n<li>伯公 // 福德老爺、土地公。</li>\n<li>五穀公 // 神農大帝，相傳其發明耒耜，教民耕種五穀，並能以百草為民治病。農曆十月十五拜之。</li>\n<li>城隍公 // 古代城鎮保護神。</li>\n<li>皇帝公 // 南宋小皇帝趙昰，曾流亡到甲子待渡山。</li>\n<li>灶公 // 灶君，主掌廚房和飲食的神。</li>\n<li>百姓公 // 無主死者，集中掩埋於百姓公墓，稱爲百姓公(媽)，其中多喪於 1943 年的大飢荒，其時僅甲子一鎮亡者就近 2 萬人，慘絕。</li>\n<li>地主爺 // 住宅的守護靈。</li>\n<li>財神爺 // 常指陝西終南山的玄壇真君趙公明，也指關聖帝君關羽。</li>\n<li>三山國王 // 指現揭西縣河婆鎮北面的三座山——巾山、明山、獨山的三位山神。</li>\n</ol>\n<h2 id=\"風俗-hong¹-sioh⁸\"><a href=\"#風俗-hong¹-sioh⁸\" class=\"headerlink\" title=\"風俗(hong¹ sioh⁸)\"></a>風俗(hong¹ sioh⁸)</h2><ol>\n<li>大年初一：食齋菜（菠薐菜、粉絲、菜頭丸、豆腐乾）。</li>\n<li>人日(正月初七)：食七樣菜（厚合、蒜仔、芥藍、高麗菜、真珠菜、香菜、大菜芯）。</li>\n<li>元宵(正月十五)：食蔗。</li>\n<li>三月初三：食青草飯（雞屎藤、伸筋藤、苦刺心、臭草心、蠟裏葉、四方枝苦楝葉）。</li>\n<li>清明：食硬殼餅，掃墓掛紙。</li>\n<li>佛誕(四月初八)：食飯茶。</li>\n<li>端午：食梔粽、梔粿，洗午時水。</li>\n<li>七月初七：出花園。</li>\n<li>中秋：食月餅、芋頭、蔗。</li>\n<li>重陽(九月初九)：食雞湯。</li>\n<li>冬節：食冬節丸、羊肉。</li>\n<li>三十夜、廿九夜：食團圓飯、送壓腰錢（dêh⁴ io¹ zin⁵, 壓歲錢）。</li>\n</ol>\n<h2 id=\"歷史-leg⁸-su²\"><a href=\"#歷史-leg⁸-su²\" class=\"headerlink\" title=\"歷史(lêg⁸ su²)\"></a>歷史(lêg⁸ su²)</h2><ol>\n<li><p>甲子的名號是因爲港後有六十塊大石頭，應了干支紀年法一甲子的數目，故名。</p>\n</li>\n<li><p>漢文帝時曾派遣大臣陸賈（約公元前240年～公元前170年）到南越國，期間命令將士調查海岸線，到過甲子門。</p>\n</li>\n<li><p>三國時，吳侯孫權派遣將軍衛溫（？～231年）攻打福建、琉球和台灣（夷州），被風雨刮到甲子門。</p>\n</li>\n<li><p>南宋乾道五年(1169)，承奉郎致仕范有仁建順濟橋，橋從大膽山腳(今東宮社轄區)跨越瀛江到後庭（今甲東鎮雨亭村轄區）。</p>\n<p> <img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2084.png\" alt=\"順濟橋（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）\"></p>\n</li>\n<li><p>宋嘉定甲申年(1224)，南宋承奉郎范良臣（范有仁之孫）登腹石山，因山對面可見甲子門奇石十八，屹立如人，遂刻「登瀛」二字於石，取十八學士登瀛洲之義。</p>\n</li>\n<li><p>1276 年，元兵攻陷南宋京城臨安，南宋擁立幼帝趙昰，從福州乘船經福建沿海入廣東，於冬十二月抵甲子門腹石山（後人爲紀念此事，更山名爲待渡山），范良臣給軍食三日，留帝像登瀛石上。</p>\n</li>\n<li><p>1277 年正月，漁民鄭復組織義兵509人乘船護送宋帝昺及隨臣去崖門。途中在現珠海橫琴島和澳門與元兵相遇，十六日宋室全軍覆滅，陸秀夫背幼帝昺投海自盡，鄭復等在激戰中全部士兵犧牲。</p>\n</li>\n<li><p>明永樂六年(1408)，順濟橋被拆。因「指揮花茂奉旨建甲子所，慮倭寇泊海易渡，拆之以為城基。」</p>\n</li>\n<li><p>明嘉靖三十九年(1560)，八萬洞資首黃啓薦扎寨惠來冰山頭（今邦山村）攻陷甲子所城，城中居民移至龍溪都（今惠來隆江以南）為逃避倭禍而暫居，該城之難民，慘遭殺害者甚眾，婦女被擄掠，有的全家罹難。</p>\n</li>\n<li><p>明隆慶二年(1568)，倭寇入侵甲子，千戶馬壽麻痹輕敵，城被攻陷，甲子和龍溪都一帶受害慘重。馬壽因失職罪下獄，死於獄中。</p>\n</li>\n<li><p>明隆慶四年(1570)，大旱，入春至初夏，天無滴雨，時又常遭賊寇蹂躪，田園拋荒，赤地千里，人民苦不堪言。</p>\n</li>\n<li><p>明隆慶四年(1570)九月，曾作倭寇嚮導之海寇楊老復，率賊眾攻陷甲子所城，擄掠男女上船，千戶董（佚名）戰死。次日，船遇颱風，賊與被擄者均溺死。</p>\n</li>\n<li><p>隆慶五年(1571)七月，海盜林道乾（又名林鳳，惠來人），於龍溪都一帶擄民劫捨，後聞朝廷將派兵進剿，遂遠循至甲子一帶搶劫，攻破新寨，劫擄李棠，其妻卓氏攜二子上船換夫歸，遂投海殉節。後朝廷封為「南海夫人」。</p>\n</li>\n<li><p>明萬曆二十六年(1598)，湯顯祖作《牡丹亭》，其第六齣中有詞句「榕樹梢頭訪古台，下看甲子海門開。越王歌舞今何在？時有鷓鴣飛去來。」</p>\n</li>\n<li><p>明萬曆二十八年(1600)八月二十三日，惠來及甲子一帶地震。</p>\n</li>\n<li><p>明萬曆三十三年(1605)三月，惠來及甲子一帶地震，七月初三至初七颱風暴雨，沿海田舍淹沒。</p>\n</li>\n<li><p>明萬曆三十五年(1607)，參將張萬紀、守備胡文烜在待渡山下建宋帝亭，即進食亭。</p>\n</li>\n<li><p>明萬曆四十二年(1620)春正月，海盜袁八老余黨林新老入甲子沃，把總金允武出戰死之。</p>\n</li>\n<li><p>明天啓七年(1627)三月，海寇入甲子門，守備葉台死亡。</p>\n</li>\n<li><p>明崇禎八年(1635)，海寇劉香攻陷甲子，擄去守道洪雲蒸。閩粵大兵突至，洪遇害，後劉香被擄伏誅。</p>\n</li>\n<li><p>明崇禎十四年(1641)十二月十四日夜，惠來地震，波及甲子。</p>\n</li>\n<li><p>民國32年(1943，癸未年)，甲子乃至整個海陸豐地區、潮汕地區遭遇大飢荒，時兵災、旱災、蝗災和瘟疫，餓殍遍野，僅甲子一鎮亡者就近 2 萬，佔當時鎮人口逾 45%。</p>\n</li>\n<li><p>1966年，中國大陸爆發文化大革命，「破四舊」。次年，有360年歷史的進食亭被炸毀！</p>\n</li>\n<li><p>2004年夏～2005年秋，甲子諸賢達捐資重建了進食亭。</p>\n</li>\n<li><p>2013年12月29日凌晨，廣東警方出動3000多人的警力對有「毒品村」之稱的甲西鎮博社村開展清繳行動，當天繳獲近3噸冰毒，抓捕180多名涉毒犯罪嫌疑人，原村委書記蔡東家名列其中。</p>\n</li>\n</ol>\n<h2 id=\"建置-giang³-di³\"><a href=\"#建置-giang³-di³\" class=\"headerlink\" title=\"建置(giang³ di³)\"></a>建置(giang³ di³)</h2><ol>\n<li><p>秦以前：屬南越國</p>\n</li>\n<li><p>秦：屬南海郡之博羅縣</p>\n</li>\n<li><p>漢：屬博羅縣</p>\n</li>\n<li><p>三國：屬博羅縣</p>\n</li>\n<li><p>晉：咸和六年（326）析博羅，置海豐縣，屬东官郡</p>\n</li>\n<li><p>宋：屬海豐縣</p>\n</li>\n<li><p>齊：屬海豐縣</p>\n</li>\n<li><p>梁：屬海豐縣</p>\n</li>\n<li><p>陳：屬海豐縣</p>\n</li>\n<li><p>隋：海豐縣屬循州</p>\n</li>\n<li><p>唐：海豐縣屬循州。武德五年（622）析置安陸縣；貞觀元年（627）復歸海豐縣。</p>\n</li>\n<li><p>五代：大寶元年（958）海豐縣属祯州。</p>\n</li>\n<li><p>宋：海豐縣屬祯州。天禧五年（1021）屬惠州。</p>\n</li>\n<li><p>元：海豐縣屬惠州路。</p>\n</li>\n<li><p>明：海豐縣屬惠州府。洪武二十七年(1394)，置甲子守禦千戸所，隸屬碣石衛。嘉靖三年（1524）海豐划出龍溪都、潮州府析出潮陽縣合置惠來縣。</p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2085.png\" alt=\"甲子所城範圍（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）\"></p>\n</li>\n<li><p>清：海豐縣屬惠州府。雍正九年（1731）海豐划出石帆（甲子屬石帆都）、吉康、坊廓3都置陸豐縣，並裁甲子所設立甲子巡檢司。</p>\n</li>\n<li><p>中華民國：陸豐縣屬潮循道。</p>\n</li>\n<li><p>中華人民共和國：1957年甲子鎮劃出甲東鎮、甲西鎮（取甲子之東、甲子之西義）；1958年鎮改爲人民公社，陸豐縣屬汕頭地區；1983年陸豐屬惠陽地區；1980年成立甲子鎮人民政府；1988年陸豐縣改屬汕尾市；1995年陸豐撤縣建市。</p>\n</li>\n</ol>\n<h2 id=\"拼音方案-peng³-im¹-huang¹-uan³\"><a href=\"#拼音方案-peng³-im¹-huang¹-uan³\" class=\"headerlink\" title=\"拼音方案(pêng³ im¹ huang¹ uan³)\"></a>拼音方案(pêng³ im¹ huang¹ uan³)</h2><h3 id=\"聲母表-sian¹-bho²-biao²\"><a href=\"#聲母表-sian¹-bho²-biao²\" class=\"headerlink\" title=\"聲母表(sian¹ bho² biao²)\"></a>聲母表(sian¹ bho² biao²)</h3><p>格式：<code>聲母 [國際音標] 例字</code></p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png\" alt></p>\n<h3 id=\"韻母表-ung¹-bho²-biao²\"><a href=\"#韻母表-ung¹-bho²-biao²\" class=\"headerlink\" title=\"韻母表(ung¹ bho² biao²)\"></a>韻母表(ung¹ bho² biao²)</h3><p>格式：<code>韻母 [國際音標] 例字 / 入聲韻 [國際音標] 例字</code></p>\n<p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png\" alt></p>\n<h3 id=\"聲調-sian¹-diao⁶\"><a href=\"#聲調-sian¹-diao⁶\" class=\"headerlink\" title=\"聲調(sian¹ diao⁶)\"></a>聲調(sian¹ diao⁶)</h3><p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png\" alt></p>\n<h3 id=\"變調-biang³-diao⁶\"><a href=\"#變調-biang³-diao⁶\" class=\"headerlink\" title=\"變調(biang³ diao⁶)\"></a>變調(biang³ diao⁶)</h3><p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png\" alt></p>\n<h2 id=\"地圖-di⁷-dao⁵\"><a href=\"#地圖-di⁷-dao⁵\" class=\"headerlink\" title=\"地圖(di⁷ dao⁵)\"></a>地圖(di⁷ dao⁵)</h2><p><img src=\"/language/min/gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg\" alt=\"三甲地區（來源：騰訊地圖）\"></p>"}],"PostAsset":[{"_id":"source/_posts/essay/think-about-me/IMG_4140.JPG","slug":"IMG_4140.JPG","post":"cl5qxxlen00081n9k5qarexpw","modified":0,"renderable":0},{"_id":"source/_posts/music/listen-chopin-raindrop/cdefgab.jpg","slug":"cdefgab.jpg","post":"cl5qxxleq000b1n9kaucd99vp","modified":0,"renderable":0},{"_id":"source/_posts/music/listen-chopin-raindrop/piano-keys.gif","slug":"piano-keys.gif","post":"cl5qxxleq000b1n9kaucd99vp","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3717.jpg","slug":"IMG_3717.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3721.jpg","slug":"IMG_3721.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3726.jpg","slug":"IMG_3726.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3730.jpg","slug":"IMG_3730.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3732.jpg","slug":"IMG_3732.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3734.jpg","slug":"IMG_3734.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3736.jpg","slug":"IMG_3736.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3739.jpg","slug":"IMG_3739.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3742.jpg","slug":"IMG_3742.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3744.jpg","slug":"IMG_3744.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3751.jpg","slug":"IMG_3751.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3763.jpg","slug":"IMG_3763.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3766.jpg","slug":"IMG_3766.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3768.jpg","slug":"IMG_3768.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/essay/visit-qinghui-garden/IMG_3778.jpg","slug":"IMG_3778.jpg","post":"cl5qxxler000d1n9k479p1p3a","modified":0,"renderable":0},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/3-views-data.png","slug":"3-views-data.png","post":"cl5qxxleu000h1n9keyz3f3ar","modified":0,"renderable":0},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/3-views-processing.png","slug":"3-views-processing.png","post":"cl5qxxleu000h1n9keyz3f3ar","modified":0,"renderable":0},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/4+1-views.png","slug":"4+1-views.png","post":"cl5qxxleu000h1n9keyz3f3ar","modified":0,"renderable":0},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/5-views.png","slug":"5-views.png","post":"cl5qxxleu000h1n9keyz3f3ar","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3826.jpg","slug":"IMG_3826.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3829.jpg","slug":"IMG_3829.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3853.jpg","slug":"IMG_3853.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3860.jpg","slug":"IMG_3860.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3874.jpg","slug":"IMG_3874.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3886.jpg","slug":"IMG_3886.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3912.jpg","slug":"IMG_3912.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3916.jpg","slug":"IMG_3916.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3925.jpg","slug":"IMG_3925.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3929.jpg","slug":"IMG_3929.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3931.jpg","slug":"IMG_3931.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3934.jpg","slug":"IMG_3934.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3937.jpg","slug":"IMG_3937.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3956.jpg","slug":"IMG_3956.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3957.jpg","slug":"IMG_3957.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3965.jpg","slug":"IMG_3965.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3976.jpg","slug":"IMG_3976.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3979.jpg","slug":"IMG_3979.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/essay/seeing-and-hearing-in-guilin/IMG_3985.jpg","slug":"IMG_3985.jpg","post":"cl5qxxlel00041n9k3ybpf0lo","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 1.png","slug":"Untitled 1.png","post":"cl5qxxlex000m1n9kechf3lf9","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 2.png","slug":"Untitled 2.png","post":"cl5qxxlex000m1n9kechf3lf9","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 3.png","slug":"Untitled 3.png","post":"cl5qxxlex000m1n9kechf3lf9","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled.png","slug":"Untitled.png","post":"cl5qxxlex000m1n9kechf3lf9","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-tool-pprof/callgraph.png","slug":"callgraph.png","post":"cl5qxxlez000r1n9k1o8h2rnj","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-scheduler/mpg.png","slug":"mpg.png","post":"cl5qxxlf0000u1n9kcfc955du","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-scheduler/steal.jpg","slug":"steal.jpg","post":"cl5qxxlf0000u1n9kcfc955du","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-scheduler/syscall.jpg","slug":"syscall.jpg","post":"cl5qxxlf0000u1n9kcfc955du","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled 1.png","slug":"Untitled 1.png","post":"cl5qxxlex000n1n9kejwo7ble","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled 2.png","slug":"Untitled 2.png","post":"cl5qxxlex000n1n9kejwo7ble","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled.png","slug":"Untitled.png","post":"cl5qxxlex000n1n9kejwo7ble","modified":0,"renderable":0},{"_id":"source/_posts/language/min/how-to-select-pinyin-for-minnan-language/W系統和C系統.jpeg","slug":"W系統和C系統.jpeg","post":"cl5qxxlf200101n9kc10m1m16","modified":0,"renderable":0},{"_id":"source/_posts/language/min/how-to-select-pinyin-for-minnan-language/聲母.png","slug":"聲母.png","post":"cl5qxxlf200101n9kc10m1m16","modified":0,"renderable":0},{"_id":"source/_posts/language/min/how-to-select-pinyin-for-minnan-language/聲調.png","slug":"聲調.png","post":"cl5qxxlf200101n9kc10m1m16","modified":0,"renderable":0},{"_id":"source/_posts/language/min/how-to-select-pinyin-for-minnan-language/韻母.png","slug":"韻母.png","post":"cl5qxxlf200101n9kc10m1m16","modified":0,"renderable":0},{"_id":"source/_posts/language/min/nang-tu-kang-im/ang.jpg","slug":"ang.jpg","post":"cl5qxxlfi002m1n9k7l3q8948","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-kahtsi-vowel/202010042112.png","slug":"202010042112.png","post":"cl5qxxlfm002r1n9kb6zsa5jv","modified":0,"renderable":0},{"_id":"source/_posts/language/min/sigêng-giamgia/202010060948.jpg","slug":"202010060948.jpg","post":"cl5qxxlfk002p1n9kcobp0u87","modified":0,"renderable":0},{"_id":"source/_posts/language/min/sigêng-giamgia/蒹葭.m4a","slug":"蒹葭.m4a","post":"cl5qxxlfk002p1n9kcobp0u87","modified":0,"renderable":0},{"_id":"source/_posts/language/min/tsheng-pheng-ngak-tshng-ku/清平樂·村居.m4a","slug":"清平樂·村居.m4a","post":"cl5qxxlfn002w1n9k9q12070l","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png","slug":"2020-10-14-12.41.34.png","post":"cl5qxxlfn002u1n9kh13eeldd","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png","slug":"2020-10-15-1.10.20.png","post":"cl5qxxlfn002u1n9kh13eeldd","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png","slug":"2020-10-15-1.11.30.png","post":"cl5qxxlfn002u1n9kh13eeldd","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png","slug":"2020-10-15-1.12.28.png","post":"cl5qxxlfn002u1n9kh13eeldd","modified":0,"renderable":0},{"_id":"source/_posts/it/common/protobuf-intro/protobuf-field-structure.jpeg","slug":"protobuf-field-structure.jpeg","post":"cl5qxxlfo002z1n9kbg9g7flo","modified":0,"renderable":0},{"_id":"source/_posts/it/common/protobuf-intro/w644.jpeg","slug":"w644.jpeg","post":"cl5qxxlfo002z1n9kbg9g7flo","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 1.png","slug":"Untitled 1.png","post":"cl5qxxlfp00311n9k4xupefeb","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 2.png","slug":"Untitled 2.png","post":"cl5qxxlfp00311n9k4xupefeb","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 3.png","slug":"Untitled 3.png","post":"cl5qxxlfp00311n9k4xupefeb","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 4.png","slug":"Untitled 4.png","post":"cl5qxxlfp00311n9k4xupefeb","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 5.png","slug":"Untitled 5.png","post":"cl5qxxlfp00311n9k4xupefeb","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 6.png","slug":"Untitled 6.png","post":"cl5qxxlfp00311n9k4xupefeb","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled.png","slug":"Untitled.png","post":"cl5qxxlfp00311n9k4xupefeb","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-basic/Untitled 1.png","slug":"Untitled 1.png","post":"cl5qxxlfr00361n9k3dktbace","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-basic/Untitled.png","slug":"Untitled.png","post":"cl5qxxlfr00361n9k3dktbace","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 1.png","slug":"Untitled 1.png","post":"cl5qxxlfq00341n9kg6j17eu9","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 2.png","slug":"Untitled 2.png","post":"cl5qxxlfq00341n9kg6j17eu9","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 3.png","slug":"Untitled 3.png","post":"cl5qxxlfq00341n9kg6j17eu9","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 4.png","slug":"Untitled 4.png","post":"cl5qxxlfq00341n9kg6j17eu9","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 5.png","slug":"Untitled 5.png","post":"cl5qxxlfq00341n9kg6j17eu9","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 6.png","slug":"Untitled 6.png","post":"cl5qxxlfq00341n9kg6j17eu9","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 7.png","slug":"Untitled 7.png","post":"cl5qxxlfq00341n9kg6j17eu9","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 8.png","slug":"Untitled 8.png","post":"cl5qxxlfq00341n9kg6j17eu9","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled.png","slug":"Untitled.png","post":"cl5qxxlfq00341n9kg6j17eu9","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/20201114_101407.png","slug":"20201114_101407.png","post":"cl5qxxlfw00401n9kf5k2cd4u","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/20201202_24328.png","slug":"20201202_24328.png","post":"cl5qxxlfw00401n9kf5k2cd4u","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 1.png","slug":"Untitled 1.png","post":"cl5qxxlfw00401n9kf5k2cd4u","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 2.png","slug":"Untitled 2.png","post":"cl5qxxlfw00401n9kf5k2cd4u","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 3.png","slug":"Untitled 3.png","post":"cl5qxxlfw00401n9kf5k2cd4u","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 4.png","slug":"Untitled 4.png","post":"cl5qxxlfw00401n9kf5k2cd4u","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled.png","slug":"Untitled.png","post":"cl5qxxlfw00401n9kf5k2cd4u","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 1.png","slug":"Untitled 1.png","post":"cl5qxxlfx00411n9k0n8f796r","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 2.png","slug":"Untitled 2.png","post":"cl5qxxlfx00411n9k0n8f796r","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 3.png","slug":"Untitled 3.png","post":"cl5qxxlfx00411n9k0n8f796r","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 4.png","slug":"Untitled 4.png","post":"cl5qxxlfx00411n9k0n8f796r","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 5.png","slug":"Untitled 5.png","post":"cl5qxxlfx00411n9k0n8f796r","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 6.png","slug":"Untitled 6.png","post":"cl5qxxlfx00411n9k0n8f796r","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 7.png","slug":"Untitled 7.png","post":"cl5qxxlfx00411n9k0n8f796r","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 8.png","slug":"Untitled 8.png","post":"cl5qxxlfx00411n9k0n8f796r","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled.png","slug":"Untitled.png","post":"cl5qxxlfx00411n9k0n8f796r","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 1.png","slug":"Untitled 1.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 10.png","slug":"Untitled 10.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 11.png","slug":"Untitled 11.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 12.png","slug":"Untitled 12.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 13.png","slug":"Untitled 13.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 14.png","slug":"Untitled 14.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 15.png","slug":"Untitled 15.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 16.png","slug":"Untitled 16.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 17.png","slug":"Untitled 17.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 18.png","slug":"Untitled 18.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 19.png","slug":"Untitled 19.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 2.png","slug":"Untitled 2.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 20.png","slug":"Untitled 20.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 21.png","slug":"Untitled 21.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 22.png","slug":"Untitled 22.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 23.png","slug":"Untitled 23.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 24.png","slug":"Untitled 24.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 25.png","slug":"Untitled 25.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 26.png","slug":"Untitled 26.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 27.png","slug":"Untitled 27.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 28.png","slug":"Untitled 28.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 29.png","slug":"Untitled 29.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 3.png","slug":"Untitled 3.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 30.png","slug":"Untitled 30.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 31.png","slug":"Untitled 31.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 32.png","slug":"Untitled 32.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 33.png","slug":"Untitled 33.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 34.png","slug":"Untitled 34.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 35.png","slug":"Untitled 35.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 36.png","slug":"Untitled 36.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 37.png","slug":"Untitled 37.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 38.png","slug":"Untitled 38.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 39.png","slug":"Untitled 39.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 4.png","slug":"Untitled 4.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 40.png","slug":"Untitled 40.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 41.png","slug":"Untitled 41.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 42.png","slug":"Untitled 42.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 43.png","slug":"Untitled 43.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 44.png","slug":"Untitled 44.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 45.png","slug":"Untitled 45.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 46.png","slug":"Untitled 46.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 47.png","slug":"Untitled 47.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 48.png","slug":"Untitled 48.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 49.png","slug":"Untitled 49.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 5.png","slug":"Untitled 5.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 50.png","slug":"Untitled 50.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 51.png","slug":"Untitled 51.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 52.png","slug":"Untitled 52.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 53.png","slug":"Untitled 53.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 54.png","slug":"Untitled 54.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 55.png","slug":"Untitled 55.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 56.png","slug":"Untitled 56.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 57.png","slug":"Untitled 57.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 58.png","slug":"Untitled 58.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 59.png","slug":"Untitled 59.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 6.png","slug":"Untitled 6.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 60.png","slug":"Untitled 60.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 61.png","slug":"Untitled 61.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 62.png","slug":"Untitled 62.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 63.png","slug":"Untitled 63.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 64.png","slug":"Untitled 64.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 65.png","slug":"Untitled 65.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 66.png","slug":"Untitled 66.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 67.png","slug":"Untitled 67.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 68.png","slug":"Untitled 68.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 69.png","slug":"Untitled 69.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 7.png","slug":"Untitled 7.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 70.png","slug":"Untitled 70.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 71.png","slug":"Untitled 71.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 72.png","slug":"Untitled 72.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 73.png","slug":"Untitled 73.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 74.png","slug":"Untitled 74.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 75.png","slug":"Untitled 75.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 76.png","slug":"Untitled 76.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 77.png","slug":"Untitled 77.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 78.png","slug":"Untitled 78.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 79.png","slug":"Untitled 79.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 8.png","slug":"Untitled 8.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 80.png","slug":"Untitled 80.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 81.png","slug":"Untitled 81.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 82.png","slug":"Untitled 82.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 83.png","slug":"Untitled 83.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 84.png","slug":"Untitled 84.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 85.png","slug":"Untitled 85.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 9.png","slug":"Untitled 9.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled.png","slug":"Untitled.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png","slug":"gahzi-biang-diao.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png","slug":"gahzi-sian-bho.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png","slug":"gahzi-sian-diao.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png","slug":"gahzi-ung-bho.png","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/image.jpg","slug":"image.jpg","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg","slug":"jiazi-map.jpg","post":"cl5qxxlgl00441n9kf5pl6kip","modified":0,"renderable":0},{"_id":"source/_posts/it/common/software-architecture-and-kants-philosophy/c4-model.jpg","slug":"c4-model.jpg","post":"cl5qxxleu000h1n9keyz3f3ar","modified":1,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cl5qxxled00001n9k2a48cr5n","tag_id":"cl5qxxlej00021n9kgnkj4mcr","_id":"cl5qxxlen00071n9k9kfyesie"},{"post_id":"cl5qxxleh00011n9kftz475pr","tag_id":"cl5qxxlem00061n9k0f976ldo","_id":"cl5qxxler000c1n9kaeccducz"},{"post_id":"cl5qxxlek00031n9kdo0s2ytt","tag_id":"cl5qxxlem00061n9k0f976ldo","_id":"cl5qxxlet000g1n9khdjc5yuw"},{"post_id":"cl5qxxlel00041n9k3ybpf0lo","tag_id":"cl5qxxlem00061n9k0f976ldo","_id":"cl5qxxlez000q1n9khv385mbp"},{"post_id":"cl5qxxlel00041n9k3ybpf0lo","tag_id":"cl5qxxlev000i1n9ka93fbwbk","_id":"cl5qxxlez000s1n9kcxs338tk"},{"post_id":"cl5qxxlel00041n9k3ybpf0lo","tag_id":"cl5qxxlew000l1n9ka0tt3ra2","_id":"cl5qxxlf0000v1n9kbkyg5hwm"},{"post_id":"cl5qxxlem00051n9kgtgyd2ic","tag_id":"cl5qxxlem00061n9k0f976ldo","_id":"cl5qxxlf2000z1n9kgn9w3ibz"},{"post_id":"cl5qxxlem00051n9kgtgyd2ic","tag_id":"cl5qxxlf0000t1n9kfr79cy5x","_id":"cl5qxxlf300111n9kbp8n7r0x"},{"post_id":"cl5qxxlen00081n9k5qarexpw","tag_id":"cl5qxxlem00061n9k0f976ldo","_id":"cl5qxxlf500131n9k6jqq74ix"},{"post_id":"cl5qxxlen00081n9k5qarexpw","tag_id":"cl5qxxlf2000y1n9k3iox2fcy","_id":"cl5qxxlf500141n9kezez0l4f"},{"post_id":"cl5qxxleo00091n9k4y03fo3a","tag_id":"cl5qxxlem00061n9k0f976ldo","_id":"cl5qxxlf500161n9k1x3h5010"},{"post_id":"cl5qxxleo00091n9k4y03fo3a","tag_id":"cl5qxxlf300121n9k6pf4hwzs","_id":"cl5qxxlf500171n9k3qg881jv"},{"post_id":"cl5qxxleq000b1n9kaucd99vp","tag_id":"cl5qxxlf500151n9k012h30c7","_id":"cl5qxxlf600191n9kc17qdj3b"},{"post_id":"cl5qxxler000d1n9k479p1p3a","tag_id":"cl5qxxlem00061n9k0f976ldo","_id":"cl5qxxlf7001d1n9k50pa0nr6"},{"post_id":"cl5qxxler000d1n9k479p1p3a","tag_id":"cl5qxxlev000i1n9ka93fbwbk","_id":"cl5qxxlf7001e1n9k3ysk8tbt"},{"post_id":"cl5qxxler000d1n9k479p1p3a","tag_id":"cl5qxxlf6001a1n9k76krda4w","_id":"cl5qxxlf7001g1n9k3zcyg0di"},{"post_id":"cl5qxxler000d1n9k479p1p3a","tag_id":"cl5qxxlf6001b1n9k20za2s8f","_id":"cl5qxxlf7001h1n9k9gtqhrbx"},{"post_id":"cl5qxxlet000f1n9k0ny19s3z","tag_id":"cl5qxxlf6001c1n9k2pcaadis","_id":"cl5qxxlf8001j1n9ke18ncq5m"},{"post_id":"cl5qxxleu000h1n9keyz3f3ar","tag_id":"cl5qxxlf7001f1n9k0ood8t8n","_id":"cl5qxxlf8001l1n9k4npq5uqo"},{"post_id":"cl5qxxleu000h1n9keyz3f3ar","tag_id":"cl5qxxlf0000t1n9kfr79cy5x","_id":"cl5qxxlf8001m1n9k7rlc8duy"},{"post_id":"cl5qxxlev000j1n9kcajidxol","tag_id":"cl5qxxlf8001k1n9kdvshbj34","_id":"cl5qxxlf9001r1n9kebo83oep"},{"post_id":"cl5qxxlev000j1n9kcajidxol","tag_id":"cl5qxxlf8001n1n9kduac2f92","_id":"cl5qxxlf9001s1n9k37zz4j3y"},{"post_id":"cl5qxxlev000j1n9kcajidxol","tag_id":"cl5qxxlf8001o1n9k4gq69y7y","_id":"cl5qxxlfa001u1n9k1d5tgndy"},{"post_id":"cl5qxxlev000j1n9kcajidxol","tag_id":"cl5qxxlf9001p1n9k2gbsedz7","_id":"cl5qxxlfa001v1n9keltefyct"},{"post_id":"cl5qxxlew000k1n9kfqbbf5ie","tag_id":"cl5qxxlf9001q1n9k7b6pf276","_id":"cl5qxxlfa001x1n9k8q2l8k8y"},{"post_id":"cl5qxxlew000k1n9kfqbbf5ie","tag_id":"cl5qxxlf9001t1n9k6902ad64","_id":"cl5qxxlfa001y1n9k2pmw868d"},{"post_id":"cl5qxxlex000m1n9kechf3lf9","tag_id":"cl5qxxlf9001q1n9k7b6pf276","_id":"cl5qxxlfa00201n9k5ahv05at"},{"post_id":"cl5qxxlex000n1n9kejwo7ble","tag_id":"cl5qxxlf9001q1n9k7b6pf276","_id":"cl5qxxlfb00221n9k0wvi5054"},{"post_id":"cl5qxxley000p1n9ke3sa1p7f","tag_id":"cl5qxxlf9001q1n9k7b6pf276","_id":"cl5qxxlfb00241n9k4wno7ylr"},{"post_id":"cl5qxxlez000r1n9k1o8h2rnj","tag_id":"cl5qxxlf9001q1n9k7b6pf276","_id":"cl5qxxlfc00271n9keihl5quz"},{"post_id":"cl5qxxlez000r1n9k1o8h2rnj","tag_id":"cl5qxxlfb00251n9k3440blk8","_id":"cl5qxxlfc00281n9k7likd0yo"},{"post_id":"cl5qxxlf0000u1n9kcfc955du","tag_id":"cl5qxxlf9001q1n9k7b6pf276","_id":"cl5qxxlfd002a1n9k1jl86nf6"},{"post_id":"cl5qxxlf1000w1n9ke52lf5gs","tag_id":"cl5qxxlf6001b1n9k20za2s8f","_id":"cl5qxxlfe002f1n9kefmd69yt"},{"post_id":"cl5qxxlf1000w1n9ke52lf5gs","tag_id":"cl5qxxlfd002b1n9k7ffu35uy","_id":"cl5qxxlfe002g1n9kblpd3q5t"},{"post_id":"cl5qxxlf1000w1n9ke52lf5gs","tag_id":"cl5qxxlfd002c1n9kd4i9aage","_id":"cl5qxxlfe002i1n9k9ad0cvvt"},{"post_id":"cl5qxxlf1000w1n9ke52lf5gs","tag_id":"cl5qxxlf9001q1n9k7b6pf276","_id":"cl5qxxlff002j1n9kfl4odqqq"},{"post_id":"cl5qxxlf1000x1n9k1w364p19","tag_id":"cl5qxxlfd002e1n9kfks07uhb","_id":"cl5qxxlff002k1n9keqwm922x"},{"post_id":"cl5qxxlf200101n9kc10m1m16","tag_id":"cl5qxxlf6001a1n9k76krda4w","_id":"cl5qxxlff002l1n9k5sou5y1b"},{"post_id":"cl5qxxlfl002q1n9k5znhf7an","tag_id":"cl5qxxlfk002o1n9k5jva6694","_id":"cl5qxxlfn002t1n9k5x7zcwkl"},{"post_id":"cl5qxxlfl002q1n9k5znhf7an","tag_id":"cl5qxxlf6001b1n9k20za2s8f","_id":"cl5qxxlfn002v1n9ka0rd8lqu"},{"post_id":"cl5qxxlfl002q1n9k5znhf7an","tag_id":"cl5qxxlf6001a1n9k76krda4w","_id":"cl5qxxlfo002y1n9kd3nbc5lk"},{"post_id":"cl5qxxlfi002m1n9k7l3q8948","tag_id":"cl5qxxlfk002o1n9k5jva6694","_id":"cl5qxxlfp00301n9ke24719oh"},{"post_id":"cl5qxxlfi002m1n9k7l3q8948","tag_id":"cl5qxxlf6001b1n9k20za2s8f","_id":"cl5qxxlfq00331n9k6m8g4k63"},{"post_id":"cl5qxxlfi002m1n9k7l3q8948","tag_id":"cl5qxxlf6001a1n9k76krda4w","_id":"cl5qxxlfr00351n9kgkp6dth5"},{"post_id":"cl5qxxlfj002n1n9k6p10dnom","tag_id":"cl5qxxlfm002s1n9k7cs9g3c1","_id":"cl5qxxlfr00371n9k6f013fw6"},{"post_id":"cl5qxxlfj002n1n9k6p10dnom","tag_id":"cl5qxxlf6001b1n9k20za2s8f","_id":"cl5qxxlfs00391n9kc5n41pqt"},{"post_id":"cl5qxxlfj002n1n9k6p10dnom","tag_id":"cl5qxxlf6001a1n9k76krda4w","_id":"cl5qxxlfs003a1n9kf2fb9ipj"},{"post_id":"cl5qxxlfn002w1n9k9q12070l","tag_id":"cl5qxxlfm002s1n9k7cs9g3c1","_id":"cl5qxxlfs003c1n9k939596ps"},{"post_id":"cl5qxxlfn002w1n9k9q12070l","tag_id":"cl5qxxlf6001b1n9k20za2s8f","_id":"cl5qxxlfs003d1n9k9bpv0znh"},{"post_id":"cl5qxxlfn002w1n9k9q12070l","tag_id":"cl5qxxlf6001a1n9k76krda4w","_id":"cl5qxxlft003f1n9kdf7wblw4"},{"post_id":"cl5qxxlfk002p1n9kcobp0u87","tag_id":"cl5qxxlfo002x1n9kh5o1e5ge","_id":"cl5qxxlft003g1n9ka1jq197z"},{"post_id":"cl5qxxlfk002p1n9kcobp0u87","tag_id":"cl5qxxlf6001b1n9k20za2s8f","_id":"cl5qxxlft003i1n9kgyi6fi7y"},{"post_id":"cl5qxxlfk002p1n9kcobp0u87","tag_id":"cl5qxxlf6001a1n9k76krda4w","_id":"cl5qxxlft003j1n9k6imu1uxq"},{"post_id":"cl5qxxlfm002r1n9kb6zsa5jv","tag_id":"cl5qxxlf6001a1n9k76krda4w","_id":"cl5qxxlft003l1n9k5s76dnsh"},{"post_id":"cl5qxxlfm002r1n9kb6zsa5jv","tag_id":"cl5qxxlfq00321n9kde163b62","_id":"cl5qxxlft003m1n9k129balp8"},{"post_id":"cl5qxxlfm002r1n9kb6zsa5jv","tag_id":"cl5qxxlf6001b1n9k20za2s8f","_id":"cl5qxxlfu003n1n9kem96c6p3"},{"post_id":"cl5qxxlfr00361n9k3dktbace","tag_id":"cl5qxxlf9001q1n9k7b6pf276","_id":"cl5qxxlfu003p1n9kcyvm2y8y"},{"post_id":"cl5qxxlfn002u1n9kh13eeldd","tag_id":"cl5qxxlfr00381n9kcadj2eah","_id":"cl5qxxlfu003q1n9kbmqd2wv9"},{"post_id":"cl5qxxlfn002u1n9kh13eeldd","tag_id":"cl5qxxlfq00321n9kde163b62","_id":"cl5qxxlfu003s1n9k78q16oiw"},{"post_id":"cl5qxxlfn002u1n9kh13eeldd","tag_id":"cl5qxxlf6001a1n9k76krda4w","_id":"cl5qxxlfv003t1n9k29i9gcbc"},{"post_id":"cl5qxxlfo002z1n9kbg9g7flo","tag_id":"cl5qxxlfs003e1n9k152qfblz","_id":"cl5qxxlfv003u1n9k1t3b6tzx"},{"post_id":"cl5qxxlfo002z1n9kbg9g7flo","tag_id":"cl5qxxlft003h1n9kf6dtfbzv","_id":"cl5qxxlfv003v1n9k7d9wbbak"},{"post_id":"cl5qxxlfo002z1n9kbg9g7flo","tag_id":"cl5qxxlf9001q1n9k7b6pf276","_id":"cl5qxxlfv003w1n9kf1k24blh"},{"post_id":"cl5qxxlfo002z1n9kbg9g7flo","tag_id":"cl5qxxlft003k1n9k6ydt948j","_id":"cl5qxxlfv003x1n9kdu60cb74"},{"post_id":"cl5qxxlfp00311n9k4xupefeb","tag_id":"cl5qxxlft003k1n9k6ydt948j","_id":"cl5qxxlfv003y1n9khqw39tiw"},{"post_id":"cl5qxxlfq00341n9kg6j17eu9","tag_id":"cl5qxxlft003k1n9k6ydt948j","_id":"cl5qxxlfv003z1n9k0yyz1yqe"},{"post_id":"cl5qxxlfw00401n9kf5k2cd4u","tag_id":"cl5qxxlft003k1n9k6ydt948j","_id":"cl5qxxlfx00421n9k00fog9cx"},{"post_id":"cl5qxxlfx00411n9k0n8f796r","tag_id":"cl5qxxlft003k1n9k6ydt948j","_id":"cl5qxxlfy00431n9kachee4js"},{"post_id":"cl5qxxlgl00441n9kf5pl6kip","tag_id":"cl5qxxlf6001b1n9k20za2s8f","_id":"cl5qxxlgn00451n9k1pkb4lzk"},{"post_id":"cl5qxxlgl00441n9kf5pl6kip","tag_id":"cl5qxxlf6001a1n9k76krda4w","_id":"cl5qxxlgn00461n9kddyf81do"}],"Tag":[{"name":"Hello","_id":"cl5qxxlej00021n9kgnkj4mcr"},{"name":"隨筆","_id":"cl5qxxlem00061n9k0f976ldo"},{"name":"遊記","_id":"cl5qxxlev000i1n9ka93fbwbk"},{"name":"普通話","_id":"cl5qxxlew000l1n9ka0tt3ra2"},{"name":"哲學","_id":"cl5qxxlf0000t1n9kfr79cy5x"},{"name":"我思","_id":"cl5qxxlf2000y1n9k3iox2fcy"},{"name":"電影","_id":"cl5qxxlf300121n9k6pf4hwzs"},{"name":"聆聽音樂","_id":"cl5qxxlf500151n9k012h30c7"},{"name":"閩南語","_id":"cl5qxxlf6001a1n9k76krda4w"},{"name":"甲子話","_id":"cl5qxxlf6001b1n9k20za2s8f"},{"name":"net","_id":"cl5qxxlf6001c1n9k2pcaadis"},{"name":"軟件架構","_id":"cl5qxxlf7001f1n9k0ood8t8n"},{"name":"Unicode","_id":"cl5qxxlf8001k1n9kdvshbj34"},{"name":"UTF-8","_id":"cl5qxxlf8001n1n9kduac2f92"},{"name":"UTF-16","_id":"cl5qxxlf8001o1n9k4gq69y7y"},{"name":"BOM","_id":"cl5qxxlf9001p1n9k2gbsedz7"},{"name":"Go","_id":"cl5qxxlf9001q1n9k7b6pf276"},{"name":"TODO","_id":"cl5qxxlf9001t1n9k6902ad64"},{"name":"pprof","_id":"cl5qxxlfb00251n9k3440blk8"},{"name":"十二生肖","_id":"cl5qxxlfd002b1n9k7ffu35uy"},{"name":"干支紀年法","_id":"cl5qxxlfd002c1n9kd4i9aage"},{"name":"日本語","_id":"cl5qxxlfd002e1n9kfks07uhb"},{"name":"魏晉風流","_id":"cl5qxxlfk002o1n9k5jva6694"},{"name":"宋詞","_id":"cl5qxxlfm002s1n9k7cs9g3c1"},{"name":"詩經","_id":"cl5qxxlfo002x1n9kh5o1e5ge"},{"name":"潮州話","_id":"cl5qxxlfq00321n9kde163b62"},{"name":"潮劇","_id":"cl5qxxlfr00381n9kcadj2eah"},{"name":"protobuf","_id":"cl5qxxlfs003e1n9k152qfblz"},{"name":"JSON","_id":"cl5qxxlft003h1n9kf6dtfbzv"},{"name":"Java","_id":"cl5qxxlft003k1n9k6ydt948j"}]}}