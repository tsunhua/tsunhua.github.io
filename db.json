{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/kiss/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/images/moon.jpg","path":"css/images/moon.jpg","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/music.png","path":"music.png","modified":0,"renderable":0},{"_id":"source/qrcode.jpg","path":"qrcode.jpg","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/tip_img.png","path":"tip_img.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/kiss/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1623687047362},{"_id":"themes/kiss/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1623687047362},{"_id":"themes/kiss/LICENSE","hash":"62aacb980e619f9d4f3d1a99fd314536ae3333d8","modified":1623687047362},{"_id":"themes/kiss/README.md","hash":"6bf498ae8b83d9fc9db745c6d0466097b15befc9","modified":1623687047362},{"_id":"themes/kiss/_config.yml","hash":"afbc0a78bd8597a589e6ff3d0d65697112ff63e3","modified":1629728759225},{"_id":"themes/kiss/languages/default.yml","hash":"92b0b4a119d171b6a0074832785dddb715773dd5","modified":1629728038213},{"_id":"themes/kiss/languages/ja.yml","hash":"4b4460d45c4731327f4b08775afc963a508bd0da","modified":1629728069917},{"_id":"themes/kiss/languages/zh-CN.yml","hash":"2c37c7af13aea853a8229348bf350e6d53311e7c","modified":1629728082401},{"_id":"themes/kiss/languages/zh-TW.yml","hash":"9a7a80ae095a9f74377873767b336d2b8f478d10","modified":1629728091321},{"_id":"themes/kiss/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1623687047371},{"_id":"themes/kiss/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1623687047371},{"_id":"themes/kiss/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1623687047371},{"_id":"themes/kiss/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1623687047372},{"_id":"themes/kiss/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1623687047372},{"_id":"themes/kiss/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1623687047372},{"_id":"themes/kiss/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1623687047372},{"_id":"themes/kiss/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1623687047374},{"_id":"themes/kiss/layout/_partial/after-footer.ejs","hash":"c8a0b16aa29466bf4c288b48a4b458b2ac69ada7","modified":1623687047364},{"_id":"themes/kiss/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1623687047364},{"_id":"themes/kiss/layout/_partial/archive.ejs","hash":"e7685a13665c7beb57a62bee010c14ca9d251fc8","modified":1630854289882},{"_id":"themes/kiss/layout/_partial/footer.ejs","hash":"352b4c8e3f6055b7ac6e4685f25e2886c6cd482f","modified":1623687047365},{"_id":"themes/kiss/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1623687047365},{"_id":"themes/kiss/layout/_partial/article.ejs","hash":"f76d3d99a870eb272e02f7d4e6cb286728d65b4d","modified":1623687047364},{"_id":"themes/kiss/layout/_partial/head.ejs","hash":"d5609f083587b5c51f1244a2ae82f319547b105f","modified":1623687047365},{"_id":"themes/kiss/layout/_partial/header.ejs","hash":"fcad9eb622ecdd9ff828b90dc9d41da3aee277f5","modified":1629726577716},{"_id":"themes/kiss/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1623687047365},{"_id":"themes/kiss/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1623687047366},{"_id":"themes/kiss/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1623687047368},{"_id":"themes/kiss/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1623687047368},{"_id":"themes/kiss/layout/_widget/qrcode.ejs","hash":"7b3a20f35593ed9aa26ea15214a6dc269e444100","modified":1623687047369},{"_id":"themes/kiss/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1623687047369},{"_id":"themes/kiss/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1623687047369},{"_id":"themes/kiss/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1629727377677},{"_id":"themes/kiss/layout/_widget/tagcloud.ejs","hash":"439aee1aa676b2acd9510893206193078112ec7e","modified":1629727999960},{"_id":"themes/kiss/layout/_widget/tip.ejs","hash":"d1c3d925c3b878cf62d6149d86559039bb6a115e","modified":1630852802523},{"_id":"themes/kiss/source/css/_extend.styl","hash":"3d0095dfc6c3aaf7028de1aace2599bcb99ede82","modified":1623687047374},{"_id":"themes/kiss/source/css/_variables.styl","hash":"7e1bd5454a16f3d7d249918cf54bbf52796b7ab6","modified":1630853124044},{"_id":"themes/kiss/source/css/style.styl","hash":"d480f717465970cf6dfccdb6d1af18fba16cbdd0","modified":1623687047384},{"_id":"themes/kiss/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1623687047384},{"_id":"themes/kiss/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1623687047384},{"_id":"themes/kiss/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1623687047385},{"_id":"themes/kiss/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1623687047384},{"_id":"themes/kiss/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1623687047385},{"_id":"themes/kiss/package.json","hash":"715a95c1e512473cf2966ef9c5d0873da2bed2d2","modified":1623687047373},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1623687047386},{"_id":"themes/kiss/source/js/script.js","hash":"63c21efc77abda2eec546d66ee832fc9776edabd","modified":1623687047387},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1623687047387},{"_id":"themes/kiss/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1623687047366},{"_id":"themes/kiss/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1623687047366},{"_id":"themes/kiss/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1623687047366},{"_id":"themes/kiss/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1623687047367},{"_id":"themes/kiss/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1623687047368},{"_id":"themes/kiss/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1629727382769},{"_id":"themes/kiss/source/css/_partial/archive.styl","hash":"82f3417081c67faef39660762eef606a147c13b5","modified":1623687047375},{"_id":"themes/kiss/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1623687047375},{"_id":"themes/kiss/source/css/_partial/article.styl","hash":"97b4fa7d074019b61ac39f4a600d6ed17ac1680a","modified":1623687047375},{"_id":"themes/kiss/source/css/_partial/footer.styl","hash":"2fa87c61bd4f464276719a5361fc2b37c4c0762b","modified":1623687047375},{"_id":"themes/kiss/source/css/_partial/highlight.styl","hash":"aaacaa2275e25a18371af00b4020211932426e22","modified":1623687047376},{"_id":"themes/kiss/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1623687047376},{"_id":"themes/kiss/source/css/_partial/header.styl","hash":"1b9c2b2266469f2d6306c060b893d4a58b6c328c","modified":1629724979099},{"_id":"themes/kiss/source/css/_partial/sidebar-aside.styl","hash":"20cb99acd4bed917ba90c297acaa5276a79d4998","modified":1630853182366},{"_id":"themes/kiss/source/css/_partial/sidebar.styl","hash":"f5c4f4f9875693ff0f851838662639c01877450f","modified":1623687047377},{"_id":"themes/kiss/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1623687047376},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1623687047379},{"_id":"themes/kiss/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1623687047378},{"_id":"themes/kiss/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1623687047377},{"_id":"themes/kiss/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1623687047377},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1623687047382},{"_id":"themes/kiss/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1623687047385},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1623687047386},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1623687047385},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1623687047386},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1623687047386},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1623687047386},{"_id":"themes/kiss/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1623687047385},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1623687047387},{"_id":"themes/kiss/package-lock.json","hash":"ed5a0936d01b4304dcdee4773bbb3c1a56e09b68","modified":1623687047373},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1623687047381},{"_id":"source/favicon.ico","hash":"8ea7fb25464a2608b774153fe6731fd8fd82c1b0","modified":1612542077000},{"_id":"source/README.md","hash":"37db7dab750de0dcf6fc53bff077a5058e01ad54","modified":1629725533481},{"_id":"source/music.png","hash":"3ca73e04c922de92ffb44d6fe4c698720f85b041","modified":1612542077000},{"_id":"source/qrcode.jpg","hash":"4d4911dcd6a7a71ec57f46f08e7988fdb7bbbfd7","modified":1629676489365},{"_id":"source/robots.txt","hash":"be8d5ab7132ac74a9375439e438b00b8c91e50b4","modified":1612542077000},{"_id":"source/_posts/.DS_Store","hash":"8834f1dec6a6fa55106a6b52dbf53cc9d2c059c2","modified":1630242386640},{"_id":"source/tip_img.png","hash":"7abdc78506408cd91b8155911d7c49ef1f9149c3","modified":1612542077000},{"_id":"source/_posts/essay/light-and-heat.md","hash":"90b6d1854d64dcb4e97078ed893389544623b4b2","modified":1630851804005},{"_id":"source/_posts/Hello.md","hash":"04e8f02d1fa4488e2cbb0ddcea3e52487f10a5bb","modified":1612542076000},{"_id":"source/_posts/music/listen-chopin-raindrop.md","hash":"90e654b2f06e1cabecb9fe4a87679187d1462b28","modified":1612542077000},{"_id":"source/_posts/it/go/go-basic.md","hash":"cc50da7ace4475487483f7c44caebb29d8d0d58d","modified":1612542076000},{"_id":"source/_posts/it/go/go-design-and-implementation-01.md","hash":"79ff39ef7b030f2a6841d14091359d013734817a","modified":1612542076000},{"_id":"source/_posts/it/go/go-design-and-implementation-02.md","hash":"a89b14512704942790898066447e31b824559039","modified":1612542076000},{"_id":"source/_posts/it/go/zodiac-ganzhi-go.md","hash":"2f40ac749e532ab423e4b9cf560db5478bb32da3","modified":1612542076000},{"_id":"source/_posts/it/java/java-basic.md","hash":"8739b3e34f4d8fb077bc5f65a1ae283c29eea1b6","modified":1623686060179},{"_id":"source/_posts/it/java/java-collection.md","hash":"b47e5e923d21f219c06ba637be94690344e2decf","modified":1612542076000},{"_id":"source/_posts/it/java/java-concurrent.md","hash":"55171ee351c3334a206327f6a4afe765cfc26d42","modified":1612542076000},{"_id":"source/_posts/it/java/java-jvm.md","hash":"0e1ab262e6bbf50a9e364854dd8ad9463a387b5d","modified":1612542076000},{"_id":"source/_posts/language/jp/keitai-de-nihongo.md","hash":"2994a4af2a4564ee62399b2d745f6325ddfb9f6e","modified":1612542076000},{"_id":"source/_posts/language/min/sigêng-giamgia.md","hash":"12e112b30b06400736e72c6839bf902c55630821","modified":1612542077000},{"_id":"source/_posts/language/min/teochew-kahtsi-vowel.md","hash":"86f20a50b26e3aec039d79cc5d93e8bd5c626889","modified":1612542077000},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung.md","hash":"7f2ae536c8389bbb2c240a6b543459871f5c6b02","modified":1612542077000},{"_id":"source/_posts/music/listen-chopin-raindrop/cdefgab.jpg","hash":"ce62e60f342c7565b3836eaeffe1bdcdb8e25fb1","modified":1612542077000},{"_id":"source/_posts/music/listen-chopin-raindrop/piano-keys.gif","hash":"db1a2b3d591cfb88fe67069f81b91746aa38039a","modified":1612542077000},{"_id":"source/_posts/it/go/go-basic/Untitled 1.png","hash":"8d2673b96de7b480d61efc015b64e63e38646026","modified":1612542076000},{"_id":"source/_posts/it/go/go-basic/Untitled.png","hash":"4d1c3a7b3408b4d17f7976d3b4fec4cbf2c1fa8a","modified":1612542076000},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 1.png","hash":"5c7c2d5aae780ddeaa387abafd1acb505780450f","modified":1612542076000},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 2.png","hash":"2c6e57169c2be5b1246a167e4789898cf617b257","modified":1612542076000},{"_id":"source/_posts/it/java/java-basic/20201114_101407.png","hash":"1cdd3a0dc66cb17e34926515dbd121738708761c","modified":1612542076000},{"_id":"source/_posts/it/java/java-collection/Untitled 1.png","hash":"bd4f8e27ff98fce5547f1f4b277ad4debc4f2ca9","modified":1612542076000},{"_id":"source/_posts/it/java/java-collection/Untitled 2.png","hash":"7ff8b589f12130fb2e71530aa5e43aff912ac2a6","modified":1612542076000},{"_id":"source/_posts/it/java/java-collection/Untitled 3.png","hash":"b032986e28a9202479cd743464809b53668cd6b4","modified":1612542076000},{"_id":"source/_posts/it/java/java-concurrent/Untitled 1.png","hash":"5ee21cd407a58fee19858e8672eb69a0b92be4bc","modified":1612542076000},{"_id":"source/_posts/it/java/java-concurrent/Untitled 2.png","hash":"c7b8bcef572daacf2c202a295827a98c03c1548b","modified":1612542076000},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled.png","hash":"86692657ad38d318606d0426de6d0e51579f6a41","modified":1612542076000},{"_id":"source/_posts/it/java/java-concurrent/Untitled 5.png","hash":"80a8d6ec157951a7b520f8548eff8a0115b6f7b7","modified":1612542076000},{"_id":"source/_posts/it/java/java-concurrent/Untitled 6.png","hash":"54d690bd771379a73a3be2685cb3e9a1a214a616","modified":1612542076000},{"_id":"source/_posts/it/java/java-concurrent/Untitled 8.png","hash":"9bddd2e37f2204ca9d4e47fe883f8910aa9ea2f6","modified":1612542076000},{"_id":"source/_posts/it/java/java-jvm/Untitled 1.png","hash":"e426df900a411215d6bd08b7498b2b87d39dd3df","modified":1612542076000},{"_id":"source/_posts/it/java/java-jvm/Untitled 2.png","hash":"8d075c8ac9b695152a2d0e8b791061e6ece9df5c","modified":1612542076000},{"_id":"source/_posts/it/java/java-jvm/Untitled 5.png","hash":"4b1f55e64a2ed3f8af270214698d0ab78cfe6872","modified":1612542076000},{"_id":"source/_posts/it/java/java-jvm/Untitled 8.png","hash":"c4aa675c8aa3cc5103cad6a4063efe6f09300bdb","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/image.jpg","hash":"25485c91b50a52a36c1dc24f638d219768b6034b","modified":1612542077000},{"_id":"source/_posts/language/min/sigêng-giamgia/202010060948.jpg","hash":"abcd4e4bc5aeb9b8a1263329adae6b525101d7f6","modified":1612542077000},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled 1.png","hash":"9885679f1918d3815db19c046c9a932ebd037161","modified":1612542076000},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled.png","hash":"423a6f48a17f1bc2261301efa14a9c069eac008f","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao.md","hash":"06699d30b059b2bd3346b3694c25fce926114d13","modified":1612542076000},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 3.png","hash":"cd178b4c15e5bfe7911b1ddbac1efec4a2acc021","modified":1612542076000},{"_id":"source/_posts/it/java/java-basic/20201202_24328.png","hash":"c992fe54e126ad45512d012b8bf6dcb6a5e36533","modified":1612542076000},{"_id":"source/_posts/it/java/java-basic/Untitled.png","hash":"7feeb782152cb8ddc3c2fb39626145920a92062a","modified":1612542076000},{"_id":"source/_posts/it/java/java-collection/Untitled 4.png","hash":"2ddf731a2d67a0b5ff4ee6fbe7f77c5e0afcb484","modified":1612542076000},{"_id":"source/_posts/it/java/java-collection/Untitled 6.png","hash":"e31adbdb1887144a8308143ae300d74e0eda4180","modified":1612542076000},{"_id":"source/_posts/it/java/java-concurrent/_2020-11-16_8.54.01.png","hash":"a36fdf28a8d9266e036f023d2ec8b8ccc5fae2be","modified":1612542076000},{"_id":"source/_posts/it/java/java-jvm/Untitled 4.png","hash":"de2ef5d859f0a9ead28d2269a7fcb80144edc50b","modified":1612542076000},{"_id":"source/_posts/it/java/java-jvm/Untitled 3.png","hash":"d29574c8d20167f90d055f9f0ac2c722b7e6f0a1","modified":1612542076000},{"_id":"source/_posts/it/java/java-jvm/Untitled 7.png","hash":"32c58be0d5c7b712f7e58c8167c61ff08fd17acf","modified":1612542076000},{"_id":"source/_posts/it/java/java-jvm/Untitled 6.png","hash":"d0cced7f09cb7294e019f799a4d1a3adc17c2869","modified":1612542076000},{"_id":"source/_posts/it/java/java-jvm/Untitled.png","hash":"30643ff19ac17d3c1dbc1626e98dc62df66e1f8d","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 24.png","hash":"9d1ac5223de4f99edf222262252859595c85e321","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 25.png","hash":"473d101fffa104e34cb2cbcc0a428e22c966baba","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 3.png","hash":"085783bec7fc8cb4854543ac682af44cfff6bafa","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 33.png","hash":"0a62ed95f5733e84831d7f5ac376fa9b76e3f049","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 35.png","hash":"08c60dbe8acb355436cad441be2a1bcb3e7b56a9","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 48.png","hash":"d2062951eea06f120c39f9a8cf768d487b8ceb86","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 6.png","hash":"76c65edad08c094999bc714db41ae7b70d951a7a","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 78.png","hash":"83ad7cc6852b8873045410e47a217446ca9e4ba6","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png","hash":"6d446cd3dc8c2f0cfefc0f464ffde9e6ca69605a","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png","hash":"6af3c6177c3f35b4b260ec4220f6fc2a0b0136a7","modified":1612542077000},{"_id":"themes/kiss/source/css/images/moon.jpg","hash":"798c8924ee26b8f402054d6ed5743a18ba9226df","modified":1623687047384},{"_id":"source/_posts/it/java/java-basic/Untitled 1.png","hash":"b0ff3f9c9afb47aa3ec4ae861b96f91ba225de2a","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 17.png","hash":"2663c8e8c1e6aa3d12a85ba81953cf0ffb2940c3","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 19.png","hash":"c16a8ba5c538423f71699882c6634659bacfb5d5","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 34.png","hash":"4aff07d5b6421154804c83b5e0af12be66ce8b90","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 36.png","hash":"b439479608c12b3f6be283eafbd7874dd6827a8d","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 47.png","hash":"89edb396e3c2aaf9db45c548acfcb88fcbfc926f","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 5.png","hash":"ca731ffd8b5571c1c8d0f1076997b772247b139a","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 57.png","hash":"b13d2f1d8fee58b64f92213b04f9795a89eb4aae","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 7.png","hash":"6adf698e1f241cdcdd8ff25fcb75ff2862bf3844","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 71.png","hash":"b4028b014c0cd25ece3417aa5180a2a14900fffb","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 68.png","hash":"3be7c232b4c4ab85d2e288b76ca2a733b3bbfdd5","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 69.png","hash":"3daee4980804c94b5cd365391a27eff387c80dd2","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 75.png","hash":"528dcde670ccedbec01fb84d3d4a260127c16c69","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 9.png","hash":"6313844c0aa524cc0b4cbf068b905b49e9ec0509","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png","hash":"d1d67355871a937680ed4207eadd21b280a1be13","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png","hash":"2b572a253d76fbf45c2c9bfe20bda2213ca9f0df","modified":1612542077000},{"_id":"source/_posts/language/min/sigêng-giamgia/蒹葭.m4a","hash":"9b489081647694ae1fa69bf4712934565c8a11e3","modified":1612542077000},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled 2.png","hash":"f720ad260caf80e151140805c93957466f39d143","modified":1612542076000},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1623687047380},{"_id":"source/_posts/it/java/java-concurrent/Untitled 7.png","hash":"66903a5c2006db99d736a25c1c3eef004b9397ff","modified":1612542076000},{"_id":"source/_posts/it/java/java-concurrent/Untitled.png","hash":"25e267c1e2f72f077e365bd816d4f62573075511","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 11.png","hash":"3829cd163a7291869beec1e2831716e6e598faa7","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 14.png","hash":"c031c4e755ad4353a46a75183c932128b761e1dc","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 13.png","hash":"aceae21957f9e7de9c3edcc036108460c467fb3d","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 15.png","hash":"50d64d23162ea40b27fe41fdf8c82771f2a8fe9d","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 2.png","hash":"519b6e027a590c70b1b198654aa728a746fd3998","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 22.png","hash":"f358240f31acc27c0073202245c38fb31db00c7b","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 23.png","hash":"2c989d254cb3106335df80439190bf9e6e03db1d","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 21.png","hash":"6fbe1b88fbd94c918b899c527ccb8eb2ffdf2af9","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 30.png","hash":"f76a5d94bbc1244d43763e57b394e49adee9d27a","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 32.png","hash":"c931893d53d20cf62d464771534063cd1a00a355","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 37.png","hash":"bfd23dc52065cf9689a7672d36ccaee6b3838bad","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 4.png","hash":"9b66fec364c2b5695f84aa4bf68d678d8d3e81d3","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 52.png","hash":"4101f0dc6ee2d6fe4c170903ad1712e82f9d107b","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 51.png","hash":"4bff800cc7223a87753f6f73c38312e7cabeaf87","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 53.png","hash":"3f14fc60a521be89c7636fb3c58bb48126dd376a","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 62.png","hash":"3ae22b6d0c3e2edebba674eae8ad25386e1f01b0","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 66.png","hash":"d7f561114775c599d4a034b20417c75e6bfa748d","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 8.png","hash":"83687c527fe71b1f2112e573d88fd3e4a9f32acc","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled.png","hash":"60508247f23f0e5b48e864dc7901864db0ff847a","modified":1612542077000},{"_id":"source/_posts/it/java/java-collection/Untitled 5.png","hash":"922d23d15cb96dffebb5d71187bc17d8f61ae1a1","modified":1612542076000},{"_id":"source/_posts/it/java/java-concurrent/Untitled 3.png","hash":"57b6e1f1ac7c3853bfceb465e28d4396fa3a87a7","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 10.png","hash":"bedefa716e3db4de9f51414ed9e4c9026e8eb479","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 12.png","hash":"c000a526b62c3ad898d08a573e9c19f408b160cd","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 26.png","hash":"3c7419dab2c33da1f0002c5b1696b8a03dcea9fb","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 27.png","hash":"5a928dbd10c1bac4035b20adfbc00cca33b8e44a","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 20.png","hash":"fe003a15de6ac2c8a2af1752399e3fd153bbce15","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 31.png","hash":"bb603ebd66a0d470070445350f39fb6bdba8853a","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 38.png","hash":"b98bc1e15937512b80964eda63d08735c0948eb9","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 39.png","hash":"729db0180e0e1efcdbae62fda904ae0c07a9001e","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 41.png","hash":"c8d4e9d171aafe3c6fd6e48394bde794f22e251d","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 43.png","hash":"9bc088b22cdf937ea561957da666baab2d0b6a0f","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 45.png","hash":"f25020d5b4da4f8639fc8118ba42c93187d7be5f","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 50.png","hash":"bdc548956525a96a5d18d29033e7663fbb566343","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 49.png","hash":"d6694d18e81f9feb8ca72b949075072303d75c58","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 44.png","hash":"cef5bd836f351b573e4dcc44dbeb0de723ae2025","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 54.png","hash":"6eede5ec4373456f5787bd1e1b882b676fdb302d","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 56.png","hash":"12431dbde1395e173bec555c4d42e69a6d8aab09","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 58.png","hash":"0f7f03c55e1b404719a866fba8eab819aee2368b","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 60.png","hash":"f52b7c94902735215de69da3d178a6b670adac8f","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 64.png","hash":"007b0160bbe3976d2fd82f347df4e1237840613e","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 63.png","hash":"ff3a9515c5193968899aac10aadbd48526886c29","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 65.png","hash":"fbeaa7c8f90ae484da43a7358513773ad4844511","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 67.png","hash":"203576af7229e5872973befb580be0be57213bd8","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 70.png","hash":"a3960ec9ec05c8c97444b43cd35d4b4c4c2dabe1","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 74.png","hash":"5748dbbe314cc185a52b17d25bcae6eb9fe1b3d8","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 76.png","hash":"e677073faf1a318ab9f98c290052e54995f259b7","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 79.png","hash":"bd9378249cd99b18a4c91c7a2dfde7ed2f2da310","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 80.png","hash":"9ee915ef146da9faed3659510774dc4360882c01","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 81.png","hash":"9f5cdd07cadbc48ab4ad165205a94c4f6e51cc78","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 83.png","hash":"e4c62a60a52f63b976d23f8a1992e1880d9f987c","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 84.png","hash":"bf46c1323d5a946c2e069914c22827702e7a5a0d","modified":1612542077000},{"_id":"source/_posts/it/java/java-basic/Untitled 4.png","hash":"af3906ce47f968ea8aded65e377c5f643aa110a8","modified":1612542076000},{"_id":"source/_posts/it/java/java-basic/Untitled 3.png","hash":"f21a829671bd0c8e3bcab7d20e7a390363509871","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 18.png","hash":"06780da5ca0e65135af591a8119441b5b30c0ed4","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 46.png","hash":"95e3359d1e4533c003d152a6bb961f563fa2162c","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 55.png","hash":"9d10d7f96b9a1655249a761f206743a272bfe3f7","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 72.png","hash":"fb429bdb55a01d0b44dc43cda0ae70afeeda6b69","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 73.png","hash":"1acabc9e3890c02ef0b0cb5be555aa56eb79d19f","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 1.png","hash":"58d9e174a9d27c1516a3f42ebcbab4ab6bbc9d0d","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 29.png","hash":"8b491d854a87196fe33c712e100091af26d425cf","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 42.png","hash":"95fcccd01eb74b43ad75991e48294606c697ecaf","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 59.png","hash":"34e3b95cc544ee86a26fdd1a809ba1c3cee940ce","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 77.png","hash":"4bf008561f52989192e1c4de1212a016d02fefcb","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 82.png","hash":"40a4c797c671b85c7d1ed1d04c615731b63d85ab","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 85.png","hash":"5cbbe80c24cf9a7f463899d7ec0ace2a1ccf98ab","modified":1612542077000},{"_id":"source/_posts/it/java/java-concurrent/Untitled 4.png","hash":"2a18d5e552e56e6ff06599b120e0a2c3f53aa398","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 28.png","hash":"79bd3025d83d6d866be4dcae7a7792b867ee9a7c","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 40.png","hash":"9de8f883a4da464eb5633420a6d2455e6c285ee5","modified":1612542077000},{"_id":"source/_posts/it/java/java-basic/Untitled 2.png","hash":"36b1886c415bc0d597baaa227f833144132032ff","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 16.png","hash":"5a78574cd85d20cb5add7255fcc5adb24f69cba9","modified":1612542076000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 61.png","hash":"c5a73db614a03510c36123b25218cf69e1d41f5d","modified":1612542077000},{"_id":"source/_posts/language/min/teochew-kahtsi-vowel/202010042112.png","hash":"0b9ffd6564070d7d913668a0aa3dfa827eab26e8","modified":1612542077000},{"_id":"source/_posts/it/java/java-collection/Untitled.png","hash":"7a36813b6140feab84abce77938e837272413355","modified":1612542076000},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png","hash":"8fd5a50fb29b7d581d4cc3c99f25aba06d3a9b95","modified":1612542077000},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png","hash":"1ff30cad5d55cf8320e0965be31810db278f4522","modified":1612542077000},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png","hash":"4c88e38f46e12a86b53682f31d3aa56cb8b66e2b","modified":1612542077000},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png","hash":"6cfc945d1177754ccf8834ca1be4309bd5b512a7","modified":1612542077000},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg","hash":"b2caf9cdcaa183f435adf33d67d1915af116faa2","modified":1612542077000},{"_id":"public/atom.xml","hash":"9013ecff1cf5b9123c20757087bf16433449058f","modified":1630853756293},{"_id":"public/2021/09/05/essay/light-and-heat/index.html","hash":"ac5f2d9523da3acae84b911f19ac92525bf8f06e","modified":1630853756293},{"_id":"public/2019/09/01/Hello/index.html","hash":"c624364b3928bde58b26b8613e13ca85e02e44d1","modified":1630853756293},{"_id":"public/archives/index.html","hash":"8077c4a6b1364a8c76f7fc3568898a0ca23492f7","modified":1630854294799},{"_id":"public/archives/page/2/index.html","hash":"6571b32526cb30bcfecd9c84694258e5dbf83e48","modified":1630854294799},{"_id":"public/archives/2019/index.html","hash":"8f1fefbf4d5dfe131038e588a9a4ac042c03176f","modified":1630853756293},{"_id":"public/archives/2019/09/index.html","hash":"57d004385433a1aa87e611fb276375d16f46c1da","modified":1630853756293},{"_id":"public/archives/2021/index.html","hash":"6ce153412749dffe02f877d8e14c35948fb99fc6","modified":1630854294799},{"_id":"public/archives/2021/page/2/index.html","hash":"36c25323c1fd7be339f2733c5d3ff47d19c53b89","modified":1630854294799},{"_id":"public/archives/2021/02/index.html","hash":"39f03c4b0cbe9afa42318f4438f09ad71b6c10ab","modified":1630854294799},{"_id":"public/archives/2021/02/page/2/index.html","hash":"fe26d04255f139b4b015ce01d973f603f945a9fd","modified":1630854294799},{"_id":"public/archives/2021/09/index.html","hash":"1d96bab58dffdcb3e67d5a93735ca9583ce01215","modified":1630853756293},{"_id":"public/tags/聆聽音樂/index.html","hash":"9c46960187a838595c311edfc1bc592a0c5cbd34","modified":1630853756293},{"_id":"public/tags/Hello/index.html","hash":"9a0cf09a137d5b5ea8ee19bdd6274620bcdcc08f","modified":1630853756293},{"_id":"public/tags/隨筆/index.html","hash":"ddc5159d88f32afb811019d083c98c2950b85bf9","modified":1630853756293},{"_id":"public/tags/Go/index.html","hash":"fb912ef66582a35bc877c9fbab087058324eac22","modified":1630853756293},{"_id":"public/tags/十二生肖/index.html","hash":"7b264318b2c66ccb5cd33ea4b63b0e749e7055eb","modified":1630853756293},{"_id":"public/tags/甲子話/index.html","hash":"f819eb75af7eef29ac7bf70e635dc5084e9913c4","modified":1630853756293},{"_id":"public/tags/日本語/index.html","hash":"120ec6d68de882e1be4c988bbd83bfbb3a924f6b","modified":1630853756293},{"_id":"public/tags/干支紀年法/index.html","hash":"3c9dc7e878c90f268711c8d3a4e1b6bd42d7199a","modified":1630853756293},{"_id":"public/tags/詩經/index.html","hash":"58fd5f118ca93929bd0838eaf1caf31cf4a11182","modified":1630853756293},{"_id":"public/tags/閩南語/index.html","hash":"bdceeb5a1b6a718397c8c51215e66a43652284d0","modified":1630853756293},{"_id":"public/2021/02/06/music/listen-chopin-raindrop/index.html","hash":"fddb982ba30fa3262c4f01d0a5d73fda14dbd854","modified":1630853756293},{"_id":"public/2021/02/06/language/min/teochew-kahtsi-vowel/index.html","hash":"76818b3d7d3d45d5f80d64c7af2b1bbc5d6f178a","modified":1630853756293},{"_id":"public/2021/02/06/language/min/teochew-opera-ghêgdengcung/index.html","hash":"a696489a80f39cfc278735e5c49c697ecf70a648","modified":1630853756293},{"_id":"public/2021/02/06/language/min/sigêng-giamgia/index.html","hash":"8ae50f03a7d952661b5ab132d170dc3658ef20b9","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/index.html","hash":"ea39ddc134bc68a644e5380abf160385f64ad13a","modified":1630853756293},{"_id":"public/2021/02/06/language/jp/keitai-de-nihongo/index.html","hash":"7c53fe9a72e7b6ec625ab601d887e0ab52b70026","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-jvm/index.html","hash":"593520f4c7fdf6c3febc836ccda1e6ed73d226c9","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-collection/index.html","hash":"29ad000af8d222564126cf90710d4ac9b279983d","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-concurrent/index.html","hash":"72a1badadad763bd5ac4871841cdcd9f147cad21","modified":1630853756293},{"_id":"public/2021/02/06/it/go/zodiac-ganzhi-go/index.html","hash":"c53b3675c43277208ca2840ab05e6c6b07b9b750","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-basic/index.html","hash":"4f2e141b6c4035237c6b3609bf5adcedf299b4c9","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-design-and-implementation-02/index.html","hash":"c2dea45ee07919d4a236c9c647da2489c9fb47d4","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-design-and-implementation-01/index.html","hash":"1ccb8f70e20bf9753a374a536a22ec5ad119746c","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-basic/index.html","hash":"4883dd927892f1e7b392f217b713c5d57aa11ea3","modified":1630853756293},{"_id":"public/index.html","hash":"b9003581a483cf0463dbfa6b0b63ad4002580f03","modified":1630854294799},{"_id":"public/page/2/index.html","hash":"f82f2cdf61d71f0a4bf90826e3eb16a5bd2947e9","modified":1630854294799},{"_id":"public/tags/潮劇/index.html","hash":"a284f9a0aacc6c102a0539f47d5686c23fe688cc","modified":1630853756293},{"_id":"public/tags/潮州話/index.html","hash":"2ce32a8d72d827dcb6a8a8583e6d591e645d6659","modified":1630853756293},{"_id":"public/tags/Java/index.html","hash":"f2215ca5648eb2ad264975925b6e1630075b2f87","modified":1630853756293},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1630853756293},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1630853756293},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1630853756293},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1630853756293},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1630853756293},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1630853756293},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1630853756293},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1630853756293},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1630853756293},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1630853756293},{"_id":"public/README.md","hash":"37db7dab750de0dcf6fc53bff077a5058e01ad54","modified":1630853756293},{"_id":"public/music.png","hash":"3ca73e04c922de92ffb44d6fe4c698720f85b041","modified":1630853756293},{"_id":"public/qrcode.jpg","hash":"4d4911dcd6a7a71ec57f46f08e7988fdb7bbbfd7","modified":1630853756293},{"_id":"public/robots.txt","hash":"be8d5ab7132ac74a9375439e438b00b8c91e50b4","modified":1630853756293},{"_id":"public/tip_img.png","hash":"7abdc78506408cd91b8155911d7c49ef1f9149c3","modified":1630853756293},{"_id":"public/2021/02/06/music/listen-chopin-raindrop/piano-keys.gif","hash":"db1a2b3d591cfb88fe67069f81b91746aa38039a","modified":1630853756293},{"_id":"public/2021/02/06/music/listen-chopin-raindrop/cdefgab.jpg","hash":"ce62e60f342c7565b3836eaeffe1bdcdb8e25fb1","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-design-and-implementation-02/Untitled 1.png","hash":"9885679f1918d3815db19c046c9a932ebd037161","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-design-and-implementation-01/Untitled 1.png","hash":"5c7c2d5aae780ddeaa387abafd1acb505780450f","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-design-and-implementation-02/Untitled.png","hash":"423a6f48a17f1bc2261301efa14a9c069eac008f","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-design-and-implementation-01/Untitled 2.png","hash":"2c6e57169c2be5b1246a167e4789898cf617b257","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-design-and-implementation-01/Untitled.png","hash":"86692657ad38d318606d0426de6d0e51579f6a41","modified":1630853756293},{"_id":"public/2021/02/06/language/min/sigêng-giamgia/202010060948.jpg","hash":"abcd4e4bc5aeb9b8a1263329adae6b525101d7f6","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-basic/Untitled 1.png","hash":"8d2673b96de7b480d61efc015b64e63e38646026","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-basic/Untitled.png","hash":"4d1c3a7b3408b4d17f7976d3b4fec4cbf2c1fa8a","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-collection/Untitled 1.png","hash":"bd4f8e27ff98fce5547f1f4b277ad4debc4f2ca9","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-collection/Untitled 2.png","hash":"7ff8b589f12130fb2e71530aa5e43aff912ac2a6","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-collection/Untitled 3.png","hash":"b032986e28a9202479cd743464809b53668cd6b4","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-jvm/Untitled 1.png","hash":"e426df900a411215d6bd08b7498b2b87d39dd3df","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-jvm/Untitled 2.png","hash":"8d075c8ac9b695152a2d0e8b791061e6ece9df5c","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-jvm/Untitled 5.png","hash":"4b1f55e64a2ed3f8af270214698d0ab78cfe6872","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-jvm/Untitled 8.png","hash":"c4aa675c8aa3cc5103cad6a4063efe6f09300bdb","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-basic/20201114_101407.png","hash":"1cdd3a0dc66cb17e34926515dbd121738708761c","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-concurrent/Untitled 1.png","hash":"5ee21cd407a58fee19858e8672eb69a0b92be4bc","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-concurrent/Untitled 2.png","hash":"c7b8bcef572daacf2c202a295827a98c03c1548b","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-concurrent/Untitled 5.png","hash":"80a8d6ec157951a7b520f8548eff8a0115b6f7b7","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-concurrent/Untitled 6.png","hash":"54d690bd771379a73a3be2685cb3e9a1a214a616","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-concurrent/Untitled 8.png","hash":"9bddd2e37f2204ca9d4e47fe883f8910aa9ea2f6","modified":1630853756293},{"_id":"public/favicon.ico","hash":"8ea7fb25464a2608b774153fe6731fd8fd82c1b0","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/image.jpg","hash":"25485c91b50a52a36c1dc24f638d219768b6034b","modified":1630853756293},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1630853756293},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1630853756293},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1630853756293},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-collection/Untitled 4.png","hash":"2ddf731a2d67a0b5ff4ee6fbe7f77c5e0afcb484","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-collection/Untitled 6.png","hash":"e31adbdb1887144a8308143ae300d74e0eda4180","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-jvm/Untitled 3.png","hash":"d29574c8d20167f90d055f9f0ac2c722b7e6f0a1","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-jvm/Untitled 4.png","hash":"de2ef5d859f0a9ead28d2269a7fcb80144edc50b","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-jvm/Untitled 7.png","hash":"32c58be0d5c7b712f7e58c8167c61ff08fd17acf","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-jvm/Untitled 6.png","hash":"d0cced7f09cb7294e019f799a4d1a3adc17c2869","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-jvm/Untitled.png","hash":"30643ff19ac17d3c1dbc1626e98dc62df66e1f8d","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-basic/20201202_24328.png","hash":"c992fe54e126ad45512d012b8bf6dcb6a5e36533","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-basic/Untitled 1.png","hash":"b0ff3f9c9afb47aa3ec4ae861b96f91ba225de2a","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-basic/Untitled.png","hash":"7feeb782152cb8ddc3c2fb39626145920a92062a","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 14.png","hash":"c031c4e755ad4353a46a75183c932128b761e1dc","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 19.png","hash":"c16a8ba5c538423f71699882c6634659bacfb5d5","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 24.png","hash":"9d1ac5223de4f99edf222262252859595c85e321","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 25.png","hash":"473d101fffa104e34cb2cbcc0a428e22c966baba","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 3.png","hash":"085783bec7fc8cb4854543ac682af44cfff6bafa","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 33.png","hash":"0a62ed95f5733e84831d7f5ac376fa9b76e3f049","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 35.png","hash":"08c60dbe8acb355436cad441be2a1bcb3e7b56a9","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-design-and-implementation-01/Untitled 3.png","hash":"cd178b4c15e5bfe7911b1ddbac1efec4a2acc021","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 48.png","hash":"d2062951eea06f120c39f9a8cf768d487b8ceb86","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 6.png","hash":"76c65edad08c094999bc714db41ae7b70d951a7a","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 78.png","hash":"83ad7cc6852b8873045410e47a217446ca9e4ba6","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png","hash":"6d446cd3dc8c2f0cfefc0f464ffde9e6ca69605a","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png","hash":"6af3c6177c3f35b4b260ec4220f6fc2a0b0136a7","modified":1630853756293},{"_id":"public/2021/02/06/it/go/go-design-and-implementation-02/Untitled 2.png","hash":"f720ad260caf80e151140805c93957466f39d143","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 23.png","hash":"2c989d254cb3106335df80439190bf9e6e03db1d","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 36.png","hash":"b439479608c12b3f6be283eafbd7874dd6827a8d","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 34.png","hash":"4aff07d5b6421154804c83b5e0af12be66ce8b90","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 37.png","hash":"bfd23dc52065cf9689a7672d36ccaee6b3838bad","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 47.png","hash":"89edb396e3c2aaf9db45c548acfcb88fcbfc926f","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 5.png","hash":"ca731ffd8b5571c1c8d0f1076997b772247b139a","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 57.png","hash":"b13d2f1d8fee58b64f92213b04f9795a89eb4aae","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 68.png","hash":"3be7c232b4c4ab85d2e288b76ca2a733b3bbfdd5","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 7.png","hash":"6adf698e1f241cdcdd8ff25fcb75ff2862bf3844","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 69.png","hash":"3daee4980804c94b5cd365391a27eff387c80dd2","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 71.png","hash":"b4028b014c0cd25ece3417aa5180a2a14900fffb","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 75.png","hash":"528dcde670ccedbec01fb84d3d4a260127c16c69","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 9.png","hash":"6313844c0aa524cc0b4cbf068b905b49e9ec0509","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png","hash":"d1d67355871a937680ed4207eadd21b280a1be13","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png","hash":"2b572a253d76fbf45c2c9bfe20bda2213ca9f0df","modified":1630853756293},{"_id":"public/assets/js/DPlayer.min.js","hash":"490148a22ab2b03a880495cc733ecd1840c02ed6","modified":1630853756293},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1630853756293},{"_id":"public/js/script.js","hash":"63c21efc77abda2eec546d66ee832fc9776edabd","modified":1630853756293},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1630853756293},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1630853756293},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1630853756293},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1630853756293},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1630853756293},{"_id":"public/css/style.css","hash":"065bbbed7e6c0e3032b1655651b98e704160e3de","modified":1630853756293},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1630853756293},{"_id":"public/css/images/moon.jpg","hash":"798c8924ee26b8f402054d6ed5743a18ba9226df","modified":1630853756293},{"_id":"public/2021/02/06/language/min/sigêng-giamgia/蒹葭.m4a","hash":"9b489081647694ae1fa69bf4712934565c8a11e3","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-concurrent/Untitled.png","hash":"25e267c1e2f72f077e365bd816d4f62573075511","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 10.png","hash":"bedefa716e3db4de9f51414ed9e4c9026e8eb479","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 11.png","hash":"3829cd163a7291869beec1e2831716e6e598faa7","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 13.png","hash":"aceae21957f9e7de9c3edcc036108460c467fb3d","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 17.png","hash":"2663c8e8c1e6aa3d12a85ba81953cf0ffb2940c3","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 21.png","hash":"6fbe1b88fbd94c918b899c527ccb8eb2ffdf2af9","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 30.png","hash":"f76a5d94bbc1244d43763e57b394e49adee9d27a","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 32.png","hash":"c931893d53d20cf62d464771534063cd1a00a355","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 4.png","hash":"9b66fec364c2b5695f84aa4bf68d678d8d3e81d3","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 51.png","hash":"4bff800cc7223a87753f6f73c38312e7cabeaf87","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 52.png","hash":"4101f0dc6ee2d6fe4c170903ad1712e82f9d107b","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 53.png","hash":"3f14fc60a521be89c7636fb3c58bb48126dd376a","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 66.png","hash":"d7f561114775c599d4a034b20417c75e6bfa748d","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 8.png","hash":"83687c527fe71b1f2112e573d88fd3e4a9f32acc","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled.png","hash":"60508247f23f0e5b48e864dc7901864db0ff847a","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 22.png","hash":"f358240f31acc27c0073202245c38fb31db00c7b","modified":1630853756293},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-collection/Untitled 5.png","hash":"922d23d15cb96dffebb5d71187bc17d8f61ae1a1","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-concurrent/Untitled 3.png","hash":"57b6e1f1ac7c3853bfceb465e28d4396fa3a87a7","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-basic/Untitled 4.png","hash":"af3906ce47f968ea8aded65e377c5f643aa110a8","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-concurrent/Untitled 7.png","hash":"66903a5c2006db99d736a25c1c3eef004b9397ff","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 15.png","hash":"50d64d23162ea40b27fe41fdf8c82771f2a8fe9d","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 12.png","hash":"c000a526b62c3ad898d08a573e9c19f408b160cd","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 2.png","hash":"519b6e027a590c70b1b198654aa728a746fd3998","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 18.png","hash":"06780da5ca0e65135af591a8119441b5b30c0ed4","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 39.png","hash":"729db0180e0e1efcdbae62fda904ae0c07a9001e","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 38.png","hash":"b98bc1e15937512b80964eda63d08735c0948eb9","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 41.png","hash":"c8d4e9d171aafe3c6fd6e48394bde794f22e251d","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 43.png","hash":"9bc088b22cdf937ea561957da666baab2d0b6a0f","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 44.png","hash":"cef5bd836f351b573e4dcc44dbeb0de723ae2025","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 45.png","hash":"f25020d5b4da4f8639fc8118ba42c93187d7be5f","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 46.png","hash":"95e3359d1e4533c003d152a6bb961f563fa2162c","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 50.png","hash":"bdc548956525a96a5d18d29033e7663fbb566343","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 49.png","hash":"d6694d18e81f9feb8ca72b949075072303d75c58","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 58.png","hash":"0f7f03c55e1b404719a866fba8eab819aee2368b","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 60.png","hash":"f52b7c94902735215de69da3d178a6b670adac8f","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 64.png","hash":"007b0160bbe3976d2fd82f347df4e1237840613e","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 63.png","hash":"ff3a9515c5193968899aac10aadbd48526886c29","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 74.png","hash":"5748dbbe314cc185a52b17d25bcae6eb9fe1b3d8","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 20.png","hash":"fe003a15de6ac2c8a2af1752399e3fd153bbce15","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 76.png","hash":"e677073faf1a318ab9f98c290052e54995f259b7","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 77.png","hash":"4bf008561f52989192e1c4de1212a016d02fefcb","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 80.png","hash":"9ee915ef146da9faed3659510774dc4360882c01","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 81.png","hash":"9f5cdd07cadbc48ab4ad165205a94c4f6e51cc78","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 83.png","hash":"e4c62a60a52f63b976d23f8a1992e1880d9f987c","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 84.png","hash":"bf46c1323d5a946c2e069914c22827702e7a5a0d","modified":1630853756293},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 1.png","hash":"58d9e174a9d27c1516a3f42ebcbab4ab6bbc9d0d","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 28.png","hash":"79bd3025d83d6d866be4dcae7a7792b867ee9a7c","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 29.png","hash":"8b491d854a87196fe33c712e100091af26d425cf","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 31.png","hash":"bb603ebd66a0d470070445350f39fb6bdba8853a","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 40.png","hash":"9de8f883a4da464eb5633420a6d2455e6c285ee5","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 42.png","hash":"95fcccd01eb74b43ad75991e48294606c697ecaf","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 55.png","hash":"9d10d7f96b9a1655249a761f206743a272bfe3f7","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 54.png","hash":"6eede5ec4373456f5787bd1e1b882b676fdb302d","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 65.png","hash":"fbeaa7c8f90ae484da43a7358513773ad4844511","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 73.png","hash":"1acabc9e3890c02ef0b0cb5be555aa56eb79d19f","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 79.png","hash":"bd9378249cd99b18a4c91c7a2dfde7ed2f2da310","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 82.png","hash":"40a4c797c671b85c7d1ed1d04c615731b63d85ab","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 62.png","hash":"3ae22b6d0c3e2edebba674eae8ad25386e1f01b0","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 70.png","hash":"a3960ec9ec05c8c97444b43cd35d4b4c4c2dabe1","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-basic/Untitled 3.png","hash":"f21a829671bd0c8e3bcab7d20e7a390363509871","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 16.png","hash":"5a78574cd85d20cb5add7255fcc5adb24f69cba9","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 27.png","hash":"5a928dbd10c1bac4035b20adfbc00cca33b8e44a","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 61.png","hash":"c5a73db614a03510c36123b25218cf69e1d41f5d","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 67.png","hash":"203576af7229e5872973befb580be0be57213bd8","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 72.png","hash":"fb429bdb55a01d0b44dc43cda0ae70afeeda6b69","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 56.png","hash":"12431dbde1395e173bec555c4d42e69a6d8aab09","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 26.png","hash":"3c7419dab2c33da1f0002c5b1696b8a03dcea9fb","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 59.png","hash":"34e3b95cc544ee86a26fdd1a809ba1c3cee940ce","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 85.png","hash":"5cbbe80c24cf9a7f463899d7ec0ace2a1ccf98ab","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-concurrent/Untitled 4.png","hash":"2a18d5e552e56e6ff06599b120e0a2c3f53aa398","modified":1630853756293},{"_id":"public/2021/02/06/language/min/teochew-kahtsi-vowel/202010042112.png","hash":"0b9ffd6564070d7d913668a0aa3dfa827eab26e8","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-basic/Untitled 2.png","hash":"36b1886c415bc0d597baaa227f833144132032ff","modified":1630853756293},{"_id":"public/2021/02/06/it/java/java-collection/Untitled.png","hash":"7a36813b6140feab84abce77938e837272413355","modified":1630853756293},{"_id":"public/2021/02/06/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png","hash":"8fd5a50fb29b7d581d4cc3c99f25aba06d3a9b95","modified":1630853756293},{"_id":"public/2021/02/06/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png","hash":"1ff30cad5d55cf8320e0965be31810db278f4522","modified":1630853756293},{"_id":"public/2021/02/06/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png","hash":"4c88e38f46e12a86b53682f31d3aa56cb8b66e2b","modified":1630853756293},{"_id":"public/2021/02/06/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png","hash":"6cfc945d1177754ccf8834ca1be4309bd5b512a7","modified":1630853756293},{"_id":"public/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg","hash":"b2caf9cdcaa183f435adf33d67d1915af116faa2","modified":1630853756293}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","date":"2019-09-01T09:02:23.000Z","_content":"\n汝好，世界\n\n幸會，世界\n\n您好，世界\n\nHello World\n\nこんにちは、世界\n\n\n\n\n\n","source":"_posts/Hello.md","raw":"---\ntitle: Hello World\ndate: 2019-09-01 17:02:23\ntags: Hello\n---\n\n汝好，世界\n\n幸會，世界\n\n您好，世界\n\nHello World\n\nこんにちは、世界\n\n\n\n\n\n","slug":"Hello","published":1,"updated":"2021-02-05T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wo300009a9k9he6c7xz","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>汝好，世界</p>\n<p>幸會，世界</p>\n<p>您好，世界</p>\n<p>Hello World</p>\n<p>こんにちは、世界</p>\n","site":{"data":{}},"excerpt":"","more":"<p>汝好，世界</p>\n<p>幸會，世界</p>\n<p>您好，世界</p>\n<p>Hello World</p>\n<p>こんにちは、世界</p>\n"},{"title":"聆聽音樂：蕭邦之「雨滴」","p":"music/listen-chopin-raindrop","_content":"\n我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。\n\n今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。\n\n<!--more-->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n## 聽後感\n\n正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。\n\n翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。\n\n## 音樂筆記\n\n### Prélude\nPrélude：法語，英文爲Prelude， 意爲前奏曲。\n常見的音樂體裁還有：\n- Ballade 敘事曲\n- Concerto 協奏曲\n- Etude 練習曲\n- Fuga 賦格\n- Impromptu 即興曲\n- Menuet 小步舞曲\n- Overture 序曲\n- Prelude 前奏曲\n- Sonata 奏鳴曲\n- String Quartet 弦樂四重奏\n- Suite 組曲\n- Symphony 交響曲\n- Violin Concerto 小提請協奏曲\n- Waltz 圓舞曲\n\n### D Flat / Db\nD Flat / Db：降D\n相關符號有：\n-  ♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；\n- ♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；\n- ♮，還原號，英文natural，表示復歸原先的音高。\n\n### Major\n**major 大調**\n![](cdefgab.jpg)\n名詞解釋：\n- 簡譜：用數字表示音的簡單記譜方式\n- 音名：音的名字\n- 唱名：音的唱法\n- 距離：代表兩個音之間的距離\n- 半音：最靠近的兩個音之間的距離\n- 全音：1全音 = 1半音 + 1半音\n![](piano-keys.gif)\nE－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。\n\n記憶方法：\n1\tDo\tC\t這個不需要想，也很直覺，乾脆就直接背了\n2\tRe\tD\tDouble 跟 Repeat 都可以聯想到 2\n3\tMi\tE\t3 M E 都長的很像\n4\tFa\tF\t4 的英文單字是 Four\n5\tSol\tG\t你跟別人 Give me five 是用手 (Sol) 來的\n6\tLa\tA\t六的閩南語念成什麼? 尾音 A\n7\tSi\tB\t七夕(Si)。 SB\n\n音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：\n- C Major：C D E F G A B C\n- Db Major：Db Eb F Gb Ab Bb C Db\n\n**minor 小調**\n音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。\n\n### Op. 28 , No. 15\nOp. 28 , No. 15：作品 28 之 15\nOp.，拉丁文 Opus，著作，尤指編號的音樂作品。\nNo.，Number，編號。\n\n## 參考\n1. [ 音階與調性 ](http://www.dancepiano.com/scalechar.aspx \"音階與調性\")\n2. [ 必學基礎樂理：音階/簡譜/音名/唱名 ](https://www.guitar.com.tw/basic-music-theory/ \"必學基礎樂理：音階/簡譜/音名/唱名\")\n3. [ 音階基本概念 ](http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf \"音階基本概念\")\n\n\n","source":"_posts/music/listen-chopin-raindrop.md","raw":"---\ntitle: 聆聽音樂：蕭邦之「雨滴」\np: music/listen-chopin-raindrop\ntags:\n- 聆聽音樂\n---\n\n我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。\n\n今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。\n\n<!--more-->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n## 聽後感\n\n正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。\n\n翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。\n\n## 音樂筆記\n\n### Prélude\nPrélude：法語，英文爲Prelude， 意爲前奏曲。\n常見的音樂體裁還有：\n- Ballade 敘事曲\n- Concerto 協奏曲\n- Etude 練習曲\n- Fuga 賦格\n- Impromptu 即興曲\n- Menuet 小步舞曲\n- Overture 序曲\n- Prelude 前奏曲\n- Sonata 奏鳴曲\n- String Quartet 弦樂四重奏\n- Suite 組曲\n- Symphony 交響曲\n- Violin Concerto 小提請協奏曲\n- Waltz 圓舞曲\n\n### D Flat / Db\nD Flat / Db：降D\n相關符號有：\n-  ♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；\n- ♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；\n- ♮，還原號，英文natural，表示復歸原先的音高。\n\n### Major\n**major 大調**\n![](cdefgab.jpg)\n名詞解釋：\n- 簡譜：用數字表示音的簡單記譜方式\n- 音名：音的名字\n- 唱名：音的唱法\n- 距離：代表兩個音之間的距離\n- 半音：最靠近的兩個音之間的距離\n- 全音：1全音 = 1半音 + 1半音\n![](piano-keys.gif)\nE－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。\n\n記憶方法：\n1\tDo\tC\t這個不需要想，也很直覺，乾脆就直接背了\n2\tRe\tD\tDouble 跟 Repeat 都可以聯想到 2\n3\tMi\tE\t3 M E 都長的很像\n4\tFa\tF\t4 的英文單字是 Four\n5\tSol\tG\t你跟別人 Give me five 是用手 (Sol) 來的\n6\tLa\tA\t六的閩南語念成什麼? 尾音 A\n7\tSi\tB\t七夕(Si)。 SB\n\n音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：\n- C Major：C D E F G A B C\n- Db Major：Db Eb F Gb Ab Bb C Db\n\n**minor 小調**\n音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。\n\n### Op. 28 , No. 15\nOp. 28 , No. 15：作品 28 之 15\nOp.，拉丁文 Opus，著作，尤指編號的音樂作品。\nNo.，Number，編號。\n\n## 參考\n1. [ 音階與調性 ](http://www.dancepiano.com/scalechar.aspx \"音階與調性\")\n2. [ 必學基礎樂理：音階/簡譜/音名/唱名 ](https://www.guitar.com.tw/basic-music-theory/ \"必學基礎樂理：音階/簡譜/音名/唱名\")\n3. [ 音階基本概念 ](http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf \"音階基本概念\")\n\n\n","slug":"music/listen-chopin-raindrop","published":1,"date":"2021-02-05T16:21:17.846Z","updated":"2021-02-05T16:21:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wo600019a9kh2gm6od2","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。</p>\n<p>今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。</p>\n<span id=\"more\"></span>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n<h2 id=\"聽後感\"><a href=\"#聽後感\" class=\"headerlink\" title=\"聽後感\"></a>聽後感</h2><p>正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。</p>\n<p>翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。</p>\n<h2 id=\"音樂筆記\"><a href=\"#音樂筆記\" class=\"headerlink\" title=\"音樂筆記\"></a>音樂筆記</h2><h3 id=\"Prelude\"><a href=\"#Prelude\" class=\"headerlink\" title=\"Prélude\"></a>Prélude</h3><p>Prélude：法語，英文爲Prelude， 意爲前奏曲。<br>常見的音樂體裁還有：</p>\n<ul>\n<li>Ballade 敘事曲</li>\n<li>Concerto 協奏曲</li>\n<li>Etude 練習曲</li>\n<li>Fuga 賦格</li>\n<li>Impromptu 即興曲</li>\n<li>Menuet 小步舞曲</li>\n<li>Overture 序曲</li>\n<li>Prelude 前奏曲</li>\n<li>Sonata 奏鳴曲</li>\n<li>String Quartet 弦樂四重奏</li>\n<li>Suite 組曲</li>\n<li>Symphony 交響曲</li>\n<li>Violin Concerto 小提請協奏曲</li>\n<li>Waltz 圓舞曲</li>\n</ul>\n<h3 id=\"D-Flat-Db\"><a href=\"#D-Flat-Db\" class=\"headerlink\" title=\"D Flat / Db\"></a>D Flat / Db</h3><p>D Flat / Db：降D<br>相關符號有：</p>\n<ul>\n<li>♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；</li>\n<li>♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；</li>\n<li>♮，還原號，英文natural，表示復歸原先的音高。</li>\n</ul>\n<h3 id=\"Major\"><a href=\"#Major\" class=\"headerlink\" title=\"Major\"></a>Major</h3><p><strong>major 大調</strong><br><img src=\"/2021/02/06/music/listen-chopin-raindrop/cdefgab.jpg\" alt><br>名詞解釋：</p>\n<ul>\n<li>簡譜：用數字表示音的簡單記譜方式</li>\n<li>音名：音的名字</li>\n<li>唱名：音的唱法</li>\n<li>距離：代表兩個音之間的距離</li>\n<li>半音：最靠近的兩個音之間的距離</li>\n<li>全音：1全音 = 1半音 + 1半音<br><img src=\"/2021/02/06/music/listen-chopin-raindrop/piano-keys.gif\" alt><br>E－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。</li>\n</ul>\n<p>記憶方法：<br>1    Do    C    這個不需要想，也很直覺，乾脆就直接背了<br>2    Re    D    Double 跟 Repeat 都可以聯想到 2<br>3    Mi    E    3 M E 都長的很像<br>4    Fa    F    4 的英文單字是 Four<br>5    Sol    G    你跟別人 Give me five 是用手 (Sol) 來的<br>6    La    A    六的閩南語念成什麼? 尾音 A<br>7    Si    B    七夕(Si)。 SB</p>\n<p>音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：</p>\n<ul>\n<li>C Major：C D E F G A B C</li>\n<li>Db Major：Db Eb F Gb Ab Bb C Db</li>\n</ul>\n<p><strong>minor 小調</strong><br>音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。</p>\n<h3 id=\"Op-28-No-15\"><a href=\"#Op-28-No-15\" class=\"headerlink\" title=\"Op. 28 , No. 15\"></a>Op. 28 , No. 15</h3><p>Op. 28 , No. 15：作品 28 之 15<br>Op.，拉丁文 Opus，著作，尤指編號的音樂作品。<br>No.，Number，編號。</p>\n<h2 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考\"></a>參考</h2><ol>\n<li><a href=\"http://www.dancepiano.com/scalechar.aspx\" title=\"音階與調性\"> 音階與調性 </a></li>\n<li><a href=\"https://www.guitar.com.tw/basic-music-theory/\" title=\"必學基礎樂理：音階/簡譜/音名/唱名\"> 必學基礎樂理：音階/簡譜/音名/唱名 </a></li>\n<li><a href=\"http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf\" title=\"音階基本概念\"> 音階基本概念 </a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。</p>\n<p>今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。</p>","more":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n<h2 id=\"聽後感\"><a href=\"#聽後感\" class=\"headerlink\" title=\"聽後感\"></a>聽後感</h2><p>正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。</p>\n<p>翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。</p>\n<h2 id=\"音樂筆記\"><a href=\"#音樂筆記\" class=\"headerlink\" title=\"音樂筆記\"></a>音樂筆記</h2><h3 id=\"Prelude\"><a href=\"#Prelude\" class=\"headerlink\" title=\"Prélude\"></a>Prélude</h3><p>Prélude：法語，英文爲Prelude， 意爲前奏曲。<br>常見的音樂體裁還有：</p>\n<ul>\n<li>Ballade 敘事曲</li>\n<li>Concerto 協奏曲</li>\n<li>Etude 練習曲</li>\n<li>Fuga 賦格</li>\n<li>Impromptu 即興曲</li>\n<li>Menuet 小步舞曲</li>\n<li>Overture 序曲</li>\n<li>Prelude 前奏曲</li>\n<li>Sonata 奏鳴曲</li>\n<li>String Quartet 弦樂四重奏</li>\n<li>Suite 組曲</li>\n<li>Symphony 交響曲</li>\n<li>Violin Concerto 小提請協奏曲</li>\n<li>Waltz 圓舞曲</li>\n</ul>\n<h3 id=\"D-Flat-Db\"><a href=\"#D-Flat-Db\" class=\"headerlink\" title=\"D Flat / Db\"></a>D Flat / Db</h3><p>D Flat / Db：降D<br>相關符號有：</p>\n<ul>\n<li>♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；</li>\n<li>♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；</li>\n<li>♮，還原號，英文natural，表示復歸原先的音高。</li>\n</ul>\n<h3 id=\"Major\"><a href=\"#Major\" class=\"headerlink\" title=\"Major\"></a>Major</h3><p><strong>major 大調</strong><br><img src=\"/2021/02/06/music/listen-chopin-raindrop/cdefgab.jpg\" alt><br>名詞解釋：</p>\n<ul>\n<li>簡譜：用數字表示音的簡單記譜方式</li>\n<li>音名：音的名字</li>\n<li>唱名：音的唱法</li>\n<li>距離：代表兩個音之間的距離</li>\n<li>半音：最靠近的兩個音之間的距離</li>\n<li>全音：1全音 = 1半音 + 1半音<br><img src=\"/2021/02/06/music/listen-chopin-raindrop/piano-keys.gif\" alt><br>E－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。</li>\n</ul>\n<p>記憶方法：<br>1    Do    C    這個不需要想，也很直覺，乾脆就直接背了<br>2    Re    D    Double 跟 Repeat 都可以聯想到 2<br>3    Mi    E    3 M E 都長的很像<br>4    Fa    F    4 的英文單字是 Four<br>5    Sol    G    你跟別人 Give me five 是用手 (Sol) 來的<br>6    La    A    六的閩南語念成什麼? 尾音 A<br>7    Si    B    七夕(Si)。 SB</p>\n<p>音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：</p>\n<ul>\n<li>C Major：C D E F G A B C</li>\n<li>Db Major：Db Eb F Gb Ab Bb C Db</li>\n</ul>\n<p><strong>minor 小調</strong><br>音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。</p>\n<h3 id=\"Op-28-No-15\"><a href=\"#Op-28-No-15\" class=\"headerlink\" title=\"Op. 28 , No. 15\"></a>Op. 28 , No. 15</h3><p>Op. 28 , No. 15：作品 28 之 15<br>Op.，拉丁文 Opus，著作，尤指編號的音樂作品。<br>No.，Number，編號。</p>\n<h2 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考\"></a>參考</h2><ol>\n<li><a href=\"http://www.dancepiano.com/scalechar.aspx\" title=\"音階與調性\"> 音階與調性 </a></li>\n<li><a href=\"https://www.guitar.com.tw/basic-music-theory/\" title=\"必學基礎樂理：音階/簡譜/音名/唱名\"> 必學基礎樂理：音階/簡譜/音名/唱名 </a></li>\n<li><a href=\"http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf\" title=\"音階基本概念\"> 音階基本概念 </a></li>\n</ol>"},{"title":"光和熱","p":"essay/light-and-heat","date":"2021-09-05T14:17:00.000Z","_content":"\n我努力地呼吸\nI try hard to breathe\n仍然覺得氧氣不夠\nMaybe the oxygen is too thin and\n肺部仿佛被什麼東西重重壓著\nSomething heavy presses my lung\n快要令我窒息\nWhich make me suffocating\n\n<!--more-->\n\n我努力地呼吸\nI try hard to breathe\n想到兒時的烏婆嶺\nThink of the Oubo hill\n那兒風吹樹葉陽光正好\nWhere the wind brows the leaves, the sunshine is perfect\n我跑步去到那裡\nAnd I go running\n\n何等光彩奪目\nHow dazzling the sunshine is\n我關掉了空調\nI turn off the air-conditioner \n推開窗\nAnd push the window\n感受光和熱\nFeel the light and heat\n","source":"_posts/essay/light-and-heat.md","raw":"---\ntitle: 光和熱\np: essay/light-and-heat\ndate: 2021-09-05 22:17:00\ntags: 隨筆\n---\n\n我努力地呼吸\nI try hard to breathe\n仍然覺得氧氣不夠\nMaybe the oxygen is too thin and\n肺部仿佛被什麼東西重重壓著\nSomething heavy presses my lung\n快要令我窒息\nWhich make me suffocating\n\n<!--more-->\n\n我努力地呼吸\nI try hard to breathe\n想到兒時的烏婆嶺\nThink of the Oubo hill\n那兒風吹樹葉陽光正好\nWhere the wind brows the leaves, the sunshine is perfect\n我跑步去到那裡\nAnd I go running\n\n何等光彩奪目\nHow dazzling the sunshine is\n我關掉了空調\nI turn off the air-conditioner \n推開窗\nAnd push the window\n感受光和熱\nFeel the light and heat\n","slug":"essay/light-and-heat","published":1,"updated":"2021-09-05T14:23:24.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wo800039a9k0do7hn31","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>我努力地呼吸<br>I try hard to breathe<br>仍然覺得氧氣不夠<br>Maybe the oxygen is too thin and<br>肺部仿佛被什麼東西重重壓著<br>Something heavy presses my lung<br>快要令我窒息<br>Which make me suffocating</p>\n<span id=\"more\"></span>\n\n<p>我努力地呼吸<br>I try hard to breathe<br>想到兒時的烏婆嶺<br>Think of the Oubo hill<br>那兒風吹樹葉陽光正好<br>Where the wind brows the leaves, the sunshine is perfect<br>我跑步去到那裡<br>And I go running</p>\n<p>何等光彩奪目<br>How dazzling the sunshine is<br>我關掉了空調<br>I turn off the air-conditioner<br>推開窗<br>And push the window<br>感受光和熱<br>Feel the light and heat</p>\n","site":{"data":{}},"excerpt":"<p>我努力地呼吸<br>I try hard to breathe<br>仍然覺得氧氣不夠<br>Maybe the oxygen is too thin and<br>肺部仿佛被什麼東西重重壓著<br>Something heavy presses my lung<br>快要令我窒息<br>Which make me suffocating</p>","more":"<p>我努力地呼吸<br>I try hard to breathe<br>想到兒時的烏婆嶺<br>Think of the Oubo hill<br>那兒風吹樹葉陽光正好<br>Where the wind brows the leaves, the sunshine is perfect<br>我跑步去到那裡<br>And I go running</p>\n<p>何等光彩奪目<br>How dazzling the sunshine is<br>我關掉了空調<br>I turn off the air-conditioner<br>推開窗<br>And push the window<br>感受光和熱<br>Feel the light and heat</p>"},{"title":"《Go 設計與實現》筆記之第二章 編譯原理","p":"it/go/go-design-and-implementation-02.md","_content":"\n編譯原理這一章講 Go 的源代碼是如何變成二進制碼的，可分爲四個過程：\n\n1. 詞法和語法分析 lexical and grammar analysis\n2. 類型檢查 type check\n3. 中間代碼生成 IR(intermediate representation) generation\n4. 機器碼生成 machine code generation\n\n詞法分析是將源代碼視爲字符串序列，對各個字符串進行標記，生成 Token 序列。\n\n語法分析是將 Token 序列按照 LALR(1)（向前查看和自底向上解析）的解析文法進行解析，生成一棵AST (抽象語法樹 )。\n\n類型檢查分靜態類型檢查和動態類型檢查，靜態類型檢查會在編譯期對變量賦值、返回值和函數參數進行類型檢查；動態類型檢查在代碼運行時進行，可以實現向下類型轉換、延遲綁定和反射等功能。\n\n中間代碼生成階段首先會進行 ssaconfig 的初始化，緩存可能需要用到的類型和指針；然後進行遍歷和替換，將內建函數 make、map、channel、new、select、panic、recover 等等替換成 runtime 包的函數。最後不斷地進行中間代碼生成，優化代碼，生成類似彙編代碼的代碼。\n\n機器碼生成階段分兩個部分：一是 SSA 中間代碼降級、針對特定CPU架構的中間代碼優化和重寫，最後生成相當接近特定架構彙編代碼的指令；二是將特定架構的指令轉成二進制代碼。\n\n<!--more-->\n\n## 2.1 概述\n\n編譯原理就是講編譯器如何將代碼編譯成二進制碼。\n\n### 2.1.1 預備知識\n\n**（1）抽象語法樹**\n\n抽象語法樹（Abstract Syntax Tree、AST），是源代碼語法的結構的樹狀表示。以表達式 2 * 3 + 7 為例，編譯器的語法分析階段會生成如下圖所示的抽象語法樹：\n\n![](go-design-and-implementation-02/Untitled.png)\n\n**（2）靜態單賦值**\n\n靜態單賦值（Static Single Assignment、SSA），是指中間代碼每個變量只會被賦值一次。例如以下代碼：\n\n```go\nx := 1\nx := 2\ny := x\n```\n\n其中間的代碼爲：\n\n```go\nx_1 := 1\nx_2 := 2\ny_1 := x_2\n```\n\n由於 x_1 := 1 沒有什麼用，因此會在生成機器碼時省去。\n\n**（3）指令集**\n\n指令集或者說指令集架構 (Instruction set architecture, ISA)，就是計算機的抽象模型。指令集可分爲兩大類：\n\n- 複雜指令集計算機 (complex instruction set computer, CISC)：包含了很多特定的指令，但是其中的一些指令很少會被程序使用（據說有 80% 不經常使用）。例如：Intel 8080、x86-family。\n- 精簡指令集計算機 (reduced instruction set computer, RISC)：只實現了經常被使用的指令，不常用的操作都會通過組合簡單指令來實現。例如：ARM、Power ISA。\n\n### 2.1.2 編譯原理\n\n![](go-design-and-implementation-02/Untitled%201.png)\n\n編譯器的前端：\n\n- 詞法分析 lexical analysis\n- 語法分析 syntax analysis\n- 語義分析 semantic analysis\n\n編譯器的後端：\n\n- 中間代碼生成 IR(Intermediate Representation)  generation\n- 代碼優化 code optimization\n- 機器碼生成 machinecode generation\n\nGo 的編譯器邏輯上可以分爲四個階段：\n\n1. 詞法和語法分析，將源代碼字符串序列轉成 Token 序列，再轉成抽象語法樹。\n2. 類型檢查，檢查類型，並展開內建的函數。\n3. 中間代碼生成，使用 goroutine 並發生成中間代碼，並進行 SSA 優化。\n4. 機器碼生成，根據不同類型的 CPU 生成不同的機器碼\n\nGo 的編譯器入口在 [src/cmd/compile/internal/gc/main.go](https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go) 文件中，其中的 Main 函數就是編譯器的主要程序，其工作過程是：\n\n1. 獲取命令行傳入的參數並更新編譯選項和配置。\n2. 調用 parseFiles 方法解析輸入的文件，得到 AST，隨後進行以下 9 個步驟：\n    1. const, type, and names and types of funcs（檢查常量、類型以及函數的名稱和類型）\n    2. Variable assignments（處理變量賦值）\n    3. Type check function bodies（對函數體進行類型檢查）\n    4. Decide how to capture closed variables（決定如何捕獲封閉的變量）\n    5. Inlining（處理內聯函數）\n    6. Escape analysis（進行逃逸分析）\n    7. Transform closure bodies to properly reference captured variables（將閉包的主體轉成實際引用的捕獲變量）\n    8. Compile top level functions（編譯頂層函數）\n    9. Check external declarations（檢查外部聲明）\n\n## 2.2 詞法和語法分析\n\n### 2.2.1 詞法分析\n\n詞法分析就是將源代碼的字符串序列轉成標記(Token)序列的過程。如 `make(chan int)` 經過詞法分析後是一個由 `make` 、`(`、`chan`、`int` 和 `)` 組成的 Token序列。\n\n可以使用 lex 工具進行詞法分析，Go 早期也是使用該工具，[該案例](https://github.com/LinLshare/case/blob/main/doc/compile/compile_001_flex)展示了使用 lex 工具進行詞法分析。後期更換成了自身，[該案例](https://github.com/LinLshare/case/blob/main/doc/compile/compile_002_golang_lexer)展示了使用 Go 自帶的詞法分析器進行詞法分析。\n\n### 2.2.2 語法分析\n\n語法分析是根據某種特定的形式文法（Grammar）對 Token 序列構成的輸入文本進行分析並確定其語法結構的過程。\n\n**文法**\n\n上下文無關文法([context-free grammar](https://en.wikipedia.org/wiki/Context-free_grammar)) 是用來形式化、精確描述某種編程語言的工具，由以下四個部分組成：\n\n1. N, 有限個非終結符的集合\n2. Σ, 有限個終結符的集合\n3. P, 有限個生成規則(production rule)的集合\n4. S, 開始變量或符號，用來代表整個語句或程序，是集合N的成員。\n\n非終結符可以使用一組終結符根據生成規則展開，而終結符是語言定義的基本元素，不可展開。\n\nP = N x (NvΣ)* 即生成規則是集合 N與集合N、Σ的併集的 Kleene 操作之間的二元關係。\n\n假定有以下生成規則：\n\n1. S —> aSb // S 可以展開爲 aSb\n2. S —> ab // S 可以展開爲 ab\n\n那麼，aabb（運用一次規則1，一次規則2）、aaabbb（運用兩次規則1，一次規則2）等就是符合語法規則的表示。\n\n**解析方法**\n\n解析文法的方法有兩種：\n\n1. **自頂向下解析**(Top-down parsing)：從最高級別開始解析，不斷地用生成規則右側的符號展開非終結符，直到最低級別的終結符號。\n2. **自底向上解析**(Bottom-up parsing)：從最低級別開始解析，不斷地用生成規則左側非終結符歸約，直到最高級別的開始符號。\n\n**LL文法**是一種使用自頂向下解析的文法。假定有 LL文法如下：\n\n1. 𝑆→𝑎𝑆1\n2. 𝑆1→𝑏𝑆1\n3. 𝑆1→𝜖\n\n輸入流 abb 採用上面的文法進行解析，其過程爲：\n\n1. S （開始符號）\n2. aS1（規則 1）\n3. abS1 （規則 2）\n4. abbS1 （規則2）\n5. abb（規則 3）\n\n**LR(0) 文法**是一种使用自底向上解析的文法。假定有 LR(0) 文法如下：\n\n1. 𝑆→𝑆1\n2. 𝑆1→𝑆1𝑏\n3. 𝑆1→𝑎\n\n輸入流 abb 採用上面的文法進行解析，其過程爲：\n\n1. a（入棧）\n2. S1（規則3）\n3. S1b（入棧）\n4. S1（規則2）\n5. S1b（入棧）\n6. S1（規則2）\n7. S（規則1）\n\n當有多個生成規則符合時，會出現衝突。解析時可以採用 **Lookahead** 向前查看技術解決，即預讀一個 Token 確保出現衝突的生成規則可以被正確處理。\n\nGo 語言的解析器採用 LALR(1) 的文法進行解析，是一種自底向上且帶有 **Lookahead**(縮寫爲LA) 功能的解析文法。LALR(1)  也是大多數編程語言的選擇。\n\n**Go 文法**\n\n閱讀 src/cmd/compile/internal/syntax/parser.go，可知：\n\n每個 Go 源代碼文件最終都會被解析成一個獨立的抽象語法樹，所以語法樹最頂層的結構或者開始符號都是 SourceFile：\n\n```go\nSourceFile = PackageClause \";\" { ImportDecl \";\" } { TopLevelDecl \";\" } .\n```\n\nPackageClause 的生成規則爲：\n\n```go\nPackageClause  = \"package\" PackageName .\nPackageName    = identifier .\nidentifier = letter { letter | unicode_digit } .\n```\n\nImportDecl 的生成規則爲：\n\n```go\nImportDecl       = \"import\" ( ImportSpec | \"(\" { ImportSpec \";\" } \")\" ) .\nImportSpec       = [ \".\" | PackageName ] ImportPath .\nImportPath       = string_lit .\n```\n\nTopLevelDecl 的生成規則爲：\n\n```go\nTopLevelDecl  = Declaration | FunctionDecl | MethodDecl .\nDeclaration   = ConstDecl | TypeDecl | VarDecl .\n```\n\n可知頂層的聲明共有五種，分別是常量、類型、變量、函數和方法聲明，其生成规则如下：\n\n```go\nConstDecl = \"const\" ( ConstSpec | \"(\" { ConstSpec \";\" } \")\" ) .\nConstSpec = IdentifierList [ [ Type ] \"=\" ExpressionList ] .\n\nTypeDecl  = \"type\" ( TypeSpec | \"(\" { TypeSpec \";\" } \")\" ) .\nTypeSpec  = AliasDecl | TypeDef .\nAliasDecl = identifier \"=\" Type .\nTypeDef   = identifier Type .\n\nVarDecl = \"var\" ( VarSpec | \"(\" { VarSpec \";\" } \")\" ) .\nVarSpec = IdentifierList ( Type [ \"=\" ExpressionList ] | \"=\" ExpressionList ) .\n\nFunctionDecl = \"func\" FunctionName Signature [ FunctionBody ] .\nFunctionName = identifier .\nFunctionBody = Block .\n\nMethodDecl = \"func\" Receiver MethodName Signature [ FunctionBody ] .\nReceiver   = Parameters .\n\nBlock = \"{\" StatementList \"}\" .\nStatementList = { Statement \";\" } .\n\nStatement =\n\tDeclaration | LabeledStmt | SimpleStmt |\n\tGoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |\n\tFallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |\n\tDeferStmt .\n\nSimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .\n```\n\n更詳細的文法見：[Language Specification](https://golang.org/ref/spec#Declarations_and_scope)。\n\n## 2.3 類型檢查\n\n類型檢查的目的在於確保代碼正確執行。\n\n類型分兩種：強類型和弱類型。一般來說，強類型是在編譯期間有嚴格的類型限制，會在編譯期間發現變量賦值、返回值和函數調用是的類型錯誤。弱類型則是在運行時出現類型錯誤時進行隱式類型轉換。\n\n檢查也分兩種：靜態類型檢查和動態類型檢查。靜態類型檢查是在編譯期進行，動態類型檢查是在運行期間進行。實現動態類型檢查通常是爲每個運行時對象關聯一個類型標籤，包含了它的類型信息（RTTI, the Runtime type information），用來實現動態派發、延遲綁定、向下轉型和反射等等。\n\n另外，只使用動態類型檢查的編程語言叫做動態類型編程語言，比如 JavaScript、Ruby 和 PHP。\n\nGo 進行靜態類型檢查的代碼主要邏輯在 [cmd/compile/internal/gc.typecheck](https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck) 和 [cmd/compile/internal/gc.typecheck1](https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1) 中。\n\n```go\nfunc typecheck1(n *Node, top int) (res *Node) {\n\tswitch n.Op {\n\tcase OTARRAY:\n\t\t...\n\n\tcase OTMAP:\n\t\t...\n\n\tcase OTCHAN:\n\t\t...\n\t}\n\n\t...\n\n\treturn n\n}\n```\n\n介紹幾種常見類型的檢查過程：\n\n- OTARRAY 數組或切片類型：\n    1. 對右節點也就是元素進行類型檢查\n    2. 對左節點，按三種情況：\n        1. []int，直接調用 [cmd/compile/internal/types.NewSlice](https://draveness.me/golang/tree/cmd/compile/internal/types.NewSlice)，返回一個 `TSLICE` 類型的結構體。\n        2. [...]int，ODDD(即...) 先調用 [cmd/compile/internal/gc.typecheckcomplit]() ，後調用 [cmd/compile/internal/types.NewArray](https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray) 初始化一個存儲著數組中元素類型和數組大小的結構體。\n        3. [3]int，調用 [cmd/compile/internal/types.NewArray](https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray) 初始化一個存儲著數組中元素類型和數組大小的結構體。\n- OTMAP 哈希類型：\n    1. 分別檢查鍵值類型\n    2. 通過 [cmd/compile/internal/types.NewMap]() 创建一个新的 TMAP 结构并将哈希的键值类型都存储到该结构体\n    3. 代表當前哈希的節點最終也會被加入 mapqueue 隊列，編譯器會在後面的階段對哈希鍵的類型進行再次檢查。\n- OMAKE 內置函數make\n    1. 檢查第一個類型參數，然後據此進入不同的分支：TSLICE 切片分支、TMAP 哈希分支和 TCHAN 信道分支。\n    2. 如是 TSLICE 分支，將檢查 len 和 cap 的合法性，然後將當前節點的 Op 改爲 OMAKESLICE。\n    3. 如是 TMAP 分支，將在檢查 size 之後將當前節點的 Op 改爲 OMAKEMAP。\n    4. 如是 TCHAN 分支，將在檢查 buffer 之後將當前節點的 Op 改爲 OMAKECHAN。\n\n## 2.4 中間代碼生成\n\n中間代碼生成是爲了解決直接編譯成二進制碼的複雜。通過將複雜問題拆分成一個個簡單的步驟，再逐個擊破，這就是中間代碼的作用。\n\nAST 和二進制碼之間隔了幾十次中間代碼的生成。生成之初會將緩存可能需要用到的類型和指針，並將內建函數映射到 runtime包中的函數。之後每次中間代碼的生成都是對代碼的優化，最後生成具備 SSA 特性的中間代碼。\n\n![](go-design-and-implementation-02/Untitled%202.png)\n\n關鍵字和操作符和運行時函數的映射\n\n中間代碼不是彙編代碼，但是很接近彙編代碼，也用到一些寄存器，可說是彙編代碼的偽代碼（pseudo code），中間代碼形如：\n\n```go\npass trim begin\n  pass trim end [738 ns]\nhello func(int) int\n  b1:\n    v1 = InitMem <mem>\n    v10 = VarDef <mem> {~r1} v1\n    v2 = SP <uintptr> : SP\n    v6 = Arg <int> {a} : a[int]\n    v8 = LoadReg <int> v6 : AX\n    v9 = ADDQconst <int> [2] v8 : AX (c[int])\n    v11 = MOVQstore <mem> {~r1} v2 v9 v10\n    Ret v11\n```\n\n## 2.5 機器碼生成\n\n機器碼的生成包含兩個部分：\n\n1. [cmd/compile/internal/ssa](https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa) 進行 SSA 中間代碼的降級過程，執行架構特定的優化和重寫，最後生成架構特定的指令 [cmd/compile/internal/obj.Prog](https://draveness.me/golang/tree/cmd/compile/internal/obj.Prog)。\n2. [cmd/internal/obj](https://github.com/golang/go/tree/master/src/cmd/internal/obj) 作爲彙編器將架構特定的指令轉成二進制代碼。","source":"_posts/it/go/go-design-and-implementation-02.md","raw":"---\ntitle: 《Go 設計與實現》筆記之第二章 編譯原理\np: it/go/go-design-and-implementation-02.md\ntags:\n- Go\n---\n\n編譯原理這一章講 Go 的源代碼是如何變成二進制碼的，可分爲四個過程：\n\n1. 詞法和語法分析 lexical and grammar analysis\n2. 類型檢查 type check\n3. 中間代碼生成 IR(intermediate representation) generation\n4. 機器碼生成 machine code generation\n\n詞法分析是將源代碼視爲字符串序列，對各個字符串進行標記，生成 Token 序列。\n\n語法分析是將 Token 序列按照 LALR(1)（向前查看和自底向上解析）的解析文法進行解析，生成一棵AST (抽象語法樹 )。\n\n類型檢查分靜態類型檢查和動態類型檢查，靜態類型檢查會在編譯期對變量賦值、返回值和函數參數進行類型檢查；動態類型檢查在代碼運行時進行，可以實現向下類型轉換、延遲綁定和反射等功能。\n\n中間代碼生成階段首先會進行 ssaconfig 的初始化，緩存可能需要用到的類型和指針；然後進行遍歷和替換，將內建函數 make、map、channel、new、select、panic、recover 等等替換成 runtime 包的函數。最後不斷地進行中間代碼生成，優化代碼，生成類似彙編代碼的代碼。\n\n機器碼生成階段分兩個部分：一是 SSA 中間代碼降級、針對特定CPU架構的中間代碼優化和重寫，最後生成相當接近特定架構彙編代碼的指令；二是將特定架構的指令轉成二進制代碼。\n\n<!--more-->\n\n## 2.1 概述\n\n編譯原理就是講編譯器如何將代碼編譯成二進制碼。\n\n### 2.1.1 預備知識\n\n**（1）抽象語法樹**\n\n抽象語法樹（Abstract Syntax Tree、AST），是源代碼語法的結構的樹狀表示。以表達式 2 * 3 + 7 為例，編譯器的語法分析階段會生成如下圖所示的抽象語法樹：\n\n![](go-design-and-implementation-02/Untitled.png)\n\n**（2）靜態單賦值**\n\n靜態單賦值（Static Single Assignment、SSA），是指中間代碼每個變量只會被賦值一次。例如以下代碼：\n\n```go\nx := 1\nx := 2\ny := x\n```\n\n其中間的代碼爲：\n\n```go\nx_1 := 1\nx_2 := 2\ny_1 := x_2\n```\n\n由於 x_1 := 1 沒有什麼用，因此會在生成機器碼時省去。\n\n**（3）指令集**\n\n指令集或者說指令集架構 (Instruction set architecture, ISA)，就是計算機的抽象模型。指令集可分爲兩大類：\n\n- 複雜指令集計算機 (complex instruction set computer, CISC)：包含了很多特定的指令，但是其中的一些指令很少會被程序使用（據說有 80% 不經常使用）。例如：Intel 8080、x86-family。\n- 精簡指令集計算機 (reduced instruction set computer, RISC)：只實現了經常被使用的指令，不常用的操作都會通過組合簡單指令來實現。例如：ARM、Power ISA。\n\n### 2.1.2 編譯原理\n\n![](go-design-and-implementation-02/Untitled%201.png)\n\n編譯器的前端：\n\n- 詞法分析 lexical analysis\n- 語法分析 syntax analysis\n- 語義分析 semantic analysis\n\n編譯器的後端：\n\n- 中間代碼生成 IR(Intermediate Representation)  generation\n- 代碼優化 code optimization\n- 機器碼生成 machinecode generation\n\nGo 的編譯器邏輯上可以分爲四個階段：\n\n1. 詞法和語法分析，將源代碼字符串序列轉成 Token 序列，再轉成抽象語法樹。\n2. 類型檢查，檢查類型，並展開內建的函數。\n3. 中間代碼生成，使用 goroutine 並發生成中間代碼，並進行 SSA 優化。\n4. 機器碼生成，根據不同類型的 CPU 生成不同的機器碼\n\nGo 的編譯器入口在 [src/cmd/compile/internal/gc/main.go](https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go) 文件中，其中的 Main 函數就是編譯器的主要程序，其工作過程是：\n\n1. 獲取命令行傳入的參數並更新編譯選項和配置。\n2. 調用 parseFiles 方法解析輸入的文件，得到 AST，隨後進行以下 9 個步驟：\n    1. const, type, and names and types of funcs（檢查常量、類型以及函數的名稱和類型）\n    2. Variable assignments（處理變量賦值）\n    3. Type check function bodies（對函數體進行類型檢查）\n    4. Decide how to capture closed variables（決定如何捕獲封閉的變量）\n    5. Inlining（處理內聯函數）\n    6. Escape analysis（進行逃逸分析）\n    7. Transform closure bodies to properly reference captured variables（將閉包的主體轉成實際引用的捕獲變量）\n    8. Compile top level functions（編譯頂層函數）\n    9. Check external declarations（檢查外部聲明）\n\n## 2.2 詞法和語法分析\n\n### 2.2.1 詞法分析\n\n詞法分析就是將源代碼的字符串序列轉成標記(Token)序列的過程。如 `make(chan int)` 經過詞法分析後是一個由 `make` 、`(`、`chan`、`int` 和 `)` 組成的 Token序列。\n\n可以使用 lex 工具進行詞法分析，Go 早期也是使用該工具，[該案例](https://github.com/LinLshare/case/blob/main/doc/compile/compile_001_flex)展示了使用 lex 工具進行詞法分析。後期更換成了自身，[該案例](https://github.com/LinLshare/case/blob/main/doc/compile/compile_002_golang_lexer)展示了使用 Go 自帶的詞法分析器進行詞法分析。\n\n### 2.2.2 語法分析\n\n語法分析是根據某種特定的形式文法（Grammar）對 Token 序列構成的輸入文本進行分析並確定其語法結構的過程。\n\n**文法**\n\n上下文無關文法([context-free grammar](https://en.wikipedia.org/wiki/Context-free_grammar)) 是用來形式化、精確描述某種編程語言的工具，由以下四個部分組成：\n\n1. N, 有限個非終結符的集合\n2. Σ, 有限個終結符的集合\n3. P, 有限個生成規則(production rule)的集合\n4. S, 開始變量或符號，用來代表整個語句或程序，是集合N的成員。\n\n非終結符可以使用一組終結符根據生成規則展開，而終結符是語言定義的基本元素，不可展開。\n\nP = N x (NvΣ)* 即生成規則是集合 N與集合N、Σ的併集的 Kleene 操作之間的二元關係。\n\n假定有以下生成規則：\n\n1. S —> aSb // S 可以展開爲 aSb\n2. S —> ab // S 可以展開爲 ab\n\n那麼，aabb（運用一次規則1，一次規則2）、aaabbb（運用兩次規則1，一次規則2）等就是符合語法規則的表示。\n\n**解析方法**\n\n解析文法的方法有兩種：\n\n1. **自頂向下解析**(Top-down parsing)：從最高級別開始解析，不斷地用生成規則右側的符號展開非終結符，直到最低級別的終結符號。\n2. **自底向上解析**(Bottom-up parsing)：從最低級別開始解析，不斷地用生成規則左側非終結符歸約，直到最高級別的開始符號。\n\n**LL文法**是一種使用自頂向下解析的文法。假定有 LL文法如下：\n\n1. 𝑆→𝑎𝑆1\n2. 𝑆1→𝑏𝑆1\n3. 𝑆1→𝜖\n\n輸入流 abb 採用上面的文法進行解析，其過程爲：\n\n1. S （開始符號）\n2. aS1（規則 1）\n3. abS1 （規則 2）\n4. abbS1 （規則2）\n5. abb（規則 3）\n\n**LR(0) 文法**是一种使用自底向上解析的文法。假定有 LR(0) 文法如下：\n\n1. 𝑆→𝑆1\n2. 𝑆1→𝑆1𝑏\n3. 𝑆1→𝑎\n\n輸入流 abb 採用上面的文法進行解析，其過程爲：\n\n1. a（入棧）\n2. S1（規則3）\n3. S1b（入棧）\n4. S1（規則2）\n5. S1b（入棧）\n6. S1（規則2）\n7. S（規則1）\n\n當有多個生成規則符合時，會出現衝突。解析時可以採用 **Lookahead** 向前查看技術解決，即預讀一個 Token 確保出現衝突的生成規則可以被正確處理。\n\nGo 語言的解析器採用 LALR(1) 的文法進行解析，是一種自底向上且帶有 **Lookahead**(縮寫爲LA) 功能的解析文法。LALR(1)  也是大多數編程語言的選擇。\n\n**Go 文法**\n\n閱讀 src/cmd/compile/internal/syntax/parser.go，可知：\n\n每個 Go 源代碼文件最終都會被解析成一個獨立的抽象語法樹，所以語法樹最頂層的結構或者開始符號都是 SourceFile：\n\n```go\nSourceFile = PackageClause \";\" { ImportDecl \";\" } { TopLevelDecl \";\" } .\n```\n\nPackageClause 的生成規則爲：\n\n```go\nPackageClause  = \"package\" PackageName .\nPackageName    = identifier .\nidentifier = letter { letter | unicode_digit } .\n```\n\nImportDecl 的生成規則爲：\n\n```go\nImportDecl       = \"import\" ( ImportSpec | \"(\" { ImportSpec \";\" } \")\" ) .\nImportSpec       = [ \".\" | PackageName ] ImportPath .\nImportPath       = string_lit .\n```\n\nTopLevelDecl 的生成規則爲：\n\n```go\nTopLevelDecl  = Declaration | FunctionDecl | MethodDecl .\nDeclaration   = ConstDecl | TypeDecl | VarDecl .\n```\n\n可知頂層的聲明共有五種，分別是常量、類型、變量、函數和方法聲明，其生成规则如下：\n\n```go\nConstDecl = \"const\" ( ConstSpec | \"(\" { ConstSpec \";\" } \")\" ) .\nConstSpec = IdentifierList [ [ Type ] \"=\" ExpressionList ] .\n\nTypeDecl  = \"type\" ( TypeSpec | \"(\" { TypeSpec \";\" } \")\" ) .\nTypeSpec  = AliasDecl | TypeDef .\nAliasDecl = identifier \"=\" Type .\nTypeDef   = identifier Type .\n\nVarDecl = \"var\" ( VarSpec | \"(\" { VarSpec \";\" } \")\" ) .\nVarSpec = IdentifierList ( Type [ \"=\" ExpressionList ] | \"=\" ExpressionList ) .\n\nFunctionDecl = \"func\" FunctionName Signature [ FunctionBody ] .\nFunctionName = identifier .\nFunctionBody = Block .\n\nMethodDecl = \"func\" Receiver MethodName Signature [ FunctionBody ] .\nReceiver   = Parameters .\n\nBlock = \"{\" StatementList \"}\" .\nStatementList = { Statement \";\" } .\n\nStatement =\n\tDeclaration | LabeledStmt | SimpleStmt |\n\tGoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |\n\tFallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |\n\tDeferStmt .\n\nSimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .\n```\n\n更詳細的文法見：[Language Specification](https://golang.org/ref/spec#Declarations_and_scope)。\n\n## 2.3 類型檢查\n\n類型檢查的目的在於確保代碼正確執行。\n\n類型分兩種：強類型和弱類型。一般來說，強類型是在編譯期間有嚴格的類型限制，會在編譯期間發現變量賦值、返回值和函數調用是的類型錯誤。弱類型則是在運行時出現類型錯誤時進行隱式類型轉換。\n\n檢查也分兩種：靜態類型檢查和動態類型檢查。靜態類型檢查是在編譯期進行，動態類型檢查是在運行期間進行。實現動態類型檢查通常是爲每個運行時對象關聯一個類型標籤，包含了它的類型信息（RTTI, the Runtime type information），用來實現動態派發、延遲綁定、向下轉型和反射等等。\n\n另外，只使用動態類型檢查的編程語言叫做動態類型編程語言，比如 JavaScript、Ruby 和 PHP。\n\nGo 進行靜態類型檢查的代碼主要邏輯在 [cmd/compile/internal/gc.typecheck](https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck) 和 [cmd/compile/internal/gc.typecheck1](https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1) 中。\n\n```go\nfunc typecheck1(n *Node, top int) (res *Node) {\n\tswitch n.Op {\n\tcase OTARRAY:\n\t\t...\n\n\tcase OTMAP:\n\t\t...\n\n\tcase OTCHAN:\n\t\t...\n\t}\n\n\t...\n\n\treturn n\n}\n```\n\n介紹幾種常見類型的檢查過程：\n\n- OTARRAY 數組或切片類型：\n    1. 對右節點也就是元素進行類型檢查\n    2. 對左節點，按三種情況：\n        1. []int，直接調用 [cmd/compile/internal/types.NewSlice](https://draveness.me/golang/tree/cmd/compile/internal/types.NewSlice)，返回一個 `TSLICE` 類型的結構體。\n        2. [...]int，ODDD(即...) 先調用 [cmd/compile/internal/gc.typecheckcomplit]() ，後調用 [cmd/compile/internal/types.NewArray](https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray) 初始化一個存儲著數組中元素類型和數組大小的結構體。\n        3. [3]int，調用 [cmd/compile/internal/types.NewArray](https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray) 初始化一個存儲著數組中元素類型和數組大小的結構體。\n- OTMAP 哈希類型：\n    1. 分別檢查鍵值類型\n    2. 通過 [cmd/compile/internal/types.NewMap]() 创建一个新的 TMAP 结构并将哈希的键值类型都存储到该结构体\n    3. 代表當前哈希的節點最終也會被加入 mapqueue 隊列，編譯器會在後面的階段對哈希鍵的類型進行再次檢查。\n- OMAKE 內置函數make\n    1. 檢查第一個類型參數，然後據此進入不同的分支：TSLICE 切片分支、TMAP 哈希分支和 TCHAN 信道分支。\n    2. 如是 TSLICE 分支，將檢查 len 和 cap 的合法性，然後將當前節點的 Op 改爲 OMAKESLICE。\n    3. 如是 TMAP 分支，將在檢查 size 之後將當前節點的 Op 改爲 OMAKEMAP。\n    4. 如是 TCHAN 分支，將在檢查 buffer 之後將當前節點的 Op 改爲 OMAKECHAN。\n\n## 2.4 中間代碼生成\n\n中間代碼生成是爲了解決直接編譯成二進制碼的複雜。通過將複雜問題拆分成一個個簡單的步驟，再逐個擊破，這就是中間代碼的作用。\n\nAST 和二進制碼之間隔了幾十次中間代碼的生成。生成之初會將緩存可能需要用到的類型和指針，並將內建函數映射到 runtime包中的函數。之後每次中間代碼的生成都是對代碼的優化，最後生成具備 SSA 特性的中間代碼。\n\n![](go-design-and-implementation-02/Untitled%202.png)\n\n關鍵字和操作符和運行時函數的映射\n\n中間代碼不是彙編代碼，但是很接近彙編代碼，也用到一些寄存器，可說是彙編代碼的偽代碼（pseudo code），中間代碼形如：\n\n```go\npass trim begin\n  pass trim end [738 ns]\nhello func(int) int\n  b1:\n    v1 = InitMem <mem>\n    v10 = VarDef <mem> {~r1} v1\n    v2 = SP <uintptr> : SP\n    v6 = Arg <int> {a} : a[int]\n    v8 = LoadReg <int> v6 : AX\n    v9 = ADDQconst <int> [2] v8 : AX (c[int])\n    v11 = MOVQstore <mem> {~r1} v2 v9 v10\n    Ret v11\n```\n\n## 2.5 機器碼生成\n\n機器碼的生成包含兩個部分：\n\n1. [cmd/compile/internal/ssa](https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa) 進行 SSA 中間代碼的降級過程，執行架構特定的優化和重寫，最後生成架構特定的指令 [cmd/compile/internal/obj.Prog](https://draveness.me/golang/tree/cmd/compile/internal/obj.Prog)。\n2. [cmd/internal/obj](https://github.com/golang/go/tree/master/src/cmd/internal/obj) 作爲彙編器將架構特定的指令轉成二進制代碼。","slug":"it/go/go-design-and-implementation-02","published":1,"date":"2021-02-05T16:21:16.536Z","updated":"2021-02-05T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wo900049a9khw360xtn","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>編譯原理這一章講 Go 的源代碼是如何變成二進制碼的，可分爲四個過程：</p>\n<ol>\n<li>詞法和語法分析 lexical and grammar analysis</li>\n<li>類型檢查 type check</li>\n<li>中間代碼生成 IR(intermediate representation) generation</li>\n<li>機器碼生成 machine code generation</li>\n</ol>\n<p>詞法分析是將源代碼視爲字符串序列，對各個字符串進行標記，生成 Token 序列。</p>\n<p>語法分析是將 Token 序列按照 LALR(1)（向前查看和自底向上解析）的解析文法進行解析，生成一棵AST (抽象語法樹 )。</p>\n<p>類型檢查分靜態類型檢查和動態類型檢查，靜態類型檢查會在編譯期對變量賦值、返回值和函數參數進行類型檢查；動態類型檢查在代碼運行時進行，可以實現向下類型轉換、延遲綁定和反射等功能。</p>\n<p>中間代碼生成階段首先會進行 ssaconfig 的初始化，緩存可能需要用到的類型和指針；然後進行遍歷和替換，將內建函數 make、map、channel、new、select、panic、recover 等等替換成 runtime 包的函數。最後不斷地進行中間代碼生成，優化代碼，生成類似彙編代碼的代碼。</p>\n<p>機器碼生成階段分兩個部分：一是 SSA 中間代碼降級、針對特定CPU架構的中間代碼優化和重寫，最後生成相當接近特定架構彙編代碼的指令；二是將特定架構的指令轉成二進制代碼。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h2><p>編譯原理就是講編譯器如何將代碼編譯成二進制碼。</p>\n<h3 id=\"2-1-1-預備知識\"><a href=\"#2-1-1-預備知識\" class=\"headerlink\" title=\"2.1.1 預備知識\"></a>2.1.1 預備知識</h3><p><strong>（1）抽象語法樹</strong></p>\n<p>抽象語法樹（Abstract Syntax Tree、AST），是源代碼語法的結構的樹狀表示。以表達式 2 * 3 + 7 為例，編譯器的語法分析階段會生成如下圖所示的抽象語法樹：</p>\n<p><img src=\"/2021/02/06/it/go/go-design-and-implementation-02/Untitled.png\" alt></p>\n<p><strong>（2）靜態單賦值</strong></p>\n<p>靜態單賦值（Static Single Assignment、SSA），是指中間代碼每個變量只會被賦值一次。例如以下代碼：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">1</span></span><br><span class=\"line\">x := <span class=\"number\">2</span></span><br><span class=\"line\">y := x</span><br></pre></td></tr></table></figure>\n\n<p>其中間的代碼爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x_1 := <span class=\"number\">1</span></span><br><span class=\"line\">x_2 := <span class=\"number\">2</span></span><br><span class=\"line\">y_1 := x_2</span><br></pre></td></tr></table></figure>\n\n<p>由於 x_1 := 1 沒有什麼用，因此會在生成機器碼時省去。</p>\n<p><strong>（3）指令集</strong></p>\n<p>指令集或者說指令集架構 (Instruction set architecture, ISA)，就是計算機的抽象模型。指令集可分爲兩大類：</p>\n<ul>\n<li>複雜指令集計算機 (complex instruction set computer, CISC)：包含了很多特定的指令，但是其中的一些指令很少會被程序使用（據說有 80% 不經常使用）。例如：Intel 8080、x86-family。</li>\n<li>精簡指令集計算機 (reduced instruction set computer, RISC)：只實現了經常被使用的指令，不常用的操作都會通過組合簡單指令來實現。例如：ARM、Power ISA。</li>\n</ul>\n<h3 id=\"2-1-2-編譯原理\"><a href=\"#2-1-2-編譯原理\" class=\"headerlink\" title=\"2.1.2 編譯原理\"></a>2.1.2 編譯原理</h3><p><img src=\"/2021/02/06/it/go/go-design-and-implementation-02/Untitled%201.png\" alt></p>\n<p>編譯器的前端：</p>\n<ul>\n<li>詞法分析 lexical analysis</li>\n<li>語法分析 syntax analysis</li>\n<li>語義分析 semantic analysis</li>\n</ul>\n<p>編譯器的後端：</p>\n<ul>\n<li>中間代碼生成 IR(Intermediate Representation)  generation</li>\n<li>代碼優化 code optimization</li>\n<li>機器碼生成 machinecode generation</li>\n</ul>\n<p>Go 的編譯器邏輯上可以分爲四個階段：</p>\n<ol>\n<li>詞法和語法分析，將源代碼字符串序列轉成 Token 序列，再轉成抽象語法樹。</li>\n<li>類型檢查，檢查類型，並展開內建的函數。</li>\n<li>中間代碼生成，使用 goroutine 並發生成中間代碼，並進行 SSA 優化。</li>\n<li>機器碼生成，根據不同類型的 CPU 生成不同的機器碼</li>\n</ol>\n<p>Go 的編譯器入口在 <a href=\"https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go\">src/cmd/compile/internal/gc/main.go</a> 文件中，其中的 Main 函數就是編譯器的主要程序，其工作過程是：</p>\n<ol>\n<li>獲取命令行傳入的參數並更新編譯選項和配置。</li>\n<li>調用 parseFiles 方法解析輸入的文件，得到 AST，隨後進行以下 9 個步驟：<ol>\n<li>const, type, and names and types of funcs（檢查常量、類型以及函數的名稱和類型）</li>\n<li>Variable assignments（處理變量賦值）</li>\n<li>Type check function bodies（對函數體進行類型檢查）</li>\n<li>Decide how to capture closed variables（決定如何捕獲封閉的變量）</li>\n<li>Inlining（處理內聯函數）</li>\n<li>Escape analysis（進行逃逸分析）</li>\n<li>Transform closure bodies to properly reference captured variables（將閉包的主體轉成實際引用的捕獲變量）</li>\n<li>Compile top level functions（編譯頂層函數）</li>\n<li>Check external declarations（檢查外部聲明）</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-2-詞法和語法分析\"><a href=\"#2-2-詞法和語法分析\" class=\"headerlink\" title=\"2.2 詞法和語法分析\"></a>2.2 詞法和語法分析</h2><h3 id=\"2-2-1-詞法分析\"><a href=\"#2-2-1-詞法分析\" class=\"headerlink\" title=\"2.2.1 詞法分析\"></a>2.2.1 詞法分析</h3><p>詞法分析就是將源代碼的字符串序列轉成標記(Token)序列的過程。如 <code>make(chan int)</code> 經過詞法分析後是一個由 <code>make</code> 、<code>(</code>、<code>chan</code>、<code>int</code> 和 <code>)</code> 組成的 Token序列。</p>\n<p>可以使用 lex 工具進行詞法分析，Go 早期也是使用該工具，<a href=\"https://github.com/LinLshare/case/blob/main/doc/compile/compile_001_flex\">該案例</a>展示了使用 lex 工具進行詞法分析。後期更換成了自身，<a href=\"https://github.com/LinLshare/case/blob/main/doc/compile/compile_002_golang_lexer\">該案例</a>展示了使用 Go 自帶的詞法分析器進行詞法分析。</p>\n<h3 id=\"2-2-2-語法分析\"><a href=\"#2-2-2-語法分析\" class=\"headerlink\" title=\"2.2.2 語法分析\"></a>2.2.2 語法分析</h3><p>語法分析是根據某種特定的形式文法（Grammar）對 Token 序列構成的輸入文本進行分析並確定其語法結構的過程。</p>\n<p><strong>文法</strong></p>\n<p>上下文無關文法(<a href=\"https://en.wikipedia.org/wiki/Context-free_grammar\">context-free grammar</a>) 是用來形式化、精確描述某種編程語言的工具，由以下四個部分組成：</p>\n<ol>\n<li>N, 有限個非終結符的集合</li>\n<li>Σ, 有限個終結符的集合</li>\n<li>P, 有限個生成規則(production rule)的集合</li>\n<li>S, 開始變量或符號，用來代表整個語句或程序，是集合N的成員。</li>\n</ol>\n<p>非終結符可以使用一組終結符根據生成規則展開，而終結符是語言定義的基本元素，不可展開。</p>\n<p>P = N x (NvΣ)* 即生成規則是集合 N與集合N、Σ的併集的 Kleene 操作之間的二元關係。</p>\n<p>假定有以下生成規則：</p>\n<ol>\n<li>S —&gt; aSb // S 可以展開爲 aSb</li>\n<li>S —&gt; ab // S 可以展開爲 ab</li>\n</ol>\n<p>那麼，aabb（運用一次規則1，一次規則2）、aaabbb（運用兩次規則1，一次規則2）等就是符合語法規則的表示。</p>\n<p><strong>解析方法</strong></p>\n<p>解析文法的方法有兩種：</p>\n<ol>\n<li><strong>自頂向下解析</strong>(Top-down parsing)：從最高級別開始解析，不斷地用生成規則右側的符號展開非終結符，直到最低級別的終結符號。</li>\n<li><strong>自底向上解析</strong>(Bottom-up parsing)：從最低級別開始解析，不斷地用生成規則左側非終結符歸約，直到最高級別的開始符號。</li>\n</ol>\n<p><strong>LL文法</strong>是一種使用自頂向下解析的文法。假定有 LL文法如下：</p>\n<ol>\n<li>𝑆→𝑎𝑆1</li>\n<li>𝑆1→𝑏𝑆1</li>\n<li>𝑆1→𝜖</li>\n</ol>\n<p>輸入流 abb 採用上面的文法進行解析，其過程爲：</p>\n<ol>\n<li>S （開始符號）</li>\n<li>aS1（規則 1）</li>\n<li>abS1 （規則 2）</li>\n<li>abbS1 （規則2）</li>\n<li>abb（規則 3）</li>\n</ol>\n<p><strong>LR(0) 文法</strong>是一种使用自底向上解析的文法。假定有 LR(0) 文法如下：</p>\n<ol>\n<li>𝑆→𝑆1</li>\n<li>𝑆1→𝑆1𝑏</li>\n<li>𝑆1→𝑎</li>\n</ol>\n<p>輸入流 abb 採用上面的文法進行解析，其過程爲：</p>\n<ol>\n<li>a（入棧）</li>\n<li>S1（規則3）</li>\n<li>S1b（入棧）</li>\n<li>S1（規則2）</li>\n<li>S1b（入棧）</li>\n<li>S1（規則2）</li>\n<li>S（規則1）</li>\n</ol>\n<p>當有多個生成規則符合時，會出現衝突。解析時可以採用 <strong>Lookahead</strong> 向前查看技術解決，即預讀一個 Token 確保出現衝突的生成規則可以被正確處理。</p>\n<p>Go 語言的解析器採用 LALR(1) 的文法進行解析，是一種自底向上且帶有 <strong>Lookahead</strong>(縮寫爲LA) 功能的解析文法。LALR(1)  也是大多數編程語言的選擇。</p>\n<p><strong>Go 文法</strong></p>\n<p>閱讀 src/cmd/compile/internal/syntax/parser.go，可知：</p>\n<p>每個 Go 源代碼文件最終都會被解析成一個獨立的抽象語法樹，所以語法樹最頂層的結構或者開始符號都是 SourceFile：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">SourceFile = PackageClause <span class=\"string\">&quot;;&quot;</span> &#123; ImportDecl <span class=\"string\">&quot;;&quot;</span> &#125; &#123; TopLevelDecl <span class=\"string\">&quot;;&quot;</span> &#125; .</span><br></pre></td></tr></table></figure>\n\n<p>PackageClause 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">PackageClause  = <span class=\"string\">&quot;package&quot;</span> PackageName .</span><br><span class=\"line\">PackageName    = identifier .</span><br><span class=\"line\">identifier = letter &#123; letter | unicode_digit &#125; .</span><br></pre></td></tr></table></figure>\n\n<p>ImportDecl 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ImportDecl       = <span class=\"string\">&quot;import&quot;</span> ( ImportSpec | <span class=\"string\">&quot;(&quot;</span> &#123; ImportSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">ImportSpec       = [ <span class=\"string\">&quot;.&quot;</span> | PackageName ] ImportPath .</span><br><span class=\"line\">ImportPath       = string_lit .</span><br></pre></td></tr></table></figure>\n\n<p>TopLevelDecl 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .</span><br><span class=\"line\">Declaration   = ConstDecl | TypeDecl | VarDecl .</span><br></pre></td></tr></table></figure>\n\n<p>可知頂層的聲明共有五種，分別是常量、類型、變量、函數和方法聲明，其生成规则如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ConstDecl = <span class=\"string\">&quot;const&quot;</span> ( ConstSpec | <span class=\"string\">&quot;(&quot;</span> &#123; ConstSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">ConstSpec = IdentifierList [ [ Type ] <span class=\"string\">&quot;=&quot;</span> ExpressionList ] .</span><br><span class=\"line\"></span><br><span class=\"line\">TypeDecl  = <span class=\"string\">&quot;type&quot;</span> ( TypeSpec | <span class=\"string\">&quot;(&quot;</span> &#123; TypeSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">TypeSpec  = AliasDecl | TypeDef .</span><br><span class=\"line\">AliasDecl = identifier <span class=\"string\">&quot;=&quot;</span> Type .</span><br><span class=\"line\">TypeDef   = identifier Type .</span><br><span class=\"line\"></span><br><span class=\"line\">VarDecl = <span class=\"string\">&quot;var&quot;</span> ( VarSpec | <span class=\"string\">&quot;(&quot;</span> &#123; VarSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">VarSpec = IdentifierList ( Type [ <span class=\"string\">&quot;=&quot;</span> ExpressionList ] | <span class=\"string\">&quot;=&quot;</span> ExpressionList ) .</span><br><span class=\"line\"></span><br><span class=\"line\">FunctionDecl = <span class=\"string\">&quot;func&quot;</span> FunctionName Signature [ FunctionBody ] .</span><br><span class=\"line\">FunctionName = identifier .</span><br><span class=\"line\">FunctionBody = Block .</span><br><span class=\"line\"></span><br><span class=\"line\">MethodDecl = <span class=\"string\">&quot;func&quot;</span> Receiver MethodName Signature [ FunctionBody ] .</span><br><span class=\"line\">Receiver   = Parameters .</span><br><span class=\"line\"></span><br><span class=\"line\">Block = <span class=\"string\">&quot;&#123;&quot;</span> StatementList <span class=\"string\">&quot;&#125;&quot;</span> .</span><br><span class=\"line\">StatementList = &#123; Statement <span class=\"string\">&quot;;&quot;</span> &#125; .</span><br><span class=\"line\"></span><br><span class=\"line\">Statement =</span><br><span class=\"line\">  Declaration | LabeledStmt | SimpleStmt |</span><br><span class=\"line\">  GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |</span><br><span class=\"line\">  FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |</span><br><span class=\"line\">  DeferStmt .</span><br><span class=\"line\"></span><br><span class=\"line\">SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .</span><br></pre></td></tr></table></figure>\n\n<p>更詳細的文法見：<a href=\"https://golang.org/ref/spec#Declarations_and_scope\">Language Specification</a>。</p>\n<h2 id=\"2-3-類型檢查\"><a href=\"#2-3-類型檢查\" class=\"headerlink\" title=\"2.3 類型檢查\"></a>2.3 類型檢查</h2><p>類型檢查的目的在於確保代碼正確執行。</p>\n<p>類型分兩種：強類型和弱類型。一般來說，強類型是在編譯期間有嚴格的類型限制，會在編譯期間發現變量賦值、返回值和函數調用是的類型錯誤。弱類型則是在運行時出現類型錯誤時進行隱式類型轉換。</p>\n<p>檢查也分兩種：靜態類型檢查和動態類型檢查。靜態類型檢查是在編譯期進行，動態類型檢查是在運行期間進行。實現動態類型檢查通常是爲每個運行時對象關聯一個類型標籤，包含了它的類型信息（RTTI, the Runtime type information），用來實現動態派發、延遲綁定、向下轉型和反射等等。</p>\n<p>另外，只使用動態類型檢查的編程語言叫做動態類型編程語言，比如 JavaScript、Ruby 和 PHP。</p>\n<p>Go 進行靜態類型檢查的代碼主要邏輯在 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck\">cmd/compile/internal/gc.typecheck</a> 和 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1\">cmd/compile/internal/gc.typecheck1</a> 中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">typecheck1</span><span class=\"params\">(n *Node, top <span class=\"keyword\">int</span>)</span> <span class=\"params\">(res *Node)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> n.Op &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTARRAY:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTMAP:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTCHAN:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>介紹幾種常見類型的檢查過程：</p>\n<ul>\n<li>OTARRAY 數組或切片類型：<ol>\n<li>對右節點也就是元素進行類型檢查</li>\n<li>對左節點，按三種情況：<ol>\n<li>[]int，直接調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewSlice\">cmd/compile/internal/types.NewSlice</a>，返回一個 <code>TSLICE</code> 類型的結構體。</li>\n<li>[…]int，ODDD(即…) 先調用 <a href>cmd/compile/internal/gc.typecheckcomplit</a> ，後調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray\">cmd/compile/internal/types.NewArray</a> 初始化一個存儲著數組中元素類型和數組大小的結構體。</li>\n<li>[3]int，調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray\">cmd/compile/internal/types.NewArray</a> 初始化一個存儲著數組中元素類型和數組大小的結構體。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>OTMAP 哈希類型：<ol>\n<li>分別檢查鍵值類型</li>\n<li>通過 <a href>cmd/compile/internal/types.NewMap</a> 创建一个新的 TMAP 结构并将哈希的键值类型都存储到该结构体</li>\n<li>代表當前哈希的節點最終也會被加入 mapqueue 隊列，編譯器會在後面的階段對哈希鍵的類型進行再次檢查。</li>\n</ol>\n</li>\n<li>OMAKE 內置函數make<ol>\n<li>檢查第一個類型參數，然後據此進入不同的分支：TSLICE 切片分支、TMAP 哈希分支和 TCHAN 信道分支。</li>\n<li>如是 TSLICE 分支，將檢查 len 和 cap 的合法性，然後將當前節點的 Op 改爲 OMAKESLICE。</li>\n<li>如是 TMAP 分支，將在檢查 size 之後將當前節點的 Op 改爲 OMAKEMAP。</li>\n<li>如是 TCHAN 分支，將在檢查 buffer 之後將當前節點的 Op 改爲 OMAKECHAN。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-4-中間代碼生成\"><a href=\"#2-4-中間代碼生成\" class=\"headerlink\" title=\"2.4 中間代碼生成\"></a>2.4 中間代碼生成</h2><p>中間代碼生成是爲了解決直接編譯成二進制碼的複雜。通過將複雜問題拆分成一個個簡單的步驟，再逐個擊破，這就是中間代碼的作用。</p>\n<p>AST 和二進制碼之間隔了幾十次中間代碼的生成。生成之初會將緩存可能需要用到的類型和指針，並將內建函數映射到 runtime包中的函數。之後每次中間代碼的生成都是對代碼的優化，最後生成具備 SSA 特性的中間代碼。</p>\n<p><img src=\"/2021/02/06/it/go/go-design-and-implementation-02/Untitled%202.png\" alt></p>\n<p>關鍵字和操作符和運行時函數的映射</p>\n<p>中間代碼不是彙編代碼，但是很接近彙編代碼，也用到一些寄存器，可說是彙編代碼的偽代碼（pseudo code），中間代碼形如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">pass trim begin</span><br><span class=\"line\">  pass trim end [<span class=\"number\">738</span> ns]</span><br><span class=\"line\">hello <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span></span><br><span class=\"line\">  b1:</span><br><span class=\"line\">    v1 = InitMem &lt;mem&gt;</span><br><span class=\"line\">    v10 = VarDef &lt;mem&gt; &#123;~r1&#125; v1</span><br><span class=\"line\">    v2 = SP &lt;<span class=\"keyword\">uintptr</span>&gt; : SP</span><br><span class=\"line\">    v6 = Arg &lt;<span class=\"keyword\">int</span>&gt; &#123;a&#125; : a[<span class=\"keyword\">int</span>]</span><br><span class=\"line\">    v8 = LoadReg &lt;<span class=\"keyword\">int</span>&gt; v6 : AX</span><br><span class=\"line\">    v9 = ADDQconst &lt;<span class=\"keyword\">int</span>&gt; [<span class=\"number\">2</span>] v8 : AX (c[<span class=\"keyword\">int</span>])</span><br><span class=\"line\">    v11 = MOVQstore &lt;mem&gt; &#123;~r1&#125; v2 v9 v10</span><br><span class=\"line\">    Ret v11</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5-機器碼生成\"><a href=\"#2-5-機器碼生成\" class=\"headerlink\" title=\"2.5 機器碼生成\"></a>2.5 機器碼生成</h2><p>機器碼的生成包含兩個部分：</p>\n<ol>\n<li><a href=\"https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa\">cmd/compile/internal/ssa</a> 進行 SSA 中間代碼的降級過程，執行架構特定的優化和重寫，最後生成架構特定的指令 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/obj.Prog\">cmd/compile/internal/obj.Prog</a>。</li>\n<li><a href=\"https://github.com/golang/go/tree/master/src/cmd/internal/obj\">cmd/internal/obj</a> 作爲彙編器將架構特定的指令轉成二進制代碼。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>編譯原理這一章講 Go 的源代碼是如何變成二進制碼的，可分爲四個過程：</p>\n<ol>\n<li>詞法和語法分析 lexical and grammar analysis</li>\n<li>類型檢查 type check</li>\n<li>中間代碼生成 IR(intermediate representation) generation</li>\n<li>機器碼生成 machine code generation</li>\n</ol>\n<p>詞法分析是將源代碼視爲字符串序列，對各個字符串進行標記，生成 Token 序列。</p>\n<p>語法分析是將 Token 序列按照 LALR(1)（向前查看和自底向上解析）的解析文法進行解析，生成一棵AST (抽象語法樹 )。</p>\n<p>類型檢查分靜態類型檢查和動態類型檢查，靜態類型檢查會在編譯期對變量賦值、返回值和函數參數進行類型檢查；動態類型檢查在代碼運行時進行，可以實現向下類型轉換、延遲綁定和反射等功能。</p>\n<p>中間代碼生成階段首先會進行 ssaconfig 的初始化，緩存可能需要用到的類型和指針；然後進行遍歷和替換，將內建函數 make、map、channel、new、select、panic、recover 等等替換成 runtime 包的函數。最後不斷地進行中間代碼生成，優化代碼，生成類似彙編代碼的代碼。</p>\n<p>機器碼生成階段分兩個部分：一是 SSA 中間代碼降級、針對特定CPU架構的中間代碼優化和重寫，最後生成相當接近特定架構彙編代碼的指令；二是將特定架構的指令轉成二進制代碼。</p>","more":"<h2 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h2><p>編譯原理就是講編譯器如何將代碼編譯成二進制碼。</p>\n<h3 id=\"2-1-1-預備知識\"><a href=\"#2-1-1-預備知識\" class=\"headerlink\" title=\"2.1.1 預備知識\"></a>2.1.1 預備知識</h3><p><strong>（1）抽象語法樹</strong></p>\n<p>抽象語法樹（Abstract Syntax Tree、AST），是源代碼語法的結構的樹狀表示。以表達式 2 * 3 + 7 為例，編譯器的語法分析階段會生成如下圖所示的抽象語法樹：</p>\n<p><img src=\"/2021/02/06/it/go/go-design-and-implementation-02/Untitled.png\" alt></p>\n<p><strong>（2）靜態單賦值</strong></p>\n<p>靜態單賦值（Static Single Assignment、SSA），是指中間代碼每個變量只會被賦值一次。例如以下代碼：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">1</span></span><br><span class=\"line\">x := <span class=\"number\">2</span></span><br><span class=\"line\">y := x</span><br></pre></td></tr></table></figure>\n\n<p>其中間的代碼爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x_1 := <span class=\"number\">1</span></span><br><span class=\"line\">x_2 := <span class=\"number\">2</span></span><br><span class=\"line\">y_1 := x_2</span><br></pre></td></tr></table></figure>\n\n<p>由於 x_1 := 1 沒有什麼用，因此會在生成機器碼時省去。</p>\n<p><strong>（3）指令集</strong></p>\n<p>指令集或者說指令集架構 (Instruction set architecture, ISA)，就是計算機的抽象模型。指令集可分爲兩大類：</p>\n<ul>\n<li>複雜指令集計算機 (complex instruction set computer, CISC)：包含了很多特定的指令，但是其中的一些指令很少會被程序使用（據說有 80% 不經常使用）。例如：Intel 8080、x86-family。</li>\n<li>精簡指令集計算機 (reduced instruction set computer, RISC)：只實現了經常被使用的指令，不常用的操作都會通過組合簡單指令來實現。例如：ARM、Power ISA。</li>\n</ul>\n<h3 id=\"2-1-2-編譯原理\"><a href=\"#2-1-2-編譯原理\" class=\"headerlink\" title=\"2.1.2 編譯原理\"></a>2.1.2 編譯原理</h3><p><img src=\"/2021/02/06/it/go/go-design-and-implementation-02/Untitled%201.png\" alt></p>\n<p>編譯器的前端：</p>\n<ul>\n<li>詞法分析 lexical analysis</li>\n<li>語法分析 syntax analysis</li>\n<li>語義分析 semantic analysis</li>\n</ul>\n<p>編譯器的後端：</p>\n<ul>\n<li>中間代碼生成 IR(Intermediate Representation)  generation</li>\n<li>代碼優化 code optimization</li>\n<li>機器碼生成 machinecode generation</li>\n</ul>\n<p>Go 的編譯器邏輯上可以分爲四個階段：</p>\n<ol>\n<li>詞法和語法分析，將源代碼字符串序列轉成 Token 序列，再轉成抽象語法樹。</li>\n<li>類型檢查，檢查類型，並展開內建的函數。</li>\n<li>中間代碼生成，使用 goroutine 並發生成中間代碼，並進行 SSA 優化。</li>\n<li>機器碼生成，根據不同類型的 CPU 生成不同的機器碼</li>\n</ol>\n<p>Go 的編譯器入口在 <a href=\"https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/main.go\">src/cmd/compile/internal/gc/main.go</a> 文件中，其中的 Main 函數就是編譯器的主要程序，其工作過程是：</p>\n<ol>\n<li>獲取命令行傳入的參數並更新編譯選項和配置。</li>\n<li>調用 parseFiles 方法解析輸入的文件，得到 AST，隨後進行以下 9 個步驟：<ol>\n<li>const, type, and names and types of funcs（檢查常量、類型以及函數的名稱和類型）</li>\n<li>Variable assignments（處理變量賦值）</li>\n<li>Type check function bodies（對函數體進行類型檢查）</li>\n<li>Decide how to capture closed variables（決定如何捕獲封閉的變量）</li>\n<li>Inlining（處理內聯函數）</li>\n<li>Escape analysis（進行逃逸分析）</li>\n<li>Transform closure bodies to properly reference captured variables（將閉包的主體轉成實際引用的捕獲變量）</li>\n<li>Compile top level functions（編譯頂層函數）</li>\n<li>Check external declarations（檢查外部聲明）</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-2-詞法和語法分析\"><a href=\"#2-2-詞法和語法分析\" class=\"headerlink\" title=\"2.2 詞法和語法分析\"></a>2.2 詞法和語法分析</h2><h3 id=\"2-2-1-詞法分析\"><a href=\"#2-2-1-詞法分析\" class=\"headerlink\" title=\"2.2.1 詞法分析\"></a>2.2.1 詞法分析</h3><p>詞法分析就是將源代碼的字符串序列轉成標記(Token)序列的過程。如 <code>make(chan int)</code> 經過詞法分析後是一個由 <code>make</code> 、<code>(</code>、<code>chan</code>、<code>int</code> 和 <code>)</code> 組成的 Token序列。</p>\n<p>可以使用 lex 工具進行詞法分析，Go 早期也是使用該工具，<a href=\"https://github.com/LinLshare/case/blob/main/doc/compile/compile_001_flex\">該案例</a>展示了使用 lex 工具進行詞法分析。後期更換成了自身，<a href=\"https://github.com/LinLshare/case/blob/main/doc/compile/compile_002_golang_lexer\">該案例</a>展示了使用 Go 自帶的詞法分析器進行詞法分析。</p>\n<h3 id=\"2-2-2-語法分析\"><a href=\"#2-2-2-語法分析\" class=\"headerlink\" title=\"2.2.2 語法分析\"></a>2.2.2 語法分析</h3><p>語法分析是根據某種特定的形式文法（Grammar）對 Token 序列構成的輸入文本進行分析並確定其語法結構的過程。</p>\n<p><strong>文法</strong></p>\n<p>上下文無關文法(<a href=\"https://en.wikipedia.org/wiki/Context-free_grammar\">context-free grammar</a>) 是用來形式化、精確描述某種編程語言的工具，由以下四個部分組成：</p>\n<ol>\n<li>N, 有限個非終結符的集合</li>\n<li>Σ, 有限個終結符的集合</li>\n<li>P, 有限個生成規則(production rule)的集合</li>\n<li>S, 開始變量或符號，用來代表整個語句或程序，是集合N的成員。</li>\n</ol>\n<p>非終結符可以使用一組終結符根據生成規則展開，而終結符是語言定義的基本元素，不可展開。</p>\n<p>P = N x (NvΣ)* 即生成規則是集合 N與集合N、Σ的併集的 Kleene 操作之間的二元關係。</p>\n<p>假定有以下生成規則：</p>\n<ol>\n<li>S —&gt; aSb // S 可以展開爲 aSb</li>\n<li>S —&gt; ab // S 可以展開爲 ab</li>\n</ol>\n<p>那麼，aabb（運用一次規則1，一次規則2）、aaabbb（運用兩次規則1，一次規則2）等就是符合語法規則的表示。</p>\n<p><strong>解析方法</strong></p>\n<p>解析文法的方法有兩種：</p>\n<ol>\n<li><strong>自頂向下解析</strong>(Top-down parsing)：從最高級別開始解析，不斷地用生成規則右側的符號展開非終結符，直到最低級別的終結符號。</li>\n<li><strong>自底向上解析</strong>(Bottom-up parsing)：從最低級別開始解析，不斷地用生成規則左側非終結符歸約，直到最高級別的開始符號。</li>\n</ol>\n<p><strong>LL文法</strong>是一種使用自頂向下解析的文法。假定有 LL文法如下：</p>\n<ol>\n<li>𝑆→𝑎𝑆1</li>\n<li>𝑆1→𝑏𝑆1</li>\n<li>𝑆1→𝜖</li>\n</ol>\n<p>輸入流 abb 採用上面的文法進行解析，其過程爲：</p>\n<ol>\n<li>S （開始符號）</li>\n<li>aS1（規則 1）</li>\n<li>abS1 （規則 2）</li>\n<li>abbS1 （規則2）</li>\n<li>abb（規則 3）</li>\n</ol>\n<p><strong>LR(0) 文法</strong>是一种使用自底向上解析的文法。假定有 LR(0) 文法如下：</p>\n<ol>\n<li>𝑆→𝑆1</li>\n<li>𝑆1→𝑆1𝑏</li>\n<li>𝑆1→𝑎</li>\n</ol>\n<p>輸入流 abb 採用上面的文法進行解析，其過程爲：</p>\n<ol>\n<li>a（入棧）</li>\n<li>S1（規則3）</li>\n<li>S1b（入棧）</li>\n<li>S1（規則2）</li>\n<li>S1b（入棧）</li>\n<li>S1（規則2）</li>\n<li>S（規則1）</li>\n</ol>\n<p>當有多個生成規則符合時，會出現衝突。解析時可以採用 <strong>Lookahead</strong> 向前查看技術解決，即預讀一個 Token 確保出現衝突的生成規則可以被正確處理。</p>\n<p>Go 語言的解析器採用 LALR(1) 的文法進行解析，是一種自底向上且帶有 <strong>Lookahead</strong>(縮寫爲LA) 功能的解析文法。LALR(1)  也是大多數編程語言的選擇。</p>\n<p><strong>Go 文法</strong></p>\n<p>閱讀 src/cmd/compile/internal/syntax/parser.go，可知：</p>\n<p>每個 Go 源代碼文件最終都會被解析成一個獨立的抽象語法樹，所以語法樹最頂層的結構或者開始符號都是 SourceFile：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">SourceFile = PackageClause <span class=\"string\">&quot;;&quot;</span> &#123; ImportDecl <span class=\"string\">&quot;;&quot;</span> &#125; &#123; TopLevelDecl <span class=\"string\">&quot;;&quot;</span> &#125; .</span><br></pre></td></tr></table></figure>\n\n<p>PackageClause 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">PackageClause  = <span class=\"string\">&quot;package&quot;</span> PackageName .</span><br><span class=\"line\">PackageName    = identifier .</span><br><span class=\"line\">identifier = letter &#123; letter | unicode_digit &#125; .</span><br></pre></td></tr></table></figure>\n\n<p>ImportDecl 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ImportDecl       = <span class=\"string\">&quot;import&quot;</span> ( ImportSpec | <span class=\"string\">&quot;(&quot;</span> &#123; ImportSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">ImportSpec       = [ <span class=\"string\">&quot;.&quot;</span> | PackageName ] ImportPath .</span><br><span class=\"line\">ImportPath       = string_lit .</span><br></pre></td></tr></table></figure>\n\n<p>TopLevelDecl 的生成規則爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .</span><br><span class=\"line\">Declaration   = ConstDecl | TypeDecl | VarDecl .</span><br></pre></td></tr></table></figure>\n\n<p>可知頂層的聲明共有五種，分別是常量、類型、變量、函數和方法聲明，其生成规则如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ConstDecl = <span class=\"string\">&quot;const&quot;</span> ( ConstSpec | <span class=\"string\">&quot;(&quot;</span> &#123; ConstSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">ConstSpec = IdentifierList [ [ Type ] <span class=\"string\">&quot;=&quot;</span> ExpressionList ] .</span><br><span class=\"line\"></span><br><span class=\"line\">TypeDecl  = <span class=\"string\">&quot;type&quot;</span> ( TypeSpec | <span class=\"string\">&quot;(&quot;</span> &#123; TypeSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">TypeSpec  = AliasDecl | TypeDef .</span><br><span class=\"line\">AliasDecl = identifier <span class=\"string\">&quot;=&quot;</span> Type .</span><br><span class=\"line\">TypeDef   = identifier Type .</span><br><span class=\"line\"></span><br><span class=\"line\">VarDecl = <span class=\"string\">&quot;var&quot;</span> ( VarSpec | <span class=\"string\">&quot;(&quot;</span> &#123; VarSpec <span class=\"string\">&quot;;&quot;</span> &#125; <span class=\"string\">&quot;)&quot;</span> ) .</span><br><span class=\"line\">VarSpec = IdentifierList ( Type [ <span class=\"string\">&quot;=&quot;</span> ExpressionList ] | <span class=\"string\">&quot;=&quot;</span> ExpressionList ) .</span><br><span class=\"line\"></span><br><span class=\"line\">FunctionDecl = <span class=\"string\">&quot;func&quot;</span> FunctionName Signature [ FunctionBody ] .</span><br><span class=\"line\">FunctionName = identifier .</span><br><span class=\"line\">FunctionBody = Block .</span><br><span class=\"line\"></span><br><span class=\"line\">MethodDecl = <span class=\"string\">&quot;func&quot;</span> Receiver MethodName Signature [ FunctionBody ] .</span><br><span class=\"line\">Receiver   = Parameters .</span><br><span class=\"line\"></span><br><span class=\"line\">Block = <span class=\"string\">&quot;&#123;&quot;</span> StatementList <span class=\"string\">&quot;&#125;&quot;</span> .</span><br><span class=\"line\">StatementList = &#123; Statement <span class=\"string\">&quot;;&quot;</span> &#125; .</span><br><span class=\"line\"></span><br><span class=\"line\">Statement =</span><br><span class=\"line\">  Declaration | LabeledStmt | SimpleStmt |</span><br><span class=\"line\">  GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |</span><br><span class=\"line\">  FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |</span><br><span class=\"line\">  DeferStmt .</span><br><span class=\"line\"></span><br><span class=\"line\">SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .</span><br></pre></td></tr></table></figure>\n\n<p>更詳細的文法見：<a href=\"https://golang.org/ref/spec#Declarations_and_scope\">Language Specification</a>。</p>\n<h2 id=\"2-3-類型檢查\"><a href=\"#2-3-類型檢查\" class=\"headerlink\" title=\"2.3 類型檢查\"></a>2.3 類型檢查</h2><p>類型檢查的目的在於確保代碼正確執行。</p>\n<p>類型分兩種：強類型和弱類型。一般來說，強類型是在編譯期間有嚴格的類型限制，會在編譯期間發現變量賦值、返回值和函數調用是的類型錯誤。弱類型則是在運行時出現類型錯誤時進行隱式類型轉換。</p>\n<p>檢查也分兩種：靜態類型檢查和動態類型檢查。靜態類型檢查是在編譯期進行，動態類型檢查是在運行期間進行。實現動態類型檢查通常是爲每個運行時對象關聯一個類型標籤，包含了它的類型信息（RTTI, the Runtime type information），用來實現動態派發、延遲綁定、向下轉型和反射等等。</p>\n<p>另外，只使用動態類型檢查的編程語言叫做動態類型編程語言，比如 JavaScript、Ruby 和 PHP。</p>\n<p>Go 進行靜態類型檢查的代碼主要邏輯在 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck\">cmd/compile/internal/gc.typecheck</a> 和 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1\">cmd/compile/internal/gc.typecheck1</a> 中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">typecheck1</span><span class=\"params\">(n *Node, top <span class=\"keyword\">int</span>)</span> <span class=\"params\">(res *Node)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> n.Op &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTARRAY:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTMAP:</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> OTCHAN:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>介紹幾種常見類型的檢查過程：</p>\n<ul>\n<li>OTARRAY 數組或切片類型：<ol>\n<li>對右節點也就是元素進行類型檢查</li>\n<li>對左節點，按三種情況：<ol>\n<li>[]int，直接調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewSlice\">cmd/compile/internal/types.NewSlice</a>，返回一個 <code>TSLICE</code> 類型的結構體。</li>\n<li>[…]int，ODDD(即…) 先調用 <a href>cmd/compile/internal/gc.typecheckcomplit</a> ，後調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray\">cmd/compile/internal/types.NewArray</a> 初始化一個存儲著數組中元素類型和數組大小的結構體。</li>\n<li>[3]int，調用 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray\">cmd/compile/internal/types.NewArray</a> 初始化一個存儲著數組中元素類型和數組大小的結構體。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>OTMAP 哈希類型：<ol>\n<li>分別檢查鍵值類型</li>\n<li>通過 <a href>cmd/compile/internal/types.NewMap</a> 创建一个新的 TMAP 结构并将哈希的键值类型都存储到该结构体</li>\n<li>代表當前哈希的節點最終也會被加入 mapqueue 隊列，編譯器會在後面的階段對哈希鍵的類型進行再次檢查。</li>\n</ol>\n</li>\n<li>OMAKE 內置函數make<ol>\n<li>檢查第一個類型參數，然後據此進入不同的分支：TSLICE 切片分支、TMAP 哈希分支和 TCHAN 信道分支。</li>\n<li>如是 TSLICE 分支，將檢查 len 和 cap 的合法性，然後將當前節點的 Op 改爲 OMAKESLICE。</li>\n<li>如是 TMAP 分支，將在檢查 size 之後將當前節點的 Op 改爲 OMAKEMAP。</li>\n<li>如是 TCHAN 分支，將在檢查 buffer 之後將當前節點的 Op 改爲 OMAKECHAN。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-4-中間代碼生成\"><a href=\"#2-4-中間代碼生成\" class=\"headerlink\" title=\"2.4 中間代碼生成\"></a>2.4 中間代碼生成</h2><p>中間代碼生成是爲了解決直接編譯成二進制碼的複雜。通過將複雜問題拆分成一個個簡單的步驟，再逐個擊破，這就是中間代碼的作用。</p>\n<p>AST 和二進制碼之間隔了幾十次中間代碼的生成。生成之初會將緩存可能需要用到的類型和指針，並將內建函數映射到 runtime包中的函數。之後每次中間代碼的生成都是對代碼的優化，最後生成具備 SSA 特性的中間代碼。</p>\n<p><img src=\"/2021/02/06/it/go/go-design-and-implementation-02/Untitled%202.png\" alt></p>\n<p>關鍵字和操作符和運行時函數的映射</p>\n<p>中間代碼不是彙編代碼，但是很接近彙編代碼，也用到一些寄存器，可說是彙編代碼的偽代碼（pseudo code），中間代碼形如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">pass trim begin</span><br><span class=\"line\">  pass trim end [<span class=\"number\">738</span> ns]</span><br><span class=\"line\">hello <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span></span><br><span class=\"line\">  b1:</span><br><span class=\"line\">    v1 = InitMem &lt;mem&gt;</span><br><span class=\"line\">    v10 = VarDef &lt;mem&gt; &#123;~r1&#125; v1</span><br><span class=\"line\">    v2 = SP &lt;<span class=\"keyword\">uintptr</span>&gt; : SP</span><br><span class=\"line\">    v6 = Arg &lt;<span class=\"keyword\">int</span>&gt; &#123;a&#125; : a[<span class=\"keyword\">int</span>]</span><br><span class=\"line\">    v8 = LoadReg &lt;<span class=\"keyword\">int</span>&gt; v6 : AX</span><br><span class=\"line\">    v9 = ADDQconst &lt;<span class=\"keyword\">int</span>&gt; [<span class=\"number\">2</span>] v8 : AX (c[<span class=\"keyword\">int</span>])</span><br><span class=\"line\">    v11 = MOVQstore &lt;mem&gt; &#123;~r1&#125; v2 v9 v10</span><br><span class=\"line\">    Ret v11</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5-機器碼生成\"><a href=\"#2-5-機器碼生成\" class=\"headerlink\" title=\"2.5 機器碼生成\"></a>2.5 機器碼生成</h2><p>機器碼的生成包含兩個部分：</p>\n<ol>\n<li><a href=\"https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa\">cmd/compile/internal/ssa</a> 進行 SSA 中間代碼的降級過程，執行架構特定的優化和重寫，最後生成架構特定的指令 <a href=\"https://draveness.me/golang/tree/cmd/compile/internal/obj.Prog\">cmd/compile/internal/obj.Prog</a>。</li>\n<li><a href=\"https://github.com/golang/go/tree/master/src/cmd/internal/obj\">cmd/internal/obj</a> 作爲彙編器將架構特定的指令轉成二進制代碼。</li>\n</ol>"},{"title":"《Go 設計與實現》筆記之第一章 準備工作","p":"it/go/go-design-and-implementation-01.md","_content":"\n深入學習 Go 語言的設計與實現之前要準備以下工作：\n\n1. 克隆 Go 倉庫源代碼並編譯它。\n2. 了解 Plan 9 彙編，知道 Go 的棧結構並能分析代碼的執行過程。\n\n彙編者，二進制代碼的文本形式也，其最大的特點就是不可移植。Plan 9 彙編是貝爾實驗室的九號計劃的產物，目前被用於 Go 程序編譯的中間代碼，因爲 Go 的作者 Rob Pike，同時也是 Plan 9 彙編的作者。\n\nPlan 9 彙編指令與 Intel 等彙編等的不同在於：\n\n1. 一般情況下，命令的源操作數在先，目的操作數在後。 如同樣是將十六進制的 10 傳送到 AX寄存器，在 Plan 9 中是 `MOVQ $0x10, AX` ，而在 Intel 彙編中是 `mov rax, 0x10` 。\n2.  棧的調整通過硬件 SP 寄存器進行加減運算實現。而 Intel 彙編中通過 push 和 pop 命令實現。\n3. 操作的數據長度取決於命令的後綴。而 Intel 彙編取決於寄存器。\n\n    ```go\n    // plan 9 彙編\n    MOVB $1, DI      // 1 byte\n    MOVW $0x10, BX   // 2 bytes\n    MOVD $1, DX      // 4 bytes\n    MOVQ $-10, AX     // 8 bytes\n\n    // intel 彙編\n    mov rax, 0x1   // 8 bytes\n    mov eax, 0x100 // 4 bytes\n    mov ax, 0x22   // 2 bytes\n    mov ah, 0x33   // 1 byte\n    mov al, 0x44   // 1 byte\n    ```\n\n通過分析 Plan 9 彙編代碼我們可以繪製出如下的棧結構：\n\n![](go-design-and-implementation-01/Untitled.png)\n\n<!-- more -->\n\n## 1.1 調試 Go 語言\n\n### **1.1.1 克隆 go 倉庫並查看代碼行數**\n\ncloc (Count Lines of Code) 工具可以計算源代碼行數。執行後可知 Go 源代碼超過 140 萬行。\n\n```bash\n$ git clone https://github.com/golang/go.git\n$ cloc go/src\n6277 text files.\n6156 unique files.\n1298 files ignored.\n# 省略部分內容\n-----------------------------------------------------------------------------------\nLanguage                         files          blank        comment           code\n-----------------------------------------------------------------------------------\nGo                                4340         143352         253857        1412372\nAssembly                           497          12862          18550         108301\nC                                   68            763            599           4745\n# 省略部分內容\n```\n\n### 1.1.2 編譯源碼\n\n在源代碼中找到 fmt 包，修改 Println 函數如下：\n\n```bash\nfunc Println(a ...interface{}) (n int, err error) {\n\tprintln(\"draven\")\n\treturn Fprintln(os.Stdout, a...)\n}\n```\n\n隨後執行  `./src/make.bash` 編譯源代碼，成功之後用編譯出來的 Go 二進制文件來執行你的代碼：\n\n```bash\n$ cat main.go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello World\")\n}\n$ src/github.com/golang/go/bin/go run main.go\ndraven\nHello World\n```\n\n## 1.2 Plan 9 彙編\n\n### **1.2.1 彙編**\n\n在正式學習 Plan 9 彙編之前，建議先看下阮一峰老師的[《汇编语言入门教程》](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)以理解以下結論：\n\n1. 匯編語言是二進制指令的文本形式。\n2. 較之CPU 緩存，CPU 訪問寄存器速度更快且不需要尋址。\n3. 寄存器依靠名稱而不是地址來區分數據。\n4. 內存中的堆自下而上分配，棧自上而下分配。\n\n    ![](go-design-and-implementation-01/Untitled%201.png)\n\n### **1.2.2 Plan 9**\n\nPlan 9，貝爾實驗室九號計劃，是一個基於 Unix 的分布式操作系統，該系統開源但並未商業化使用。Go 語言的作者 Rob Pike 是其帶領者之一。\n\nGo 使用了 Plan 9 彙編作爲中間代碼，最後再編譯成二進制代碼。了解 Plan 9 彙編有助於分析 Go 語言的底層實現和排查問題。\n\n彙編語言具有不可移植性，各個平台上的平台指令集和寄存器都不一樣。學習時我們以 Linux amd64 爲例。\n\n### **1.2.3 寄存器**\n\namd64 上的寄存器有：\n\n1. **AX**：累加寄存器(AccumulatorRegister)，用於存放數據，包括算術、操作數、結果和臨時存放地址。\n2. **BX**：基址寄存器(BaseRegister)，用於存放訪問存儲器時的地址。\n3. **CX**：計數寄存器(CountRegister)，用於保存計算值，用作計數器。\n4. **DX**：數據寄存器(DataRegister)，用於數據傳遞，在寄存器間接尋址中的I/O指令中存放I/O端口的地址。\n5. DI：目的寄存器(DestinationIndex)，用於存放目的操作數的偏移地址。\n6. SI：源變址寄存器(SourceIndex)，用於存放源操作數的偏移地址。\n7. **BP：**棧基指針(BasePointer)，保存在進入函數前的棧頂基址。\n8. **SP：**棧指針(StackPointer)，指向當前棧幀的局部變量的開始位置。如果是symbol+offset(SP)的形式表示**偽寄存器**，offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间；如果是offset(SP)的形式表示**硬件寄存器**。（注意：對於編譯輸出(`go tool compile -S / go tool objdump`)的代碼來講，目前所有的 SP 都是硬件寄存器 SP，無論是否帶 symbol）\n9. **FP**：棧幀指針(FramePointer)，偽寄存器。指向引用函數的輸入參數，形式是symbol+offset(FP)，例如 arg0+0(FP)。\n10. SB：靜態基指針(StaticBasePointer)，偽寄存器。一般用來聲明函數或全局變量。\n11. PC：程序計數器(ProgramCounter)，偽寄存器。存放下一條指令的地址。\n12. R8\n13. R9\n14. R10\n\n**偽寄存器**(pseudo register)：僞寄存器與平台無關，只在生成目標代碼時才與平台上的硬件寄存器對應起來。Plan 9 彙編有四個偽寄存器，FP、SP、SB、PC。FP 存放引用函數的輸入參數，SP 存放當前棧幀的局部變量的開始位置，SB 聲明函數和全局變量，PC 存放下一條指令的地址。\n\n### **1.2.4 基本指令**\n\n1. **棧調整**\n\n    通過對 SP 寄存器進行操作實現，這與 intle 或 AT&T 匯編不同，他們是使用 push、pop 指令實現。\n\n    ```go\n    SUBQ $0x18, SP // 對 SP 做減法，為函數分配函數棧幀\n    ...               // 省略無用代碼\n    ADDQ $0x18, SP // 對 SP 做加法，清除函數棧幀\n    ```\n\n    注意：SP 一開始處於棧頂且棧是自上而下分配的，所以要通過減法分配棧幀，通過加法清除棧幀。示意圖如下：\n\n    ![](go-design-and-implementation-01/Untitled%202.png)\n\n2. **數據搬運**\n\n    將源操作數複製到目的操作數。Plan 9 中用 `$num` 形式表示常數，默認爲十進制，也可用 `$0x123` 形式表示十六進制。搬運的長度由 `MOV` 的後綴決定。\n\n    格式：`MOVB source destination`\n\n    ```go\n    // move byte\n    // 搬運一個字節長\n    MOVB $1, DI\n    // move word = 2 bytes\n    // 搬運一個字長\n    MOVW $0x10, BX\n    // move double word = 4 bytes\n    // 搬運兩倍字長\n    MOVD $1, DX\n    // move quad word = 8 bytes\n    // 搬運四倍字長\n    MOVQ $-10, AX\n    ```\n\n3. **地址傳送**\n\n    將源操作數的地址複製到目的操作數。\n\n    > lea is an abbreviation of \"load effective address\"。— [Stack Overflow](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwif6oDs8PbtAhWNzIsBHb-kDG0QFjADegQICBAC&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F1658294%2Fwhats-the-purpose-of-the-lea-instruction&usg=AOvVaw1XNxphxiOi5AcnWxGpYRbV)\n\n    ```go\n    // 把AX內容的地址傳送到BX中\n    LEAQ AX, BX\n    ```\n\n4. **計算**\n\n    ```go\n    // add quad word from AX to BX\n    // BX += AX\n    ADDQ  AX, BX\n    // subtract quad word from AX to BX\n    // BX -= AX\n    SUBQ  AX, BX\n    // 無符號乘法 IMUL\n    // BX *= AX\n    IMULQ AX, BX\n    // 無符號除法 IDIV\n    // 除數是CX，被除數是AX，結果存儲到AX中\n    IDIVQ CX\n    // 比較SI和CX的大小。與SUBQ類似，只是不賦值\n    // 其結果會存放到寄存器中\n    CMPQ SI CX\n    ```\n\n5. **跳轉**\n\n    ```go\n    // -- 無條件跳轉 -- \n    // 跳轉到地址，地址可為代碼中的地址，不過實際上手寫不會出現這種東西\n    JMP addr\n    // 跳轉到標籤，可以跳轉到同一函數內的標籤位置\n    JMP label\n    // 以當前指令為基礎，向前跳轉 x 行\n    JMP 2(PC)\n    // 以當前指令為基礎，向後跳轉 x 行\n    JMP -2(PC)\n\n    // -- 有條件跳轉 --\n    // jump target if zero\n    // 如果 zero flag 被 set 過，則跳轉\n    JZ target\n    // jump target if less\n    // 上一行的比較CMP結果，左邊小於右邊則執行跳到0x0185地址處(十進制389轉換成十六進制0x0185)\n    JLS 389\n    ```\n\n6. **指令集**\n\n    見源代碼的 [arch 部分](https://github.com/golang/arch/blob/master/x86/x86.csv)。\n\n### 1.2.5 **案例分析：函數調用**\n\n編寫以下代碼於 call.go 文件：\n\n```go\npackage main\n\nfunc Callee(x, y int) int {\n\tr := x + y\n\treturn r\n}\n\nfunc Caller() {\n\tCallee(1, 2)\n}\n```\n\n執行以下命令可查看彙編代碼：\n\n```go\n// -S 輸出彙編代碼到控制台 Print assembly listing to standard output (code only).\n// -l 禁止內聯 Disable inlining.\n// -N 禁止優化 Disable optimizations.\n// 更多參數：https://pkg.go.dev/cmd/compile@go1.15.6\ngo build -gcflags=\"-S -l -N\" call.go\n```\n\n輸出結果爲（有刪減）：\n\n```go\n\"\".Callee STEXT nosplit size=52 args=0x18 locals=0x10\n0x0000 00000 (call.go:3)    TEXT    \"\".Callee(SB), NOSPLIT|ABIInternal, $16-24\n0x0000 00000 (call.go:3)    SUBQ    $16, SP\n0x0004 00004 (call.go:3)    MOVQ    BP, 8(SP)\n0x0009 00009 (call.go:3)    LEAQ    8(SP), BP\n// 將40(SP)處的變量~r2的值爲0，即返回值初始化爲0\n0x000e 00014 (call.go:3)    MOVQ    $0, \"\".~r2+40(SP)\n// 將24(SP)處的變量x的值傳送到AX中\n0x0017 00023 (call.go:4)    MOVQ    \"\".x+24(SP), AX\n// 將32(SP)處的變量y加到AX中\n0x001c 00028 (call.go:4)    ADDQ    \"\".y+32(SP), AX\n// 將AX的值傳送到(SP)處的變量r中\n0x0021 00033 (call.go:4)    MOVQ    AX, \"\".r(SP)\n// 將AX中的值傳送到40(SP)處的變量~r2，即返回值賦值爲AX中的值\n0x0025 00037 (call.go:5)    MOVQ    AX, \"\".~r2+40(SP)\n0x002a 00042 (call.go:5)    MOVQ    8(SP), BP\n0x002f 00047 (call.go:5)    ADDQ    $16, SP\n0x0033 00051 (call.go:5)    RET\n\n// Go 彙編的固定開頭，Caller爲函數名，\n// args 爲入參和返回值佔用的字節大小 0x0=0，\n// locals 爲局部變量佔用的字節大小 0x20=32\n\"\".Caller STEXT size=71 args=0x0 locals=0x20\n// 聲明函數Caller\n0x0000 00000 (call.go:8)    TEXT    \"\".Caller(SB), ABIInternal, $32-0\n// 將(TLS)複製到CX寄存器，(TLS)是指向當前G(goroutine的一種數據結構)的指針\n0x0000 00000 (call.go:8)    MOVQ    (TLS), CX\n// 比較當前棧指針和CX正偏移16個字節的地址\n0x0009 00009 (call.go:8)    CMPQ    SP, 16(CX)\n// 如果比較值左邊小於右邊，則跳轉到地址 64 處，即 CALL    runtime.morestack_noctxt(SB)\n0x000d 00013 (call.go:8)    JLS     64\n// SP減去32，函數開始入棧\n0x000f 00015 (call.go:8)    SUBQ    $32, SP\n// 把BP中的值傳送到24(SP)處開始的內存空間，保存調用者棧幀地址到本棧。\n0x0013 00019 (call.go:8)    MOVQ    BP, 24(SP)\n// 將24(SP)處的地址傳送到BP，保存當前棧幀地址到BP。\n0x0018 00024 (call.go:8)    LEAQ    24(SP), BP\n// 將數字1傳送到(SP)處開始的內存空間\n0x001d 00029 (call.go:9)    MOVQ    $1, (SP)\n// 將數字2傳送到8(SP)處開始的內存空間\n0x0025 00037 (call.go:9)    MOVQ    $2, 8(SP)\n// 調用Callee函數\n0x002e 00046 (call.go:9)    CALL    \"\".Callee(SB)\n// 調用Callee函數時BP寄存器的值會指向Callee的棧幀地址，因此結束後需要復位。\n0x0033 00051 (call.go:10)   MOVQ    24(SP), BP\n// 出棧\n0x0038 00056 (call.go:10)   ADDQ    $32, SP\n// 返回\n0x003c 00060 (call.go:10)   RET\n// 無操作\n0x003d 00061 (call.go:10)   NOP\n0x003d 00061 (call.go:8)    NOP\n// 調用runtime.morestack_noctxt函數\n0x0040 00064 (call.go:8)    CALL    runtime.morestack_noctxt(SB)\n// 跳轉到函數聲明處\n0x0045 00069 (call.go:8)    JMP     0\n```\n\n分析可得棧結構如下：\n\n![](go-design-and-implementation-01/Untitled%203.png)\n\n## 1.3 參考\n\n1. [Go 语言设计与实现：第一章 准备工作 — draveness](https://draveness.me/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/)\n2. [汇编语言入门教程 — 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)\n3. [Go 系列文章3 ：plan9 汇编入门 — 曹春晖@No Headback](https://xargin.com/plan9-assembly/)\n4. [深入Go的底层，带你走近一群有追求的人 — Stefno@博客园](https://www.cnblogs.com/qcrao-2018/p/10562216.html)\n5. [go plan9汇编入门 — yuchanns@Go 语言中文网](https://studygolang.com/articles/26380)\n6. [go编译工具的使用之汇编 — yuchanns@github.com](https://github.com/yuchanns/Atelier/blob/theme/hermit/src/_posts/golang-assembly.md)\n7. [Go Assembly by Example](https://davidwong.fr/goasm/)\n8. [A Quick Guide to Go's Assembler — golang.org](https://golang.org/doc/asm)\n9. [A Manual for the Plan 9 assembler — Rob Pike](http://doc.cat-v.org/plan_9/4th_edition/papers/asm)","source":"_posts/it/go/go-design-and-implementation-01.md","raw":"---\ntitle: 《Go 設計與實現》筆記之第一章 準備工作\np: it/go/go-design-and-implementation-01.md\ntags:\n- Go\n---\n\n深入學習 Go 語言的設計與實現之前要準備以下工作：\n\n1. 克隆 Go 倉庫源代碼並編譯它。\n2. 了解 Plan 9 彙編，知道 Go 的棧結構並能分析代碼的執行過程。\n\n彙編者，二進制代碼的文本形式也，其最大的特點就是不可移植。Plan 9 彙編是貝爾實驗室的九號計劃的產物，目前被用於 Go 程序編譯的中間代碼，因爲 Go 的作者 Rob Pike，同時也是 Plan 9 彙編的作者。\n\nPlan 9 彙編指令與 Intel 等彙編等的不同在於：\n\n1. 一般情況下，命令的源操作數在先，目的操作數在後。 如同樣是將十六進制的 10 傳送到 AX寄存器，在 Plan 9 中是 `MOVQ $0x10, AX` ，而在 Intel 彙編中是 `mov rax, 0x10` 。\n2.  棧的調整通過硬件 SP 寄存器進行加減運算實現。而 Intel 彙編中通過 push 和 pop 命令實現。\n3. 操作的數據長度取決於命令的後綴。而 Intel 彙編取決於寄存器。\n\n    ```go\n    // plan 9 彙編\n    MOVB $1, DI      // 1 byte\n    MOVW $0x10, BX   // 2 bytes\n    MOVD $1, DX      // 4 bytes\n    MOVQ $-10, AX     // 8 bytes\n\n    // intel 彙編\n    mov rax, 0x1   // 8 bytes\n    mov eax, 0x100 // 4 bytes\n    mov ax, 0x22   // 2 bytes\n    mov ah, 0x33   // 1 byte\n    mov al, 0x44   // 1 byte\n    ```\n\n通過分析 Plan 9 彙編代碼我們可以繪製出如下的棧結構：\n\n![](go-design-and-implementation-01/Untitled.png)\n\n<!-- more -->\n\n## 1.1 調試 Go 語言\n\n### **1.1.1 克隆 go 倉庫並查看代碼行數**\n\ncloc (Count Lines of Code) 工具可以計算源代碼行數。執行後可知 Go 源代碼超過 140 萬行。\n\n```bash\n$ git clone https://github.com/golang/go.git\n$ cloc go/src\n6277 text files.\n6156 unique files.\n1298 files ignored.\n# 省略部分內容\n-----------------------------------------------------------------------------------\nLanguage                         files          blank        comment           code\n-----------------------------------------------------------------------------------\nGo                                4340         143352         253857        1412372\nAssembly                           497          12862          18550         108301\nC                                   68            763            599           4745\n# 省略部分內容\n```\n\n### 1.1.2 編譯源碼\n\n在源代碼中找到 fmt 包，修改 Println 函數如下：\n\n```bash\nfunc Println(a ...interface{}) (n int, err error) {\n\tprintln(\"draven\")\n\treturn Fprintln(os.Stdout, a...)\n}\n```\n\n隨後執行  `./src/make.bash` 編譯源代碼，成功之後用編譯出來的 Go 二進制文件來執行你的代碼：\n\n```bash\n$ cat main.go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello World\")\n}\n$ src/github.com/golang/go/bin/go run main.go\ndraven\nHello World\n```\n\n## 1.2 Plan 9 彙編\n\n### **1.2.1 彙編**\n\n在正式學習 Plan 9 彙編之前，建議先看下阮一峰老師的[《汇编语言入门教程》](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)以理解以下結論：\n\n1. 匯編語言是二進制指令的文本形式。\n2. 較之CPU 緩存，CPU 訪問寄存器速度更快且不需要尋址。\n3. 寄存器依靠名稱而不是地址來區分數據。\n4. 內存中的堆自下而上分配，棧自上而下分配。\n\n    ![](go-design-and-implementation-01/Untitled%201.png)\n\n### **1.2.2 Plan 9**\n\nPlan 9，貝爾實驗室九號計劃，是一個基於 Unix 的分布式操作系統，該系統開源但並未商業化使用。Go 語言的作者 Rob Pike 是其帶領者之一。\n\nGo 使用了 Plan 9 彙編作爲中間代碼，最後再編譯成二進制代碼。了解 Plan 9 彙編有助於分析 Go 語言的底層實現和排查問題。\n\n彙編語言具有不可移植性，各個平台上的平台指令集和寄存器都不一樣。學習時我們以 Linux amd64 爲例。\n\n### **1.2.3 寄存器**\n\namd64 上的寄存器有：\n\n1. **AX**：累加寄存器(AccumulatorRegister)，用於存放數據，包括算術、操作數、結果和臨時存放地址。\n2. **BX**：基址寄存器(BaseRegister)，用於存放訪問存儲器時的地址。\n3. **CX**：計數寄存器(CountRegister)，用於保存計算值，用作計數器。\n4. **DX**：數據寄存器(DataRegister)，用於數據傳遞，在寄存器間接尋址中的I/O指令中存放I/O端口的地址。\n5. DI：目的寄存器(DestinationIndex)，用於存放目的操作數的偏移地址。\n6. SI：源變址寄存器(SourceIndex)，用於存放源操作數的偏移地址。\n7. **BP：**棧基指針(BasePointer)，保存在進入函數前的棧頂基址。\n8. **SP：**棧指針(StackPointer)，指向當前棧幀的局部變量的開始位置。如果是symbol+offset(SP)的形式表示**偽寄存器**，offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间；如果是offset(SP)的形式表示**硬件寄存器**。（注意：對於編譯輸出(`go tool compile -S / go tool objdump`)的代碼來講，目前所有的 SP 都是硬件寄存器 SP，無論是否帶 symbol）\n9. **FP**：棧幀指針(FramePointer)，偽寄存器。指向引用函數的輸入參數，形式是symbol+offset(FP)，例如 arg0+0(FP)。\n10. SB：靜態基指針(StaticBasePointer)，偽寄存器。一般用來聲明函數或全局變量。\n11. PC：程序計數器(ProgramCounter)，偽寄存器。存放下一條指令的地址。\n12. R8\n13. R9\n14. R10\n\n**偽寄存器**(pseudo register)：僞寄存器與平台無關，只在生成目標代碼時才與平台上的硬件寄存器對應起來。Plan 9 彙編有四個偽寄存器，FP、SP、SB、PC。FP 存放引用函數的輸入參數，SP 存放當前棧幀的局部變量的開始位置，SB 聲明函數和全局變量，PC 存放下一條指令的地址。\n\n### **1.2.4 基本指令**\n\n1. **棧調整**\n\n    通過對 SP 寄存器進行操作實現，這與 intle 或 AT&T 匯編不同，他們是使用 push、pop 指令實現。\n\n    ```go\n    SUBQ $0x18, SP // 對 SP 做減法，為函數分配函數棧幀\n    ...               // 省略無用代碼\n    ADDQ $0x18, SP // 對 SP 做加法，清除函數棧幀\n    ```\n\n    注意：SP 一開始處於棧頂且棧是自上而下分配的，所以要通過減法分配棧幀，通過加法清除棧幀。示意圖如下：\n\n    ![](go-design-and-implementation-01/Untitled%202.png)\n\n2. **數據搬運**\n\n    將源操作數複製到目的操作數。Plan 9 中用 `$num` 形式表示常數，默認爲十進制，也可用 `$0x123` 形式表示十六進制。搬運的長度由 `MOV` 的後綴決定。\n\n    格式：`MOVB source destination`\n\n    ```go\n    // move byte\n    // 搬運一個字節長\n    MOVB $1, DI\n    // move word = 2 bytes\n    // 搬運一個字長\n    MOVW $0x10, BX\n    // move double word = 4 bytes\n    // 搬運兩倍字長\n    MOVD $1, DX\n    // move quad word = 8 bytes\n    // 搬運四倍字長\n    MOVQ $-10, AX\n    ```\n\n3. **地址傳送**\n\n    將源操作數的地址複製到目的操作數。\n\n    > lea is an abbreviation of \"load effective address\"。— [Stack Overflow](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwif6oDs8PbtAhWNzIsBHb-kDG0QFjADegQICBAC&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F1658294%2Fwhats-the-purpose-of-the-lea-instruction&usg=AOvVaw1XNxphxiOi5AcnWxGpYRbV)\n\n    ```go\n    // 把AX內容的地址傳送到BX中\n    LEAQ AX, BX\n    ```\n\n4. **計算**\n\n    ```go\n    // add quad word from AX to BX\n    // BX += AX\n    ADDQ  AX, BX\n    // subtract quad word from AX to BX\n    // BX -= AX\n    SUBQ  AX, BX\n    // 無符號乘法 IMUL\n    // BX *= AX\n    IMULQ AX, BX\n    // 無符號除法 IDIV\n    // 除數是CX，被除數是AX，結果存儲到AX中\n    IDIVQ CX\n    // 比較SI和CX的大小。與SUBQ類似，只是不賦值\n    // 其結果會存放到寄存器中\n    CMPQ SI CX\n    ```\n\n5. **跳轉**\n\n    ```go\n    // -- 無條件跳轉 -- \n    // 跳轉到地址，地址可為代碼中的地址，不過實際上手寫不會出現這種東西\n    JMP addr\n    // 跳轉到標籤，可以跳轉到同一函數內的標籤位置\n    JMP label\n    // 以當前指令為基礎，向前跳轉 x 行\n    JMP 2(PC)\n    // 以當前指令為基礎，向後跳轉 x 行\n    JMP -2(PC)\n\n    // -- 有條件跳轉 --\n    // jump target if zero\n    // 如果 zero flag 被 set 過，則跳轉\n    JZ target\n    // jump target if less\n    // 上一行的比較CMP結果，左邊小於右邊則執行跳到0x0185地址處(十進制389轉換成十六進制0x0185)\n    JLS 389\n    ```\n\n6. **指令集**\n\n    見源代碼的 [arch 部分](https://github.com/golang/arch/blob/master/x86/x86.csv)。\n\n### 1.2.5 **案例分析：函數調用**\n\n編寫以下代碼於 call.go 文件：\n\n```go\npackage main\n\nfunc Callee(x, y int) int {\n\tr := x + y\n\treturn r\n}\n\nfunc Caller() {\n\tCallee(1, 2)\n}\n```\n\n執行以下命令可查看彙編代碼：\n\n```go\n// -S 輸出彙編代碼到控制台 Print assembly listing to standard output (code only).\n// -l 禁止內聯 Disable inlining.\n// -N 禁止優化 Disable optimizations.\n// 更多參數：https://pkg.go.dev/cmd/compile@go1.15.6\ngo build -gcflags=\"-S -l -N\" call.go\n```\n\n輸出結果爲（有刪減）：\n\n```go\n\"\".Callee STEXT nosplit size=52 args=0x18 locals=0x10\n0x0000 00000 (call.go:3)    TEXT    \"\".Callee(SB), NOSPLIT|ABIInternal, $16-24\n0x0000 00000 (call.go:3)    SUBQ    $16, SP\n0x0004 00004 (call.go:3)    MOVQ    BP, 8(SP)\n0x0009 00009 (call.go:3)    LEAQ    8(SP), BP\n// 將40(SP)處的變量~r2的值爲0，即返回值初始化爲0\n0x000e 00014 (call.go:3)    MOVQ    $0, \"\".~r2+40(SP)\n// 將24(SP)處的變量x的值傳送到AX中\n0x0017 00023 (call.go:4)    MOVQ    \"\".x+24(SP), AX\n// 將32(SP)處的變量y加到AX中\n0x001c 00028 (call.go:4)    ADDQ    \"\".y+32(SP), AX\n// 將AX的值傳送到(SP)處的變量r中\n0x0021 00033 (call.go:4)    MOVQ    AX, \"\".r(SP)\n// 將AX中的值傳送到40(SP)處的變量~r2，即返回值賦值爲AX中的值\n0x0025 00037 (call.go:5)    MOVQ    AX, \"\".~r2+40(SP)\n0x002a 00042 (call.go:5)    MOVQ    8(SP), BP\n0x002f 00047 (call.go:5)    ADDQ    $16, SP\n0x0033 00051 (call.go:5)    RET\n\n// Go 彙編的固定開頭，Caller爲函數名，\n// args 爲入參和返回值佔用的字節大小 0x0=0，\n// locals 爲局部變量佔用的字節大小 0x20=32\n\"\".Caller STEXT size=71 args=0x0 locals=0x20\n// 聲明函數Caller\n0x0000 00000 (call.go:8)    TEXT    \"\".Caller(SB), ABIInternal, $32-0\n// 將(TLS)複製到CX寄存器，(TLS)是指向當前G(goroutine的一種數據結構)的指針\n0x0000 00000 (call.go:8)    MOVQ    (TLS), CX\n// 比較當前棧指針和CX正偏移16個字節的地址\n0x0009 00009 (call.go:8)    CMPQ    SP, 16(CX)\n// 如果比較值左邊小於右邊，則跳轉到地址 64 處，即 CALL    runtime.morestack_noctxt(SB)\n0x000d 00013 (call.go:8)    JLS     64\n// SP減去32，函數開始入棧\n0x000f 00015 (call.go:8)    SUBQ    $32, SP\n// 把BP中的值傳送到24(SP)處開始的內存空間，保存調用者棧幀地址到本棧。\n0x0013 00019 (call.go:8)    MOVQ    BP, 24(SP)\n// 將24(SP)處的地址傳送到BP，保存當前棧幀地址到BP。\n0x0018 00024 (call.go:8)    LEAQ    24(SP), BP\n// 將數字1傳送到(SP)處開始的內存空間\n0x001d 00029 (call.go:9)    MOVQ    $1, (SP)\n// 將數字2傳送到8(SP)處開始的內存空間\n0x0025 00037 (call.go:9)    MOVQ    $2, 8(SP)\n// 調用Callee函數\n0x002e 00046 (call.go:9)    CALL    \"\".Callee(SB)\n// 調用Callee函數時BP寄存器的值會指向Callee的棧幀地址，因此結束後需要復位。\n0x0033 00051 (call.go:10)   MOVQ    24(SP), BP\n// 出棧\n0x0038 00056 (call.go:10)   ADDQ    $32, SP\n// 返回\n0x003c 00060 (call.go:10)   RET\n// 無操作\n0x003d 00061 (call.go:10)   NOP\n0x003d 00061 (call.go:8)    NOP\n// 調用runtime.morestack_noctxt函數\n0x0040 00064 (call.go:8)    CALL    runtime.morestack_noctxt(SB)\n// 跳轉到函數聲明處\n0x0045 00069 (call.go:8)    JMP     0\n```\n\n分析可得棧結構如下：\n\n![](go-design-and-implementation-01/Untitled%203.png)\n\n## 1.3 參考\n\n1. [Go 语言设计与实现：第一章 准备工作 — draveness](https://draveness.me/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/)\n2. [汇编语言入门教程 — 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)\n3. [Go 系列文章3 ：plan9 汇编入门 — 曹春晖@No Headback](https://xargin.com/plan9-assembly/)\n4. [深入Go的底层，带你走近一群有追求的人 — Stefno@博客园](https://www.cnblogs.com/qcrao-2018/p/10562216.html)\n5. [go plan9汇编入门 — yuchanns@Go 语言中文网](https://studygolang.com/articles/26380)\n6. [go编译工具的使用之汇编 — yuchanns@github.com](https://github.com/yuchanns/Atelier/blob/theme/hermit/src/_posts/golang-assembly.md)\n7. [Go Assembly by Example](https://davidwong.fr/goasm/)\n8. [A Quick Guide to Go's Assembler — golang.org](https://golang.org/doc/asm)\n9. [A Manual for the Plan 9 assembler — Rob Pike](http://doc.cat-v.org/plan_9/4th_edition/papers/asm)","slug":"it/go/go-design-and-implementation-01","published":1,"date":"2021-02-05T16:21:16.474Z","updated":"2021-02-05T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7woa00059a9kc7ku484w","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>深入學習 Go 語言的設計與實現之前要準備以下工作：</p>\n<ol>\n<li>克隆 Go 倉庫源代碼並編譯它。</li>\n<li>了解 Plan 9 彙編，知道 Go 的棧結構並能分析代碼的執行過程。</li>\n</ol>\n<p>彙編者，二進制代碼的文本形式也，其最大的特點就是不可移植。Plan 9 彙編是貝爾實驗室的九號計劃的產物，目前被用於 Go 程序編譯的中間代碼，因爲 Go 的作者 Rob Pike，同時也是 Plan 9 彙編的作者。</p>\n<p>Plan 9 彙編指令與 Intel 等彙編等的不同在於：</p>\n<ol>\n<li><p>一般情況下，命令的源操作數在先，目的操作數在後。 如同樣是將十六進制的 10 傳送到 AX寄存器，在 Plan 9 中是 <code>MOVQ $0x10, AX</code> ，而在 Intel 彙編中是 <code>mov rax, 0x10</code> 。</p>\n</li>\n<li><p>棧的調整通過硬件 SP 寄存器進行加減運算實現。而 Intel 彙編中通過 push 和 pop 命令實現。</p>\n</li>\n<li><p>操作的數據長度取決於命令的後綴。而 Intel 彙編取決於寄存器。</p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plan 9 彙編</span></span><br><span class=\"line\">MOVB $<span class=\"number\">1</span>, DI      <span class=\"comment\">// 1 byte</span></span><br><span class=\"line\">MOVW $<span class=\"number\">0x10</span>, BX   <span class=\"comment\">// 2 bytes</span></span><br><span class=\"line\">MOVD $<span class=\"number\">1</span>, DX      <span class=\"comment\">// 4 bytes</span></span><br><span class=\"line\">MOVQ $<span class=\"number\">-10</span>, AX     <span class=\"comment\">// 8 bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// intel 彙編</span></span><br><span class=\"line\">mov rax, <span class=\"number\">0x1</span>   <span class=\"comment\">// 8 bytes</span></span><br><span class=\"line\">mov eax, <span class=\"number\">0x100</span> <span class=\"comment\">// 4 bytes</span></span><br><span class=\"line\">mov ax, <span class=\"number\">0x22</span>   <span class=\"comment\">// 2 bytes</span></span><br><span class=\"line\">mov ah, <span class=\"number\">0x33</span>   <span class=\"comment\">// 1 byte</span></span><br><span class=\"line\">mov al, <span class=\"number\">0x44</span>   <span class=\"comment\">// 1 byte</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>通過分析 Plan 9 彙編代碼我們可以繪製出如下的棧結構：</p>\n<p><img src=\"/2021/02/06/it/go/go-design-and-implementation-01/Untitled.png\" alt></p>\n<span id=\"more\"></span>\n\n<h2 id=\"1-1-調試-Go-語言\"><a href=\"#1-1-調試-Go-語言\" class=\"headerlink\" title=\"1.1 調試 Go 語言\"></a>1.1 調試 Go 語言</h2><h3 id=\"1-1-1-克隆-go-倉庫並查看代碼行數\"><a href=\"#1-1-1-克隆-go-倉庫並查看代碼行數\" class=\"headerlink\" title=\"1.1.1 克隆 go 倉庫並查看代碼行數\"></a><strong>1.1.1 克隆 go 倉庫並查看代碼行數</strong></h3><p>cloc (Count Lines of Code) 工具可以計算源代碼行數。執行後可知 Go 源代碼超過 140 萬行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/golang/go.git</span><br><span class=\"line\">$ cloc go/src</span><br><span class=\"line\">6277 text files.</span><br><span class=\"line\">6156 unique files.</span><br><span class=\"line\">1298 files ignored.</span><br><span class=\"line\"><span class=\"comment\"># 省略部分內容</span></span><br><span class=\"line\">-----------------------------------------------------------------------------------</span><br><span class=\"line\">Language                         files          blank        comment           code</span><br><span class=\"line\">-----------------------------------------------------------------------------------</span><br><span class=\"line\">Go                                4340         143352         253857        1412372</span><br><span class=\"line\">Assembly                           497          12862          18550         108301</span><br><span class=\"line\">C                                   68            763            599           4745</span><br><span class=\"line\"><span class=\"comment\"># 省略部分內容</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-2-編譯源碼\"><a href=\"#1-1-2-編譯源碼\" class=\"headerlink\" title=\"1.1.2 編譯源碼\"></a>1.1.2 編譯源碼</h3><p>在源代碼中找到 fmt 包，修改 Println 函數如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">func Println(a ...interface&#123;&#125;) (n int, err error) &#123;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;draven&quot;</span>)</span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fprintln(os.Stdout, a...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>隨後執行  <code>./src/make.bash</code> 編譯源代碼，成功之後用編譯出來的 Go 二進制文件來執行你的代碼：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat main.go</span><br><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$ src/github.com/golang/go/bin/go run main.go</span><br><span class=\"line\">draven</span><br><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-Plan-9-彙編\"><a href=\"#1-2-Plan-9-彙編\" class=\"headerlink\" title=\"1.2 Plan 9 彙編\"></a>1.2 Plan 9 彙編</h2><h3 id=\"1-2-1-彙編\"><a href=\"#1-2-1-彙編\" class=\"headerlink\" title=\"1.2.1 彙編\"></a><strong>1.2.1 彙編</strong></h3><p>在正式學習 Plan 9 彙編之前，建議先看下阮一峰老師的<a href=\"http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html\">《汇编语言入门教程》</a>以理解以下結論：</p>\n<ol>\n<li><p>匯編語言是二進制指令的文本形式。</p>\n</li>\n<li><p>較之CPU 緩存，CPU 訪問寄存器速度更快且不需要尋址。</p>\n</li>\n<li><p>寄存器依靠名稱而不是地址來區分數據。</p>\n</li>\n<li><p>內存中的堆自下而上分配，棧自上而下分配。</p>\n<p> <img src=\"/2021/02/06/it/go/go-design-and-implementation-01/Untitled%201.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"1-2-2-Plan-9\"><a href=\"#1-2-2-Plan-9\" class=\"headerlink\" title=\"1.2.2 Plan 9\"></a><strong>1.2.2 Plan 9</strong></h3><p>Plan 9，貝爾實驗室九號計劃，是一個基於 Unix 的分布式操作系統，該系統開源但並未商業化使用。Go 語言的作者 Rob Pike 是其帶領者之一。</p>\n<p>Go 使用了 Plan 9 彙編作爲中間代碼，最後再編譯成二進制代碼。了解 Plan 9 彙編有助於分析 Go 語言的底層實現和排查問題。</p>\n<p>彙編語言具有不可移植性，各個平台上的平台指令集和寄存器都不一樣。學習時我們以 Linux amd64 爲例。</p>\n<h3 id=\"1-2-3-寄存器\"><a href=\"#1-2-3-寄存器\" class=\"headerlink\" title=\"1.2.3 寄存器\"></a><strong>1.2.3 寄存器</strong></h3><p>amd64 上的寄存器有：</p>\n<ol>\n<li><strong>AX</strong>：累加寄存器(AccumulatorRegister)，用於存放數據，包括算術、操作數、結果和臨時存放地址。</li>\n<li><strong>BX</strong>：基址寄存器(BaseRegister)，用於存放訪問存儲器時的地址。</li>\n<li><strong>CX</strong>：計數寄存器(CountRegister)，用於保存計算值，用作計數器。</li>\n<li><strong>DX</strong>：數據寄存器(DataRegister)，用於數據傳遞，在寄存器間接尋址中的I/O指令中存放I/O端口的地址。</li>\n<li>DI：目的寄存器(DestinationIndex)，用於存放目的操作數的偏移地址。</li>\n<li>SI：源變址寄存器(SourceIndex)，用於存放源操作數的偏移地址。</li>\n<li><strong>BP：</strong>棧基指針(BasePointer)，保存在進入函數前的棧頂基址。</li>\n<li><strong>SP：</strong>棧指針(StackPointer)，指向當前棧幀的局部變量的開始位置。如果是symbol+offset(SP)的形式表示<strong>偽寄存器</strong>，offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间；如果是offset(SP)的形式表示<strong>硬件寄存器</strong>。（注意：對於編譯輸出(<code>go tool compile -S / go tool objdump</code>)的代碼來講，目前所有的 SP 都是硬件寄存器 SP，無論是否帶 symbol）</li>\n<li><strong>FP</strong>：棧幀指針(FramePointer)，偽寄存器。指向引用函數的輸入參數，形式是symbol+offset(FP)，例如 arg0+0(FP)。</li>\n<li>SB：靜態基指針(StaticBasePointer)，偽寄存器。一般用來聲明函數或全局變量。</li>\n<li>PC：程序計數器(ProgramCounter)，偽寄存器。存放下一條指令的地址。</li>\n<li>R8</li>\n<li>R9</li>\n<li>R10</li>\n</ol>\n<p><strong>偽寄存器</strong>(pseudo register)：僞寄存器與平台無關，只在生成目標代碼時才與平台上的硬件寄存器對應起來。Plan 9 彙編有四個偽寄存器，FP、SP、SB、PC。FP 存放引用函數的輸入參數，SP 存放當前棧幀的局部變量的開始位置，SB 聲明函數和全局變量，PC 存放下一條指令的地址。</p>\n<h3 id=\"1-2-4-基本指令\"><a href=\"#1-2-4-基本指令\" class=\"headerlink\" title=\"1.2.4 基本指令\"></a><strong>1.2.4 基本指令</strong></h3><ol>\n<li><p><strong>棧調整</strong></p>\n<p> 通過對 SP 寄存器進行操作實現，這與 intle 或 AT&amp;T 匯編不同，他們是使用 push、pop 指令實現。</p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">SUBQ $<span class=\"number\">0x18</span>, SP <span class=\"comment\">// 對 SP 做減法，為函數分配函數棧幀</span></span><br><span class=\"line\">...               <span class=\"comment\">// 省略無用代碼</span></span><br><span class=\"line\">ADDQ $<span class=\"number\">0x18</span>, SP <span class=\"comment\">// 對 SP 做加法，清除函數棧幀</span></span><br></pre></td></tr></table></figure>\n\n<p> 注意：SP 一開始處於棧頂且棧是自上而下分配的，所以要通過減法分配棧幀，通過加法清除棧幀。示意圖如下：</p>\n<p> <img src=\"/2021/02/06/it/go/go-design-and-implementation-01/Untitled%202.png\" alt></p>\n</li>\n<li><p><strong>數據搬運</strong></p>\n<p> 將源操作數複製到目的操作數。Plan 9 中用 <code>$num</code> 形式表示常數，默認爲十進制，也可用 <code>$0x123</code> 形式表示十六進制。搬運的長度由 <code>MOV</code> 的後綴決定。</p>\n<p> 格式：<code>MOVB source destination</code></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// move byte</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運一個字節長</span></span><br><span class=\"line\">MOVB $<span class=\"number\">1</span>, DI</span><br><span class=\"line\"><span class=\"comment\">// move word = 2 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運一個字長</span></span><br><span class=\"line\">MOVW $<span class=\"number\">0x10</span>, BX</span><br><span class=\"line\"><span class=\"comment\">// move double word = 4 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運兩倍字長</span></span><br><span class=\"line\">MOVD $<span class=\"number\">1</span>, DX</span><br><span class=\"line\"><span class=\"comment\">// move quad word = 8 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運四倍字長</span></span><br><span class=\"line\">MOVQ $<span class=\"number\">-10</span>, AX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>地址傳送</strong></p>\n<p> 將源操作數的地址複製到目的操作數。</p>\n<blockquote>\n<p>lea is an abbreviation of “load effective address”。— <a href=\"https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwif6oDs8PbtAhWNzIsBHb-kDG0QFjADegQICBAC&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F1658294%2Fwhats-the-purpose-of-the-lea-instruction&usg=AOvVaw1XNxphxiOi5AcnWxGpYRbV\">Stack Overflow</a></p>\n</blockquote>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把AX內容的地址傳送到BX中</span></span><br><span class=\"line\">LEAQ AX, BX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>計算</strong></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add quad word from AX to BX</span></span><br><span class=\"line\"><span class=\"comment\">// BX += AX</span></span><br><span class=\"line\">ADDQ  AX, BX</span><br><span class=\"line\"><span class=\"comment\">// subtract quad word from AX to BX</span></span><br><span class=\"line\"><span class=\"comment\">// BX -= AX</span></span><br><span class=\"line\">SUBQ  AX, BX</span><br><span class=\"line\"><span class=\"comment\">// 無符號乘法 IMUL</span></span><br><span class=\"line\"><span class=\"comment\">// BX *= AX</span></span><br><span class=\"line\">IMULQ AX, BX</span><br><span class=\"line\"><span class=\"comment\">// 無符號除法 IDIV</span></span><br><span class=\"line\"><span class=\"comment\">// 除數是CX，被除數是AX，結果存儲到AX中</span></span><br><span class=\"line\">IDIVQ CX</span><br><span class=\"line\"><span class=\"comment\">// 比較SI和CX的大小。與SUBQ類似，只是不賦值</span></span><br><span class=\"line\"><span class=\"comment\">// 其結果會存放到寄存器中</span></span><br><span class=\"line\">CMPQ SI CX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>跳轉</strong></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- 無條件跳轉 -- </span></span><br><span class=\"line\"><span class=\"comment\">// 跳轉到地址，地址可為代碼中的地址，不過實際上手寫不會出現這種東西</span></span><br><span class=\"line\">JMP addr</span><br><span class=\"line\"><span class=\"comment\">// 跳轉到標籤，可以跳轉到同一函數內的標籤位置</span></span><br><span class=\"line\">JMP label</span><br><span class=\"line\"><span class=\"comment\">// 以當前指令為基礎，向前跳轉 x 行</span></span><br><span class=\"line\">JMP <span class=\"number\">2</span>(PC)</span><br><span class=\"line\"><span class=\"comment\">// 以當前指令為基礎，向後跳轉 x 行</span></span><br><span class=\"line\">JMP <span class=\"number\">-2</span>(PC)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- 有條件跳轉 --</span></span><br><span class=\"line\"><span class=\"comment\">// jump target if zero</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 zero flag 被 set 過，則跳轉</span></span><br><span class=\"line\">JZ target</span><br><span class=\"line\"><span class=\"comment\">// jump target if less</span></span><br><span class=\"line\"><span class=\"comment\">// 上一行的比較CMP結果，左邊小於右邊則執行跳到0x0185地址處(十進制389轉換成十六進制0x0185)</span></span><br><span class=\"line\">JLS <span class=\"number\">389</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>指令集</strong></p>\n<p> 見源代碼的 <a href=\"https://github.com/golang/arch/blob/master/x86/x86.csv\">arch 部分</a>。</p>\n</li>\n</ol>\n<h3 id=\"1-2-5-案例分析：函數調用\"><a href=\"#1-2-5-案例分析：函數調用\" class=\"headerlink\" title=\"1.2.5 案例分析：函數調用\"></a>1.2.5 <strong>案例分析：函數調用</strong></h3><p>編寫以下代碼於 call.go 文件：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Callee</span><span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  r := x + y</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Caller</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  Callee(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行以下命令可查看彙編代碼：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -S 輸出彙編代碼到控制台 Print assembly listing to standard output (code only).</span></span><br><span class=\"line\"><span class=\"comment\">// -l 禁止內聯 Disable inlining.</span></span><br><span class=\"line\"><span class=\"comment\">// -N 禁止優化 Disable optimizations.</span></span><br><span class=\"line\"><span class=\"comment\">// 更多參數：https://pkg.go.dev/cmd/compile@go1.15.6</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> build -gcflags=<span class=\"string\">&quot;-S -l -N&quot;</span> call.<span class=\"keyword\">go</span></span><br></pre></td></tr></table></figure>\n\n<p>輸出結果爲（有刪減）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span>.Callee STEXT nosplit size=<span class=\"number\">52</span> args=<span class=\"number\">0x18</span> locals=<span class=\"number\">0x10</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    TEXT    <span class=\"string\">&quot;&quot;</span>.Callee(SB), NOSPLIT|ABIInternal, $<span class=\"number\">16</span><span class=\"number\">-24</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    SUBQ    $<span class=\"number\">16</span>, SP</span><br><span class=\"line\"><span class=\"number\">0x0004</span> <span class=\"number\">00004</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    MOVQ    BP, <span class=\"number\">8</span>(SP)</span><br><span class=\"line\"><span class=\"number\">0x0009</span> <span class=\"number\">00009</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    LEAQ    <span class=\"number\">8</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 將40(SP)處的變量~r2的值爲0，即返回值初始化爲0</span></span><br><span class=\"line\"><span class=\"number\">0x000e</span> <span class=\"number\">00014</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    MOVQ    $<span class=\"number\">0</span>, <span class=\"string\">&quot;&quot;</span>.~r2+<span class=\"number\">40</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將24(SP)處的變量x的值傳送到AX中</span></span><br><span class=\"line\"><span class=\"number\">0x0017</span> <span class=\"number\">00023</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    MOVQ    <span class=\"string\">&quot;&quot;</span>.x+<span class=\"number\">24</span>(SP), AX</span><br><span class=\"line\"><span class=\"comment\">// 將32(SP)處的變量y加到AX中</span></span><br><span class=\"line\"><span class=\"number\">0x001c</span> <span class=\"number\">00028</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    ADDQ    <span class=\"string\">&quot;&quot;</span>.y+<span class=\"number\">32</span>(SP), AX</span><br><span class=\"line\"><span class=\"comment\">// 將AX的值傳送到(SP)處的變量r中</span></span><br><span class=\"line\"><span class=\"number\">0x0021</span> <span class=\"number\">00033</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    MOVQ    AX, <span class=\"string\">&quot;&quot;</span>.r(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將AX中的值傳送到40(SP)處的變量~r2，即返回值賦值爲AX中的值</span></span><br><span class=\"line\"><span class=\"number\">0x0025</span> <span class=\"number\">00037</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    MOVQ    AX, <span class=\"string\">&quot;&quot;</span>.~r2+<span class=\"number\">40</span>(SP)</span><br><span class=\"line\"><span class=\"number\">0x002a</span> <span class=\"number\">00042</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    MOVQ    <span class=\"number\">8</span>(SP), BP</span><br><span class=\"line\"><span class=\"number\">0x002f</span> <span class=\"number\">00047</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    ADDQ    $<span class=\"number\">16</span>, SP</span><br><span class=\"line\"><span class=\"number\">0x0033</span> <span class=\"number\">00051</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    RET</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Go 彙編的固定開頭，Caller爲函數名，</span></span><br><span class=\"line\"><span class=\"comment\">// args 爲入參和返回值佔用的字節大小 0x0=0，</span></span><br><span class=\"line\"><span class=\"comment\">// locals 爲局部變量佔用的字節大小 0x20=32</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span>.Caller STEXT size=<span class=\"number\">71</span> args=<span class=\"number\">0x0</span> locals=<span class=\"number\">0x20</span></span><br><span class=\"line\"><span class=\"comment\">// 聲明函數Caller</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    TEXT    <span class=\"string\">&quot;&quot;</span>.Caller(SB), ABIInternal, $<span class=\"number\">32</span><span class=\"number\">-0</span></span><br><span class=\"line\"><span class=\"comment\">// 將(TLS)複製到CX寄存器，(TLS)是指向當前G(goroutine的一種數據結構)的指針</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    MOVQ    (TLS), CX</span><br><span class=\"line\"><span class=\"comment\">// 比較當前棧指針和CX正偏移16個字節的地址</span></span><br><span class=\"line\"><span class=\"number\">0x0009</span> <span class=\"number\">00009</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    CMPQ    SP, <span class=\"number\">16</span>(CX)</span><br><span class=\"line\"><span class=\"comment\">// 如果比較值左邊小於右邊，則跳轉到地址 64 處，即 CALL    runtime.morestack_noctxt(SB)</span></span><br><span class=\"line\"><span class=\"number\">0x000d</span> <span class=\"number\">00013</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    JLS     <span class=\"number\">64</span></span><br><span class=\"line\"><span class=\"comment\">// SP減去32，函數開始入棧</span></span><br><span class=\"line\"><span class=\"number\">0x000f</span> <span class=\"number\">00015</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    SUBQ    $<span class=\"number\">32</span>, SP</span><br><span class=\"line\"><span class=\"comment\">// 把BP中的值傳送到24(SP)處開始的內存空間，保存調用者棧幀地址到本棧。</span></span><br><span class=\"line\"><span class=\"number\">0x0013</span> <span class=\"number\">00019</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    MOVQ    BP, <span class=\"number\">24</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將24(SP)處的地址傳送到BP，保存當前棧幀地址到BP。</span></span><br><span class=\"line\"><span class=\"number\">0x0018</span> <span class=\"number\">00024</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    LEAQ    <span class=\"number\">24</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 將數字1傳送到(SP)處開始的內存空間</span></span><br><span class=\"line\"><span class=\"number\">0x001d</span> <span class=\"number\">00029</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    MOVQ    $<span class=\"number\">1</span>, (SP)</span><br><span class=\"line\"><span class=\"comment\">// 將數字2傳送到8(SP)處開始的內存空間</span></span><br><span class=\"line\"><span class=\"number\">0x0025</span> <span class=\"number\">00037</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    MOVQ    $<span class=\"number\">2</span>, <span class=\"number\">8</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 調用Callee函數</span></span><br><span class=\"line\"><span class=\"number\">0x002e</span> <span class=\"number\">00046</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    CALL    <span class=\"string\">&quot;&quot;</span>.Callee(SB)</span><br><span class=\"line\"><span class=\"comment\">// 調用Callee函數時BP寄存器的值會指向Callee的棧幀地址，因此結束後需要復位。</span></span><br><span class=\"line\"><span class=\"number\">0x0033</span> <span class=\"number\">00051</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   MOVQ    <span class=\"number\">24</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 出棧</span></span><br><span class=\"line\"><span class=\"number\">0x0038</span> <span class=\"number\">00056</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   ADDQ    $<span class=\"number\">32</span>, SP</span><br><span class=\"line\"><span class=\"comment\">// 返回</span></span><br><span class=\"line\"><span class=\"number\">0x003c</span> <span class=\"number\">00060</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   RET</span><br><span class=\"line\"><span class=\"comment\">// 無操作</span></span><br><span class=\"line\"><span class=\"number\">0x003d</span> <span class=\"number\">00061</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   NOP</span><br><span class=\"line\"><span class=\"number\">0x003d</span> <span class=\"number\">00061</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    NOP</span><br><span class=\"line\"><span class=\"comment\">// 調用runtime.morestack_noctxt函數</span></span><br><span class=\"line\"><span class=\"number\">0x0040</span> <span class=\"number\">00064</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    CALL    runtime.morestack_noctxt(SB)</span><br><span class=\"line\"><span class=\"comment\">// 跳轉到函數聲明處</span></span><br><span class=\"line\"><span class=\"number\">0x0045</span> <span class=\"number\">00069</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    JMP     <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>分析可得棧結構如下：</p>\n<p><img src=\"/2021/02/06/it/go/go-design-and-implementation-01/Untitled%203.png\" alt></p>\n<h2 id=\"1-3-參考\"><a href=\"#1-3-參考\" class=\"headerlink\" title=\"1.3 參考\"></a>1.3 參考</h2><ol>\n<li><a href=\"https://draveness.me/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/\">Go 语言设计与实现：第一章 准备工作 — draveness</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html\">汇编语言入门教程 — 阮一峰的网络日志</a></li>\n<li><a href=\"https://xargin.com/plan9-assembly/\">Go 系列文章3 ：plan9 汇编入门 — 曹春晖@No Headback</a></li>\n<li><a href=\"https://www.cnblogs.com/qcrao-2018/p/10562216.html\">深入Go的底层，带你走近一群有追求的人 — Stefno@博客园</a></li>\n<li><a href=\"https://studygolang.com/articles/26380\">go plan9汇编入门 — yuchanns@Go 语言中文网</a></li>\n<li><a href=\"https://github.com/yuchanns/Atelier/blob/theme/hermit/src/_posts/golang-assembly.md\">go编译工具的使用之汇编 — yuchanns@github.com</a></li>\n<li><a href=\"https://davidwong.fr/goasm/\">Go Assembly by Example</a></li>\n<li><a href=\"https://golang.org/doc/asm\">A Quick Guide to Go’s Assembler — golang.org</a></li>\n<li><a href=\"http://doc.cat-v.org/plan_9/4th_edition/papers/asm\">A Manual for the Plan 9 assembler — Rob Pike</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>深入學習 Go 語言的設計與實現之前要準備以下工作：</p>\n<ol>\n<li>克隆 Go 倉庫源代碼並編譯它。</li>\n<li>了解 Plan 9 彙編，知道 Go 的棧結構並能分析代碼的執行過程。</li>\n</ol>\n<p>彙編者，二進制代碼的文本形式也，其最大的特點就是不可移植。Plan 9 彙編是貝爾實驗室的九號計劃的產物，目前被用於 Go 程序編譯的中間代碼，因爲 Go 的作者 Rob Pike，同時也是 Plan 9 彙編的作者。</p>\n<p>Plan 9 彙編指令與 Intel 等彙編等的不同在於：</p>\n<ol>\n<li><p>一般情況下，命令的源操作數在先，目的操作數在後。 如同樣是將十六進制的 10 傳送到 AX寄存器，在 Plan 9 中是 <code>MOVQ $0x10, AX</code> ，而在 Intel 彙編中是 <code>mov rax, 0x10</code> 。</p>\n</li>\n<li><p>棧的調整通過硬件 SP 寄存器進行加減運算實現。而 Intel 彙編中通過 push 和 pop 命令實現。</p>\n</li>\n<li><p>操作的數據長度取決於命令的後綴。而 Intel 彙編取決於寄存器。</p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plan 9 彙編</span></span><br><span class=\"line\">MOVB $<span class=\"number\">1</span>, DI      <span class=\"comment\">// 1 byte</span></span><br><span class=\"line\">MOVW $<span class=\"number\">0x10</span>, BX   <span class=\"comment\">// 2 bytes</span></span><br><span class=\"line\">MOVD $<span class=\"number\">1</span>, DX      <span class=\"comment\">// 4 bytes</span></span><br><span class=\"line\">MOVQ $<span class=\"number\">-10</span>, AX     <span class=\"comment\">// 8 bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// intel 彙編</span></span><br><span class=\"line\">mov rax, <span class=\"number\">0x1</span>   <span class=\"comment\">// 8 bytes</span></span><br><span class=\"line\">mov eax, <span class=\"number\">0x100</span> <span class=\"comment\">// 4 bytes</span></span><br><span class=\"line\">mov ax, <span class=\"number\">0x22</span>   <span class=\"comment\">// 2 bytes</span></span><br><span class=\"line\">mov ah, <span class=\"number\">0x33</span>   <span class=\"comment\">// 1 byte</span></span><br><span class=\"line\">mov al, <span class=\"number\">0x44</span>   <span class=\"comment\">// 1 byte</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>通過分析 Plan 9 彙編代碼我們可以繪製出如下的棧結構：</p>\n<p><img src=\"/2021/02/06/it/go/go-design-and-implementation-01/Untitled.png\" alt></p>","more":"<h2 id=\"1-1-調試-Go-語言\"><a href=\"#1-1-調試-Go-語言\" class=\"headerlink\" title=\"1.1 調試 Go 語言\"></a>1.1 調試 Go 語言</h2><h3 id=\"1-1-1-克隆-go-倉庫並查看代碼行數\"><a href=\"#1-1-1-克隆-go-倉庫並查看代碼行數\" class=\"headerlink\" title=\"1.1.1 克隆 go 倉庫並查看代碼行數\"></a><strong>1.1.1 克隆 go 倉庫並查看代碼行數</strong></h3><p>cloc (Count Lines of Code) 工具可以計算源代碼行數。執行後可知 Go 源代碼超過 140 萬行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/golang/go.git</span><br><span class=\"line\">$ cloc go/src</span><br><span class=\"line\">6277 text files.</span><br><span class=\"line\">6156 unique files.</span><br><span class=\"line\">1298 files ignored.</span><br><span class=\"line\"><span class=\"comment\"># 省略部分內容</span></span><br><span class=\"line\">-----------------------------------------------------------------------------------</span><br><span class=\"line\">Language                         files          blank        comment           code</span><br><span class=\"line\">-----------------------------------------------------------------------------------</span><br><span class=\"line\">Go                                4340         143352         253857        1412372</span><br><span class=\"line\">Assembly                           497          12862          18550         108301</span><br><span class=\"line\">C                                   68            763            599           4745</span><br><span class=\"line\"><span class=\"comment\"># 省略部分內容</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-2-編譯源碼\"><a href=\"#1-1-2-編譯源碼\" class=\"headerlink\" title=\"1.1.2 編譯源碼\"></a>1.1.2 編譯源碼</h3><p>在源代碼中找到 fmt 包，修改 Println 函數如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">func Println(a ...interface&#123;&#125;) (n int, err error) &#123;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;draven&quot;</span>)</span><br><span class=\"line\">  <span class=\"built_in\">return</span> Fprintln(os.Stdout, a...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>隨後執行  <code>./src/make.bash</code> 編譯源代碼，成功之後用編譯出來的 Go 二進制文件來執行你的代碼：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat main.go</span><br><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$ src/github.com/golang/go/bin/go run main.go</span><br><span class=\"line\">draven</span><br><span class=\"line\">Hello World</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-Plan-9-彙編\"><a href=\"#1-2-Plan-9-彙編\" class=\"headerlink\" title=\"1.2 Plan 9 彙編\"></a>1.2 Plan 9 彙編</h2><h3 id=\"1-2-1-彙編\"><a href=\"#1-2-1-彙編\" class=\"headerlink\" title=\"1.2.1 彙編\"></a><strong>1.2.1 彙編</strong></h3><p>在正式學習 Plan 9 彙編之前，建議先看下阮一峰老師的<a href=\"http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html\">《汇编语言入门教程》</a>以理解以下結論：</p>\n<ol>\n<li><p>匯編語言是二進制指令的文本形式。</p>\n</li>\n<li><p>較之CPU 緩存，CPU 訪問寄存器速度更快且不需要尋址。</p>\n</li>\n<li><p>寄存器依靠名稱而不是地址來區分數據。</p>\n</li>\n<li><p>內存中的堆自下而上分配，棧自上而下分配。</p>\n<p> <img src=\"/2021/02/06/it/go/go-design-and-implementation-01/Untitled%201.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"1-2-2-Plan-9\"><a href=\"#1-2-2-Plan-9\" class=\"headerlink\" title=\"1.2.2 Plan 9\"></a><strong>1.2.2 Plan 9</strong></h3><p>Plan 9，貝爾實驗室九號計劃，是一個基於 Unix 的分布式操作系統，該系統開源但並未商業化使用。Go 語言的作者 Rob Pike 是其帶領者之一。</p>\n<p>Go 使用了 Plan 9 彙編作爲中間代碼，最後再編譯成二進制代碼。了解 Plan 9 彙編有助於分析 Go 語言的底層實現和排查問題。</p>\n<p>彙編語言具有不可移植性，各個平台上的平台指令集和寄存器都不一樣。學習時我們以 Linux amd64 爲例。</p>\n<h3 id=\"1-2-3-寄存器\"><a href=\"#1-2-3-寄存器\" class=\"headerlink\" title=\"1.2.3 寄存器\"></a><strong>1.2.3 寄存器</strong></h3><p>amd64 上的寄存器有：</p>\n<ol>\n<li><strong>AX</strong>：累加寄存器(AccumulatorRegister)，用於存放數據，包括算術、操作數、結果和臨時存放地址。</li>\n<li><strong>BX</strong>：基址寄存器(BaseRegister)，用於存放訪問存儲器時的地址。</li>\n<li><strong>CX</strong>：計數寄存器(CountRegister)，用於保存計算值，用作計數器。</li>\n<li><strong>DX</strong>：數據寄存器(DataRegister)，用於數據傳遞，在寄存器間接尋址中的I/O指令中存放I/O端口的地址。</li>\n<li>DI：目的寄存器(DestinationIndex)，用於存放目的操作數的偏移地址。</li>\n<li>SI：源變址寄存器(SourceIndex)，用於存放源操作數的偏移地址。</li>\n<li><strong>BP：</strong>棧基指針(BasePointer)，保存在進入函數前的棧頂基址。</li>\n<li><strong>SP：</strong>棧指針(StackPointer)，指向當前棧幀的局部變量的開始位置。如果是symbol+offset(SP)的形式表示<strong>偽寄存器</strong>，offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间；如果是offset(SP)的形式表示<strong>硬件寄存器</strong>。（注意：對於編譯輸出(<code>go tool compile -S / go tool objdump</code>)的代碼來講，目前所有的 SP 都是硬件寄存器 SP，無論是否帶 symbol）</li>\n<li><strong>FP</strong>：棧幀指針(FramePointer)，偽寄存器。指向引用函數的輸入參數，形式是symbol+offset(FP)，例如 arg0+0(FP)。</li>\n<li>SB：靜態基指針(StaticBasePointer)，偽寄存器。一般用來聲明函數或全局變量。</li>\n<li>PC：程序計數器(ProgramCounter)，偽寄存器。存放下一條指令的地址。</li>\n<li>R8</li>\n<li>R9</li>\n<li>R10</li>\n</ol>\n<p><strong>偽寄存器</strong>(pseudo register)：僞寄存器與平台無關，只在生成目標代碼時才與平台上的硬件寄存器對應起來。Plan 9 彙編有四個偽寄存器，FP、SP、SB、PC。FP 存放引用函數的輸入參數，SP 存放當前棧幀的局部變量的開始位置，SB 聲明函數和全局變量，PC 存放下一條指令的地址。</p>\n<h3 id=\"1-2-4-基本指令\"><a href=\"#1-2-4-基本指令\" class=\"headerlink\" title=\"1.2.4 基本指令\"></a><strong>1.2.4 基本指令</strong></h3><ol>\n<li><p><strong>棧調整</strong></p>\n<p> 通過對 SP 寄存器進行操作實現，這與 intle 或 AT&amp;T 匯編不同，他們是使用 push、pop 指令實現。</p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">SUBQ $<span class=\"number\">0x18</span>, SP <span class=\"comment\">// 對 SP 做減法，為函數分配函數棧幀</span></span><br><span class=\"line\">...               <span class=\"comment\">// 省略無用代碼</span></span><br><span class=\"line\">ADDQ $<span class=\"number\">0x18</span>, SP <span class=\"comment\">// 對 SP 做加法，清除函數棧幀</span></span><br></pre></td></tr></table></figure>\n\n<p> 注意：SP 一開始處於棧頂且棧是自上而下分配的，所以要通過減法分配棧幀，通過加法清除棧幀。示意圖如下：</p>\n<p> <img src=\"/2021/02/06/it/go/go-design-and-implementation-01/Untitled%202.png\" alt></p>\n</li>\n<li><p><strong>數據搬運</strong></p>\n<p> 將源操作數複製到目的操作數。Plan 9 中用 <code>$num</code> 形式表示常數，默認爲十進制，也可用 <code>$0x123</code> 形式表示十六進制。搬運的長度由 <code>MOV</code> 的後綴決定。</p>\n<p> 格式：<code>MOVB source destination</code></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// move byte</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運一個字節長</span></span><br><span class=\"line\">MOVB $<span class=\"number\">1</span>, DI</span><br><span class=\"line\"><span class=\"comment\">// move word = 2 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運一個字長</span></span><br><span class=\"line\">MOVW $<span class=\"number\">0x10</span>, BX</span><br><span class=\"line\"><span class=\"comment\">// move double word = 4 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運兩倍字長</span></span><br><span class=\"line\">MOVD $<span class=\"number\">1</span>, DX</span><br><span class=\"line\"><span class=\"comment\">// move quad word = 8 bytes</span></span><br><span class=\"line\"><span class=\"comment\">// 搬運四倍字長</span></span><br><span class=\"line\">MOVQ $<span class=\"number\">-10</span>, AX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>地址傳送</strong></p>\n<p> 將源操作數的地址複製到目的操作數。</p>\n<blockquote>\n<p>lea is an abbreviation of “load effective address”。— <a href=\"https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwif6oDs8PbtAhWNzIsBHb-kDG0QFjADegQICBAC&url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F1658294%2Fwhats-the-purpose-of-the-lea-instruction&usg=AOvVaw1XNxphxiOi5AcnWxGpYRbV\">Stack Overflow</a></p>\n</blockquote>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把AX內容的地址傳送到BX中</span></span><br><span class=\"line\">LEAQ AX, BX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>計算</strong></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add quad word from AX to BX</span></span><br><span class=\"line\"><span class=\"comment\">// BX += AX</span></span><br><span class=\"line\">ADDQ  AX, BX</span><br><span class=\"line\"><span class=\"comment\">// subtract quad word from AX to BX</span></span><br><span class=\"line\"><span class=\"comment\">// BX -= AX</span></span><br><span class=\"line\">SUBQ  AX, BX</span><br><span class=\"line\"><span class=\"comment\">// 無符號乘法 IMUL</span></span><br><span class=\"line\"><span class=\"comment\">// BX *= AX</span></span><br><span class=\"line\">IMULQ AX, BX</span><br><span class=\"line\"><span class=\"comment\">// 無符號除法 IDIV</span></span><br><span class=\"line\"><span class=\"comment\">// 除數是CX，被除數是AX，結果存儲到AX中</span></span><br><span class=\"line\">IDIVQ CX</span><br><span class=\"line\"><span class=\"comment\">// 比較SI和CX的大小。與SUBQ類似，只是不賦值</span></span><br><span class=\"line\"><span class=\"comment\">// 其結果會存放到寄存器中</span></span><br><span class=\"line\">CMPQ SI CX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>跳轉</strong></p>\n <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- 無條件跳轉 -- </span></span><br><span class=\"line\"><span class=\"comment\">// 跳轉到地址，地址可為代碼中的地址，不過實際上手寫不會出現這種東西</span></span><br><span class=\"line\">JMP addr</span><br><span class=\"line\"><span class=\"comment\">// 跳轉到標籤，可以跳轉到同一函數內的標籤位置</span></span><br><span class=\"line\">JMP label</span><br><span class=\"line\"><span class=\"comment\">// 以當前指令為基礎，向前跳轉 x 行</span></span><br><span class=\"line\">JMP <span class=\"number\">2</span>(PC)</span><br><span class=\"line\"><span class=\"comment\">// 以當前指令為基礎，向後跳轉 x 行</span></span><br><span class=\"line\">JMP <span class=\"number\">-2</span>(PC)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- 有條件跳轉 --</span></span><br><span class=\"line\"><span class=\"comment\">// jump target if zero</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 zero flag 被 set 過，則跳轉</span></span><br><span class=\"line\">JZ target</span><br><span class=\"line\"><span class=\"comment\">// jump target if less</span></span><br><span class=\"line\"><span class=\"comment\">// 上一行的比較CMP結果，左邊小於右邊則執行跳到0x0185地址處(十進制389轉換成十六進制0x0185)</span></span><br><span class=\"line\">JLS <span class=\"number\">389</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>指令集</strong></p>\n<p> 見源代碼的 <a href=\"https://github.com/golang/arch/blob/master/x86/x86.csv\">arch 部分</a>。</p>\n</li>\n</ol>\n<h3 id=\"1-2-5-案例分析：函數調用\"><a href=\"#1-2-5-案例分析：函數調用\" class=\"headerlink\" title=\"1.2.5 案例分析：函數調用\"></a>1.2.5 <strong>案例分析：函數調用</strong></h3><p>編寫以下代碼於 call.go 文件：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Callee</span><span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  r := x + y</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Caller</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  Callee(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行以下命令可查看彙編代碼：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -S 輸出彙編代碼到控制台 Print assembly listing to standard output (code only).</span></span><br><span class=\"line\"><span class=\"comment\">// -l 禁止內聯 Disable inlining.</span></span><br><span class=\"line\"><span class=\"comment\">// -N 禁止優化 Disable optimizations.</span></span><br><span class=\"line\"><span class=\"comment\">// 更多參數：https://pkg.go.dev/cmd/compile@go1.15.6</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> build -gcflags=<span class=\"string\">&quot;-S -l -N&quot;</span> call.<span class=\"keyword\">go</span></span><br></pre></td></tr></table></figure>\n\n<p>輸出結果爲（有刪減）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span>.Callee STEXT nosplit size=<span class=\"number\">52</span> args=<span class=\"number\">0x18</span> locals=<span class=\"number\">0x10</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    TEXT    <span class=\"string\">&quot;&quot;</span>.Callee(SB), NOSPLIT|ABIInternal, $<span class=\"number\">16</span><span class=\"number\">-24</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    SUBQ    $<span class=\"number\">16</span>, SP</span><br><span class=\"line\"><span class=\"number\">0x0004</span> <span class=\"number\">00004</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    MOVQ    BP, <span class=\"number\">8</span>(SP)</span><br><span class=\"line\"><span class=\"number\">0x0009</span> <span class=\"number\">00009</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    LEAQ    <span class=\"number\">8</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 將40(SP)處的變量~r2的值爲0，即返回值初始化爲0</span></span><br><span class=\"line\"><span class=\"number\">0x000e</span> <span class=\"number\">00014</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">3</span>)    MOVQ    $<span class=\"number\">0</span>, <span class=\"string\">&quot;&quot;</span>.~r2+<span class=\"number\">40</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將24(SP)處的變量x的值傳送到AX中</span></span><br><span class=\"line\"><span class=\"number\">0x0017</span> <span class=\"number\">00023</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    MOVQ    <span class=\"string\">&quot;&quot;</span>.x+<span class=\"number\">24</span>(SP), AX</span><br><span class=\"line\"><span class=\"comment\">// 將32(SP)處的變量y加到AX中</span></span><br><span class=\"line\"><span class=\"number\">0x001c</span> <span class=\"number\">00028</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    ADDQ    <span class=\"string\">&quot;&quot;</span>.y+<span class=\"number\">32</span>(SP), AX</span><br><span class=\"line\"><span class=\"comment\">// 將AX的值傳送到(SP)處的變量r中</span></span><br><span class=\"line\"><span class=\"number\">0x0021</span> <span class=\"number\">00033</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">4</span>)    MOVQ    AX, <span class=\"string\">&quot;&quot;</span>.r(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將AX中的值傳送到40(SP)處的變量~r2，即返回值賦值爲AX中的值</span></span><br><span class=\"line\"><span class=\"number\">0x0025</span> <span class=\"number\">00037</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    MOVQ    AX, <span class=\"string\">&quot;&quot;</span>.~r2+<span class=\"number\">40</span>(SP)</span><br><span class=\"line\"><span class=\"number\">0x002a</span> <span class=\"number\">00042</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    MOVQ    <span class=\"number\">8</span>(SP), BP</span><br><span class=\"line\"><span class=\"number\">0x002f</span> <span class=\"number\">00047</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    ADDQ    $<span class=\"number\">16</span>, SP</span><br><span class=\"line\"><span class=\"number\">0x0033</span> <span class=\"number\">00051</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">5</span>)    RET</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Go 彙編的固定開頭，Caller爲函數名，</span></span><br><span class=\"line\"><span class=\"comment\">// args 爲入參和返回值佔用的字節大小 0x0=0，</span></span><br><span class=\"line\"><span class=\"comment\">// locals 爲局部變量佔用的字節大小 0x20=32</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span>.Caller STEXT size=<span class=\"number\">71</span> args=<span class=\"number\">0x0</span> locals=<span class=\"number\">0x20</span></span><br><span class=\"line\"><span class=\"comment\">// 聲明函數Caller</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    TEXT    <span class=\"string\">&quot;&quot;</span>.Caller(SB), ABIInternal, $<span class=\"number\">32</span><span class=\"number\">-0</span></span><br><span class=\"line\"><span class=\"comment\">// 將(TLS)複製到CX寄存器，(TLS)是指向當前G(goroutine的一種數據結構)的指針</span></span><br><span class=\"line\"><span class=\"number\">0x0000</span> <span class=\"number\">00000</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    MOVQ    (TLS), CX</span><br><span class=\"line\"><span class=\"comment\">// 比較當前棧指針和CX正偏移16個字節的地址</span></span><br><span class=\"line\"><span class=\"number\">0x0009</span> <span class=\"number\">00009</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    CMPQ    SP, <span class=\"number\">16</span>(CX)</span><br><span class=\"line\"><span class=\"comment\">// 如果比較值左邊小於右邊，則跳轉到地址 64 處，即 CALL    runtime.morestack_noctxt(SB)</span></span><br><span class=\"line\"><span class=\"number\">0x000d</span> <span class=\"number\">00013</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    JLS     <span class=\"number\">64</span></span><br><span class=\"line\"><span class=\"comment\">// SP減去32，函數開始入棧</span></span><br><span class=\"line\"><span class=\"number\">0x000f</span> <span class=\"number\">00015</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    SUBQ    $<span class=\"number\">32</span>, SP</span><br><span class=\"line\"><span class=\"comment\">// 把BP中的值傳送到24(SP)處開始的內存空間，保存調用者棧幀地址到本棧。</span></span><br><span class=\"line\"><span class=\"number\">0x0013</span> <span class=\"number\">00019</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    MOVQ    BP, <span class=\"number\">24</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 將24(SP)處的地址傳送到BP，保存當前棧幀地址到BP。</span></span><br><span class=\"line\"><span class=\"number\">0x0018</span> <span class=\"number\">00024</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    LEAQ    <span class=\"number\">24</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 將數字1傳送到(SP)處開始的內存空間</span></span><br><span class=\"line\"><span class=\"number\">0x001d</span> <span class=\"number\">00029</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    MOVQ    $<span class=\"number\">1</span>, (SP)</span><br><span class=\"line\"><span class=\"comment\">// 將數字2傳送到8(SP)處開始的內存空間</span></span><br><span class=\"line\"><span class=\"number\">0x0025</span> <span class=\"number\">00037</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    MOVQ    $<span class=\"number\">2</span>, <span class=\"number\">8</span>(SP)</span><br><span class=\"line\"><span class=\"comment\">// 調用Callee函數</span></span><br><span class=\"line\"><span class=\"number\">0x002e</span> <span class=\"number\">00046</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">9</span>)    CALL    <span class=\"string\">&quot;&quot;</span>.Callee(SB)</span><br><span class=\"line\"><span class=\"comment\">// 調用Callee函數時BP寄存器的值會指向Callee的棧幀地址，因此結束後需要復位。</span></span><br><span class=\"line\"><span class=\"number\">0x0033</span> <span class=\"number\">00051</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   MOVQ    <span class=\"number\">24</span>(SP), BP</span><br><span class=\"line\"><span class=\"comment\">// 出棧</span></span><br><span class=\"line\"><span class=\"number\">0x0038</span> <span class=\"number\">00056</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   ADDQ    $<span class=\"number\">32</span>, SP</span><br><span class=\"line\"><span class=\"comment\">// 返回</span></span><br><span class=\"line\"><span class=\"number\">0x003c</span> <span class=\"number\">00060</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   RET</span><br><span class=\"line\"><span class=\"comment\">// 無操作</span></span><br><span class=\"line\"><span class=\"number\">0x003d</span> <span class=\"number\">00061</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">10</span>)   NOP</span><br><span class=\"line\"><span class=\"number\">0x003d</span> <span class=\"number\">00061</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    NOP</span><br><span class=\"line\"><span class=\"comment\">// 調用runtime.morestack_noctxt函數</span></span><br><span class=\"line\"><span class=\"number\">0x0040</span> <span class=\"number\">00064</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    CALL    runtime.morestack_noctxt(SB)</span><br><span class=\"line\"><span class=\"comment\">// 跳轉到函數聲明處</span></span><br><span class=\"line\"><span class=\"number\">0x0045</span> <span class=\"number\">00069</span> (call.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>)    JMP     <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>分析可得棧結構如下：</p>\n<p><img src=\"/2021/02/06/it/go/go-design-and-implementation-01/Untitled%203.png\" alt></p>\n<h2 id=\"1-3-參考\"><a href=\"#1-3-參考\" class=\"headerlink\" title=\"1.3 參考\"></a>1.3 參考</h2><ol>\n<li><a href=\"https://draveness.me/golang/docs/part1-prerequisite/ch01-prepare/golang-debug/\">Go 语言设计与实现：第一章 准备工作 — draveness</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html\">汇编语言入门教程 — 阮一峰的网络日志</a></li>\n<li><a href=\"https://xargin.com/plan9-assembly/\">Go 系列文章3 ：plan9 汇编入门 — 曹春晖@No Headback</a></li>\n<li><a href=\"https://www.cnblogs.com/qcrao-2018/p/10562216.html\">深入Go的底层，带你走近一群有追求的人 — Stefno@博客园</a></li>\n<li><a href=\"https://studygolang.com/articles/26380\">go plan9汇编入门 — yuchanns@Go 语言中文网</a></li>\n<li><a href=\"https://github.com/yuchanns/Atelier/blob/theme/hermit/src/_posts/golang-assembly.md\">go编译工具的使用之汇编 — yuchanns@github.com</a></li>\n<li><a href=\"https://davidwong.fr/goasm/\">Go Assembly by Example</a></li>\n<li><a href=\"https://golang.org/doc/asm\">A Quick Guide to Go’s Assembler — golang.org</a></li>\n<li><a href=\"http://doc.cat-v.org/plan_9/4th_edition/papers/asm\">A Manual for the Plan 9 assembler — Rob Pike</a></li>\n</ol>"},{"title":"十二生肖、干支紀年法與Go語言編程","p":"it/go/zodiac-ganzhi-go.md","_content":"\n如無特殊說明，本文標音採用甲子話拼音方案。甲子話系陸豐市甲子鎮通行的語言，屬閩南語潮汕話三甲片。\n\n## 十二生肖\n\n十二生肖本地讀音爲：\n\n- 鼠牛虎兔 /cu² ngu⁵ hao² tao³/\n- 龍蛇馬羊 /lêng⁵ zua⁵ bhê² ion⁵/\n- 猴雞狗豬 /gao⁵ goi¹ gao² du¹/\n\n## 干支紀年法\n\n「干」是天干，有 10：\n\n- 甲乙丙丁 /gah⁴ ig⁴ bian² dêng¹/\n- 戊己庚辛 /bhao⁷ gi² gên¹ sing¹/\n- 壬癸 /rim⁶ gui³/\n\n「支」是地支，有 12：\n\n- 子丑寅卯 /zu² tiu² ing⁵ bhao²/\n- 辰巳午未 /sing⁵ zi⁶ ngao² bhi⁷/\n- 申酉戌亥 /sing¹ iu² sug⁴ hai⁶/\n\n天干從甲開始，地支從子開始，天干地支相配形成 60 種組合，用來紀年。從甲子出發，60 年後又回到甲子，因此稱 60 年爲「一甲子」。\n\n十二地支與十二生肖相對應，因此也用生肖紀年。如甲子年，地支爲「子」，對應生肖「鼠」，因此甲子年也稱之為「鼠年」。\n\n## 問題\n\n**問題1：已知 2020 年是鼠年，請問 2021 年是什麼年？**\n\n排在鼠之後的生肖是牛，因此 2021 年是牛年。\n\n**問題2：已知 2020 年是庚子年 /gên¹ zu² ni⁵/，請問 2021 年是什麼年？**\n\n庚之後爲辛，子之後爲丑，因此 2021 年是辛丑年 /sing¹ tiu² ni⁵/。\n\n**問題3：已知 1024 年是甲子年，問最近過去的甲子年和將要到來的甲子年是公元多少年？**\n\n<!-- more -->\n\n使用 Go 語言解決，編碼如下：\n\n```go\nfunc f1() {\n\tjz := 1024\n\tfor {\n\t\tjz = jz + 60\n\t\tif jz > 2020 {\n\t\t\tprintln(jz-60, jz)\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n執行後輸出結果爲：\n\n```go\n1984 2044\n```\n\n因此，最近過去的甲子年是 1984 年，將要到來的甲子年是 2044 年。\n\n**問題4：已知干支紀年法中有 10 天干，12 地支，有 60 種合法組合，求所有非法的組合，並探討其中規律。**\n\n先說結論：\n\n1. 所有非法的組合爲：\n甲丑 甲卯 甲巳 甲未 甲酉 甲亥 乙子 乙寅 乙辰 乙午 乙申 乙戌 丙丑 丙卯 丙巳 丙未 丙酉 丙亥 丁子 丁寅 丁辰 丁午 丁申 丁戌 戊丑 戊卯 戊巳 戊未 戊酉 戊亥 己子 己寅 己辰 己午 辛寅 辛辰 辛午 辛申 辛戌 壬丑 壬卯 壬巳 壬未 壬酉 壬亥 癸子 癸寅 癸辰 癸午 癸申 癸戌\n2. 其中的規律是：使用 1～10 給天干編號，1～12給地支編號，分別從天干和地支的編號中任取一個，如果其和爲偶數則是合法的組合，否則就是非法的組合。例如「甲丑」中「甲」的編號是 1，「丑」的編號是 2，1+2=3 爲奇數，是非法的組合。\n\n試著使用編程來解決此問題。\n\n首先，將天干和地址的字符串定義如下：\n\n```go\nconst gs = \"甲乙丙丁戊己庚辛壬癸\"\nconst zs = \"子丑寅卯辰巳午未申酉戌亥\"\n```\n\n第一種思路是：先求出所有合法的組合，然後窮盡所有組合，如組合不在合法組合中即是非法組合，輸出即可，編程到函數 f1 如下：\n\n```go\nfunc f1() {\n\t// 天干數組\n\tgarr := []rune(gs)\n\t// 地支數組\n\tzarr := []rune(zs)\n\t// 保存合法的干支組合的Map\n\t// Key爲干支，Value爲天干索引與地支索引之和\n\ttdmap := make(map[string]int)\n\n\t// 將干支組合保存到Map中，直到出現第一個重複項就停止遍歷\n\tfor i, j := 0, 0; i < len(garr) && j < len(zarr); i, j = (i+1)%len(garr), (j+1)%len(zarr) {\n\t\tk := string(garr[i]) + string(zarr[j])\n\t\tif _, ok := tdmap[k]; ok {\n\t\t\tbreak\n\t\t}\n\t\ttdmap[k] = i + j\n\t}\n\n\t// 輸出所有合法的組合\n\tprintln(\"\\n所有合法的組合：\")\n\n\tfor k, v := range tdmap {\n\t\tfmt.Printf(\"%s:%d \", k, v)\n\t}\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tfor j := 0; j < len(zarr); j++ {\n\t\t\tk := string(garr[i]) + string(zarr[j])\n\t\t\tif _, ok := tdmap[k]; !ok {\n\t\t\t\tfmt.Printf(\"%s:%d \", k, i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果爲：\n\n```go\n所有合法的組合：\n庚午:12 己卯:8 甲申:8 己酉:14 丙寅:4 丁卯:6 己巳:10 癸酉:18 戊寅:6 戊戌:14 癸巳:14 癸卯:12 甲辰:4 乙卯:4 辛巳:12 丙戌:12 壬辰:12 乙未:8 辛亥:18 戊午:10 丁巳:8 己未:12 辛 壬申:16 甲午:6 庚子:6 辛丑:8 庚戌:16 丙辰:6 戊辰:8 癸未:16 甲子:0 丙申:10 丁未:10 壬子:8 庚辰:10 甲戌:10 丁丑:4 壬午:14 丙子:2 庚寅:8 壬寅:10 戊申:12 甲寅:2 乙丑:2 辛未:14 丁亥:14 戊子:4 己亥:16 丙午:8 庚申:14 癸亥:20 丁酉:12 \n所有非法的組合：\n甲丑:1 甲卯:3 甲巳:5 甲未:7 甲酉:9 甲亥:11 乙子:1 乙寅:3 乙辰:5 乙午:7 乙申:9 乙戌:11 丙丑:3 丙卯:5 丙巳:7 丙未:9 丙酉:11 丙亥:13 丁子:3 丁寅:5 丁辰:7 丁午:9 丁申:11 丁 己辰:9 己午:11 己申:13 己戌:15 庚丑:7 庚卯:9 庚巳:11 庚未:13 庚酉:15 庚亥:17 辛子:7 辛寅:9 辛辰:11 辛午:13 辛申:15 辛戌:17 壬丑:9 壬卯:11 壬巳:13 壬未:15 壬酉:17 壬亥:19 癸子:9 癸寅:11 癸辰:13 癸午:15 癸申:17 癸戌:19 \n```\n\n嗯，符合預期，合法的組合和非法的組合各佔 60 個。\n\n觀察發現，所有合法的組合的Value值都是偶數，所有非法的組合的Value值都是奇數。\n\n因此有第二種思路求出非法組合：\n\n```go\nfunc f2() {\n\tgarr := []rune(gs)\n\tzarr := []rune(zs)\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tfor j := 0; j < len(zarr); j++ {\n\t\t\tif (i+j)%2 != 0 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果：\n\n```go\n所有非法的組合：\n甲丑:1 甲卯:3 甲巳:5 甲未:7 甲酉:9 甲亥:11 乙子:1 乙寅:3 乙辰:5 乙午:7 乙申:9 乙戌:11 丙丑:3 丙卯:5 丙巳:7 丙未:9 丙酉:11 丙亥:13 丁子:3 丁寅:5 丁辰:7 丁午:9 丁申:11 丁 己辰:9 己午:11 己申:13 己戌:15 庚丑:7 庚卯:9 庚巳:11 庚未:13 庚酉:15 庚亥:17 辛子:7 辛寅:9 辛辰:11 辛午:13 辛申:15 辛戌:17 壬丑:9 壬卯:11 壬巳:13 壬未:15 壬酉:17 壬亥:19 癸子:9 癸寅:11 癸辰:13 癸午:15 癸申:17 癸戌:19\n```\n\n很棒，跟思路一的非法組合一致。\n\n學過小學數學的都知道，奇數+偶數=奇數，奇數+奇數=偶數，偶數+偶數=偶數。於是有了第三種思路，只要保證 i 和 j 的奇偶性不同即可保證 i 和 j 的組合爲非法組合。代碼如下：\n\n```go\nfunc f3() {\n\tgarr := []rune(gs)\n\tzarr := []rune(zs)\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tif i%2 == 0 {\n\t\t\tfor j := 1; j < len(zarr); j = j + 2 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t} else {\n\t\t\tfor j := 0; j < len(zarr); j = j + 2 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果同思路二的一致。\n\n完結","source":"_posts/it/go/zodiac-ganzhi-go.md","raw":"---\ntitle: 十二生肖、干支紀年法與Go語言編程\np: it/go/zodiac-ganzhi-go.md\ntags:\n- 甲子話\n- 十二生肖\n- 干支紀年法\n- Go\n---\n\n如無特殊說明，本文標音採用甲子話拼音方案。甲子話系陸豐市甲子鎮通行的語言，屬閩南語潮汕話三甲片。\n\n## 十二生肖\n\n十二生肖本地讀音爲：\n\n- 鼠牛虎兔 /cu² ngu⁵ hao² tao³/\n- 龍蛇馬羊 /lêng⁵ zua⁵ bhê² ion⁵/\n- 猴雞狗豬 /gao⁵ goi¹ gao² du¹/\n\n## 干支紀年法\n\n「干」是天干，有 10：\n\n- 甲乙丙丁 /gah⁴ ig⁴ bian² dêng¹/\n- 戊己庚辛 /bhao⁷ gi² gên¹ sing¹/\n- 壬癸 /rim⁶ gui³/\n\n「支」是地支，有 12：\n\n- 子丑寅卯 /zu² tiu² ing⁵ bhao²/\n- 辰巳午未 /sing⁵ zi⁶ ngao² bhi⁷/\n- 申酉戌亥 /sing¹ iu² sug⁴ hai⁶/\n\n天干從甲開始，地支從子開始，天干地支相配形成 60 種組合，用來紀年。從甲子出發，60 年後又回到甲子，因此稱 60 年爲「一甲子」。\n\n十二地支與十二生肖相對應，因此也用生肖紀年。如甲子年，地支爲「子」，對應生肖「鼠」，因此甲子年也稱之為「鼠年」。\n\n## 問題\n\n**問題1：已知 2020 年是鼠年，請問 2021 年是什麼年？**\n\n排在鼠之後的生肖是牛，因此 2021 年是牛年。\n\n**問題2：已知 2020 年是庚子年 /gên¹ zu² ni⁵/，請問 2021 年是什麼年？**\n\n庚之後爲辛，子之後爲丑，因此 2021 年是辛丑年 /sing¹ tiu² ni⁵/。\n\n**問題3：已知 1024 年是甲子年，問最近過去的甲子年和將要到來的甲子年是公元多少年？**\n\n<!-- more -->\n\n使用 Go 語言解決，編碼如下：\n\n```go\nfunc f1() {\n\tjz := 1024\n\tfor {\n\t\tjz = jz + 60\n\t\tif jz > 2020 {\n\t\t\tprintln(jz-60, jz)\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n執行後輸出結果爲：\n\n```go\n1984 2044\n```\n\n因此，最近過去的甲子年是 1984 年，將要到來的甲子年是 2044 年。\n\n**問題4：已知干支紀年法中有 10 天干，12 地支，有 60 種合法組合，求所有非法的組合，並探討其中規律。**\n\n先說結論：\n\n1. 所有非法的組合爲：\n甲丑 甲卯 甲巳 甲未 甲酉 甲亥 乙子 乙寅 乙辰 乙午 乙申 乙戌 丙丑 丙卯 丙巳 丙未 丙酉 丙亥 丁子 丁寅 丁辰 丁午 丁申 丁戌 戊丑 戊卯 戊巳 戊未 戊酉 戊亥 己子 己寅 己辰 己午 辛寅 辛辰 辛午 辛申 辛戌 壬丑 壬卯 壬巳 壬未 壬酉 壬亥 癸子 癸寅 癸辰 癸午 癸申 癸戌\n2. 其中的規律是：使用 1～10 給天干編號，1～12給地支編號，分別從天干和地支的編號中任取一個，如果其和爲偶數則是合法的組合，否則就是非法的組合。例如「甲丑」中「甲」的編號是 1，「丑」的編號是 2，1+2=3 爲奇數，是非法的組合。\n\n試著使用編程來解決此問題。\n\n首先，將天干和地址的字符串定義如下：\n\n```go\nconst gs = \"甲乙丙丁戊己庚辛壬癸\"\nconst zs = \"子丑寅卯辰巳午未申酉戌亥\"\n```\n\n第一種思路是：先求出所有合法的組合，然後窮盡所有組合，如組合不在合法組合中即是非法組合，輸出即可，編程到函數 f1 如下：\n\n```go\nfunc f1() {\n\t// 天干數組\n\tgarr := []rune(gs)\n\t// 地支數組\n\tzarr := []rune(zs)\n\t// 保存合法的干支組合的Map\n\t// Key爲干支，Value爲天干索引與地支索引之和\n\ttdmap := make(map[string]int)\n\n\t// 將干支組合保存到Map中，直到出現第一個重複項就停止遍歷\n\tfor i, j := 0, 0; i < len(garr) && j < len(zarr); i, j = (i+1)%len(garr), (j+1)%len(zarr) {\n\t\tk := string(garr[i]) + string(zarr[j])\n\t\tif _, ok := tdmap[k]; ok {\n\t\t\tbreak\n\t\t}\n\t\ttdmap[k] = i + j\n\t}\n\n\t// 輸出所有合法的組合\n\tprintln(\"\\n所有合法的組合：\")\n\n\tfor k, v := range tdmap {\n\t\tfmt.Printf(\"%s:%d \", k, v)\n\t}\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tfor j := 0; j < len(zarr); j++ {\n\t\t\tk := string(garr[i]) + string(zarr[j])\n\t\t\tif _, ok := tdmap[k]; !ok {\n\t\t\t\tfmt.Printf(\"%s:%d \", k, i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果爲：\n\n```go\n所有合法的組合：\n庚午:12 己卯:8 甲申:8 己酉:14 丙寅:4 丁卯:6 己巳:10 癸酉:18 戊寅:6 戊戌:14 癸巳:14 癸卯:12 甲辰:4 乙卯:4 辛巳:12 丙戌:12 壬辰:12 乙未:8 辛亥:18 戊午:10 丁巳:8 己未:12 辛 壬申:16 甲午:6 庚子:6 辛丑:8 庚戌:16 丙辰:6 戊辰:8 癸未:16 甲子:0 丙申:10 丁未:10 壬子:8 庚辰:10 甲戌:10 丁丑:4 壬午:14 丙子:2 庚寅:8 壬寅:10 戊申:12 甲寅:2 乙丑:2 辛未:14 丁亥:14 戊子:4 己亥:16 丙午:8 庚申:14 癸亥:20 丁酉:12 \n所有非法的組合：\n甲丑:1 甲卯:3 甲巳:5 甲未:7 甲酉:9 甲亥:11 乙子:1 乙寅:3 乙辰:5 乙午:7 乙申:9 乙戌:11 丙丑:3 丙卯:5 丙巳:7 丙未:9 丙酉:11 丙亥:13 丁子:3 丁寅:5 丁辰:7 丁午:9 丁申:11 丁 己辰:9 己午:11 己申:13 己戌:15 庚丑:7 庚卯:9 庚巳:11 庚未:13 庚酉:15 庚亥:17 辛子:7 辛寅:9 辛辰:11 辛午:13 辛申:15 辛戌:17 壬丑:9 壬卯:11 壬巳:13 壬未:15 壬酉:17 壬亥:19 癸子:9 癸寅:11 癸辰:13 癸午:15 癸申:17 癸戌:19 \n```\n\n嗯，符合預期，合法的組合和非法的組合各佔 60 個。\n\n觀察發現，所有合法的組合的Value值都是偶數，所有非法的組合的Value值都是奇數。\n\n因此有第二種思路求出非法組合：\n\n```go\nfunc f2() {\n\tgarr := []rune(gs)\n\tzarr := []rune(zs)\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tfor j := 0; j < len(zarr); j++ {\n\t\t\tif (i+j)%2 != 0 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果：\n\n```go\n所有非法的組合：\n甲丑:1 甲卯:3 甲巳:5 甲未:7 甲酉:9 甲亥:11 乙子:1 乙寅:3 乙辰:5 乙午:7 乙申:9 乙戌:11 丙丑:3 丙卯:5 丙巳:7 丙未:9 丙酉:11 丙亥:13 丁子:3 丁寅:5 丁辰:7 丁午:9 丁申:11 丁 己辰:9 己午:11 己申:13 己戌:15 庚丑:7 庚卯:9 庚巳:11 庚未:13 庚酉:15 庚亥:17 辛子:7 辛寅:9 辛辰:11 辛午:13 辛申:15 辛戌:17 壬丑:9 壬卯:11 壬巳:13 壬未:15 壬酉:17 壬亥:19 癸子:9 癸寅:11 癸辰:13 癸午:15 癸申:17 癸戌:19\n```\n\n很棒，跟思路一的非法組合一致。\n\n學過小學數學的都知道，奇數+偶數=奇數，奇數+奇數=偶數，偶數+偶數=偶數。於是有了第三種思路，只要保證 i 和 j 的奇偶性不同即可保證 i 和 j 的組合爲非法組合。代碼如下：\n\n```go\nfunc f3() {\n\tgarr := []rune(gs)\n\tzarr := []rune(zs)\n\n\t// 輸出所有非法的組合\n\tprintln(\"\\n所有非法的組合：\")\n\tfor i := 0; i < len(garr); i++ {\n\t\tif i%2 == 0 {\n\t\t\tfor j := 1; j < len(zarr); j = j + 2 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t} else {\n\t\t\tfor j := 0; j < len(zarr); j = j + 2 {\n\t\t\t\tfmt.Printf(\"%s:%d \", string(garr[i])+string(zarr[j]), i+j)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n輸出結果同思路二的一致。\n\n完結","slug":"it/go/zodiac-ganzhi-go","published":1,"date":"2021-02-05T16:21:16.558Z","updated":"2021-02-05T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wob00089a9k66j2biw3","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>如無特殊說明，本文標音採用甲子話拼音方案。甲子話系陸豐市甲子鎮通行的語言，屬閩南語潮汕話三甲片。</p>\n<h2 id=\"十二生肖\"><a href=\"#十二生肖\" class=\"headerlink\" title=\"十二生肖\"></a>十二生肖</h2><p>十二生肖本地讀音爲：</p>\n<ul>\n<li>鼠牛虎兔 /cu² ngu⁵ hao² tao³/</li>\n<li>龍蛇馬羊 /lêng⁵ zua⁵ bhê² ion⁵/</li>\n<li>猴雞狗豬 /gao⁵ goi¹ gao² du¹/</li>\n</ul>\n<h2 id=\"干支紀年法\"><a href=\"#干支紀年法\" class=\"headerlink\" title=\"干支紀年法\"></a>干支紀年法</h2><p>「干」是天干，有 10：</p>\n<ul>\n<li>甲乙丙丁 /gah⁴ ig⁴ bian² dêng¹/</li>\n<li>戊己庚辛 /bhao⁷ gi² gên¹ sing¹/</li>\n<li>壬癸 /rim⁶ gui³/</li>\n</ul>\n<p>「支」是地支，有 12：</p>\n<ul>\n<li>子丑寅卯 /zu² tiu² ing⁵ bhao²/</li>\n<li>辰巳午未 /sing⁵ zi⁶ ngao² bhi⁷/</li>\n<li>申酉戌亥 /sing¹ iu² sug⁴ hai⁶/</li>\n</ul>\n<p>天干從甲開始，地支從子開始，天干地支相配形成 60 種組合，用來紀年。從甲子出發，60 年後又回到甲子，因此稱 60 年爲「一甲子」。</p>\n<p>十二地支與十二生肖相對應，因此也用生肖紀年。如甲子年，地支爲「子」，對應生肖「鼠」，因此甲子年也稱之為「鼠年」。</p>\n<h2 id=\"問題\"><a href=\"#問題\" class=\"headerlink\" title=\"問題\"></a>問題</h2><p><strong>問題1：已知 2020 年是鼠年，請問 2021 年是什麼年？</strong></p>\n<p>排在鼠之後的生肖是牛，因此 2021 年是牛年。</p>\n<p><strong>問題2：已知 2020 年是庚子年 /gên¹ zu² ni⁵/，請問 2021 年是什麼年？</strong></p>\n<p>庚之後爲辛，子之後爲丑，因此 2021 年是辛丑年 /sing¹ tiu² ni⁵/。</p>\n<p><strong>問題3：已知 1024 年是甲子年，問最近過去的甲子年和將要到來的甲子年是公元多少年？</strong></p>\n<span id=\"more\"></span>\n\n<p>使用 Go 語言解決，編碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  jz := <span class=\"number\">1024</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    jz = jz + <span class=\"number\">60</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> jz &gt; <span class=\"number\">2020</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">println</span>(jz<span class=\"number\">-60</span>, jz)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行後輸出結果爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1984</span> <span class=\"number\">2044</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，最近過去的甲子年是 1984 年，將要到來的甲子年是 2044 年。</p>\n<p><strong>問題4：已知干支紀年法中有 10 天干，12 地支，有 60 種合法組合，求所有非法的組合，並探討其中規律。</strong></p>\n<p>先說結論：</p>\n<ol>\n<li>所有非法的組合爲：<br>甲丑 甲卯 甲巳 甲未 甲酉 甲亥 乙子 乙寅 乙辰 乙午 乙申 乙戌 丙丑 丙卯 丙巳 丙未 丙酉 丙亥 丁子 丁寅 丁辰 丁午 丁申 丁戌 戊丑 戊卯 戊巳 戊未 戊酉 戊亥 己子 己寅 己辰 己午 辛寅 辛辰 辛午 辛申 辛戌 壬丑 壬卯 壬巳 壬未 壬酉 壬亥 癸子 癸寅 癸辰 癸午 癸申 癸戌</li>\n<li>其中的規律是：使用 1～10 給天干編號，1～12給地支編號，分別從天干和地支的編號中任取一個，如果其和爲偶數則是合法的組合，否則就是非法的組合。例如「甲丑」中「甲」的編號是 1，「丑」的編號是 2，1+2=3 爲奇數，是非法的組合。</li>\n</ol>\n<p>試著使用編程來解決此問題。</p>\n<p>首先，將天干和地址的字符串定義如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gs = <span class=\"string\">&quot;甲乙丙丁戊己庚辛壬癸&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> zs = <span class=\"string\">&quot;子丑寅卯辰巳午未申酉戌亥&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>第一種思路是：先求出所有合法的組合，然後窮盡所有組合，如組合不在合法組合中即是非法組合，輸出即可，編程到函數 f1 如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 天干數組</span></span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  <span class=\"comment\">// 地支數組</span></span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\">  <span class=\"comment\">// 保存合法的干支組合的Map</span></span><br><span class=\"line\">  <span class=\"comment\">// Key爲干支，Value爲天干索引與地支索引之和</span></span><br><span class=\"line\">  tdmap := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 將干支組合保存到Map中，直到出現第一個重複項就停止遍歷</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i, j := <span class=\"number\">0</span>, <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr) &amp;&amp; j &lt; <span class=\"built_in\">len</span>(zarr); i, j = (i+<span class=\"number\">1</span>)%<span class=\"built_in\">len</span>(garr), (j+<span class=\"number\">1</span>)%<span class=\"built_in\">len</span>(zarr) &#123;</span><br><span class=\"line\">    k := <span class=\"keyword\">string</span>(garr[i]) + <span class=\"keyword\">string</span>(zarr[j])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, ok := tdmap[k]; ok &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tdmap[k] = i + j</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有合法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有合法的組合：&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> tdmap &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, k, v)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j++ &#123;</span><br><span class=\"line\">      k := <span class=\"keyword\">string</span>(garr[i]) + <span class=\"keyword\">string</span>(zarr[j])</span><br><span class=\"line\">      <span class=\"keyword\">if</span> _, ok := tdmap[k]; !ok &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, k, i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">所有合法的組合：</span><br><span class=\"line\">庚午:<span class=\"number\">12</span> 己卯:<span class=\"number\">8</span> 甲申:<span class=\"number\">8</span> 己酉:<span class=\"number\">14</span> 丙寅:<span class=\"number\">4</span> 丁卯:<span class=\"number\">6</span> 己巳:<span class=\"number\">10</span> 癸酉:<span class=\"number\">18</span> 戊寅:<span class=\"number\">6</span> 戊戌:<span class=\"number\">14</span> 癸巳:<span class=\"number\">14</span> 癸卯:<span class=\"number\">12</span> 甲辰:<span class=\"number\">4</span> 乙卯:<span class=\"number\">4</span> 辛巳:<span class=\"number\">12</span> 丙戌:<span class=\"number\">12</span> 壬辰:<span class=\"number\">12</span> 乙未:<span class=\"number\">8</span> 辛亥:<span class=\"number\">18</span> 戊午:<span class=\"number\">10</span> 丁巳:<span class=\"number\">8</span> 己未:<span class=\"number\">12</span> 辛 壬申:<span class=\"number\">16</span> 甲午:<span class=\"number\">6</span> 庚子:<span class=\"number\">6</span> 辛丑:<span class=\"number\">8</span> 庚戌:<span class=\"number\">16</span> 丙辰:<span class=\"number\">6</span> 戊辰:<span class=\"number\">8</span> 癸未:<span class=\"number\">16</span> 甲子:<span class=\"number\">0</span> 丙申:<span class=\"number\">10</span> 丁未:<span class=\"number\">10</span> 壬子:<span class=\"number\">8</span> 庚辰:<span class=\"number\">10</span> 甲戌:<span class=\"number\">10</span> 丁丑:<span class=\"number\">4</span> 壬午:<span class=\"number\">14</span> 丙子:<span class=\"number\">2</span> 庚寅:<span class=\"number\">8</span> 壬寅:<span class=\"number\">10</span> 戊申:<span class=\"number\">12</span> 甲寅:<span class=\"number\">2</span> 乙丑:<span class=\"number\">2</span> 辛未:<span class=\"number\">14</span> 丁亥:<span class=\"number\">14</span> 戊子:<span class=\"number\">4</span> 己亥:<span class=\"number\">16</span> 丙午:<span class=\"number\">8</span> 庚申:<span class=\"number\">14</span> 癸亥:<span class=\"number\">20</span> 丁酉:<span class=\"number\">12</span> </span><br><span class=\"line\">所有非法的組合：</span><br><span class=\"line\">甲丑:<span class=\"number\">1</span> 甲卯:<span class=\"number\">3</span> 甲巳:<span class=\"number\">5</span> 甲未:<span class=\"number\">7</span> 甲酉:<span class=\"number\">9</span> 甲亥:<span class=\"number\">11</span> 乙子:<span class=\"number\">1</span> 乙寅:<span class=\"number\">3</span> 乙辰:<span class=\"number\">5</span> 乙午:<span class=\"number\">7</span> 乙申:<span class=\"number\">9</span> 乙戌:<span class=\"number\">11</span> 丙丑:<span class=\"number\">3</span> 丙卯:<span class=\"number\">5</span> 丙巳:<span class=\"number\">7</span> 丙未:<span class=\"number\">9</span> 丙酉:<span class=\"number\">11</span> 丙亥:<span class=\"number\">13</span> 丁子:<span class=\"number\">3</span> 丁寅:<span class=\"number\">5</span> 丁辰:<span class=\"number\">7</span> 丁午:<span class=\"number\">9</span> 丁申:<span class=\"number\">11</span> 丁 己辰:<span class=\"number\">9</span> 己午:<span class=\"number\">11</span> 己申:<span class=\"number\">13</span> 己戌:<span class=\"number\">15</span> 庚丑:<span class=\"number\">7</span> 庚卯:<span class=\"number\">9</span> 庚巳:<span class=\"number\">11</span> 庚未:<span class=\"number\">13</span> 庚酉:<span class=\"number\">15</span> 庚亥:<span class=\"number\">17</span> 辛子:<span class=\"number\">7</span> 辛寅:<span class=\"number\">9</span> 辛辰:<span class=\"number\">11</span> 辛午:<span class=\"number\">13</span> 辛申:<span class=\"number\">15</span> 辛戌:<span class=\"number\">17</span> 壬丑:<span class=\"number\">9</span> 壬卯:<span class=\"number\">11</span> 壬巳:<span class=\"number\">13</span> 壬未:<span class=\"number\">15</span> 壬酉:<span class=\"number\">17</span> 壬亥:<span class=\"number\">19</span> 癸子:<span class=\"number\">9</span> 癸寅:<span class=\"number\">11</span> 癸辰:<span class=\"number\">13</span> 癸午:<span class=\"number\">15</span> 癸申:<span class=\"number\">17</span> 癸戌:<span class=\"number\">19</span> </span><br></pre></td></tr></table></figure>\n\n<p>嗯，符合預期，合法的組合和非法的組合各佔 60 個。</p>\n<p>觀察發現，所有合法的組合的Value值都是偶數，所有非法的組合的Value值都是奇數。</p>\n<p>因此有第二種思路求出非法組合：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j++ &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i+j)%<span class=\"number\">2</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">所有非法的組合：</span><br><span class=\"line\">甲丑:<span class=\"number\">1</span> 甲卯:<span class=\"number\">3</span> 甲巳:<span class=\"number\">5</span> 甲未:<span class=\"number\">7</span> 甲酉:<span class=\"number\">9</span> 甲亥:<span class=\"number\">11</span> 乙子:<span class=\"number\">1</span> 乙寅:<span class=\"number\">3</span> 乙辰:<span class=\"number\">5</span> 乙午:<span class=\"number\">7</span> 乙申:<span class=\"number\">9</span> 乙戌:<span class=\"number\">11</span> 丙丑:<span class=\"number\">3</span> 丙卯:<span class=\"number\">5</span> 丙巳:<span class=\"number\">7</span> 丙未:<span class=\"number\">9</span> 丙酉:<span class=\"number\">11</span> 丙亥:<span class=\"number\">13</span> 丁子:<span class=\"number\">3</span> 丁寅:<span class=\"number\">5</span> 丁辰:<span class=\"number\">7</span> 丁午:<span class=\"number\">9</span> 丁申:<span class=\"number\">11</span> 丁 己辰:<span class=\"number\">9</span> 己午:<span class=\"number\">11</span> 己申:<span class=\"number\">13</span> 己戌:<span class=\"number\">15</span> 庚丑:<span class=\"number\">7</span> 庚卯:<span class=\"number\">9</span> 庚巳:<span class=\"number\">11</span> 庚未:<span class=\"number\">13</span> 庚酉:<span class=\"number\">15</span> 庚亥:<span class=\"number\">17</span> 辛子:<span class=\"number\">7</span> 辛寅:<span class=\"number\">9</span> 辛辰:<span class=\"number\">11</span> 辛午:<span class=\"number\">13</span> 辛申:<span class=\"number\">15</span> 辛戌:<span class=\"number\">17</span> 壬丑:<span class=\"number\">9</span> 壬卯:<span class=\"number\">11</span> 壬巳:<span class=\"number\">13</span> 壬未:<span class=\"number\">15</span> 壬酉:<span class=\"number\">17</span> 壬亥:<span class=\"number\">19</span> 癸子:<span class=\"number\">9</span> 癸寅:<span class=\"number\">11</span> 癸辰:<span class=\"number\">13</span> 癸午:<span class=\"number\">15</span> 癸申:<span class=\"number\">17</span> 癸戌:<span class=\"number\">19</span></span><br></pre></td></tr></table></figure>\n\n<p>很棒，跟思路一的非法組合一致。</p>\n<p>學過小學數學的都知道，奇數+偶數=奇數，奇數+奇數=偶數，偶數+偶數=偶數。於是有了第三種思路，只要保證 i 和 j 的奇偶性不同即可保證 i 和 j 的組合爲非法組合。代碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> j := <span class=\"number\">1</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j = j + <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j = j + <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果同思路二的一致。</p>\n<p>完結</p>\n","site":{"data":{}},"excerpt":"<p>如無特殊說明，本文標音採用甲子話拼音方案。甲子話系陸豐市甲子鎮通行的語言，屬閩南語潮汕話三甲片。</p>\n<h2 id=\"十二生肖\"><a href=\"#十二生肖\" class=\"headerlink\" title=\"十二生肖\"></a>十二生肖</h2><p>十二生肖本地讀音爲：</p>\n<ul>\n<li>鼠牛虎兔 /cu² ngu⁵ hao² tao³/</li>\n<li>龍蛇馬羊 /lêng⁵ zua⁵ bhê² ion⁵/</li>\n<li>猴雞狗豬 /gao⁵ goi¹ gao² du¹/</li>\n</ul>\n<h2 id=\"干支紀年法\"><a href=\"#干支紀年法\" class=\"headerlink\" title=\"干支紀年法\"></a>干支紀年法</h2><p>「干」是天干，有 10：</p>\n<ul>\n<li>甲乙丙丁 /gah⁴ ig⁴ bian² dêng¹/</li>\n<li>戊己庚辛 /bhao⁷ gi² gên¹ sing¹/</li>\n<li>壬癸 /rim⁶ gui³/</li>\n</ul>\n<p>「支」是地支，有 12：</p>\n<ul>\n<li>子丑寅卯 /zu² tiu² ing⁵ bhao²/</li>\n<li>辰巳午未 /sing⁵ zi⁶ ngao² bhi⁷/</li>\n<li>申酉戌亥 /sing¹ iu² sug⁴ hai⁶/</li>\n</ul>\n<p>天干從甲開始，地支從子開始，天干地支相配形成 60 種組合，用來紀年。從甲子出發，60 年後又回到甲子，因此稱 60 年爲「一甲子」。</p>\n<p>十二地支與十二生肖相對應，因此也用生肖紀年。如甲子年，地支爲「子」，對應生肖「鼠」，因此甲子年也稱之為「鼠年」。</p>\n<h2 id=\"問題\"><a href=\"#問題\" class=\"headerlink\" title=\"問題\"></a>問題</h2><p><strong>問題1：已知 2020 年是鼠年，請問 2021 年是什麼年？</strong></p>\n<p>排在鼠之後的生肖是牛，因此 2021 年是牛年。</p>\n<p><strong>問題2：已知 2020 年是庚子年 /gên¹ zu² ni⁵/，請問 2021 年是什麼年？</strong></p>\n<p>庚之後爲辛，子之後爲丑，因此 2021 年是辛丑年 /sing¹ tiu² ni⁵/。</p>\n<p><strong>問題3：已知 1024 年是甲子年，問最近過去的甲子年和將要到來的甲子年是公元多少年？</strong></p>","more":"<p>使用 Go 語言解決，編碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  jz := <span class=\"number\">1024</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    jz = jz + <span class=\"number\">60</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> jz &gt; <span class=\"number\">2020</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">println</span>(jz<span class=\"number\">-60</span>, jz)</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行後輸出結果爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1984</span> <span class=\"number\">2044</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，最近過去的甲子年是 1984 年，將要到來的甲子年是 2044 年。</p>\n<p><strong>問題4：已知干支紀年法中有 10 天干，12 地支，有 60 種合法組合，求所有非法的組合，並探討其中規律。</strong></p>\n<p>先說結論：</p>\n<ol>\n<li>所有非法的組合爲：<br>甲丑 甲卯 甲巳 甲未 甲酉 甲亥 乙子 乙寅 乙辰 乙午 乙申 乙戌 丙丑 丙卯 丙巳 丙未 丙酉 丙亥 丁子 丁寅 丁辰 丁午 丁申 丁戌 戊丑 戊卯 戊巳 戊未 戊酉 戊亥 己子 己寅 己辰 己午 辛寅 辛辰 辛午 辛申 辛戌 壬丑 壬卯 壬巳 壬未 壬酉 壬亥 癸子 癸寅 癸辰 癸午 癸申 癸戌</li>\n<li>其中的規律是：使用 1～10 給天干編號，1～12給地支編號，分別從天干和地支的編號中任取一個，如果其和爲偶數則是合法的組合，否則就是非法的組合。例如「甲丑」中「甲」的編號是 1，「丑」的編號是 2，1+2=3 爲奇數，是非法的組合。</li>\n</ol>\n<p>試著使用編程來解決此問題。</p>\n<p>首先，將天干和地址的字符串定義如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gs = <span class=\"string\">&quot;甲乙丙丁戊己庚辛壬癸&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> zs = <span class=\"string\">&quot;子丑寅卯辰巳午未申酉戌亥&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>第一種思路是：先求出所有合法的組合，然後窮盡所有組合，如組合不在合法組合中即是非法組合，輸出即可，編程到函數 f1 如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 天干數組</span></span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  <span class=\"comment\">// 地支數組</span></span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\">  <span class=\"comment\">// 保存合法的干支組合的Map</span></span><br><span class=\"line\">  <span class=\"comment\">// Key爲干支，Value爲天干索引與地支索引之和</span></span><br><span class=\"line\">  tdmap := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 將干支組合保存到Map中，直到出現第一個重複項就停止遍歷</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i, j := <span class=\"number\">0</span>, <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr) &amp;&amp; j &lt; <span class=\"built_in\">len</span>(zarr); i, j = (i+<span class=\"number\">1</span>)%<span class=\"built_in\">len</span>(garr), (j+<span class=\"number\">1</span>)%<span class=\"built_in\">len</span>(zarr) &#123;</span><br><span class=\"line\">    k := <span class=\"keyword\">string</span>(garr[i]) + <span class=\"keyword\">string</span>(zarr[j])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, ok := tdmap[k]; ok &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tdmap[k] = i + j</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有合法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有合法的組合：&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> tdmap &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, k, v)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j++ &#123;</span><br><span class=\"line\">      k := <span class=\"keyword\">string</span>(garr[i]) + <span class=\"keyword\">string</span>(zarr[j])</span><br><span class=\"line\">      <span class=\"keyword\">if</span> _, ok := tdmap[k]; !ok &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, k, i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果爲：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">所有合法的組合：</span><br><span class=\"line\">庚午:<span class=\"number\">12</span> 己卯:<span class=\"number\">8</span> 甲申:<span class=\"number\">8</span> 己酉:<span class=\"number\">14</span> 丙寅:<span class=\"number\">4</span> 丁卯:<span class=\"number\">6</span> 己巳:<span class=\"number\">10</span> 癸酉:<span class=\"number\">18</span> 戊寅:<span class=\"number\">6</span> 戊戌:<span class=\"number\">14</span> 癸巳:<span class=\"number\">14</span> 癸卯:<span class=\"number\">12</span> 甲辰:<span class=\"number\">4</span> 乙卯:<span class=\"number\">4</span> 辛巳:<span class=\"number\">12</span> 丙戌:<span class=\"number\">12</span> 壬辰:<span class=\"number\">12</span> 乙未:<span class=\"number\">8</span> 辛亥:<span class=\"number\">18</span> 戊午:<span class=\"number\">10</span> 丁巳:<span class=\"number\">8</span> 己未:<span class=\"number\">12</span> 辛 壬申:<span class=\"number\">16</span> 甲午:<span class=\"number\">6</span> 庚子:<span class=\"number\">6</span> 辛丑:<span class=\"number\">8</span> 庚戌:<span class=\"number\">16</span> 丙辰:<span class=\"number\">6</span> 戊辰:<span class=\"number\">8</span> 癸未:<span class=\"number\">16</span> 甲子:<span class=\"number\">0</span> 丙申:<span class=\"number\">10</span> 丁未:<span class=\"number\">10</span> 壬子:<span class=\"number\">8</span> 庚辰:<span class=\"number\">10</span> 甲戌:<span class=\"number\">10</span> 丁丑:<span class=\"number\">4</span> 壬午:<span class=\"number\">14</span> 丙子:<span class=\"number\">2</span> 庚寅:<span class=\"number\">8</span> 壬寅:<span class=\"number\">10</span> 戊申:<span class=\"number\">12</span> 甲寅:<span class=\"number\">2</span> 乙丑:<span class=\"number\">2</span> 辛未:<span class=\"number\">14</span> 丁亥:<span class=\"number\">14</span> 戊子:<span class=\"number\">4</span> 己亥:<span class=\"number\">16</span> 丙午:<span class=\"number\">8</span> 庚申:<span class=\"number\">14</span> 癸亥:<span class=\"number\">20</span> 丁酉:<span class=\"number\">12</span> </span><br><span class=\"line\">所有非法的組合：</span><br><span class=\"line\">甲丑:<span class=\"number\">1</span> 甲卯:<span class=\"number\">3</span> 甲巳:<span class=\"number\">5</span> 甲未:<span class=\"number\">7</span> 甲酉:<span class=\"number\">9</span> 甲亥:<span class=\"number\">11</span> 乙子:<span class=\"number\">1</span> 乙寅:<span class=\"number\">3</span> 乙辰:<span class=\"number\">5</span> 乙午:<span class=\"number\">7</span> 乙申:<span class=\"number\">9</span> 乙戌:<span class=\"number\">11</span> 丙丑:<span class=\"number\">3</span> 丙卯:<span class=\"number\">5</span> 丙巳:<span class=\"number\">7</span> 丙未:<span class=\"number\">9</span> 丙酉:<span class=\"number\">11</span> 丙亥:<span class=\"number\">13</span> 丁子:<span class=\"number\">3</span> 丁寅:<span class=\"number\">5</span> 丁辰:<span class=\"number\">7</span> 丁午:<span class=\"number\">9</span> 丁申:<span class=\"number\">11</span> 丁 己辰:<span class=\"number\">9</span> 己午:<span class=\"number\">11</span> 己申:<span class=\"number\">13</span> 己戌:<span class=\"number\">15</span> 庚丑:<span class=\"number\">7</span> 庚卯:<span class=\"number\">9</span> 庚巳:<span class=\"number\">11</span> 庚未:<span class=\"number\">13</span> 庚酉:<span class=\"number\">15</span> 庚亥:<span class=\"number\">17</span> 辛子:<span class=\"number\">7</span> 辛寅:<span class=\"number\">9</span> 辛辰:<span class=\"number\">11</span> 辛午:<span class=\"number\">13</span> 辛申:<span class=\"number\">15</span> 辛戌:<span class=\"number\">17</span> 壬丑:<span class=\"number\">9</span> 壬卯:<span class=\"number\">11</span> 壬巳:<span class=\"number\">13</span> 壬未:<span class=\"number\">15</span> 壬酉:<span class=\"number\">17</span> 壬亥:<span class=\"number\">19</span> 癸子:<span class=\"number\">9</span> 癸寅:<span class=\"number\">11</span> 癸辰:<span class=\"number\">13</span> 癸午:<span class=\"number\">15</span> 癸申:<span class=\"number\">17</span> 癸戌:<span class=\"number\">19</span> </span><br></pre></td></tr></table></figure>\n\n<p>嗯，符合預期，合法的組合和非法的組合各佔 60 個。</p>\n<p>觀察發現，所有合法的組合的Value值都是偶數，所有非法的組合的Value值都是奇數。</p>\n<p>因此有第二種思路求出非法組合：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j++ &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i+j)%<span class=\"number\">2</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">所有非法的組合：</span><br><span class=\"line\">甲丑:<span class=\"number\">1</span> 甲卯:<span class=\"number\">3</span> 甲巳:<span class=\"number\">5</span> 甲未:<span class=\"number\">7</span> 甲酉:<span class=\"number\">9</span> 甲亥:<span class=\"number\">11</span> 乙子:<span class=\"number\">1</span> 乙寅:<span class=\"number\">3</span> 乙辰:<span class=\"number\">5</span> 乙午:<span class=\"number\">7</span> 乙申:<span class=\"number\">9</span> 乙戌:<span class=\"number\">11</span> 丙丑:<span class=\"number\">3</span> 丙卯:<span class=\"number\">5</span> 丙巳:<span class=\"number\">7</span> 丙未:<span class=\"number\">9</span> 丙酉:<span class=\"number\">11</span> 丙亥:<span class=\"number\">13</span> 丁子:<span class=\"number\">3</span> 丁寅:<span class=\"number\">5</span> 丁辰:<span class=\"number\">7</span> 丁午:<span class=\"number\">9</span> 丁申:<span class=\"number\">11</span> 丁 己辰:<span class=\"number\">9</span> 己午:<span class=\"number\">11</span> 己申:<span class=\"number\">13</span> 己戌:<span class=\"number\">15</span> 庚丑:<span class=\"number\">7</span> 庚卯:<span class=\"number\">9</span> 庚巳:<span class=\"number\">11</span> 庚未:<span class=\"number\">13</span> 庚酉:<span class=\"number\">15</span> 庚亥:<span class=\"number\">17</span> 辛子:<span class=\"number\">7</span> 辛寅:<span class=\"number\">9</span> 辛辰:<span class=\"number\">11</span> 辛午:<span class=\"number\">13</span> 辛申:<span class=\"number\">15</span> 辛戌:<span class=\"number\">17</span> 壬丑:<span class=\"number\">9</span> 壬卯:<span class=\"number\">11</span> 壬巳:<span class=\"number\">13</span> 壬未:<span class=\"number\">15</span> 壬酉:<span class=\"number\">17</span> 壬亥:<span class=\"number\">19</span> 癸子:<span class=\"number\">9</span> 癸寅:<span class=\"number\">11</span> 癸辰:<span class=\"number\">13</span> 癸午:<span class=\"number\">15</span> 癸申:<span class=\"number\">17</span> 癸戌:<span class=\"number\">19</span></span><br></pre></td></tr></table></figure>\n\n<p>很棒，跟思路一的非法組合一致。</p>\n<p>學過小學數學的都知道，奇數+偶數=奇數，奇數+奇數=偶數，偶數+偶數=偶數。於是有了第三種思路，只要保證 i 和 j 的奇偶性不同即可保證 i 和 j 的組合爲非法組合。代碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  garr := []<span class=\"keyword\">rune</span>(gs)</span><br><span class=\"line\">  zarr := []<span class=\"keyword\">rune</span>(zs)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 輸出所有非法的組合</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">&quot;\\n所有非法的組合：&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(garr); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> j := <span class=\"number\">1</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j = j + <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(zarr); j = j + <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s:%d &quot;</span>, <span class=\"keyword\">string</span>(garr[i])+<span class=\"keyword\">string</span>(zarr[j]), i+j)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果同思路二的一致。</p>\n<p>完結</p>"},{"title":"携帯で日本語（手机上的日语）","p":"language/jp/keitai-de-nihongo.md","_content":"\n有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。\n\n<!--more-->\n\n## 一、アプリ（应用程序）\n\n手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。\n\n下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。\n\n### （一）システムアプリ（系统应用）\n\n| アプリ                   | Applications         | 应用程序      | 應用程式   |\n| ------------------------ | -------------------- | ------------- | ---------- |\n| アプリストア(apurisutoa) | App store            | 应用商店      | 應用商店   |\n| パスウードとアカウード   | Passwords & Accounts | 密码与账户    | 密碼與賬號 |\n| メール                   | Mail                 | 邮件          | 郵件       |\n| 連絡先（れんらくさき）   | Contacts             | 通讯录        | 聯絡資訊   |\n| カレンダー               | Calendar             | 日历          | 行事曆     |\n| メモ                     | Notes                | 备忘录        | 備忘錄     |\n| リマインダー             | Reminders            | 提醒事项      | 提醒事項   |\n| ボイスメモ               | Voice Memos          | 语言备忘录    | 語音備忘錄 |\n| 電話（でんわ）           | Phone                | 电话          | 電話       |\n| メッセージ               | Messages             | 信息          | 訊息       |\n| FaceTime                 | FaceTime             | FaceTime      | FaceTime   |\n| マップ                   | Maps                 | 地图          | 地圖       |\n| コンパス                 | Compass              | 指南针        | 指南針     |\n| 計測（けいそく）         | Measure              | 测距仪        | 測距儀     |\n| Safari                   | Safari               | Safari 浏览器 | Safari     |\n| 株価（かぶか）           | Stocks               | 股市          | 股市       |\n| ミュージック             | Music                | 音乐          | 音樂       |\n| ビデオ                   | Videos               | 视频          | 影片       |\n| 写真（しゃしん）         | Photos               | 照片          | 照片       |\n| カメラ                   | Camera               | 相机          | 相機       |\n| ブック                   | Books                | 图书          | 書籍       |\n\n备注：\n\n1. 股票：株式（かぶしき）\n2. 股市：株式市場（かぶしきしじょう）\n3. 股价：株価（かぶか）\n\n### （二）ユーザーアプリ（用户应用）\n\n| アプリ                          | Applications | 应用程序 | 應用程式 |\n| ------------------------------- | --------------- | -------- | -------- |\n| 微信 / ウェイシン \\| WeChat / ウィチャット | Wechat          | 微信     | 微信   |\n| QQ / キュキュ           | QQ              | QQ       | QQ     |\n| アリペイ                | Alipay          | 支付宝   | 支付寶 |\n| ビリビリ              | Bilibili        | 哔哩哔哩 | 嗶哩嗶哩 |\n| Google / グーグル       | Google          | 谷歌     | 谷歌   |\n| Kindle / キンドル | Kindle          | Kindle   | Kindle |\n| Chrome / クロム | Chrome | Chrome | Chrome |\n| YouTube / ユーチューブ | YouTube | YouTube | YouTube |\n| Gmail / ジメイル | Gmail | Gmail | Gmail |\n| Google フォト | Google Photo | Google相册 | Google相簿 |\n| 翻訳（ほにゃく） | Translate | 翻译 | 翻譯 |\n| Instagram / インスタグラム | Instagram | Instagram | Instagram |\n| WhatsApp / ワッツアップ | WhatsApp | WhatsApp | WhatsApp |\n| Wunderlist / ワンダーリスト | Wunderlist | 奇妙清单 | 奇妙清單 |\n| NetEase Music / ネットイース ミュージック | NetEase Music | 网易云音乐 | 網易云音樂 |\n| 好奇心日報（こうきしんにっぽう） | Qdaily | 好奇心日报 | 好奇心日報 |\n| Taobao / タオバオ | Taobao | 手机淘宝 | 手機淘寶 |\n| 京東 / ジンドン | JD | 京东 | 京東 |\n| 高德地図 / こうとくちず | Amap | 高德地图 | 高德地圖 |\n| 印象メモ | Evernote | 印象笔记 | 印象筆記 |\n| 招商銀行 / しょうしょうぎんこう | CMB | 招商银行 | 招商銀行 |\n| WeChat 読書（どくしょ 1）? | WeRead | 微信读书 | 微信讀書 |\n| Youku（ヨウク） | Youku | 优酷 | 優酷 |\n| 愛奇芸（アイキゲー） | IQiyi | 爱奇艺 | 愛奇藝 |\n\n## 二、設定（せってい）\n\n「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。\n\n下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。\n\n### （一）接続（せつぞく）設定（连接设置）\n\n| 設定（せってい）                 | Settings         | 设置         | 設定     |\n| -------------------------------- | ---------------- | ------------ | -------- |\n| 機内モード（きない 1）           | Airplane Mode    | 飞行模式     | 飛航模式 |\n| WLAN                             | WLAN             | 无线网络     | WLAN     |\n| Bluetooth                        | Bluetooth        | 蓝牙         | 藍牙     |\n| モバイル通信（つうしん）         | Cellular         | 蜂窝移动网络 | 行動服務 |\n| インターネット共有（きょうゆう） | Personal Hotspot | 个人热点     | 個人熱點 |\n| VPN                              | VPN              | VPN          | VPN      |\n\n### （二）フィードバック設定（反馈设置）\n\n| 設定（せってい）             | Settings        | 设置         | 設定           |\n| ---------------------------- | --------------- | ------------ | -------------- |\n| 通知（つうち）               | Notifications   | 通知         | 通知           |\n| サウンドと触覚（しょっかく） | Sounds＆Haptics | 声音与触感   | 聲音與觸覺回饋 |\n| おやすみモード               | Do Not Disturb  | 勿扰模式     | 勿擾模式       |\n| スクリーンタイム             | Screen Time     | 屏幕使用时间 | 熒幕使用時間   |\n\n### （三）一般設定（通用设置）\n\n| 設定（せってい）                             | Settings              | 设置           | 設定           |\n| -------------------------------------------- | --------------------- | -------------- | -------------- |\n| 一般（いっぱん）                             | General               | 通用           | 一般           |\n| コントロールセンター                         | Control Center        | 控制中心       | 控制中心       |\n| 画面表示と明るさ（がめんひょうじとあかるさ） | Display ＆ Brightness | 显示与亮度     | 熒幕顯示與亮度 |\n| 壁紙（かべがみ）                             | Wallpaper             | 墙纸           | 背景圖片       |\n| Siriと検索（けんさく）                       | Siri ＆Search         | Siri 与搜索    | Siri 與搜尋    |\n| Face ID とパスコード                         | Face ID & Passcode    | 面容 ID 与密码 | Face ID 與密碼 |\n| 緊急SOS（きんきゅう）                        | Emergency SOS         | SOS 紧急联络   | SOS 緊急服務   |\n| バッテリー                                   | Battery               | 电池           | 電池           |\n| プライバシー                                 | Privacy               | 隐私           | 隱私權         |\n\n### （四）ストアー設定（商店设置）\n\n| 設定（せってい）          | Settings                | 设置                      | 設定                      |\n| ------------------------- | ----------------------- | ------------------------- | ------------------------- |\n| iTunes Store と App Store | iTunes Store＆App Store | iTunes Store 与 App Store | iTunes Store 與 App Store |\n| WalletとApple Pay         | Wallet＆Apple Pay       | 钱包与 Apple Pay          | 錢包與 Apple Pay          |\n\n## 三、操作（そうさ）\n\nアプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：\n\n| 日本語               | English | 汉语 | 漢語 |\n| -------------------- | ------- | ---- | ---- |\n| OK                   | OK      | 好的 | 好的 |\n| 確認                 | Comfirm | 确定 | 確定 |\n| キャンセル           | Cancel  | 取消 | 取消 |\n| 完了（かんりょう）   | Finish  | 完成 | 完成 |\n| オン                 | On      | 开启 | 開啟 |\n| オフ                 | Off     | 关闭 | 關閉 |\n| 消去（しょうきょ 1） | Clear   | 清除 | 清除 |\n| 検索（けんさく）     | Search  | 搜索 | 搜尋 |\n| 削除（さくじょ 1）   | Delete  | 删除 | 删除 |\n| 破棄（はき 1）       | Discard | 废弃 | 捨棄 |\n| 元に戻す（もとにもどす） | Undo | 撤消 | 復原 |\n| 開く（ひらく2）      | Open    | 打开 | 打開 |\n| 閉じる（とじる 2）   | Close   | 关闭 | 關閉 |\n| 編集（へんしゅう）   | Edit    | 编辑 | 編輯 |\n| 表示（ひょうじ） | View | 查看 | 檢視 |\n| 送る（おくる） | Send    | 发送 | 發送 |\n| 追加（ついか） | Add | 添加 | 加入 |\n| 新着（しんちゃく） | New | 新增 | 新增 |\n| 報告（ほうこく） | Report | 举报 | 回報 |\n| マーク | Mark | 标记 | 標示 |\n| 再生（さいせい） | Play | 播放 | 播放 |\n| 一時停止（いちじていし） | Pause | 暂停 | 暫停 |\n| 停止（ていし） | Stop | 停止 | 停止 |\n| 登録（とうろく） | Sign Up | 注册 | 註冊 |\n| ログイン | Sign In / Log In | 登录 | 登入 |\n| ログアウト | Sign Out / Log Out | 退出 | 登出 / 退出 |\n\n","source":"_posts/language/jp/keitai-de-nihongo.md","raw":"---\ntitle: 携帯で日本語（手机上的日语）\np: language/jp/keitai-de-nihongo.md\ntags:\n- 日本語\n---\n\n有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。\n\n<!--more-->\n\n## 一、アプリ（应用程序）\n\n手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。\n\n下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。\n\n### （一）システムアプリ（系统应用）\n\n| アプリ                   | Applications         | 应用程序      | 應用程式   |\n| ------------------------ | -------------------- | ------------- | ---------- |\n| アプリストア(apurisutoa) | App store            | 应用商店      | 應用商店   |\n| パスウードとアカウード   | Passwords & Accounts | 密码与账户    | 密碼與賬號 |\n| メール                   | Mail                 | 邮件          | 郵件       |\n| 連絡先（れんらくさき）   | Contacts             | 通讯录        | 聯絡資訊   |\n| カレンダー               | Calendar             | 日历          | 行事曆     |\n| メモ                     | Notes                | 备忘录        | 備忘錄     |\n| リマインダー             | Reminders            | 提醒事项      | 提醒事項   |\n| ボイスメモ               | Voice Memos          | 语言备忘录    | 語音備忘錄 |\n| 電話（でんわ）           | Phone                | 电话          | 電話       |\n| メッセージ               | Messages             | 信息          | 訊息       |\n| FaceTime                 | FaceTime             | FaceTime      | FaceTime   |\n| マップ                   | Maps                 | 地图          | 地圖       |\n| コンパス                 | Compass              | 指南针        | 指南針     |\n| 計測（けいそく）         | Measure              | 测距仪        | 測距儀     |\n| Safari                   | Safari               | Safari 浏览器 | Safari     |\n| 株価（かぶか）           | Stocks               | 股市          | 股市       |\n| ミュージック             | Music                | 音乐          | 音樂       |\n| ビデオ                   | Videos               | 视频          | 影片       |\n| 写真（しゃしん）         | Photos               | 照片          | 照片       |\n| カメラ                   | Camera               | 相机          | 相機       |\n| ブック                   | Books                | 图书          | 書籍       |\n\n备注：\n\n1. 股票：株式（かぶしき）\n2. 股市：株式市場（かぶしきしじょう）\n3. 股价：株価（かぶか）\n\n### （二）ユーザーアプリ（用户应用）\n\n| アプリ                          | Applications | 应用程序 | 應用程式 |\n| ------------------------------- | --------------- | -------- | -------- |\n| 微信 / ウェイシン \\| WeChat / ウィチャット | Wechat          | 微信     | 微信   |\n| QQ / キュキュ           | QQ              | QQ       | QQ     |\n| アリペイ                | Alipay          | 支付宝   | 支付寶 |\n| ビリビリ              | Bilibili        | 哔哩哔哩 | 嗶哩嗶哩 |\n| Google / グーグル       | Google          | 谷歌     | 谷歌   |\n| Kindle / キンドル | Kindle          | Kindle   | Kindle |\n| Chrome / クロム | Chrome | Chrome | Chrome |\n| YouTube / ユーチューブ | YouTube | YouTube | YouTube |\n| Gmail / ジメイル | Gmail | Gmail | Gmail |\n| Google フォト | Google Photo | Google相册 | Google相簿 |\n| 翻訳（ほにゃく） | Translate | 翻译 | 翻譯 |\n| Instagram / インスタグラム | Instagram | Instagram | Instagram |\n| WhatsApp / ワッツアップ | WhatsApp | WhatsApp | WhatsApp |\n| Wunderlist / ワンダーリスト | Wunderlist | 奇妙清单 | 奇妙清單 |\n| NetEase Music / ネットイース ミュージック | NetEase Music | 网易云音乐 | 網易云音樂 |\n| 好奇心日報（こうきしんにっぽう） | Qdaily | 好奇心日报 | 好奇心日報 |\n| Taobao / タオバオ | Taobao | 手机淘宝 | 手機淘寶 |\n| 京東 / ジンドン | JD | 京东 | 京東 |\n| 高德地図 / こうとくちず | Amap | 高德地图 | 高德地圖 |\n| 印象メモ | Evernote | 印象笔记 | 印象筆記 |\n| 招商銀行 / しょうしょうぎんこう | CMB | 招商银行 | 招商銀行 |\n| WeChat 読書（どくしょ 1）? | WeRead | 微信读书 | 微信讀書 |\n| Youku（ヨウク） | Youku | 优酷 | 優酷 |\n| 愛奇芸（アイキゲー） | IQiyi | 爱奇艺 | 愛奇藝 |\n\n## 二、設定（せってい）\n\n「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。\n\n下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。\n\n### （一）接続（せつぞく）設定（连接设置）\n\n| 設定（せってい）                 | Settings         | 设置         | 設定     |\n| -------------------------------- | ---------------- | ------------ | -------- |\n| 機内モード（きない 1）           | Airplane Mode    | 飞行模式     | 飛航模式 |\n| WLAN                             | WLAN             | 无线网络     | WLAN     |\n| Bluetooth                        | Bluetooth        | 蓝牙         | 藍牙     |\n| モバイル通信（つうしん）         | Cellular         | 蜂窝移动网络 | 行動服務 |\n| インターネット共有（きょうゆう） | Personal Hotspot | 个人热点     | 個人熱點 |\n| VPN                              | VPN              | VPN          | VPN      |\n\n### （二）フィードバック設定（反馈设置）\n\n| 設定（せってい）             | Settings        | 设置         | 設定           |\n| ---------------------------- | --------------- | ------------ | -------------- |\n| 通知（つうち）               | Notifications   | 通知         | 通知           |\n| サウンドと触覚（しょっかく） | Sounds＆Haptics | 声音与触感   | 聲音與觸覺回饋 |\n| おやすみモード               | Do Not Disturb  | 勿扰模式     | 勿擾模式       |\n| スクリーンタイム             | Screen Time     | 屏幕使用时间 | 熒幕使用時間   |\n\n### （三）一般設定（通用设置）\n\n| 設定（せってい）                             | Settings              | 设置           | 設定           |\n| -------------------------------------------- | --------------------- | -------------- | -------------- |\n| 一般（いっぱん）                             | General               | 通用           | 一般           |\n| コントロールセンター                         | Control Center        | 控制中心       | 控制中心       |\n| 画面表示と明るさ（がめんひょうじとあかるさ） | Display ＆ Brightness | 显示与亮度     | 熒幕顯示與亮度 |\n| 壁紙（かべがみ）                             | Wallpaper             | 墙纸           | 背景圖片       |\n| Siriと検索（けんさく）                       | Siri ＆Search         | Siri 与搜索    | Siri 與搜尋    |\n| Face ID とパスコード                         | Face ID & Passcode    | 面容 ID 与密码 | Face ID 與密碼 |\n| 緊急SOS（きんきゅう）                        | Emergency SOS         | SOS 紧急联络   | SOS 緊急服務   |\n| バッテリー                                   | Battery               | 电池           | 電池           |\n| プライバシー                                 | Privacy               | 隐私           | 隱私權         |\n\n### （四）ストアー設定（商店设置）\n\n| 設定（せってい）          | Settings                | 设置                      | 設定                      |\n| ------------------------- | ----------------------- | ------------------------- | ------------------------- |\n| iTunes Store と App Store | iTunes Store＆App Store | iTunes Store 与 App Store | iTunes Store 與 App Store |\n| WalletとApple Pay         | Wallet＆Apple Pay       | 钱包与 Apple Pay          | 錢包與 Apple Pay          |\n\n## 三、操作（そうさ）\n\nアプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：\n\n| 日本語               | English | 汉语 | 漢語 |\n| -------------------- | ------- | ---- | ---- |\n| OK                   | OK      | 好的 | 好的 |\n| 確認                 | Comfirm | 确定 | 確定 |\n| キャンセル           | Cancel  | 取消 | 取消 |\n| 完了（かんりょう）   | Finish  | 完成 | 完成 |\n| オン                 | On      | 开启 | 開啟 |\n| オフ                 | Off     | 关闭 | 關閉 |\n| 消去（しょうきょ 1） | Clear   | 清除 | 清除 |\n| 検索（けんさく）     | Search  | 搜索 | 搜尋 |\n| 削除（さくじょ 1）   | Delete  | 删除 | 删除 |\n| 破棄（はき 1）       | Discard | 废弃 | 捨棄 |\n| 元に戻す（もとにもどす） | Undo | 撤消 | 復原 |\n| 開く（ひらく2）      | Open    | 打开 | 打開 |\n| 閉じる（とじる 2）   | Close   | 关闭 | 關閉 |\n| 編集（へんしゅう）   | Edit    | 编辑 | 編輯 |\n| 表示（ひょうじ） | View | 查看 | 檢視 |\n| 送る（おくる） | Send    | 发送 | 發送 |\n| 追加（ついか） | Add | 添加 | 加入 |\n| 新着（しんちゃく） | New | 新增 | 新增 |\n| 報告（ほうこく） | Report | 举报 | 回報 |\n| マーク | Mark | 标记 | 標示 |\n| 再生（さいせい） | Play | 播放 | 播放 |\n| 一時停止（いちじていし） | Pause | 暂停 | 暫停 |\n| 停止（ていし） | Stop | 停止 | 停止 |\n| 登録（とうろく） | Sign Up | 注册 | 註冊 |\n| ログイン | Sign In / Log In | 登录 | 登入 |\n| ログアウト | Sign Out / Log Out | 退出 | 登出 / 退出 |\n\n","slug":"language/jp/keitai-de-nihongo","published":1,"date":"2021-02-05T16:21:16.891Z","updated":"2021-02-05T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7woc00099a9kf6cagxvw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"一、アプリ（应用程序）\"><a href=\"#一、アプリ（应用程序）\" class=\"headerlink\" title=\"一、アプリ（应用程序）\"></a>一、アプリ（应用程序）</h2><p>手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。</p>\n<p>下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。</p>\n<h3 id=\"（一）システムアプリ（系统应用）\"><a href=\"#（一）システムアプリ（系统应用）\" class=\"headerlink\" title=\"（一）システムアプリ（系统应用）\"></a>（一）システムアプリ（系统应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>アプリストア(apurisutoa)</td>\n<td>App store</td>\n<td>应用商店</td>\n<td>應用商店</td>\n</tr>\n<tr>\n<td>パスウードとアカウード</td>\n<td>Passwords &amp; Accounts</td>\n<td>密码与账户</td>\n<td>密碼與賬號</td>\n</tr>\n<tr>\n<td>メール</td>\n<td>Mail</td>\n<td>邮件</td>\n<td>郵件</td>\n</tr>\n<tr>\n<td>連絡先（れんらくさき）</td>\n<td>Contacts</td>\n<td>通讯录</td>\n<td>聯絡資訊</td>\n</tr>\n<tr>\n<td>カレンダー</td>\n<td>Calendar</td>\n<td>日历</td>\n<td>行事曆</td>\n</tr>\n<tr>\n<td>メモ</td>\n<td>Notes</td>\n<td>备忘录</td>\n<td>備忘錄</td>\n</tr>\n<tr>\n<td>リマインダー</td>\n<td>Reminders</td>\n<td>提醒事项</td>\n<td>提醒事項</td>\n</tr>\n<tr>\n<td>ボイスメモ</td>\n<td>Voice Memos</td>\n<td>语言备忘录</td>\n<td>語音備忘錄</td>\n</tr>\n<tr>\n<td>電話（でんわ）</td>\n<td>Phone</td>\n<td>电话</td>\n<td>電話</td>\n</tr>\n<tr>\n<td>メッセージ</td>\n<td>Messages</td>\n<td>信息</td>\n<td>訊息</td>\n</tr>\n<tr>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n</tr>\n<tr>\n<td>マップ</td>\n<td>Maps</td>\n<td>地图</td>\n<td>地圖</td>\n</tr>\n<tr>\n<td>コンパス</td>\n<td>Compass</td>\n<td>指南针</td>\n<td>指南針</td>\n</tr>\n<tr>\n<td>計測（けいそく）</td>\n<td>Measure</td>\n<td>测距仪</td>\n<td>測距儀</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>Safari</td>\n<td>Safari 浏览器</td>\n<td>Safari</td>\n</tr>\n<tr>\n<td>株価（かぶか）</td>\n<td>Stocks</td>\n<td>股市</td>\n<td>股市</td>\n</tr>\n<tr>\n<td>ミュージック</td>\n<td>Music</td>\n<td>音乐</td>\n<td>音樂</td>\n</tr>\n<tr>\n<td>ビデオ</td>\n<td>Videos</td>\n<td>视频</td>\n<td>影片</td>\n</tr>\n<tr>\n<td>写真（しゃしん）</td>\n<td>Photos</td>\n<td>照片</td>\n<td>照片</td>\n</tr>\n<tr>\n<td>カメラ</td>\n<td>Camera</td>\n<td>相机</td>\n<td>相機</td>\n</tr>\n<tr>\n<td>ブック</td>\n<td>Books</td>\n<td>图书</td>\n<td>書籍</td>\n</tr>\n</tbody></table>\n<p>备注：</p>\n<ol>\n<li>股票：株式（かぶしき）</li>\n<li>股市：株式市場（かぶしきしじょう）</li>\n<li>股价：株価（かぶか）</li>\n</ol>\n<h3 id=\"（二）ユーザーアプリ（用户应用）\"><a href=\"#（二）ユーザーアプリ（用户应用）\" class=\"headerlink\" title=\"（二）ユーザーアプリ（用户应用）\"></a>（二）ユーザーアプリ（用户应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微信 / ウェイシン | WeChat / ウィチャット</td>\n<td>Wechat</td>\n<td>微信</td>\n<td>微信</td>\n</tr>\n<tr>\n<td>QQ / キュキュ</td>\n<td>QQ</td>\n<td>QQ</td>\n<td>QQ</td>\n</tr>\n<tr>\n<td>アリペイ</td>\n<td>Alipay</td>\n<td>支付宝</td>\n<td>支付寶</td>\n</tr>\n<tr>\n<td>ビリビリ</td>\n<td>Bilibili</td>\n<td>哔哩哔哩</td>\n<td>嗶哩嗶哩</td>\n</tr>\n<tr>\n<td>Google / グーグル</td>\n<td>Google</td>\n<td>谷歌</td>\n<td>谷歌</td>\n</tr>\n<tr>\n<td>Kindle / キンドル</td>\n<td>Kindle</td>\n<td>Kindle</td>\n<td>Kindle</td>\n</tr>\n<tr>\n<td>Chrome / クロム</td>\n<td>Chrome</td>\n<td>Chrome</td>\n<td>Chrome</td>\n</tr>\n<tr>\n<td>YouTube / ユーチューブ</td>\n<td>YouTube</td>\n<td>YouTube</td>\n<td>YouTube</td>\n</tr>\n<tr>\n<td>Gmail / ジメイル</td>\n<td>Gmail</td>\n<td>Gmail</td>\n<td>Gmail</td>\n</tr>\n<tr>\n<td>Google フォト</td>\n<td>Google Photo</td>\n<td>Google相册</td>\n<td>Google相簿</td>\n</tr>\n<tr>\n<td>翻訳（ほにゃく）</td>\n<td>Translate</td>\n<td>翻译</td>\n<td>翻譯</td>\n</tr>\n<tr>\n<td>Instagram / インスタグラム</td>\n<td>Instagram</td>\n<td>Instagram</td>\n<td>Instagram</td>\n</tr>\n<tr>\n<td>WhatsApp / ワッツアップ</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n</tr>\n<tr>\n<td>Wunderlist / ワンダーリスト</td>\n<td>Wunderlist</td>\n<td>奇妙清单</td>\n<td>奇妙清單</td>\n</tr>\n<tr>\n<td>NetEase Music / ネットイース ミュージック</td>\n<td>NetEase Music</td>\n<td>网易云音乐</td>\n<td>網易云音樂</td>\n</tr>\n<tr>\n<td>好奇心日報（こうきしんにっぽう）</td>\n<td>Qdaily</td>\n<td>好奇心日报</td>\n<td>好奇心日報</td>\n</tr>\n<tr>\n<td>Taobao / タオバオ</td>\n<td>Taobao</td>\n<td>手机淘宝</td>\n<td>手機淘寶</td>\n</tr>\n<tr>\n<td>京東 / ジンドン</td>\n<td>JD</td>\n<td>京东</td>\n<td>京東</td>\n</tr>\n<tr>\n<td>高德地図 / こうとくちず</td>\n<td>Amap</td>\n<td>高德地图</td>\n<td>高德地圖</td>\n</tr>\n<tr>\n<td>印象メモ</td>\n<td>Evernote</td>\n<td>印象笔记</td>\n<td>印象筆記</td>\n</tr>\n<tr>\n<td>招商銀行 / しょうしょうぎんこう</td>\n<td>CMB</td>\n<td>招商银行</td>\n<td>招商銀行</td>\n</tr>\n<tr>\n<td>WeChat 読書（どくしょ 1）?</td>\n<td>WeRead</td>\n<td>微信读书</td>\n<td>微信讀書</td>\n</tr>\n<tr>\n<td>Youku（ヨウク）</td>\n<td>Youku</td>\n<td>优酷</td>\n<td>優酷</td>\n</tr>\n<tr>\n<td>愛奇芸（アイキゲー）</td>\n<td>IQiyi</td>\n<td>爱奇艺</td>\n<td>愛奇藝</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、設定（せってい）\"><a href=\"#二、設定（せってい）\" class=\"headerlink\" title=\"二、設定（せってい）\"></a>二、設定（せってい）</h2><p>「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。</p>\n<p>下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。</p>\n<h3 id=\"（一）接続（せつぞく）設定（连接设置）\"><a href=\"#（一）接続（せつぞく）設定（连接设置）\" class=\"headerlink\" title=\"（一）接続（せつぞく）設定（连接设置）\"></a>（一）接続（せつぞく）設定（连接设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>機内モード（きない 1）</td>\n<td>Airplane Mode</td>\n<td>飞行模式</td>\n<td>飛航模式</td>\n</tr>\n<tr>\n<td>WLAN</td>\n<td>WLAN</td>\n<td>无线网络</td>\n<td>WLAN</td>\n</tr>\n<tr>\n<td>Bluetooth</td>\n<td>Bluetooth</td>\n<td>蓝牙</td>\n<td>藍牙</td>\n</tr>\n<tr>\n<td>モバイル通信（つうしん）</td>\n<td>Cellular</td>\n<td>蜂窝移动网络</td>\n<td>行動服務</td>\n</tr>\n<tr>\n<td>インターネット共有（きょうゆう）</td>\n<td>Personal Hotspot</td>\n<td>个人热点</td>\n<td>個人熱點</td>\n</tr>\n<tr>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n</tr>\n</tbody></table>\n<h3 id=\"（二）フィードバック設定（反馈设置）\"><a href=\"#（二）フィードバック設定（反馈设置）\" class=\"headerlink\" title=\"（二）フィードバック設定（反馈设置）\"></a>（二）フィードバック設定（反馈设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通知（つうち）</td>\n<td>Notifications</td>\n<td>通知</td>\n<td>通知</td>\n</tr>\n<tr>\n<td>サウンドと触覚（しょっかく）</td>\n<td>Sounds＆Haptics</td>\n<td>声音与触感</td>\n<td>聲音與觸覺回饋</td>\n</tr>\n<tr>\n<td>おやすみモード</td>\n<td>Do Not Disturb</td>\n<td>勿扰模式</td>\n<td>勿擾模式</td>\n</tr>\n<tr>\n<td>スクリーンタイム</td>\n<td>Screen Time</td>\n<td>屏幕使用时间</td>\n<td>熒幕使用時間</td>\n</tr>\n</tbody></table>\n<h3 id=\"（三）一般設定（通用设置）\"><a href=\"#（三）一般設定（通用设置）\" class=\"headerlink\" title=\"（三）一般設定（通用设置）\"></a>（三）一般設定（通用设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一般（いっぱん）</td>\n<td>General</td>\n<td>通用</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>コントロールセンター</td>\n<td>Control Center</td>\n<td>控制中心</td>\n<td>控制中心</td>\n</tr>\n<tr>\n<td>画面表示と明るさ（がめんひょうじとあかるさ）</td>\n<td>Display ＆ Brightness</td>\n<td>显示与亮度</td>\n<td>熒幕顯示與亮度</td>\n</tr>\n<tr>\n<td>壁紙（かべがみ）</td>\n<td>Wallpaper</td>\n<td>墙纸</td>\n<td>背景圖片</td>\n</tr>\n<tr>\n<td>Siriと検索（けんさく）</td>\n<td>Siri ＆Search</td>\n<td>Siri 与搜索</td>\n<td>Siri 與搜尋</td>\n</tr>\n<tr>\n<td>Face ID とパスコード</td>\n<td>Face ID &amp; Passcode</td>\n<td>面容 ID 与密码</td>\n<td>Face ID 與密碼</td>\n</tr>\n<tr>\n<td>緊急SOS（きんきゅう）</td>\n<td>Emergency SOS</td>\n<td>SOS 紧急联络</td>\n<td>SOS 緊急服務</td>\n</tr>\n<tr>\n<td>バッテリー</td>\n<td>Battery</td>\n<td>电池</td>\n<td>電池</td>\n</tr>\n<tr>\n<td>プライバシー</td>\n<td>Privacy</td>\n<td>隐私</td>\n<td>隱私權</td>\n</tr>\n</tbody></table>\n<h3 id=\"（四）ストアー設定（商店设置）\"><a href=\"#（四）ストアー設定（商店设置）\" class=\"headerlink\" title=\"（四）ストアー設定（商店设置）\"></a>（四）ストアー設定（商店设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iTunes Store と App Store</td>\n<td>iTunes Store＆App Store</td>\n<td>iTunes Store 与 App Store</td>\n<td>iTunes Store 與 App Store</td>\n</tr>\n<tr>\n<td>WalletとApple Pay</td>\n<td>Wallet＆Apple Pay</td>\n<td>钱包与 Apple Pay</td>\n<td>錢包與 Apple Pay</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、操作（そうさ）\"><a href=\"#三、操作（そうさ）\" class=\"headerlink\" title=\"三、操作（そうさ）\"></a>三、操作（そうさ）</h2><p>アプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：</p>\n<table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>English</th>\n<th>汉语</th>\n<th>漢語</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OK</td>\n<td>OK</td>\n<td>好的</td>\n<td>好的</td>\n</tr>\n<tr>\n<td>確認</td>\n<td>Comfirm</td>\n<td>确定</td>\n<td>確定</td>\n</tr>\n<tr>\n<td>キャンセル</td>\n<td>Cancel</td>\n<td>取消</td>\n<td>取消</td>\n</tr>\n<tr>\n<td>完了（かんりょう）</td>\n<td>Finish</td>\n<td>完成</td>\n<td>完成</td>\n</tr>\n<tr>\n<td>オン</td>\n<td>On</td>\n<td>开启</td>\n<td>開啟</td>\n</tr>\n<tr>\n<td>オフ</td>\n<td>Off</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>消去（しょうきょ 1）</td>\n<td>Clear</td>\n<td>清除</td>\n<td>清除</td>\n</tr>\n<tr>\n<td>検索（けんさく）</td>\n<td>Search</td>\n<td>搜索</td>\n<td>搜尋</td>\n</tr>\n<tr>\n<td>削除（さくじょ 1）</td>\n<td>Delete</td>\n<td>删除</td>\n<td>删除</td>\n</tr>\n<tr>\n<td>破棄（はき 1）</td>\n<td>Discard</td>\n<td>废弃</td>\n<td>捨棄</td>\n</tr>\n<tr>\n<td>元に戻す（もとにもどす）</td>\n<td>Undo</td>\n<td>撤消</td>\n<td>復原</td>\n</tr>\n<tr>\n<td>開く（ひらく2）</td>\n<td>Open</td>\n<td>打开</td>\n<td>打開</td>\n</tr>\n<tr>\n<td>閉じる（とじる 2）</td>\n<td>Close</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>編集（へんしゅう）</td>\n<td>Edit</td>\n<td>编辑</td>\n<td>編輯</td>\n</tr>\n<tr>\n<td>表示（ひょうじ）</td>\n<td>View</td>\n<td>查看</td>\n<td>檢視</td>\n</tr>\n<tr>\n<td>送る（おくる）</td>\n<td>Send</td>\n<td>发送</td>\n<td>發送</td>\n</tr>\n<tr>\n<td>追加（ついか）</td>\n<td>Add</td>\n<td>添加</td>\n<td>加入</td>\n</tr>\n<tr>\n<td>新着（しんちゃく）</td>\n<td>New</td>\n<td>新增</td>\n<td>新增</td>\n</tr>\n<tr>\n<td>報告（ほうこく）</td>\n<td>Report</td>\n<td>举报</td>\n<td>回報</td>\n</tr>\n<tr>\n<td>マーク</td>\n<td>Mark</td>\n<td>标记</td>\n<td>標示</td>\n</tr>\n<tr>\n<td>再生（さいせい）</td>\n<td>Play</td>\n<td>播放</td>\n<td>播放</td>\n</tr>\n<tr>\n<td>一時停止（いちじていし）</td>\n<td>Pause</td>\n<td>暂停</td>\n<td>暫停</td>\n</tr>\n<tr>\n<td>停止（ていし）</td>\n<td>Stop</td>\n<td>停止</td>\n<td>停止</td>\n</tr>\n<tr>\n<td>登録（とうろく）</td>\n<td>Sign Up</td>\n<td>注册</td>\n<td>註冊</td>\n</tr>\n<tr>\n<td>ログイン</td>\n<td>Sign In / Log In</td>\n<td>登录</td>\n<td>登入</td>\n</tr>\n<tr>\n<td>ログアウト</td>\n<td>Sign Out / Log Out</td>\n<td>退出</td>\n<td>登出 / 退出</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<p>有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。</p>","more":"<h2 id=\"一、アプリ（应用程序）\"><a href=\"#一、アプリ（应用程序）\" class=\"headerlink\" title=\"一、アプリ（应用程序）\"></a>一、アプリ（应用程序）</h2><p>手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。</p>\n<p>下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。</p>\n<h3 id=\"（一）システムアプリ（系统应用）\"><a href=\"#（一）システムアプリ（系统应用）\" class=\"headerlink\" title=\"（一）システムアプリ（系统应用）\"></a>（一）システムアプリ（系统应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>アプリストア(apurisutoa)</td>\n<td>App store</td>\n<td>应用商店</td>\n<td>應用商店</td>\n</tr>\n<tr>\n<td>パスウードとアカウード</td>\n<td>Passwords &amp; Accounts</td>\n<td>密码与账户</td>\n<td>密碼與賬號</td>\n</tr>\n<tr>\n<td>メール</td>\n<td>Mail</td>\n<td>邮件</td>\n<td>郵件</td>\n</tr>\n<tr>\n<td>連絡先（れんらくさき）</td>\n<td>Contacts</td>\n<td>通讯录</td>\n<td>聯絡資訊</td>\n</tr>\n<tr>\n<td>カレンダー</td>\n<td>Calendar</td>\n<td>日历</td>\n<td>行事曆</td>\n</tr>\n<tr>\n<td>メモ</td>\n<td>Notes</td>\n<td>备忘录</td>\n<td>備忘錄</td>\n</tr>\n<tr>\n<td>リマインダー</td>\n<td>Reminders</td>\n<td>提醒事项</td>\n<td>提醒事項</td>\n</tr>\n<tr>\n<td>ボイスメモ</td>\n<td>Voice Memos</td>\n<td>语言备忘录</td>\n<td>語音備忘錄</td>\n</tr>\n<tr>\n<td>電話（でんわ）</td>\n<td>Phone</td>\n<td>电话</td>\n<td>電話</td>\n</tr>\n<tr>\n<td>メッセージ</td>\n<td>Messages</td>\n<td>信息</td>\n<td>訊息</td>\n</tr>\n<tr>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n</tr>\n<tr>\n<td>マップ</td>\n<td>Maps</td>\n<td>地图</td>\n<td>地圖</td>\n</tr>\n<tr>\n<td>コンパス</td>\n<td>Compass</td>\n<td>指南针</td>\n<td>指南針</td>\n</tr>\n<tr>\n<td>計測（けいそく）</td>\n<td>Measure</td>\n<td>测距仪</td>\n<td>測距儀</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>Safari</td>\n<td>Safari 浏览器</td>\n<td>Safari</td>\n</tr>\n<tr>\n<td>株価（かぶか）</td>\n<td>Stocks</td>\n<td>股市</td>\n<td>股市</td>\n</tr>\n<tr>\n<td>ミュージック</td>\n<td>Music</td>\n<td>音乐</td>\n<td>音樂</td>\n</tr>\n<tr>\n<td>ビデオ</td>\n<td>Videos</td>\n<td>视频</td>\n<td>影片</td>\n</tr>\n<tr>\n<td>写真（しゃしん）</td>\n<td>Photos</td>\n<td>照片</td>\n<td>照片</td>\n</tr>\n<tr>\n<td>カメラ</td>\n<td>Camera</td>\n<td>相机</td>\n<td>相機</td>\n</tr>\n<tr>\n<td>ブック</td>\n<td>Books</td>\n<td>图书</td>\n<td>書籍</td>\n</tr>\n</tbody></table>\n<p>备注：</p>\n<ol>\n<li>股票：株式（かぶしき）</li>\n<li>股市：株式市場（かぶしきしじょう）</li>\n<li>股价：株価（かぶか）</li>\n</ol>\n<h3 id=\"（二）ユーザーアプリ（用户应用）\"><a href=\"#（二）ユーザーアプリ（用户应用）\" class=\"headerlink\" title=\"（二）ユーザーアプリ（用户应用）\"></a>（二）ユーザーアプリ（用户应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微信 / ウェイシン | WeChat / ウィチャット</td>\n<td>Wechat</td>\n<td>微信</td>\n<td>微信</td>\n</tr>\n<tr>\n<td>QQ / キュキュ</td>\n<td>QQ</td>\n<td>QQ</td>\n<td>QQ</td>\n</tr>\n<tr>\n<td>アリペイ</td>\n<td>Alipay</td>\n<td>支付宝</td>\n<td>支付寶</td>\n</tr>\n<tr>\n<td>ビリビリ</td>\n<td>Bilibili</td>\n<td>哔哩哔哩</td>\n<td>嗶哩嗶哩</td>\n</tr>\n<tr>\n<td>Google / グーグル</td>\n<td>Google</td>\n<td>谷歌</td>\n<td>谷歌</td>\n</tr>\n<tr>\n<td>Kindle / キンドル</td>\n<td>Kindle</td>\n<td>Kindle</td>\n<td>Kindle</td>\n</tr>\n<tr>\n<td>Chrome / クロム</td>\n<td>Chrome</td>\n<td>Chrome</td>\n<td>Chrome</td>\n</tr>\n<tr>\n<td>YouTube / ユーチューブ</td>\n<td>YouTube</td>\n<td>YouTube</td>\n<td>YouTube</td>\n</tr>\n<tr>\n<td>Gmail / ジメイル</td>\n<td>Gmail</td>\n<td>Gmail</td>\n<td>Gmail</td>\n</tr>\n<tr>\n<td>Google フォト</td>\n<td>Google Photo</td>\n<td>Google相册</td>\n<td>Google相簿</td>\n</tr>\n<tr>\n<td>翻訳（ほにゃく）</td>\n<td>Translate</td>\n<td>翻译</td>\n<td>翻譯</td>\n</tr>\n<tr>\n<td>Instagram / インスタグラム</td>\n<td>Instagram</td>\n<td>Instagram</td>\n<td>Instagram</td>\n</tr>\n<tr>\n<td>WhatsApp / ワッツアップ</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n</tr>\n<tr>\n<td>Wunderlist / ワンダーリスト</td>\n<td>Wunderlist</td>\n<td>奇妙清单</td>\n<td>奇妙清單</td>\n</tr>\n<tr>\n<td>NetEase Music / ネットイース ミュージック</td>\n<td>NetEase Music</td>\n<td>网易云音乐</td>\n<td>網易云音樂</td>\n</tr>\n<tr>\n<td>好奇心日報（こうきしんにっぽう）</td>\n<td>Qdaily</td>\n<td>好奇心日报</td>\n<td>好奇心日報</td>\n</tr>\n<tr>\n<td>Taobao / タオバオ</td>\n<td>Taobao</td>\n<td>手机淘宝</td>\n<td>手機淘寶</td>\n</tr>\n<tr>\n<td>京東 / ジンドン</td>\n<td>JD</td>\n<td>京东</td>\n<td>京東</td>\n</tr>\n<tr>\n<td>高德地図 / こうとくちず</td>\n<td>Amap</td>\n<td>高德地图</td>\n<td>高德地圖</td>\n</tr>\n<tr>\n<td>印象メモ</td>\n<td>Evernote</td>\n<td>印象笔记</td>\n<td>印象筆記</td>\n</tr>\n<tr>\n<td>招商銀行 / しょうしょうぎんこう</td>\n<td>CMB</td>\n<td>招商银行</td>\n<td>招商銀行</td>\n</tr>\n<tr>\n<td>WeChat 読書（どくしょ 1）?</td>\n<td>WeRead</td>\n<td>微信读书</td>\n<td>微信讀書</td>\n</tr>\n<tr>\n<td>Youku（ヨウク）</td>\n<td>Youku</td>\n<td>优酷</td>\n<td>優酷</td>\n</tr>\n<tr>\n<td>愛奇芸（アイキゲー）</td>\n<td>IQiyi</td>\n<td>爱奇艺</td>\n<td>愛奇藝</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、設定（せってい）\"><a href=\"#二、設定（せってい）\" class=\"headerlink\" title=\"二、設定（せってい）\"></a>二、設定（せってい）</h2><p>「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。</p>\n<p>下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。</p>\n<h3 id=\"（一）接続（せつぞく）設定（连接设置）\"><a href=\"#（一）接続（せつぞく）設定（连接设置）\" class=\"headerlink\" title=\"（一）接続（せつぞく）設定（连接设置）\"></a>（一）接続（せつぞく）設定（连接设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>機内モード（きない 1）</td>\n<td>Airplane Mode</td>\n<td>飞行模式</td>\n<td>飛航模式</td>\n</tr>\n<tr>\n<td>WLAN</td>\n<td>WLAN</td>\n<td>无线网络</td>\n<td>WLAN</td>\n</tr>\n<tr>\n<td>Bluetooth</td>\n<td>Bluetooth</td>\n<td>蓝牙</td>\n<td>藍牙</td>\n</tr>\n<tr>\n<td>モバイル通信（つうしん）</td>\n<td>Cellular</td>\n<td>蜂窝移动网络</td>\n<td>行動服務</td>\n</tr>\n<tr>\n<td>インターネット共有（きょうゆう）</td>\n<td>Personal Hotspot</td>\n<td>个人热点</td>\n<td>個人熱點</td>\n</tr>\n<tr>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n</tr>\n</tbody></table>\n<h3 id=\"（二）フィードバック設定（反馈设置）\"><a href=\"#（二）フィードバック設定（反馈设置）\" class=\"headerlink\" title=\"（二）フィードバック設定（反馈设置）\"></a>（二）フィードバック設定（反馈设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通知（つうち）</td>\n<td>Notifications</td>\n<td>通知</td>\n<td>通知</td>\n</tr>\n<tr>\n<td>サウンドと触覚（しょっかく）</td>\n<td>Sounds＆Haptics</td>\n<td>声音与触感</td>\n<td>聲音與觸覺回饋</td>\n</tr>\n<tr>\n<td>おやすみモード</td>\n<td>Do Not Disturb</td>\n<td>勿扰模式</td>\n<td>勿擾模式</td>\n</tr>\n<tr>\n<td>スクリーンタイム</td>\n<td>Screen Time</td>\n<td>屏幕使用时间</td>\n<td>熒幕使用時間</td>\n</tr>\n</tbody></table>\n<h3 id=\"（三）一般設定（通用设置）\"><a href=\"#（三）一般設定（通用设置）\" class=\"headerlink\" title=\"（三）一般設定（通用设置）\"></a>（三）一般設定（通用设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一般（いっぱん）</td>\n<td>General</td>\n<td>通用</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>コントロールセンター</td>\n<td>Control Center</td>\n<td>控制中心</td>\n<td>控制中心</td>\n</tr>\n<tr>\n<td>画面表示と明るさ（がめんひょうじとあかるさ）</td>\n<td>Display ＆ Brightness</td>\n<td>显示与亮度</td>\n<td>熒幕顯示與亮度</td>\n</tr>\n<tr>\n<td>壁紙（かべがみ）</td>\n<td>Wallpaper</td>\n<td>墙纸</td>\n<td>背景圖片</td>\n</tr>\n<tr>\n<td>Siriと検索（けんさく）</td>\n<td>Siri ＆Search</td>\n<td>Siri 与搜索</td>\n<td>Siri 與搜尋</td>\n</tr>\n<tr>\n<td>Face ID とパスコード</td>\n<td>Face ID &amp; Passcode</td>\n<td>面容 ID 与密码</td>\n<td>Face ID 與密碼</td>\n</tr>\n<tr>\n<td>緊急SOS（きんきゅう）</td>\n<td>Emergency SOS</td>\n<td>SOS 紧急联络</td>\n<td>SOS 緊急服務</td>\n</tr>\n<tr>\n<td>バッテリー</td>\n<td>Battery</td>\n<td>电池</td>\n<td>電池</td>\n</tr>\n<tr>\n<td>プライバシー</td>\n<td>Privacy</td>\n<td>隐私</td>\n<td>隱私權</td>\n</tr>\n</tbody></table>\n<h3 id=\"（四）ストアー設定（商店设置）\"><a href=\"#（四）ストアー設定（商店设置）\" class=\"headerlink\" title=\"（四）ストアー設定（商店设置）\"></a>（四）ストアー設定（商店设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iTunes Store と App Store</td>\n<td>iTunes Store＆App Store</td>\n<td>iTunes Store 与 App Store</td>\n<td>iTunes Store 與 App Store</td>\n</tr>\n<tr>\n<td>WalletとApple Pay</td>\n<td>Wallet＆Apple Pay</td>\n<td>钱包与 Apple Pay</td>\n<td>錢包與 Apple Pay</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、操作（そうさ）\"><a href=\"#三、操作（そうさ）\" class=\"headerlink\" title=\"三、操作（そうさ）\"></a>三、操作（そうさ）</h2><p>アプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：</p>\n<table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>English</th>\n<th>汉语</th>\n<th>漢語</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OK</td>\n<td>OK</td>\n<td>好的</td>\n<td>好的</td>\n</tr>\n<tr>\n<td>確認</td>\n<td>Comfirm</td>\n<td>确定</td>\n<td>確定</td>\n</tr>\n<tr>\n<td>キャンセル</td>\n<td>Cancel</td>\n<td>取消</td>\n<td>取消</td>\n</tr>\n<tr>\n<td>完了（かんりょう）</td>\n<td>Finish</td>\n<td>完成</td>\n<td>完成</td>\n</tr>\n<tr>\n<td>オン</td>\n<td>On</td>\n<td>开启</td>\n<td>開啟</td>\n</tr>\n<tr>\n<td>オフ</td>\n<td>Off</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>消去（しょうきょ 1）</td>\n<td>Clear</td>\n<td>清除</td>\n<td>清除</td>\n</tr>\n<tr>\n<td>検索（けんさく）</td>\n<td>Search</td>\n<td>搜索</td>\n<td>搜尋</td>\n</tr>\n<tr>\n<td>削除（さくじょ 1）</td>\n<td>Delete</td>\n<td>删除</td>\n<td>删除</td>\n</tr>\n<tr>\n<td>破棄（はき 1）</td>\n<td>Discard</td>\n<td>废弃</td>\n<td>捨棄</td>\n</tr>\n<tr>\n<td>元に戻す（もとにもどす）</td>\n<td>Undo</td>\n<td>撤消</td>\n<td>復原</td>\n</tr>\n<tr>\n<td>開く（ひらく2）</td>\n<td>Open</td>\n<td>打开</td>\n<td>打開</td>\n</tr>\n<tr>\n<td>閉じる（とじる 2）</td>\n<td>Close</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>編集（へんしゅう）</td>\n<td>Edit</td>\n<td>编辑</td>\n<td>編輯</td>\n</tr>\n<tr>\n<td>表示（ひょうじ）</td>\n<td>View</td>\n<td>查看</td>\n<td>檢視</td>\n</tr>\n<tr>\n<td>送る（おくる）</td>\n<td>Send</td>\n<td>发送</td>\n<td>發送</td>\n</tr>\n<tr>\n<td>追加（ついか）</td>\n<td>Add</td>\n<td>添加</td>\n<td>加入</td>\n</tr>\n<tr>\n<td>新着（しんちゃく）</td>\n<td>New</td>\n<td>新增</td>\n<td>新增</td>\n</tr>\n<tr>\n<td>報告（ほうこく）</td>\n<td>Report</td>\n<td>举报</td>\n<td>回報</td>\n</tr>\n<tr>\n<td>マーク</td>\n<td>Mark</td>\n<td>标记</td>\n<td>標示</td>\n</tr>\n<tr>\n<td>再生（さいせい）</td>\n<td>Play</td>\n<td>播放</td>\n<td>播放</td>\n</tr>\n<tr>\n<td>一時停止（いちじていし）</td>\n<td>Pause</td>\n<td>暂停</td>\n<td>暫停</td>\n</tr>\n<tr>\n<td>停止（ていし）</td>\n<td>Stop</td>\n<td>停止</td>\n<td>停止</td>\n</tr>\n<tr>\n<td>登録（とうろく）</td>\n<td>Sign Up</td>\n<td>注册</td>\n<td>註冊</td>\n</tr>\n<tr>\n<td>ログイン</td>\n<td>Sign In / Log In</td>\n<td>登录</td>\n<td>登入</td>\n</tr>\n<tr>\n<td>ログアウト</td>\n<td>Sign Out / Log Out</td>\n<td>退出</td>\n<td>登出 / 退出</td>\n</tr>\n</tbody></table>"},{"title":"詩經·秦風‧蒹葭 (甲子話注音版)","p":"language/min/sigêng-giamgia","_content":"\n![](sigêng-giamgia/202010060948.jpg)\n\n{% aplayer \"蒹葭\" \"Hua\" \"2020/10/06/language/min/sigêng-giamgia/蒹葭.m4a\" \"/music.png\" %}\n\n蒹葭[^1]蒼蒼[^2]，白露爲霜。所謂伊人，在水一方。溯洄[^3]從之，道阻且長。溯游[^4]從之，宛在水中央。[^5]\ngiam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.\n\n蒹葭萋萋，白露未晞[^6]。所謂伊人，在水之湄[^7]。溯洄從之，道阻且躋。溯游從之，宛在水中坻[^8]。[^9]\ngiam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².\n\n蒹葭采采，白露未已[^10]。所謂伊人，在水之涘[^11]。溯洄從之，道阻且右[^12]。溯游從之，宛在水中沚[^13]。[^14]_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².\n\n<!--more-->\n\n[^1]:\t「蒹」，荻草；「葭」，蘆草。\n\n[^2]:\t按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\n\n[^3]:\t逆著河流走。\n\n[^4]:\t順著河流走。\n\n[^5]:\t蒼、霜、方、長、央，陽部。\n\n[^6]:\t露水未乾。\n\n[^7]:\t水草交接處，即岸邊。\n\n[^8]:\t水中小沙洲。\n\n[^9]:\t萋、晞、湄、躋、坻，脂部。\n\n[^10]:\t「已」完全。言露水還未完全乾。\n\n[^11]:\t岸邊。\n\n[^12]:\t水路彎曲。\n\n[^13]:\t水中小沙洲。\n\n[^14]:\t采、已、涘、右、沚，之部。","source":"_posts/language/min/sigêng-giamgia.md","raw":"---\ntitle: 詩經·秦風‧蒹葭 (甲子話注音版)\np: language/min/sigêng-giamgia\ntags:\n- 詩經\n- 甲子話\n- 閩南語\n---\n\n![](sigêng-giamgia/202010060948.jpg)\n\n{% aplayer \"蒹葭\" \"Hua\" \"2020/10/06/language/min/sigêng-giamgia/蒹葭.m4a\" \"/music.png\" %}\n\n蒹葭[^1]蒼蒼[^2]，白露爲霜。所謂伊人，在水一方。溯洄[^3]從之，道阻且長。溯游[^4]從之，宛在水中央。[^5]\ngiam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.\n\n蒹葭萋萋，白露未晞[^6]。所謂伊人，在水之湄[^7]。溯洄從之，道阻且躋。溯游從之，宛在水中坻[^8]。[^9]\ngiam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².\n\n蒹葭采采，白露未已[^10]。所謂伊人，在水之涘[^11]。溯洄從之，道阻且右[^12]。溯游從之，宛在水中沚[^13]。[^14]_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².\n\n<!--more-->\n\n[^1]:\t「蒹」，荻草；「葭」，蘆草。\n\n[^2]:\t按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\n\n[^3]:\t逆著河流走。\n\n[^4]:\t順著河流走。\n\n[^5]:\t蒼、霜、方、長、央，陽部。\n\n[^6]:\t露水未乾。\n\n[^7]:\t水草交接處，即岸邊。\n\n[^8]:\t水中小沙洲。\n\n[^9]:\t萋、晞、湄、躋、坻，脂部。\n\n[^10]:\t「已」完全。言露水還未完全乾。\n\n[^11]:\t岸邊。\n\n[^12]:\t水路彎曲。\n\n[^13]:\t水中小沙洲。\n\n[^14]:\t采、已、涘、右、沚，之部。","slug":"language/min/sigêng-giamgia","published":1,"date":"2021-02-05T16:21:17.652Z","updated":"2021-02-05T16:21:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wod000b9a9k4atlbnyk","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><img src=\"/2021/02/06/language/min/sige%CC%82ng-giamgia/202010060948.jpg\" alt></p>\n\n        <div id=\"aplayer-HoNTUAZR\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-HoNTUAZR\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"蒹葭\",\n              author: \"Hua\",\n              url: \"2020/10/06/language/min/sigêng-giamgia/蒹葭.m4a\",\n              pic: \"/music.png\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<p>蒹葭<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「蒹」，荻草；「葭」，蘆草。\">[1]</span></a></sup>蒼蒼<sup id=\"fnref:2\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\">[2]</span></a></sup>，白露爲霜。所謂伊人，在水一方。溯洄<sup id=\"fnref:3\"><a href=\"#fn:3\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    逆著河流走。\">[3]</span></a></sup>從之，道阻且長。溯游<sup id=\"fnref:4\"><a href=\"#fn:4\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    順著河流走。\">[4]</span></a></sup>從之，宛在水中央。<sup id=\"fnref:5\"><a href=\"#fn:5\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    蒼、霜、方、長、央，陽部。\">[5]</span></a></sup><br>giam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.</p>\n<p>蒹葭萋萋，白露未晞<sup id=\"fnref:6\"><a href=\"#fn:6\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    露水未乾。\">[6]</span></a></sup>。所謂伊人，在水之湄<sup id=\"fnref:7\"><a href=\"#fn:7\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水草交接處，即岸邊。\">[7]</span></a></sup>。溯洄從之，道阻且躋。溯游從之，宛在水中坻<sup id=\"fnref:8\"><a href=\"#fn:8\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[8]</span></a></sup>。<sup id=\"fnref:9\"><a href=\"#fn:9\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    萋、晞、湄、躋、坻，脂部。\">[9]</span></a></sup><br>giam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².</p>\n<p>蒹葭采采，白露未已<sup id=\"fnref:10\"><a href=\"#fn:10\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「已」完全。言露水還未完全乾。\">[10]</span></a></sup>。所謂伊人，在水之涘<sup id=\"fnref:11\"><a href=\"#fn:11\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    岸邊。\">[11]</span></a></sup>。溯洄從之，道阻且右<sup id=\"fnref:12\"><a href=\"#fn:12\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水路彎曲。\">[12]</span></a></sup>。溯游從之，宛在水中沚<sup id=\"fnref:13\"><a href=\"#fn:13\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[13]</span></a></sup>。<sup id=\"fnref:14\"><a href=\"#fn:14\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    采、已、涘、右、沚，之部。\">[14]</span></a></sup>_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².</p>\n<span id=\"more\"></span>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<div id=\"footnotes\"><hr><div id=\"footnotelist\"><ol style=\"list-style: none; padding-left: 0; margin-left: 40px\"><li id=\"fn:1\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">1.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「蒹」，荻草；「葭」，蘆草。<a href=\"#fnref:1\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:2\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">2.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。<a href=\"#fnref:2\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:3\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">3.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">逆著河流走。<a href=\"#fnref:3\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:4\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">4.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">順著河流走。<a href=\"#fnref:4\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:5\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">5.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">蒼、霜、方、長、央，陽部。<a href=\"#fnref:5\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:6\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">6.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">露水未乾。<a href=\"#fnref:6\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:7\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">7.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水草交接處，即岸邊。<a href=\"#fnref:7\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:8\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">8.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:8\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:9\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">9.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">萋、晞、湄、躋、坻，脂部。<a href=\"#fnref:9\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:10\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">10.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「已」完全。言露水還未完全乾。<a href=\"#fnref:10\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:11\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">11.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">岸邊。<a href=\"#fnref:11\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:12\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">12.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水路彎曲。<a href=\"#fnref:12\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:13\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">13.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:13\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:14\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">14.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">采、已、涘、右、沚，之部。<a href=\"#fnref:14\" rev=\"footnote\"> ↩</a></span></li></ol></div></div>","site":{"data":{}},"excerpt":"<p><img src=\"/2021/02/06/language/min/sige%CC%82ng-giamgia/202010060948.jpg\" alt></p>\n\n        <div id=\"aplayer-HoNTUAZR\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-HoNTUAZR\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"蒹葭\",\n              author: \"Hua\",\n              url: \"2020/10/06/language/min/sigêng-giamgia/蒹葭.m4a\",\n              pic: \"/music.png\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<p>蒹葭<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「蒹」，荻草；「葭」，蘆草。\">[1]</span></a></sup>蒼蒼<sup id=\"fnref:2\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\">[2]</span></a></sup>，白露爲霜。所謂伊人，在水一方。溯洄<sup id=\"fnref:3\"><a href=\"#fn:3\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    逆著河流走。\">[3]</span></a></sup>從之，道阻且長。溯游<sup id=\"fnref:4\"><a href=\"#fn:4\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    順著河流走。\">[4]</span></a></sup>從之，宛在水中央。<sup id=\"fnref:5\"><a href=\"#fn:5\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    蒼、霜、方、長、央，陽部。\">[5]</span></a></sup><br>giam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.</p>\n<p>蒹葭萋萋，白露未晞<sup id=\"fnref:6\"><a href=\"#fn:6\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    露水未乾。\">[6]</span></a></sup>。所謂伊人，在水之湄<sup id=\"fnref:7\"><a href=\"#fn:7\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水草交接處，即岸邊。\">[7]</span></a></sup>。溯洄從之，道阻且躋。溯游從之，宛在水中坻<sup id=\"fnref:8\"><a href=\"#fn:8\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[8]</span></a></sup>。<sup id=\"fnref:9\"><a href=\"#fn:9\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    萋、晞、湄、躋、坻，脂部。\">[9]</span></a></sup><br>giam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².</p>\n<p>蒹葭采采，白露未已<sup id=\"fnref:10\"><a href=\"#fn:10\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「已」完全。言露水還未完全乾。\">[10]</span></a></sup>。所謂伊人，在水之涘<sup id=\"fnref:11\"><a href=\"#fn:11\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    岸邊。\">[11]</span></a></sup>。溯洄從之，道阻且右<sup id=\"fnref:12\"><a href=\"#fn:12\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水路彎曲。\">[12]</span></a></sup>。溯游從之，宛在水中沚<sup id=\"fnref:13\"><a href=\"#fn:13\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[13]</span></a></sup>。<sup id=\"fnref:14\"><a href=\"#fn:14\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    采、已、涘、右、沚，之部。\">[14]</span></a></sup>_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².</p>","more":"<div id=\"footnotes\"><hr><div id=\"footnotelist\"><ol style=\"list-style: none; padding-left: 0; margin-left: 40px\"><li id=\"fn:1\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">1.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「蒹」，荻草；「葭」，蘆草。<a href=\"#fnref:1\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:2\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">2.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。<a href=\"#fnref:2\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:3\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">3.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">逆著河流走。<a href=\"#fnref:3\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:4\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">4.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">順著河流走。<a href=\"#fnref:4\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:5\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">5.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">蒼、霜、方、長、央，陽部。<a href=\"#fnref:5\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:6\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">6.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">露水未乾。<a href=\"#fnref:6\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:7\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">7.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水草交接處，即岸邊。<a href=\"#fnref:7\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:8\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">8.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:8\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:9\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">9.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">萋、晞、湄、躋、坻，脂部。<a href=\"#fnref:9\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:10\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">10.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「已」完全。言露水還未完全乾。<a href=\"#fnref:10\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:11\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">11.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">岸邊。<a href=\"#fnref:11\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:12\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">12.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水路彎曲。<a href=\"#fnref:12\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:13\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">13.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:13\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:14\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">14.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">采、已、涘、右、沚，之部。<a href=\"#fnref:14\" rev=\"footnote\"> ↩</a></span></li></ol></div></div>"},{"title":"在潮劇中學之《玉堂春》","p":"language/min/teochew-opera-ghêgdengcung","_content":"\n潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。\n\n潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）\n\n<!--more-->\n\n今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n## 故事概要\n蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。\n\n另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。\n\n恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。\n\n在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。\n\n網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：\n- 明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。\n- 20世紀30年代，**林如烈**編導《王金龍》，即《玉堂春》。\n-  1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。\n- 1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計**黃欽賜**，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。\n\n## 潮劇筆記\n\n### 上集第一場 \n故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。\n1. 5:01 衋(gêg⁴)心：傷心。\n2. 5:13 煩惱(huang⁵ lo²)：擔心。\n3. 5:22 變(bin³)作寶。\n4. 5:44 相(siên³)輔：幫忙。\n5. 5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。\n6. 7:24 鴇(bao²)婆。\n7. 9:12 人客：客人。\n8. 10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。\n9. 10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。\n10. 10:55 十五貫錢，買作菜脯，儉儉好食一年。\n11. 10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。\n12. 11:27 個面七個空，怎知汝是乜人。\n13. 11:37 縣衙(guin⁷ ghê⁵)。\n14. 11:41 頭欹欹(ki¹)：歪頭狀。\n15. 11:57 常來常往，若敢胡來，就著知慘。\n16. 12:47 稍(ciao²)候。\n17. 13:10 至切：一定。如：至切勿上錯牀。\n18. 15:04 吃(ngeg⁴)。\n19. 15:48 參詳：商量。如：這事好參詳。\n20. 15:49 偪側(bêg⁴ cêg⁴)：逼迫。\n21. 16:14 娉婷(pêng³ têng⁵)。\n22. 16:53 後生人：年輕人。\n23. 16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。\n24. 17:03 愈更：更加。如：愈更胡說。\n25. 17:20 強扭之瓜不甜，強掰之花不香。\n26. 17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。\n\n### 上集第二場\n故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。\n1. 21:14王(hêng⁵)瓊。\n2. 23:09 才華洋溢(iang⁵ êg⁸)。\n3. 25:12 鴛鴦(uang¹ iang¹)。\n4. 27:56 絢(sung¹)麗。\n5. 28:09 秦樓楚館煙(ing¹)花地。\n6. 30:30 銅錢落草草會青，豈容坐食破大家。\n7. 30:42 仔細：客氣。如：免仔細。\n8. 30:43 熟人免行生(cên¹)禮(loi²)。\n9. 32:02 一朝無食夫妻無義。\n10. 33:33 沈溺(dim⁵ nêg⁸)。\n11. 33:33 紈絝(iang⁵ kou³)子弟。\n12. 33:51 戰戰兢兢(kêng¹)。\n13. 35:08 食罪陷百罹(li⁵)。\n14. 38:15 鵬程(pong⁵ têng⁵)。\n15. 38:30 擔承：承擔。\n16. 39:25 畜(têg⁴)生。\n17. 40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。\n18. 40:13 如其不然。\n\n### 上集第三場 關王廟♥️\n![](teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png)\n故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。\n1. 41:40 奇事年年有，無年奇相同。\n2. 42:00 花子(hua¹ ze²)：叫花子。\n3. 42:13 庵寺：尼寺、僧寺的通稱。\n4. 42:24 照書行事。\n5. 44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。\n6. 45:16 殷勤(heng¹ keng⁵)。\n7. 46:57 人事不省(sêng³)。\n8. 48:12 五行：面相，處境。\n9. 48:37 忍淚吞聲(sêng¹)。\n10. 49:35 訴(su³)苦。\n11. 49:35 顏(nguang⁵)色。\n12. 50:13 烏雲密佈(bu³)。\n13. 50:24 時運不濟。\n14. 52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。\n15. 53:52 坫(diam³)：躲藏。如：走去坫牀下。\n16. 55:09 祭奠(diang⁶)。\n17. 56:14 齊備(ci⁵ bi⁶)：齊全完備。\n18. 56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。\n19. 1:00:27 愁雲冉冉難見晴空。\n20. 1:00:49 飛禍疊(tah⁸)至慘無窮。\n21. 1:01:13 噩耗(ngag⁸ ho³)。\n22. 1:04:35 衣衫襤褸(nam⁵ nu²)。\n23. 1:05:08 邂逅(hai⁶ hou⁶)。\n24. 1:05:44 一霎(siab⁴)時。\n25. 1:07:09 果(guan²)然。\n26. 1:07:17 妾願隨君陰曹去，從此聚首不分離。\n27. 1:09:23 嗟嘆(za¹ tam³)。\n28. 1:09:55 寂寞(sog⁴ mog⁸)。\n29. 1:10:49 啜(coih⁴)泣。\n30. 1:11:43 甌：大碗。\n31. 1:11:44 箸：筷子。\n32. 1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。\n33. 1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。\n34. 1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。\n\n### 上集第四場\n故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。\n1. 1:19:22 未是孥囝砌宮闈，騙汝好怎呢？\n2. 1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」\n3. 1:22:48 主僕(bog⁸)。\n4. 1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。\n5. 1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。\n6. 1:26:29 惆悵(tiu⁵ ziang³)。\n7. 1:26:46 贖(sog⁸)身。\n8. 1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。\n9. 1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？\n\n### 上集第五場\n故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。\n1. 1:34:11 眼中釘(ding¹/dêng¹)。\n2. 1:40:47 聰穎(kêng²)。\n3. 1:41:22 物輕意重。\n4. 1:42:26 狗母蛇假龍。\n5. 1:42:45 好心分你作歹意。\n6. 1:42:56 皮燈籠，肚內明。\n7. 1:43:45 二山相疊出出出。\n8. 1:48:16 拖三延四。\n9. 1:51:36 糙米錔(tag⁴)空臼(ku⁶)。\n\n### 上集第六場 縣衙公堂\n故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。\n1. 2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。\n2. 2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。\n3. 2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。\n4. 2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。\n5. 2:05:40 好貨墊底。\n6. 2:09:42 砒(bi¹)霜。\n7. 2:11:02 舵(dua⁶)。如：轉舵往回走。\n8. 2:14:41 因依：原委、緣由。如：時晴時雨何因依。\n9. 2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。\n10. 2:17:32 死牢(lo⁵)。\n\n### 下集第一場\n故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。\n1. 名譽(u⁶)。\n2. 花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。\n3. 蹺蹊(kiao¹ ki¹)：蹊蹺。\n\n### 下集第二場 荒野 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png)\n故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。\n1. 2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。\n2. 2:36:54 跋涉(buag⁸ siab⁴)。\n3. 2:37:35 拚駁：盡力辯駁。\n4. 2:41:20 勿許生哩免這生，欲許生哩著這生。\n5. 2:42:18 含冤負屈。\n6. 2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。\n7. 2:49:18 一死如死，現死駁賒死。\n8. 2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。\n9. 2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。\n\n### 下集第三場 太原府公堂 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png)\n故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。\n1. 2:55:28布(bu³)政使(sai³)，官名。\n2. 2:59:24寸步難行(hêng⁵)。\n3. 3:03:13 昏厥(kiag⁴)。\n4. 3:12:26 修葺(cib⁴)。\n5. 3:16:50 梟(hiao¹)情絕義：無情無義。\n6. 3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。\n\n### 下集第四場\n故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。\n1. 3:28:46 金釵(toi¹)。\n2. 3:29:16 擺宴(ang³)。\n3. 3:31:55 家無常禮(li²)。\n\n### 下集第五場♥️ 城外五里亭（梅亭）\n![](teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png)\n故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。\n1. 3:37:56 怨疊疊(tah⁸)，恨重重。\n2. 3:41:05 履(li²)薄衣單(dang¹)。\n3. 3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。\n4. 3:44:04 坐摩(mua⁵)些。摩，近。\n5. 3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。\n6. 3:55:39 啱(ngam¹)：恰好。\n7. 3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。\n8. 4:01:06 假惺惺(sêng¹)。\n9. 4:01:07 寒夜無燈心自明。\n10. 4:08:46 失寵(tong²)。\n11. 4:17:10 珍重(diang¹ dong⁶)。\n12. 4:19:12 草芥(gai⁶)。如：功名利祿如草芥。\n\n### 下集第六場\n故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。\n1. 4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。\n2. 4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。\n3. 4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。\n","source":"_posts/language/min/teochew-opera-ghêgdengcung.md","raw":"---\ntitle: 在潮劇中學之《玉堂春》\np: language/min/teochew-opera-ghêgdengcung\ntags:\n- 潮劇\n- 潮州話\n- 閩南語\n---\n\n潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。\n\n潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）\n\n<!--more-->\n\n今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n## 故事概要\n蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。\n\n另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。\n\n恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。\n\n在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。\n\n網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：\n- 明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。\n- 20世紀30年代，**林如烈**編導《王金龍》，即《玉堂春》。\n-  1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。\n- 1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計**黃欽賜**，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。\n\n## 潮劇筆記\n\n### 上集第一場 \n故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。\n1. 5:01 衋(gêg⁴)心：傷心。\n2. 5:13 煩惱(huang⁵ lo²)：擔心。\n3. 5:22 變(bin³)作寶。\n4. 5:44 相(siên³)輔：幫忙。\n5. 5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。\n6. 7:24 鴇(bao²)婆。\n7. 9:12 人客：客人。\n8. 10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。\n9. 10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。\n10. 10:55 十五貫錢，買作菜脯，儉儉好食一年。\n11. 10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。\n12. 11:27 個面七個空，怎知汝是乜人。\n13. 11:37 縣衙(guin⁷ ghê⁵)。\n14. 11:41 頭欹欹(ki¹)：歪頭狀。\n15. 11:57 常來常往，若敢胡來，就著知慘。\n16. 12:47 稍(ciao²)候。\n17. 13:10 至切：一定。如：至切勿上錯牀。\n18. 15:04 吃(ngeg⁴)。\n19. 15:48 參詳：商量。如：這事好參詳。\n20. 15:49 偪側(bêg⁴ cêg⁴)：逼迫。\n21. 16:14 娉婷(pêng³ têng⁵)。\n22. 16:53 後生人：年輕人。\n23. 16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。\n24. 17:03 愈更：更加。如：愈更胡說。\n25. 17:20 強扭之瓜不甜，強掰之花不香。\n26. 17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。\n\n### 上集第二場\n故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。\n1. 21:14王(hêng⁵)瓊。\n2. 23:09 才華洋溢(iang⁵ êg⁸)。\n3. 25:12 鴛鴦(uang¹ iang¹)。\n4. 27:56 絢(sung¹)麗。\n5. 28:09 秦樓楚館煙(ing¹)花地。\n6. 30:30 銅錢落草草會青，豈容坐食破大家。\n7. 30:42 仔細：客氣。如：免仔細。\n8. 30:43 熟人免行生(cên¹)禮(loi²)。\n9. 32:02 一朝無食夫妻無義。\n10. 33:33 沈溺(dim⁵ nêg⁸)。\n11. 33:33 紈絝(iang⁵ kou³)子弟。\n12. 33:51 戰戰兢兢(kêng¹)。\n13. 35:08 食罪陷百罹(li⁵)。\n14. 38:15 鵬程(pong⁵ têng⁵)。\n15. 38:30 擔承：承擔。\n16. 39:25 畜(têg⁴)生。\n17. 40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。\n18. 40:13 如其不然。\n\n### 上集第三場 關王廟♥️\n![](teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png)\n故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。\n1. 41:40 奇事年年有，無年奇相同。\n2. 42:00 花子(hua¹ ze²)：叫花子。\n3. 42:13 庵寺：尼寺、僧寺的通稱。\n4. 42:24 照書行事。\n5. 44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。\n6. 45:16 殷勤(heng¹ keng⁵)。\n7. 46:57 人事不省(sêng³)。\n8. 48:12 五行：面相，處境。\n9. 48:37 忍淚吞聲(sêng¹)。\n10. 49:35 訴(su³)苦。\n11. 49:35 顏(nguang⁵)色。\n12. 50:13 烏雲密佈(bu³)。\n13. 50:24 時運不濟。\n14. 52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。\n15. 53:52 坫(diam³)：躲藏。如：走去坫牀下。\n16. 55:09 祭奠(diang⁶)。\n17. 56:14 齊備(ci⁵ bi⁶)：齊全完備。\n18. 56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。\n19. 1:00:27 愁雲冉冉難見晴空。\n20. 1:00:49 飛禍疊(tah⁸)至慘無窮。\n21. 1:01:13 噩耗(ngag⁸ ho³)。\n22. 1:04:35 衣衫襤褸(nam⁵ nu²)。\n23. 1:05:08 邂逅(hai⁶ hou⁶)。\n24. 1:05:44 一霎(siab⁴)時。\n25. 1:07:09 果(guan²)然。\n26. 1:07:17 妾願隨君陰曹去，從此聚首不分離。\n27. 1:09:23 嗟嘆(za¹ tam³)。\n28. 1:09:55 寂寞(sog⁴ mog⁸)。\n29. 1:10:49 啜(coih⁴)泣。\n30. 1:11:43 甌：大碗。\n31. 1:11:44 箸：筷子。\n32. 1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。\n33. 1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。\n34. 1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。\n\n### 上集第四場\n故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。\n1. 1:19:22 未是孥囝砌宮闈，騙汝好怎呢？\n2. 1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」\n3. 1:22:48 主僕(bog⁸)。\n4. 1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。\n5. 1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。\n6. 1:26:29 惆悵(tiu⁵ ziang³)。\n7. 1:26:46 贖(sog⁸)身。\n8. 1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。\n9. 1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？\n\n### 上集第五場\n故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。\n1. 1:34:11 眼中釘(ding¹/dêng¹)。\n2. 1:40:47 聰穎(kêng²)。\n3. 1:41:22 物輕意重。\n4. 1:42:26 狗母蛇假龍。\n5. 1:42:45 好心分你作歹意。\n6. 1:42:56 皮燈籠，肚內明。\n7. 1:43:45 二山相疊出出出。\n8. 1:48:16 拖三延四。\n9. 1:51:36 糙米錔(tag⁴)空臼(ku⁶)。\n\n### 上集第六場 縣衙公堂\n故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。\n1. 2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。\n2. 2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。\n3. 2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。\n4. 2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。\n5. 2:05:40 好貨墊底。\n6. 2:09:42 砒(bi¹)霜。\n7. 2:11:02 舵(dua⁶)。如：轉舵往回走。\n8. 2:14:41 因依：原委、緣由。如：時晴時雨何因依。\n9. 2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。\n10. 2:17:32 死牢(lo⁵)。\n\n### 下集第一場\n故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。\n1. 名譽(u⁶)。\n2. 花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。\n3. 蹺蹊(kiao¹ ki¹)：蹊蹺。\n\n### 下集第二場 荒野 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png)\n故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。\n1. 2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。\n2. 2:36:54 跋涉(buag⁸ siab⁴)。\n3. 2:37:35 拚駁：盡力辯駁。\n4. 2:41:20 勿許生哩免這生，欲許生哩著這生。\n5. 2:42:18 含冤負屈。\n6. 2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。\n7. 2:49:18 一死如死，現死駁賒死。\n8. 2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。\n9. 2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。\n\n### 下集第三場 太原府公堂 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png)\n故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。\n1. 2:55:28布(bu³)政使(sai³)，官名。\n2. 2:59:24寸步難行(hêng⁵)。\n3. 3:03:13 昏厥(kiag⁴)。\n4. 3:12:26 修葺(cib⁴)。\n5. 3:16:50 梟(hiao¹)情絕義：無情無義。\n6. 3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。\n\n### 下集第四場\n故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。\n1. 3:28:46 金釵(toi¹)。\n2. 3:29:16 擺宴(ang³)。\n3. 3:31:55 家無常禮(li²)。\n\n### 下集第五場♥️ 城外五里亭（梅亭）\n![](teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png)\n故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。\n1. 3:37:56 怨疊疊(tah⁸)，恨重重。\n2. 3:41:05 履(li²)薄衣單(dang¹)。\n3. 3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。\n4. 3:44:04 坐摩(mua⁵)些。摩，近。\n5. 3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。\n6. 3:55:39 啱(ngam¹)：恰好。\n7. 3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。\n8. 4:01:06 假惺惺(sêng¹)。\n9. 4:01:07 寒夜無燈心自明。\n10. 4:08:46 失寵(tong²)。\n11. 4:17:10 珍重(diang¹ dong⁶)。\n12. 4:19:12 草芥(gai⁶)。如：功名利祿如草芥。\n\n### 下集第六場\n故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。\n1. 4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。\n2. 4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。\n3. 4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。\n","slug":"language/min/teochew-opera-ghêgdengcung","published":1,"date":"2021-02-05T16:21:17.702Z","updated":"2021-02-05T16:21:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wom000y9a9khvzs32aa","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。</p>\n<p>潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）</p>\n<span id=\"more\"></span>\n\n<p>今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：</p>\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<h2 id=\"故事概要\"><a href=\"#故事概要\" class=\"headerlink\" title=\"故事概要\"></a>故事概要</h2><p>蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。</p>\n<p>另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。</p>\n<p>恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。</p>\n<p>在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。</p>\n<p>網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：</p>\n<ul>\n<li>明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。</li>\n<li>20世紀30年代，<strong>林如烈</strong>編導《王金龍》，即《玉堂春》。</li>\n<li>1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。</li>\n<li>1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計<strong>黃欽賜</strong>，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。</li>\n</ul>\n<h2 id=\"潮劇筆記\"><a href=\"#潮劇筆記\" class=\"headerlink\" title=\"潮劇筆記\"></a>潮劇筆記</h2><h3 id=\"上集第一場\"><a href=\"#上集第一場\" class=\"headerlink\" title=\"上集第一場\"></a>上集第一場</h3><p>故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。</p>\n<ol>\n<li>5:01 衋(gêg⁴)心：傷心。</li>\n<li>5:13 煩惱(huang⁵ lo²)：擔心。</li>\n<li>5:22 變(bin³)作寶。</li>\n<li>5:44 相(siên³)輔：幫忙。</li>\n<li>5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。</li>\n<li>7:24 鴇(bao²)婆。</li>\n<li>9:12 人客：客人。</li>\n<li>10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。</li>\n<li>10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。</li>\n<li>10:55 十五貫錢，買作菜脯，儉儉好食一年。</li>\n<li>10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。</li>\n<li>11:27 個面七個空，怎知汝是乜人。</li>\n<li>11:37 縣衙(guin⁷ ghê⁵)。</li>\n<li>11:41 頭欹欹(ki¹)：歪頭狀。</li>\n<li>11:57 常來常往，若敢胡來，就著知慘。</li>\n<li>12:47 稍(ciao²)候。</li>\n<li>13:10 至切：一定。如：至切勿上錯牀。</li>\n<li>15:04 吃(ngeg⁴)。</li>\n<li>15:48 參詳：商量。如：這事好參詳。</li>\n<li>15:49 偪側(bêg⁴ cêg⁴)：逼迫。</li>\n<li>16:14 娉婷(pêng³ têng⁵)。</li>\n<li>16:53 後生人：年輕人。</li>\n<li>16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。</li>\n<li>17:03 愈更：更加。如：愈更胡說。</li>\n<li>17:20 強扭之瓜不甜，強掰之花不香。</li>\n<li>17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。</li>\n</ol>\n<h3 id=\"上集第二場\"><a href=\"#上集第二場\" class=\"headerlink\" title=\"上集第二場\"></a>上集第二場</h3><p>故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。</p>\n<ol>\n<li>21:14王(hêng⁵)瓊。</li>\n<li>23:09 才華洋溢(iang⁵ êg⁸)。</li>\n<li>25:12 鴛鴦(uang¹ iang¹)。</li>\n<li>27:56 絢(sung¹)麗。</li>\n<li>28:09 秦樓楚館煙(ing¹)花地。</li>\n<li>30:30 銅錢落草草會青，豈容坐食破大家。</li>\n<li>30:42 仔細：客氣。如：免仔細。</li>\n<li>30:43 熟人免行生(cên¹)禮(loi²)。</li>\n<li>32:02 一朝無食夫妻無義。</li>\n<li>33:33 沈溺(dim⁵ nêg⁸)。</li>\n<li>33:33 紈絝(iang⁵ kou³)子弟。</li>\n<li>33:51 戰戰兢兢(kêng¹)。</li>\n<li>35:08 食罪陷百罹(li⁵)。</li>\n<li>38:15 鵬程(pong⁵ têng⁵)。</li>\n<li>38:30 擔承：承擔。</li>\n<li>39:25 畜(têg⁴)生。</li>\n<li>40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。</li>\n<li>40:13 如其不然。</li>\n</ol>\n<h3 id=\"上集第三場-關王廟♥️\"><a href=\"#上集第三場-關王廟♥️\" class=\"headerlink\" title=\"上集第三場 關王廟♥️\"></a>上集第三場 關王廟♥️</h3><p><img src=\"/2021/02/06/language/min/teochew-opera-ghe%CC%82gdengcung/2020-10-14-12.41.34.png\" alt><br>故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。</p>\n<ol>\n<li>41:40 奇事年年有，無年奇相同。</li>\n<li>42:00 花子(hua¹ ze²)：叫花子。</li>\n<li>42:13 庵寺：尼寺、僧寺的通稱。</li>\n<li>42:24 照書行事。</li>\n<li>44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。</li>\n<li>45:16 殷勤(heng¹ keng⁵)。</li>\n<li>46:57 人事不省(sêng³)。</li>\n<li>48:12 五行：面相，處境。</li>\n<li>48:37 忍淚吞聲(sêng¹)。</li>\n<li>49:35 訴(su³)苦。</li>\n<li>49:35 顏(nguang⁵)色。</li>\n<li>50:13 烏雲密佈(bu³)。</li>\n<li>50:24 時運不濟。</li>\n<li>52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。</li>\n<li>53:52 坫(diam³)：躲藏。如：走去坫牀下。</li>\n<li>55:09 祭奠(diang⁶)。</li>\n<li>56:14 齊備(ci⁵ bi⁶)：齊全完備。</li>\n<li>56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。</li>\n<li>1:00:27 愁雲冉冉難見晴空。</li>\n<li>1:00:49 飛禍疊(tah⁸)至慘無窮。</li>\n<li>1:01:13 噩耗(ngag⁸ ho³)。</li>\n<li>1:04:35 衣衫襤褸(nam⁵ nu²)。</li>\n<li>1:05:08 邂逅(hai⁶ hou⁶)。</li>\n<li>1:05:44 一霎(siab⁴)時。</li>\n<li>1:07:09 果(guan²)然。</li>\n<li>1:07:17 妾願隨君陰曹去，從此聚首不分離。</li>\n<li>1:09:23 嗟嘆(za¹ tam³)。</li>\n<li>1:09:55 寂寞(sog⁴ mog⁸)。</li>\n<li>1:10:49 啜(coih⁴)泣。</li>\n<li>1:11:43 甌：大碗。</li>\n<li>1:11:44 箸：筷子。</li>\n<li>1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。</li>\n<li>1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。</li>\n<li>1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。</li>\n</ol>\n<h3 id=\"上集第四場\"><a href=\"#上集第四場\" class=\"headerlink\" title=\"上集第四場\"></a>上集第四場</h3><p>故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。</p>\n<ol>\n<li>1:19:22 未是孥囝砌宮闈，騙汝好怎呢？</li>\n<li>1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」</li>\n<li>1:22:48 主僕(bog⁸)。</li>\n<li>1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。</li>\n<li>1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。</li>\n<li>1:26:29 惆悵(tiu⁵ ziang³)。</li>\n<li>1:26:46 贖(sog⁸)身。</li>\n<li>1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。</li>\n<li>1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？</li>\n</ol>\n<h3 id=\"上集第五場\"><a href=\"#上集第五場\" class=\"headerlink\" title=\"上集第五場\"></a>上集第五場</h3><p>故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。</p>\n<ol>\n<li>1:34:11 眼中釘(ding¹/dêng¹)。</li>\n<li>1:40:47 聰穎(kêng²)。</li>\n<li>1:41:22 物輕意重。</li>\n<li>1:42:26 狗母蛇假龍。</li>\n<li>1:42:45 好心分你作歹意。</li>\n<li>1:42:56 皮燈籠，肚內明。</li>\n<li>1:43:45 二山相疊出出出。</li>\n<li>1:48:16 拖三延四。</li>\n<li>1:51:36 糙米錔(tag⁴)空臼(ku⁶)。</li>\n</ol>\n<h3 id=\"上集第六場-縣衙公堂\"><a href=\"#上集第六場-縣衙公堂\" class=\"headerlink\" title=\"上集第六場 縣衙公堂\"></a>上集第六場 縣衙公堂</h3><p>故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。</p>\n<ol>\n<li>2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。</li>\n<li>2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。</li>\n<li>2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。</li>\n<li>2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。</li>\n<li>2:05:40 好貨墊底。</li>\n<li>2:09:42 砒(bi¹)霜。</li>\n<li>2:11:02 舵(dua⁶)。如：轉舵往回走。</li>\n<li>2:14:41 因依：原委、緣由。如：時晴時雨何因依。</li>\n<li>2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。</li>\n<li>2:17:32 死牢(lo⁵)。</li>\n</ol>\n<h3 id=\"下集第一場\"><a href=\"#下集第一場\" class=\"headerlink\" title=\"下集第一場\"></a>下集第一場</h3><p>故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。</p>\n<ol>\n<li>名譽(u⁶)。</li>\n<li>花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。</li>\n<li>蹺蹊(kiao¹ ki¹)：蹊蹺。</li>\n</ol>\n<h3 id=\"下集第二場-荒野-♥️\"><a href=\"#下集第二場-荒野-♥️\" class=\"headerlink\" title=\"下集第二場 荒野 ♥️\"></a>下集第二場 荒野 ♥️</h3><p><img src=\"/2021/02/06/language/min/teochew-opera-ghe%CC%82gdengcung/2020-10-15-1.10.20.png\" alt><br>故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。</p>\n<ol>\n<li>2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。</li>\n<li>2:36:54 跋涉(buag⁸ siab⁴)。</li>\n<li>2:37:35 拚駁：盡力辯駁。</li>\n<li>2:41:20 勿許生哩免這生，欲許生哩著這生。</li>\n<li>2:42:18 含冤負屈。</li>\n<li>2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。</li>\n<li>2:49:18 一死如死，現死駁賒死。</li>\n<li>2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。</li>\n<li>2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。</li>\n</ol>\n<h3 id=\"下集第三場-太原府公堂-♥️\"><a href=\"#下集第三場-太原府公堂-♥️\" class=\"headerlink\" title=\"下集第三場 太原府公堂 ♥️\"></a>下集第三場 太原府公堂 ♥️</h3><p><img src=\"/2021/02/06/language/min/teochew-opera-ghe%CC%82gdengcung/2020-10-15-1.11.30.png\" alt><br>故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。</p>\n<ol>\n<li>2:55:28布(bu³)政使(sai³)，官名。</li>\n<li>2:59:24寸步難行(hêng⁵)。</li>\n<li>3:03:13 昏厥(kiag⁴)。</li>\n<li>3:12:26 修葺(cib⁴)。</li>\n<li>3:16:50 梟(hiao¹)情絕義：無情無義。</li>\n<li>3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。</li>\n</ol>\n<h3 id=\"下集第四場\"><a href=\"#下集第四場\" class=\"headerlink\" title=\"下集第四場\"></a>下集第四場</h3><p>故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。</p>\n<ol>\n<li>3:28:46 金釵(toi¹)。</li>\n<li>3:29:16 擺宴(ang³)。</li>\n<li>3:31:55 家無常禮(li²)。</li>\n</ol>\n<h3 id=\"下集第五場♥️-城外五里亭（梅亭）\"><a href=\"#下集第五場♥️-城外五里亭（梅亭）\" class=\"headerlink\" title=\"下集第五場♥️ 城外五里亭（梅亭）\"></a>下集第五場♥️ 城外五里亭（梅亭）</h3><p><img src=\"/2021/02/06/language/min/teochew-opera-ghe%CC%82gdengcung/2020-10-15-1.12.28.png\" alt><br>故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。</p>\n<ol>\n<li>3:37:56 怨疊疊(tah⁸)，恨重重。</li>\n<li>3:41:05 履(li²)薄衣單(dang¹)。</li>\n<li>3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。</li>\n<li>3:44:04 坐摩(mua⁵)些。摩，近。</li>\n<li>3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。</li>\n<li>3:55:39 啱(ngam¹)：恰好。</li>\n<li>3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。</li>\n<li>4:01:06 假惺惺(sêng¹)。</li>\n<li>4:01:07 寒夜無燈心自明。</li>\n<li>4:08:46 失寵(tong²)。</li>\n<li>4:17:10 珍重(diang¹ dong⁶)。</li>\n<li>4:19:12 草芥(gai⁶)。如：功名利祿如草芥。</li>\n</ol>\n<h3 id=\"下集第六場\"><a href=\"#下集第六場\" class=\"headerlink\" title=\"下集第六場\"></a>下集第六場</h3><p>故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。</p>\n<ol>\n<li>4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。</li>\n<li>4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。</li>\n<li>4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。</p>\n<p>潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）</p>","more":"<p>今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：</p>\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<h2 id=\"故事概要\"><a href=\"#故事概要\" class=\"headerlink\" title=\"故事概要\"></a>故事概要</h2><p>蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。</p>\n<p>另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。</p>\n<p>恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。</p>\n<p>在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。</p>\n<p>網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：</p>\n<ul>\n<li>明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。</li>\n<li>20世紀30年代，<strong>林如烈</strong>編導《王金龍》，即《玉堂春》。</li>\n<li>1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。</li>\n<li>1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計<strong>黃欽賜</strong>，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。</li>\n</ul>\n<h2 id=\"潮劇筆記\"><a href=\"#潮劇筆記\" class=\"headerlink\" title=\"潮劇筆記\"></a>潮劇筆記</h2><h3 id=\"上集第一場\"><a href=\"#上集第一場\" class=\"headerlink\" title=\"上集第一場\"></a>上集第一場</h3><p>故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。</p>\n<ol>\n<li>5:01 衋(gêg⁴)心：傷心。</li>\n<li>5:13 煩惱(huang⁵ lo²)：擔心。</li>\n<li>5:22 變(bin³)作寶。</li>\n<li>5:44 相(siên³)輔：幫忙。</li>\n<li>5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。</li>\n<li>7:24 鴇(bao²)婆。</li>\n<li>9:12 人客：客人。</li>\n<li>10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。</li>\n<li>10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。</li>\n<li>10:55 十五貫錢，買作菜脯，儉儉好食一年。</li>\n<li>10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。</li>\n<li>11:27 個面七個空，怎知汝是乜人。</li>\n<li>11:37 縣衙(guin⁷ ghê⁵)。</li>\n<li>11:41 頭欹欹(ki¹)：歪頭狀。</li>\n<li>11:57 常來常往，若敢胡來，就著知慘。</li>\n<li>12:47 稍(ciao²)候。</li>\n<li>13:10 至切：一定。如：至切勿上錯牀。</li>\n<li>15:04 吃(ngeg⁴)。</li>\n<li>15:48 參詳：商量。如：這事好參詳。</li>\n<li>15:49 偪側(bêg⁴ cêg⁴)：逼迫。</li>\n<li>16:14 娉婷(pêng³ têng⁵)。</li>\n<li>16:53 後生人：年輕人。</li>\n<li>16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。</li>\n<li>17:03 愈更：更加。如：愈更胡說。</li>\n<li>17:20 強扭之瓜不甜，強掰之花不香。</li>\n<li>17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。</li>\n</ol>\n<h3 id=\"上集第二場\"><a href=\"#上集第二場\" class=\"headerlink\" title=\"上集第二場\"></a>上集第二場</h3><p>故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。</p>\n<ol>\n<li>21:14王(hêng⁵)瓊。</li>\n<li>23:09 才華洋溢(iang⁵ êg⁸)。</li>\n<li>25:12 鴛鴦(uang¹ iang¹)。</li>\n<li>27:56 絢(sung¹)麗。</li>\n<li>28:09 秦樓楚館煙(ing¹)花地。</li>\n<li>30:30 銅錢落草草會青，豈容坐食破大家。</li>\n<li>30:42 仔細：客氣。如：免仔細。</li>\n<li>30:43 熟人免行生(cên¹)禮(loi²)。</li>\n<li>32:02 一朝無食夫妻無義。</li>\n<li>33:33 沈溺(dim⁵ nêg⁸)。</li>\n<li>33:33 紈絝(iang⁵ kou³)子弟。</li>\n<li>33:51 戰戰兢兢(kêng¹)。</li>\n<li>35:08 食罪陷百罹(li⁵)。</li>\n<li>38:15 鵬程(pong⁵ têng⁵)。</li>\n<li>38:30 擔承：承擔。</li>\n<li>39:25 畜(têg⁴)生。</li>\n<li>40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。</li>\n<li>40:13 如其不然。</li>\n</ol>\n<h3 id=\"上集第三場-關王廟♥️\"><a href=\"#上集第三場-關王廟♥️\" class=\"headerlink\" title=\"上集第三場 關王廟♥️\"></a>上集第三場 關王廟♥️</h3><p><img src=\"/2021/02/06/language/min/teochew-opera-ghe%CC%82gdengcung/2020-10-14-12.41.34.png\" alt><br>故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。</p>\n<ol>\n<li>41:40 奇事年年有，無年奇相同。</li>\n<li>42:00 花子(hua¹ ze²)：叫花子。</li>\n<li>42:13 庵寺：尼寺、僧寺的通稱。</li>\n<li>42:24 照書行事。</li>\n<li>44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。</li>\n<li>45:16 殷勤(heng¹ keng⁵)。</li>\n<li>46:57 人事不省(sêng³)。</li>\n<li>48:12 五行：面相，處境。</li>\n<li>48:37 忍淚吞聲(sêng¹)。</li>\n<li>49:35 訴(su³)苦。</li>\n<li>49:35 顏(nguang⁵)色。</li>\n<li>50:13 烏雲密佈(bu³)。</li>\n<li>50:24 時運不濟。</li>\n<li>52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。</li>\n<li>53:52 坫(diam³)：躲藏。如：走去坫牀下。</li>\n<li>55:09 祭奠(diang⁶)。</li>\n<li>56:14 齊備(ci⁵ bi⁶)：齊全完備。</li>\n<li>56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。</li>\n<li>1:00:27 愁雲冉冉難見晴空。</li>\n<li>1:00:49 飛禍疊(tah⁸)至慘無窮。</li>\n<li>1:01:13 噩耗(ngag⁸ ho³)。</li>\n<li>1:04:35 衣衫襤褸(nam⁵ nu²)。</li>\n<li>1:05:08 邂逅(hai⁶ hou⁶)。</li>\n<li>1:05:44 一霎(siab⁴)時。</li>\n<li>1:07:09 果(guan²)然。</li>\n<li>1:07:17 妾願隨君陰曹去，從此聚首不分離。</li>\n<li>1:09:23 嗟嘆(za¹ tam³)。</li>\n<li>1:09:55 寂寞(sog⁴ mog⁸)。</li>\n<li>1:10:49 啜(coih⁴)泣。</li>\n<li>1:11:43 甌：大碗。</li>\n<li>1:11:44 箸：筷子。</li>\n<li>1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。</li>\n<li>1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。</li>\n<li>1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。</li>\n</ol>\n<h3 id=\"上集第四場\"><a href=\"#上集第四場\" class=\"headerlink\" title=\"上集第四場\"></a>上集第四場</h3><p>故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。</p>\n<ol>\n<li>1:19:22 未是孥囝砌宮闈，騙汝好怎呢？</li>\n<li>1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」</li>\n<li>1:22:48 主僕(bog⁸)。</li>\n<li>1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。</li>\n<li>1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。</li>\n<li>1:26:29 惆悵(tiu⁵ ziang³)。</li>\n<li>1:26:46 贖(sog⁸)身。</li>\n<li>1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。</li>\n<li>1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？</li>\n</ol>\n<h3 id=\"上集第五場\"><a href=\"#上集第五場\" class=\"headerlink\" title=\"上集第五場\"></a>上集第五場</h3><p>故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。</p>\n<ol>\n<li>1:34:11 眼中釘(ding¹/dêng¹)。</li>\n<li>1:40:47 聰穎(kêng²)。</li>\n<li>1:41:22 物輕意重。</li>\n<li>1:42:26 狗母蛇假龍。</li>\n<li>1:42:45 好心分你作歹意。</li>\n<li>1:42:56 皮燈籠，肚內明。</li>\n<li>1:43:45 二山相疊出出出。</li>\n<li>1:48:16 拖三延四。</li>\n<li>1:51:36 糙米錔(tag⁴)空臼(ku⁶)。</li>\n</ol>\n<h3 id=\"上集第六場-縣衙公堂\"><a href=\"#上集第六場-縣衙公堂\" class=\"headerlink\" title=\"上集第六場 縣衙公堂\"></a>上集第六場 縣衙公堂</h3><p>故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。</p>\n<ol>\n<li>2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。</li>\n<li>2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。</li>\n<li>2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。</li>\n<li>2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。</li>\n<li>2:05:40 好貨墊底。</li>\n<li>2:09:42 砒(bi¹)霜。</li>\n<li>2:11:02 舵(dua⁶)。如：轉舵往回走。</li>\n<li>2:14:41 因依：原委、緣由。如：時晴時雨何因依。</li>\n<li>2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。</li>\n<li>2:17:32 死牢(lo⁵)。</li>\n</ol>\n<h3 id=\"下集第一場\"><a href=\"#下集第一場\" class=\"headerlink\" title=\"下集第一場\"></a>下集第一場</h3><p>故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。</p>\n<ol>\n<li>名譽(u⁶)。</li>\n<li>花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。</li>\n<li>蹺蹊(kiao¹ ki¹)：蹊蹺。</li>\n</ol>\n<h3 id=\"下集第二場-荒野-♥️\"><a href=\"#下集第二場-荒野-♥️\" class=\"headerlink\" title=\"下集第二場 荒野 ♥️\"></a>下集第二場 荒野 ♥️</h3><p><img src=\"/2021/02/06/language/min/teochew-opera-ghe%CC%82gdengcung/2020-10-15-1.10.20.png\" alt><br>故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。</p>\n<ol>\n<li>2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。</li>\n<li>2:36:54 跋涉(buag⁸ siab⁴)。</li>\n<li>2:37:35 拚駁：盡力辯駁。</li>\n<li>2:41:20 勿許生哩免這生，欲許生哩著這生。</li>\n<li>2:42:18 含冤負屈。</li>\n<li>2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。</li>\n<li>2:49:18 一死如死，現死駁賒死。</li>\n<li>2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。</li>\n<li>2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。</li>\n</ol>\n<h3 id=\"下集第三場-太原府公堂-♥️\"><a href=\"#下集第三場-太原府公堂-♥️\" class=\"headerlink\" title=\"下集第三場 太原府公堂 ♥️\"></a>下集第三場 太原府公堂 ♥️</h3><p><img src=\"/2021/02/06/language/min/teochew-opera-ghe%CC%82gdengcung/2020-10-15-1.11.30.png\" alt><br>故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。</p>\n<ol>\n<li>2:55:28布(bu³)政使(sai³)，官名。</li>\n<li>2:59:24寸步難行(hêng⁵)。</li>\n<li>3:03:13 昏厥(kiag⁴)。</li>\n<li>3:12:26 修葺(cib⁴)。</li>\n<li>3:16:50 梟(hiao¹)情絕義：無情無義。</li>\n<li>3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。</li>\n</ol>\n<h3 id=\"下集第四場\"><a href=\"#下集第四場\" class=\"headerlink\" title=\"下集第四場\"></a>下集第四場</h3><p>故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。</p>\n<ol>\n<li>3:28:46 金釵(toi¹)。</li>\n<li>3:29:16 擺宴(ang³)。</li>\n<li>3:31:55 家無常禮(li²)。</li>\n</ol>\n<h3 id=\"下集第五場♥️-城外五里亭（梅亭）\"><a href=\"#下集第五場♥️-城外五里亭（梅亭）\" class=\"headerlink\" title=\"下集第五場♥️ 城外五里亭（梅亭）\"></a>下集第五場♥️ 城外五里亭（梅亭）</h3><p><img src=\"/2021/02/06/language/min/teochew-opera-ghe%CC%82gdengcung/2020-10-15-1.12.28.png\" alt><br>故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。</p>\n<ol>\n<li>3:37:56 怨疊疊(tah⁸)，恨重重。</li>\n<li>3:41:05 履(li²)薄衣單(dang¹)。</li>\n<li>3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。</li>\n<li>3:44:04 坐摩(mua⁵)些。摩，近。</li>\n<li>3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。</li>\n<li>3:55:39 啱(ngam¹)：恰好。</li>\n<li>3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。</li>\n<li>4:01:06 假惺惺(sêng¹)。</li>\n<li>4:01:07 寒夜無燈心自明。</li>\n<li>4:08:46 失寵(tong²)。</li>\n<li>4:17:10 珍重(diang¹ dong⁶)。</li>\n<li>4:19:12 草芥(gai⁶)。如：功名利祿如草芥。</li>\n</ol>\n<h3 id=\"下集第六場\"><a href=\"#下集第六場\" class=\"headerlink\" title=\"下集第六場\"></a>下集第六場</h3><p>故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。</p>\n<ol>\n<li>4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。</li>\n<li>4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。</li>\n<li>4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。</li>\n</ol>"},{"title":"潮州話與甲子話韻母差異（稿）","p":"language/min/vowel","_content":"\n![](teochew-kahtsi-vowel/202010042112.png)\n\n## 概述\n\n本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。\n通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。\n\n<!--more-->\n\n## 潮州 do(to) / 甲子 dê(tê)\n\n例如：\n1. do / dê：短、代、袋\n2. to / tê：退、褪、推、胎、蛻\n\n例外：\n1. do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄\n2. to / to：討、妥、唾、橢、馱、陀、沱、跎、桃\n\n## 潮州 e(eh) / 甲子 u(uh)\n\n例如：\n1. e / u：於\n2. ce / cu：蛆、此、鼠、徐\n3. de / du：豬、除、鋤、箸\n4. ge / gu：車、居、舉、齲、據、距\n5. ghe / ghu：馭、御\n6. he / hu：虛、墟、噓、許、滸、魚、漁\n7. ke / ku：去、渠、瞿\n8. le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾\n9. re / ru：爾、而、荋\n10. se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜\n11. ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 \n\n例外：\n1. ghe / ngo：語\n2. he / hê：許（～搭）\n3. keh / kig：乞（～丐）\n4. keh / koh：乞（～汝）\n5. re / ri：耳（木～）、洱、餌、貳、膩\n6. se / si：始\n\n☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：\n1. u / ngo： 吾\n2. nge / ngo： 語\n3. ngo / ngo：悟、晤、梧、寤、遇、愚\n\n## 潮州 eng / 甲子 ing、ng\n\n例如：\n1. eng / ing：恩、摁\n2. geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲\n3. ngeng / nging：銀、垠、齦、鄞、元、圓\n4. heng / hing：很、狠、恨\n5. keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）\n6. ceng / cng：倉、瘡、艙、村、床\n7. deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞\n8. keng / kng：勸、囥、糠\n9. meng / mng：晚、門、們、捫、問\n10. neng / nng：女、軟、鑽、郎、卵、浪\n11. seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算\n12. teng / tng：湯、捅、燙、褪、糖\n13. zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋\n\n例外：\n1. seng / siong 桑\n2. keng / kêng：墾、懇\n\n## 潮州 eg / 甲子 ig、iag\n\n例如：\n1. keg / kig ：仡（～佬族）\n2. keg / kiag：橛、镢\n3. ngeg / ngiag：迄、訖、屹\n\n例外：\n1. ngeg / ngib：吃\n\n## 潮州 iê(iêh) / 甲子 io(ioh)\n\n例如：\n1. iê / io：腰、姚、窯、揺\n2. iêh / ioh：約、藥\n3. biê / bio：表\n4. biê & piao / pio & biao：標、飆\n5. bhiê / bhio：描、廟\n6. ciê / cio：笑、唱\n7. ciêh / cioh：尺、席\n8. diê / dio：跳、潮\n9. diêh / dioh： 著\n10. giê / gio：叫、茄、橋\n11. hiêh / hioh：葉、頁\n12. kiêh / kioh：挈/𢭪\n13. liê / lio：撈\n14. niê / nio：兩、娘、量、讓 \n15. piê / pio：票、鰾\n16. riê / rio：尿\n17. riêh / rioh：若\n18. siê / sio：相、燒、小\n19. siêh / sioh：惜、液\n20. tiê / tio：挑、糶\n21. ziê / zio：招、蕉、少、照\n22. ziêh / zioh：質、借、石\n\n## 潮州 iên / 甲子 ion\n\n例如：\n1. iên / ion：鴦、羊、陽、楊、洋、樣\n2. ciên / cion：槍、鯧、搶、牆、象、匠\n3. diên / dion：張、長、帳、脹、賬、場、丈、趙\n4. giên / gion： 姜、強、彊\n5. hiên / hion：香、鄉\n6. kiên / kion：腔\n7. siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗\n8. ziên / zion 漿、章、樟、蔣、掌、醬、上、癢\n\n例外： \n1. diên / dio 釣（☞ 鼻音完全脫落）\n\n## 潮州 iêng(iêg) / iang(iag)\n\n例如：\n1. iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援\n2. biêng / biang：邊、砭、鞭、變、遍、便、辯\n3. ciêng / ciang：阡、遷、芊、纖、淺\n4. ciêg / ciag：切\n5. diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍\n6. giêng /giang：堅、捐、鵑、見、建、鍵\n7. hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇\n8. kiêng /kiang：虔、愆、騫、犬、乾\n9. liêng / liang：臉、連、憐、蓮、吝、躪、練\n10. miêng /miang：免、勉、娩、憫、敏、緬、腼、綿\n11. ngiêng / ngiang：妍、研、齴\n12. ngiêg / ngiag：嚙（～齒）\n\n## 潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\n\n例如：\n1. mig / mêg：默、陌\n2. ing / iang：沿、鉛\n3. mig / miag：滅、蔑\n4. zing / ziang：薦\n\n例外：\n1. ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演\n2. ing / hing：暈\n3. bing / bing：乒、賓、彬、斌、稟\n4. big / big：筆、必、畢、蓽、篳、弼\n5. bhig / bhig：蜜\n6. cing / cing：親、臣、秦\n7. cig / cig：七\n8. ding / ding：顛、振、鎮、塵、藤、陣\n9. cing / cim：襯\n10. king / king：輕、氫\n11. ling / ling：鄰、遴、嶙、麟\n12. ming / ming：民、氓、泯、眠、面\n13. mig / mig 密、蜜、冪、覓、謐\n14. ning / ning 恁\n15. ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻\n16. bing / ping：品\n17. ring / ring：人、仁、認\n18. sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛\n19. ting / ting： 烴、陳、澄\n20. zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼\n21. zing / ding 珍\n\n## 潮州 iou(iouh) / 甲子 iao(iaoh)\n\n例如：\n1. iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀\n2. biou / biao：表、婊\n3. ciou / ciao：悄、稍、朝、嘲、瞧、晁\n4. diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉\n5. giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬\n6. hiou / hiao：僥、梟、驍、曉\n7. kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑\n8. liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺\n9. miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）\n10. niou / niao：撓、裊、皺\n11. ngiou / ngiao：貓、堯\n12. piou / piao：飄、漂、嫖、樸\n13. piou / biao：標\n14. riou / riao：爪、擾、嬈、繞、饒\n15. siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶\n16. tiou / tiao：迢、挑、超、窕、柱\n17. ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭\n\n## 潮州 iong / 甲子 êng\n\n例如：\n1. iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴\n\n## 潮州 ong / iong\n\n例如：\n1. dong / diong：重、中、忠、仲\n2. rong / riong：戎、絨、茸\n3. zong / ziong：眾\n4. rong / riong：仍、扔\n5. song / siong：松、訟、誦、頌\n\n例外：\n1. cong / cong：從、充、衝\n\n## 潮州 ng / 甲子 ing\n\n例如：\n1. ng / ing：尹、隱\n2. hng / hing：軒、欣、鍁、勳、殷\n\n## 潮州 oin / 甲子 ain\n\n例如：\n1. oin / ain：閒\n2. boin / bain：斑、反、板、爿\n3. coin / cain：千、蠶\n4. doin / dain：殿\n5. goin / gain：間、肩、繭\n6. hoin / hain：蜆、還、莧\n7. koin / kain：蓋\n8. soin / sain：先\n\n例外：\n1. toin / toin：睇\n2. noin / nai：蓮（☞ 鼻音完全脫落）\n\n☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。\n\n## 潮州 uê(uêh) / 甲子 oi(oih)\n\n例如：\n1. uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛\n2. uêh / oih：划、畫\n3. buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩\n4. buê / poi：陪\n5. bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未\n6. cuê / coi：吹、炊、髓、覓\n7. duê / doi：綴、兌\n8. guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）\n9. guêh / goih：郭、橛\n10. ghuêh / ghoih8：月\n11. huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）\n12. huêh / hoih：血\n13. kuê / koi：科、蝌、課、稞、瘸\n14. kuêh / koih：缺、闕、闋\n15. muêh / moih：物\n16. muê / moi：每、糜、妹、昧、寐、魅、袂\n17. nuê / noi：餒\n18. puê / poi：皮、被、坯、胚、配、裴\n19. puêh / poih：詖、坺\n20. ruê / roi：枘、蚋、銳、睿\n21. suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅\n22. suêh / soih：說\n23. tuê / toi：頹\n24. zuê / zoi：最、襊、罪、㩼\n\n例外：\n1. bhuêh / ghoih：襪\n2. kuê / kui：盔\n3. suêh / suah：刷、涮\n\n## 潮州 uên / 甲子 oin\n\n例如：\n1. guên / goin：關、果\n2. huên / hoin：橫\n\n## 潮州 uêng(uêg) / 甲子 uang(uag)\n\n例如：\n1. uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣\n2. uêg / uag：曰、斡、鉞、越、粵\n3. buêng / puang：叛\n4. buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤\n5. bhuêng / muan：幔（☞ 後鼻音退成鼻化音）\n6. cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓\n7. cuêg / cuag：啜、綴、輟\n8. duêng / duang：端、斷、鍛、段（又音deng）、篆\n9. guêng / guang：關、觀、冠、鰥\n10. guêg / guag：決、訣、抉、玦、聒、譎\n11. guêg / kuag：括\n12. huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢\n13. huêg / huag：發、髮、乏、穴、伐、罰、閥\n14. kuêng / kuang：寬、圈、髖、權、款、蜷\n15. kuêg / kuag：擴\n16. luêng / luang：暖、戀、巒、孿、鸞、亂\n17. luêg / luag：劣\n18. muêg / muag：末、沫、秣\n19. nguêng / nguang：阮、玩、頑、元、原、源、願\n20. puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣\n21. puêng / puan：般（☞ 後鼻音退成鼻化音）\n22. puêg / puag：潑、銖\n23. ruêng / ruang：亂\n24. ruêg / ruag：悅\n25. suêng / suang：選、算（又音 seng）、旋、漩\n26. tuêng / tuang：湍、團、傳\n27. zuêng / zuang： 專、轉、鐫、顓、撰\n28. zuêg / zuag：拙、茁、咄、絀\n\n例外：\n1. bhuêng/mang：萬、饅、慢、漫\n2. kuêng /  kêng：傾、頃、卿\n3. huêng / hoin：衡\n4. huêg / hoig：或 、惑\n5. uêg / oig：獲 、域、役、鑊\n6. guêng / goin：囧、炯、耿、穎\n7. nguêng / ngiang：顏\n8. nguêng / iang：芫\n\n## 其餘\n1. 宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³\n2. 唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²\n3. 言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²\n4. 瓊、煢：潮州kuang⁵ / 甲子kêng⁵\n5. 舀：潮州 io² / 甲子ion² ","source":"_posts/language/min/teochew-kahtsi-vowel.md","raw":"---\ntitle: 潮州話與甲子話韻母差異（稿）\np: language/min/vowel\ntags:\n- 閩南語\n- 潮州話\n- 甲子話\n---\n\n![](teochew-kahtsi-vowel/202010042112.png)\n\n## 概述\n\n本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。\n通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。\n\n<!--more-->\n\n## 潮州 do(to) / 甲子 dê(tê)\n\n例如：\n1. do / dê：短、代、袋\n2. to / tê：退、褪、推、胎、蛻\n\n例外：\n1. do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄\n2. to / to：討、妥、唾、橢、馱、陀、沱、跎、桃\n\n## 潮州 e(eh) / 甲子 u(uh)\n\n例如：\n1. e / u：於\n2. ce / cu：蛆、此、鼠、徐\n3. de / du：豬、除、鋤、箸\n4. ge / gu：車、居、舉、齲、據、距\n5. ghe / ghu：馭、御\n6. he / hu：虛、墟、噓、許、滸、魚、漁\n7. ke / ku：去、渠、瞿\n8. le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾\n9. re / ru：爾、而、荋\n10. se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜\n11. ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 \n\n例外：\n1. ghe / ngo：語\n2. he / hê：許（～搭）\n3. keh / kig：乞（～丐）\n4. keh / koh：乞（～汝）\n5. re / ri：耳（木～）、洱、餌、貳、膩\n6. se / si：始\n\n☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：\n1. u / ngo： 吾\n2. nge / ngo： 語\n3. ngo / ngo：悟、晤、梧、寤、遇、愚\n\n## 潮州 eng / 甲子 ing、ng\n\n例如：\n1. eng / ing：恩、摁\n2. geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲\n3. ngeng / nging：銀、垠、齦、鄞、元、圓\n4. heng / hing：很、狠、恨\n5. keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）\n6. ceng / cng：倉、瘡、艙、村、床\n7. deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞\n8. keng / kng：勸、囥、糠\n9. meng / mng：晚、門、們、捫、問\n10. neng / nng：女、軟、鑽、郎、卵、浪\n11. seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算\n12. teng / tng：湯、捅、燙、褪、糖\n13. zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋\n\n例外：\n1. seng / siong 桑\n2. keng / kêng：墾、懇\n\n## 潮州 eg / 甲子 ig、iag\n\n例如：\n1. keg / kig ：仡（～佬族）\n2. keg / kiag：橛、镢\n3. ngeg / ngiag：迄、訖、屹\n\n例外：\n1. ngeg / ngib：吃\n\n## 潮州 iê(iêh) / 甲子 io(ioh)\n\n例如：\n1. iê / io：腰、姚、窯、揺\n2. iêh / ioh：約、藥\n3. biê / bio：表\n4. biê & piao / pio & biao：標、飆\n5. bhiê / bhio：描、廟\n6. ciê / cio：笑、唱\n7. ciêh / cioh：尺、席\n8. diê / dio：跳、潮\n9. diêh / dioh： 著\n10. giê / gio：叫、茄、橋\n11. hiêh / hioh：葉、頁\n12. kiêh / kioh：挈/𢭪\n13. liê / lio：撈\n14. niê / nio：兩、娘、量、讓 \n15. piê / pio：票、鰾\n16. riê / rio：尿\n17. riêh / rioh：若\n18. siê / sio：相、燒、小\n19. siêh / sioh：惜、液\n20. tiê / tio：挑、糶\n21. ziê / zio：招、蕉、少、照\n22. ziêh / zioh：質、借、石\n\n## 潮州 iên / 甲子 ion\n\n例如：\n1. iên / ion：鴦、羊、陽、楊、洋、樣\n2. ciên / cion：槍、鯧、搶、牆、象、匠\n3. diên / dion：張、長、帳、脹、賬、場、丈、趙\n4. giên / gion： 姜、強、彊\n5. hiên / hion：香、鄉\n6. kiên / kion：腔\n7. siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗\n8. ziên / zion 漿、章、樟、蔣、掌、醬、上、癢\n\n例外： \n1. diên / dio 釣（☞ 鼻音完全脫落）\n\n## 潮州 iêng(iêg) / iang(iag)\n\n例如：\n1. iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援\n2. biêng / biang：邊、砭、鞭、變、遍、便、辯\n3. ciêng / ciang：阡、遷、芊、纖、淺\n4. ciêg / ciag：切\n5. diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍\n6. giêng /giang：堅、捐、鵑、見、建、鍵\n7. hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇\n8. kiêng /kiang：虔、愆、騫、犬、乾\n9. liêng / liang：臉、連、憐、蓮、吝、躪、練\n10. miêng /miang：免、勉、娩、憫、敏、緬、腼、綿\n11. ngiêng / ngiang：妍、研、齴\n12. ngiêg / ngiag：嚙（～齒）\n\n## 潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\n\n例如：\n1. mig / mêg：默、陌\n2. ing / iang：沿、鉛\n3. mig / miag：滅、蔑\n4. zing / ziang：薦\n\n例外：\n1. ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演\n2. ing / hing：暈\n3. bing / bing：乒、賓、彬、斌、稟\n4. big / big：筆、必、畢、蓽、篳、弼\n5. bhig / bhig：蜜\n6. cing / cing：親、臣、秦\n7. cig / cig：七\n8. ding / ding：顛、振、鎮、塵、藤、陣\n9. cing / cim：襯\n10. king / king：輕、氫\n11. ling / ling：鄰、遴、嶙、麟\n12. ming / ming：民、氓、泯、眠、面\n13. mig / mig 密、蜜、冪、覓、謐\n14. ning / ning 恁\n15. ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻\n16. bing / ping：品\n17. ring / ring：人、仁、認\n18. sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛\n19. ting / ting： 烴、陳、澄\n20. zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼\n21. zing / ding 珍\n\n## 潮州 iou(iouh) / 甲子 iao(iaoh)\n\n例如：\n1. iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀\n2. biou / biao：表、婊\n3. ciou / ciao：悄、稍、朝、嘲、瞧、晁\n4. diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉\n5. giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬\n6. hiou / hiao：僥、梟、驍、曉\n7. kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑\n8. liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺\n9. miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）\n10. niou / niao：撓、裊、皺\n11. ngiou / ngiao：貓、堯\n12. piou / piao：飄、漂、嫖、樸\n13. piou / biao：標\n14. riou / riao：爪、擾、嬈、繞、饒\n15. siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶\n16. tiou / tiao：迢、挑、超、窕、柱\n17. ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭\n\n## 潮州 iong / 甲子 êng\n\n例如：\n1. iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴\n\n## 潮州 ong / iong\n\n例如：\n1. dong / diong：重、中、忠、仲\n2. rong / riong：戎、絨、茸\n3. zong / ziong：眾\n4. rong / riong：仍、扔\n5. song / siong：松、訟、誦、頌\n\n例外：\n1. cong / cong：從、充、衝\n\n## 潮州 ng / 甲子 ing\n\n例如：\n1. ng / ing：尹、隱\n2. hng / hing：軒、欣、鍁、勳、殷\n\n## 潮州 oin / 甲子 ain\n\n例如：\n1. oin / ain：閒\n2. boin / bain：斑、反、板、爿\n3. coin / cain：千、蠶\n4. doin / dain：殿\n5. goin / gain：間、肩、繭\n6. hoin / hain：蜆、還、莧\n7. koin / kain：蓋\n8. soin / sain：先\n\n例外：\n1. toin / toin：睇\n2. noin / nai：蓮（☞ 鼻音完全脫落）\n\n☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。\n\n## 潮州 uê(uêh) / 甲子 oi(oih)\n\n例如：\n1. uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛\n2. uêh / oih：划、畫\n3. buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩\n4. buê / poi：陪\n5. bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未\n6. cuê / coi：吹、炊、髓、覓\n7. duê / doi：綴、兌\n8. guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）\n9. guêh / goih：郭、橛\n10. ghuêh / ghoih8：月\n11. huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）\n12. huêh / hoih：血\n13. kuê / koi：科、蝌、課、稞、瘸\n14. kuêh / koih：缺、闕、闋\n15. muêh / moih：物\n16. muê / moi：每、糜、妹、昧、寐、魅、袂\n17. nuê / noi：餒\n18. puê / poi：皮、被、坯、胚、配、裴\n19. puêh / poih：詖、坺\n20. ruê / roi：枘、蚋、銳、睿\n21. suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅\n22. suêh / soih：說\n23. tuê / toi：頹\n24. zuê / zoi：最、襊、罪、㩼\n\n例外：\n1. bhuêh / ghoih：襪\n2. kuê / kui：盔\n3. suêh / suah：刷、涮\n\n## 潮州 uên / 甲子 oin\n\n例如：\n1. guên / goin：關、果\n2. huên / hoin：橫\n\n## 潮州 uêng(uêg) / 甲子 uang(uag)\n\n例如：\n1. uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣\n2. uêg / uag：曰、斡、鉞、越、粵\n3. buêng / puang：叛\n4. buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤\n5. bhuêng / muan：幔（☞ 後鼻音退成鼻化音）\n6. cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓\n7. cuêg / cuag：啜、綴、輟\n8. duêng / duang：端、斷、鍛、段（又音deng）、篆\n9. guêng / guang：關、觀、冠、鰥\n10. guêg / guag：決、訣、抉、玦、聒、譎\n11. guêg / kuag：括\n12. huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢\n13. huêg / huag：發、髮、乏、穴、伐、罰、閥\n14. kuêng / kuang：寬、圈、髖、權、款、蜷\n15. kuêg / kuag：擴\n16. luêng / luang：暖、戀、巒、孿、鸞、亂\n17. luêg / luag：劣\n18. muêg / muag：末、沫、秣\n19. nguêng / nguang：阮、玩、頑、元、原、源、願\n20. puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣\n21. puêng / puan：般（☞ 後鼻音退成鼻化音）\n22. puêg / puag：潑、銖\n23. ruêng / ruang：亂\n24. ruêg / ruag：悅\n25. suêng / suang：選、算（又音 seng）、旋、漩\n26. tuêng / tuang：湍、團、傳\n27. zuêng / zuang： 專、轉、鐫、顓、撰\n28. zuêg / zuag：拙、茁、咄、絀\n\n例外：\n1. bhuêng/mang：萬、饅、慢、漫\n2. kuêng /  kêng：傾、頃、卿\n3. huêng / hoin：衡\n4. huêg / hoig：或 、惑\n5. uêg / oig：獲 、域、役、鑊\n6. guêng / goin：囧、炯、耿、穎\n7. nguêng / ngiang：顏\n8. nguêng / iang：芫\n\n## 其餘\n1. 宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³\n2. 唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²\n3. 言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²\n4. 瓊、煢：潮州kuang⁵ / 甲子kêng⁵\n5. 舀：潮州 io² / 甲子ion² ","slug":"language/min/teochew-kahtsi-vowel","published":1,"date":"2021-02-05T16:21:17.675Z","updated":"2021-02-05T16:21:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wom000z9a9kgcw78jbg","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><img src=\"/2021/02/06/language/min/teochew-kahtsi-vowel/202010042112.png\" alt></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。<br>通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"潮州-do-to-甲子-de-te\"><a href=\"#潮州-do-to-甲子-de-te\" class=\"headerlink\" title=\"潮州 do(to) / 甲子 dê(tê)\"></a>潮州 do(to) / 甲子 dê(tê)</h2><p>例如：</p>\n<ol>\n<li>do / dê：短、代、袋</li>\n<li>to / tê：退、褪、推、胎、蛻</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄</li>\n<li>to / to：討、妥、唾、橢、馱、陀、沱、跎、桃</li>\n</ol>\n<h2 id=\"潮州-e-eh-甲子-u-uh\"><a href=\"#潮州-e-eh-甲子-u-uh\" class=\"headerlink\" title=\"潮州 e(eh) / 甲子 u(uh)\"></a>潮州 e(eh) / 甲子 u(uh)</h2><p>例如：</p>\n<ol>\n<li>e / u：於</li>\n<li>ce / cu：蛆、此、鼠、徐</li>\n<li>de / du：豬、除、鋤、箸</li>\n<li>ge / gu：車、居、舉、齲、據、距</li>\n<li>ghe / ghu：馭、御</li>\n<li>he / hu：虛、墟、噓、許、滸、魚、漁</li>\n<li>ke / ku：去、渠、瞿</li>\n<li>le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾</li>\n<li>re / ru：爾、而、荋</li>\n<li>se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜</li>\n<li>ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 </li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ghe / ngo：語</li>\n<li>he / hê：許（～搭）</li>\n<li>keh / kig：乞（～丐）</li>\n<li>keh / koh：乞（～汝）</li>\n<li>re / ri：耳（木～）、洱、餌、貳、膩</li>\n<li>se / si：始</li>\n</ol>\n<p>☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：</p>\n<ol>\n<li>u / ngo： 吾</li>\n<li>nge / ngo： 語</li>\n<li>ngo / ngo：悟、晤、梧、寤、遇、愚</li>\n</ol>\n<h2 id=\"潮州-eng-甲子-ing、ng\"><a href=\"#潮州-eng-甲子-ing、ng\" class=\"headerlink\" title=\"潮州 eng / 甲子 ing、ng\"></a>潮州 eng / 甲子 ing、ng</h2><p>例如：</p>\n<ol>\n<li>eng / ing：恩、摁</li>\n<li>geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲</li>\n<li>ngeng / nging：銀、垠、齦、鄞、元、圓</li>\n<li>heng / hing：很、狠、恨</li>\n<li>keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）</li>\n<li>ceng / cng：倉、瘡、艙、村、床</li>\n<li>deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞</li>\n<li>keng / kng：勸、囥、糠</li>\n<li>meng / mng：晚、門、們、捫、問</li>\n<li>neng / nng：女、軟、鑽、郎、卵、浪</li>\n<li>seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算</li>\n<li>teng / tng：湯、捅、燙、褪、糖</li>\n<li>zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>seng / siong 桑</li>\n<li>keng / kêng：墾、懇</li>\n</ol>\n<h2 id=\"潮州-eg-甲子-ig、iag\"><a href=\"#潮州-eg-甲子-ig、iag\" class=\"headerlink\" title=\"潮州 eg / 甲子 ig、iag\"></a>潮州 eg / 甲子 ig、iag</h2><p>例如：</p>\n<ol>\n<li>keg / kig ：仡（～佬族）</li>\n<li>keg / kiag：橛、镢</li>\n<li>ngeg / ngiag：迄、訖、屹</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ngeg / ngib：吃</li>\n</ol>\n<h2 id=\"潮州-ie-ieh-甲子-io-ioh\"><a href=\"#潮州-ie-ieh-甲子-io-ioh\" class=\"headerlink\" title=\"潮州 iê(iêh) / 甲子 io(ioh)\"></a>潮州 iê(iêh) / 甲子 io(ioh)</h2><p>例如：</p>\n<ol>\n<li>iê / io：腰、姚、窯、揺</li>\n<li>iêh / ioh：約、藥</li>\n<li>biê / bio：表</li>\n<li>biê &amp; piao / pio &amp; biao：標、飆</li>\n<li>bhiê / bhio：描、廟</li>\n<li>ciê / cio：笑、唱</li>\n<li>ciêh / cioh：尺、席</li>\n<li>diê / dio：跳、潮</li>\n<li>diêh / dioh： 著</li>\n<li>giê / gio：叫、茄、橋</li>\n<li>hiêh / hioh：葉、頁</li>\n<li>kiêh / kioh：挈/𢭪</li>\n<li>liê / lio：撈</li>\n<li>niê / nio：兩、娘、量、讓 </li>\n<li>piê / pio：票、鰾</li>\n<li>riê / rio：尿</li>\n<li>riêh / rioh：若</li>\n<li>siê / sio：相、燒、小</li>\n<li>siêh / sioh：惜、液</li>\n<li>tiê / tio：挑、糶</li>\n<li>ziê / zio：招、蕉、少、照</li>\n<li>ziêh / zioh：質、借、石</li>\n</ol>\n<h2 id=\"潮州-ien-甲子-ion\"><a href=\"#潮州-ien-甲子-ion\" class=\"headerlink\" title=\"潮州 iên / 甲子 ion\"></a>潮州 iên / 甲子 ion</h2><p>例如：</p>\n<ol>\n<li>iên / ion：鴦、羊、陽、楊、洋、樣</li>\n<li>ciên / cion：槍、鯧、搶、牆、象、匠</li>\n<li>diên / dion：張、長、帳、脹、賬、場、丈、趙</li>\n<li>giên / gion： 姜、強、彊</li>\n<li>hiên / hion：香、鄉</li>\n<li>kiên / kion：腔</li>\n<li>siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗</li>\n<li>ziên / zion 漿、章、樟、蔣、掌、醬、上、癢</li>\n</ol>\n<p>例外： </p>\n<ol>\n<li>diên / dio 釣（☞ 鼻音完全脫落）</li>\n</ol>\n<h2 id=\"潮州-ieng-ieg-iang-iag\"><a href=\"#潮州-ieng-ieg-iang-iag\" class=\"headerlink\" title=\"潮州 iêng(iêg) / iang(iag)\"></a>潮州 iêng(iêg) / iang(iag)</h2><p>例如：</p>\n<ol>\n<li>iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援</li>\n<li>biêng / biang：邊、砭、鞭、變、遍、便、辯</li>\n<li>ciêng / ciang：阡、遷、芊、纖、淺</li>\n<li>ciêg / ciag：切</li>\n<li>diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍</li>\n<li>giêng /giang：堅、捐、鵑、見、建、鍵</li>\n<li>hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇</li>\n<li>kiêng /kiang：虔、愆、騫、犬、乾</li>\n<li>liêng / liang：臉、連、憐、蓮、吝、躪、練</li>\n<li>miêng /miang：免、勉、娩、憫、敏、緬、腼、綿</li>\n<li>ngiêng / ngiang：妍、研、齴</li>\n<li>ngiêg / ngiag：嚙（～齒）</li>\n</ol>\n<h2 id=\"潮州-ing-ig-甲子eng-eg-、-iang-iag\"><a href=\"#潮州-ing-ig-甲子eng-eg-、-iang-iag\" class=\"headerlink\" title=\"潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\"></a>潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)</h2><p>例如：</p>\n<ol>\n<li>mig / mêg：默、陌</li>\n<li>ing / iang：沿、鉛</li>\n<li>mig / miag：滅、蔑</li>\n<li>zing / ziang：薦</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演</li>\n<li>ing / hing：暈</li>\n<li>bing / bing：乒、賓、彬、斌、稟</li>\n<li>big / big：筆、必、畢、蓽、篳、弼</li>\n<li>bhig / bhig：蜜</li>\n<li>cing / cing：親、臣、秦</li>\n<li>cig / cig：七</li>\n<li>ding / ding：顛、振、鎮、塵、藤、陣</li>\n<li>cing / cim：襯</li>\n<li>king / king：輕、氫</li>\n<li>ling / ling：鄰、遴、嶙、麟</li>\n<li>ming / ming：民、氓、泯、眠、面</li>\n<li>mig / mig 密、蜜、冪、覓、謐</li>\n<li>ning / ning 恁</li>\n<li>ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻</li>\n<li>bing / ping：品</li>\n<li>ring / ring：人、仁、認</li>\n<li>sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛</li>\n<li>ting / ting： 烴、陳、澄</li>\n<li>zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼</li>\n<li>zing / ding 珍</li>\n</ol>\n<h2 id=\"潮州-iou-iouh-甲子-iao-iaoh\"><a href=\"#潮州-iou-iouh-甲子-iao-iaoh\" class=\"headerlink\" title=\"潮州 iou(iouh) / 甲子 iao(iaoh)\"></a>潮州 iou(iouh) / 甲子 iao(iaoh)</h2><p>例如：</p>\n<ol>\n<li>iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀</li>\n<li>biou / biao：表、婊</li>\n<li>ciou / ciao：悄、稍、朝、嘲、瞧、晁</li>\n<li>diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉</li>\n<li>giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬</li>\n<li>hiou / hiao：僥、梟、驍、曉</li>\n<li>kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑</li>\n<li>liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺</li>\n<li>miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）</li>\n<li>niou / niao：撓、裊、皺</li>\n<li>ngiou / ngiao：貓、堯</li>\n<li>piou / piao：飄、漂、嫖、樸</li>\n<li>piou / biao：標</li>\n<li>riou / riao：爪、擾、嬈、繞、饒</li>\n<li>siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶</li>\n<li>tiou / tiao：迢、挑、超、窕、柱</li>\n<li>ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭</li>\n</ol>\n<h2 id=\"潮州-iong-甲子-eng\"><a href=\"#潮州-iong-甲子-eng\" class=\"headerlink\" title=\"潮州 iong / 甲子 êng\"></a>潮州 iong / 甲子 êng</h2><p>例如：</p>\n<ol>\n<li>iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴</li>\n</ol>\n<h2 id=\"潮州-ong-iong\"><a href=\"#潮州-ong-iong\" class=\"headerlink\" title=\"潮州 ong / iong\"></a>潮州 ong / iong</h2><p>例如：</p>\n<ol>\n<li>dong / diong：重、中、忠、仲</li>\n<li>rong / riong：戎、絨、茸</li>\n<li>zong / ziong：眾</li>\n<li>rong / riong：仍、扔</li>\n<li>song / siong：松、訟、誦、頌</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>cong / cong：從、充、衝</li>\n</ol>\n<h2 id=\"潮州-ng-甲子-ing\"><a href=\"#潮州-ng-甲子-ing\" class=\"headerlink\" title=\"潮州 ng / 甲子 ing\"></a>潮州 ng / 甲子 ing</h2><p>例如：</p>\n<ol>\n<li>ng / ing：尹、隱</li>\n<li>hng / hing：軒、欣、鍁、勳、殷</li>\n</ol>\n<h2 id=\"潮州-oin-甲子-ain\"><a href=\"#潮州-oin-甲子-ain\" class=\"headerlink\" title=\"潮州 oin / 甲子 ain\"></a>潮州 oin / 甲子 ain</h2><p>例如：</p>\n<ol>\n<li>oin / ain：閒</li>\n<li>boin / bain：斑、反、板、爿</li>\n<li>coin / cain：千、蠶</li>\n<li>doin / dain：殿</li>\n<li>goin / gain：間、肩、繭</li>\n<li>hoin / hain：蜆、還、莧</li>\n<li>koin / kain：蓋</li>\n<li>soin / sain：先</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>toin / toin：睇</li>\n<li>noin / nai：蓮（☞ 鼻音完全脫落）</li>\n</ol>\n<p>☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。</p>\n<h2 id=\"潮州-ue-ueh-甲子-oi-oih\"><a href=\"#潮州-ue-ueh-甲子-oi-oih\" class=\"headerlink\" title=\"潮州 uê(uêh) / 甲子 oi(oih)\"></a>潮州 uê(uêh) / 甲子 oi(oih)</h2><p>例如：</p>\n<ol>\n<li>uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛</li>\n<li>uêh / oih：划、畫</li>\n<li>buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩</li>\n<li>buê / poi：陪</li>\n<li>bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未</li>\n<li>cuê / coi：吹、炊、髓、覓</li>\n<li>duê / doi：綴、兌</li>\n<li>guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）</li>\n<li>guêh / goih：郭、橛</li>\n<li>ghuêh / ghoih8：月</li>\n<li>huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）</li>\n<li>huêh / hoih：血</li>\n<li>kuê / koi：科、蝌、課、稞、瘸</li>\n<li>kuêh / koih：缺、闕、闋</li>\n<li>muêh / moih：物</li>\n<li>muê / moi：每、糜、妹、昧、寐、魅、袂</li>\n<li>nuê / noi：餒</li>\n<li>puê / poi：皮、被、坯、胚、配、裴</li>\n<li>puêh / poih：詖、坺</li>\n<li>ruê / roi：枘、蚋、銳、睿</li>\n<li>suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅</li>\n<li>suêh / soih：說</li>\n<li>tuê / toi：頹</li>\n<li>zuê / zoi：最、襊、罪、㩼</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêh / ghoih：襪</li>\n<li>kuê / kui：盔</li>\n<li>suêh / suah：刷、涮</li>\n</ol>\n<h2 id=\"潮州-uen-甲子-oin\"><a href=\"#潮州-uen-甲子-oin\" class=\"headerlink\" title=\"潮州 uên / 甲子 oin\"></a>潮州 uên / 甲子 oin</h2><p>例如：</p>\n<ol>\n<li>guên / goin：關、果</li>\n<li>huên / hoin：橫</li>\n</ol>\n<h2 id=\"潮州-ueng-ueg-甲子-uang-uag\"><a href=\"#潮州-ueng-ueg-甲子-uang-uag\" class=\"headerlink\" title=\"潮州 uêng(uêg) / 甲子 uang(uag)\"></a>潮州 uêng(uêg) / 甲子 uang(uag)</h2><p>例如：</p>\n<ol>\n<li>uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣</li>\n<li>uêg / uag：曰、斡、鉞、越、粵</li>\n<li>buêng / puang：叛</li>\n<li>buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤</li>\n<li>bhuêng / muan：幔（☞ 後鼻音退成鼻化音）</li>\n<li>cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓</li>\n<li>cuêg / cuag：啜、綴、輟</li>\n<li>duêng / duang：端、斷、鍛、段（又音deng）、篆</li>\n<li>guêng / guang：關、觀、冠、鰥</li>\n<li>guêg / guag：決、訣、抉、玦、聒、譎</li>\n<li>guêg / kuag：括</li>\n<li>huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢</li>\n<li>huêg / huag：發、髮、乏、穴、伐、罰、閥</li>\n<li>kuêng / kuang：寬、圈、髖、權、款、蜷</li>\n<li>kuêg / kuag：擴</li>\n<li>luêng / luang：暖、戀、巒、孿、鸞、亂</li>\n<li>luêg / luag：劣</li>\n<li>muêg / muag：末、沫、秣</li>\n<li>nguêng / nguang：阮、玩、頑、元、原、源、願</li>\n<li>puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣</li>\n<li>puêng / puan：般（☞ 後鼻音退成鼻化音）</li>\n<li>puêg / puag：潑、銖</li>\n<li>ruêng / ruang：亂</li>\n<li>ruêg / ruag：悅</li>\n<li>suêng / suang：選、算（又音 seng）、旋、漩</li>\n<li>tuêng / tuang：湍、團、傳</li>\n<li>zuêng / zuang： 專、轉、鐫、顓、撰</li>\n<li>zuêg / zuag：拙、茁、咄、絀</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêng/mang：萬、饅、慢、漫</li>\n<li>kuêng /  kêng：傾、頃、卿</li>\n<li>huêng / hoin：衡</li>\n<li>huêg / hoig：或 、惑</li>\n<li>uêg / oig：獲 、域、役、鑊</li>\n<li>guêng / goin：囧、炯、耿、穎</li>\n<li>nguêng / ngiang：顏</li>\n<li>nguêng / iang：芫</li>\n</ol>\n<h2 id=\"其餘\"><a href=\"#其餘\" class=\"headerlink\" title=\"其餘\"></a>其餘</h2><ol>\n<li>宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³</li>\n<li>唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²</li>\n<li>言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²</li>\n<li>瓊、煢：潮州kuang⁵ / 甲子kêng⁵</li>\n<li>舀：潮州 io² / 甲子ion² </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><img src=\"/2021/02/06/language/min/teochew-kahtsi-vowel/202010042112.png\" alt></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。<br>通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。</p>","more":"<h2 id=\"潮州-do-to-甲子-de-te\"><a href=\"#潮州-do-to-甲子-de-te\" class=\"headerlink\" title=\"潮州 do(to) / 甲子 dê(tê)\"></a>潮州 do(to) / 甲子 dê(tê)</h2><p>例如：</p>\n<ol>\n<li>do / dê：短、代、袋</li>\n<li>to / tê：退、褪、推、胎、蛻</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄</li>\n<li>to / to：討、妥、唾、橢、馱、陀、沱、跎、桃</li>\n</ol>\n<h2 id=\"潮州-e-eh-甲子-u-uh\"><a href=\"#潮州-e-eh-甲子-u-uh\" class=\"headerlink\" title=\"潮州 e(eh) / 甲子 u(uh)\"></a>潮州 e(eh) / 甲子 u(uh)</h2><p>例如：</p>\n<ol>\n<li>e / u：於</li>\n<li>ce / cu：蛆、此、鼠、徐</li>\n<li>de / du：豬、除、鋤、箸</li>\n<li>ge / gu：車、居、舉、齲、據、距</li>\n<li>ghe / ghu：馭、御</li>\n<li>he / hu：虛、墟、噓、許、滸、魚、漁</li>\n<li>ke / ku：去、渠、瞿</li>\n<li>le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾</li>\n<li>re / ru：爾、而、荋</li>\n<li>se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜</li>\n<li>ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 </li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ghe / ngo：語</li>\n<li>he / hê：許（～搭）</li>\n<li>keh / kig：乞（～丐）</li>\n<li>keh / koh：乞（～汝）</li>\n<li>re / ri：耳（木～）、洱、餌、貳、膩</li>\n<li>se / si：始</li>\n</ol>\n<p>☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：</p>\n<ol>\n<li>u / ngo： 吾</li>\n<li>nge / ngo： 語</li>\n<li>ngo / ngo：悟、晤、梧、寤、遇、愚</li>\n</ol>\n<h2 id=\"潮州-eng-甲子-ing、ng\"><a href=\"#潮州-eng-甲子-ing、ng\" class=\"headerlink\" title=\"潮州 eng / 甲子 ing、ng\"></a>潮州 eng / 甲子 ing、ng</h2><p>例如：</p>\n<ol>\n<li>eng / ing：恩、摁</li>\n<li>geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲</li>\n<li>ngeng / nging：銀、垠、齦、鄞、元、圓</li>\n<li>heng / hing：很、狠、恨</li>\n<li>keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）</li>\n<li>ceng / cng：倉、瘡、艙、村、床</li>\n<li>deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞</li>\n<li>keng / kng：勸、囥、糠</li>\n<li>meng / mng：晚、門、們、捫、問</li>\n<li>neng / nng：女、軟、鑽、郎、卵、浪</li>\n<li>seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算</li>\n<li>teng / tng：湯、捅、燙、褪、糖</li>\n<li>zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>seng / siong 桑</li>\n<li>keng / kêng：墾、懇</li>\n</ol>\n<h2 id=\"潮州-eg-甲子-ig、iag\"><a href=\"#潮州-eg-甲子-ig、iag\" class=\"headerlink\" title=\"潮州 eg / 甲子 ig、iag\"></a>潮州 eg / 甲子 ig、iag</h2><p>例如：</p>\n<ol>\n<li>keg / kig ：仡（～佬族）</li>\n<li>keg / kiag：橛、镢</li>\n<li>ngeg / ngiag：迄、訖、屹</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ngeg / ngib：吃</li>\n</ol>\n<h2 id=\"潮州-ie-ieh-甲子-io-ioh\"><a href=\"#潮州-ie-ieh-甲子-io-ioh\" class=\"headerlink\" title=\"潮州 iê(iêh) / 甲子 io(ioh)\"></a>潮州 iê(iêh) / 甲子 io(ioh)</h2><p>例如：</p>\n<ol>\n<li>iê / io：腰、姚、窯、揺</li>\n<li>iêh / ioh：約、藥</li>\n<li>biê / bio：表</li>\n<li>biê &amp; piao / pio &amp; biao：標、飆</li>\n<li>bhiê / bhio：描、廟</li>\n<li>ciê / cio：笑、唱</li>\n<li>ciêh / cioh：尺、席</li>\n<li>diê / dio：跳、潮</li>\n<li>diêh / dioh： 著</li>\n<li>giê / gio：叫、茄、橋</li>\n<li>hiêh / hioh：葉、頁</li>\n<li>kiêh / kioh：挈/𢭪</li>\n<li>liê / lio：撈</li>\n<li>niê / nio：兩、娘、量、讓 </li>\n<li>piê / pio：票、鰾</li>\n<li>riê / rio：尿</li>\n<li>riêh / rioh：若</li>\n<li>siê / sio：相、燒、小</li>\n<li>siêh / sioh：惜、液</li>\n<li>tiê / tio：挑、糶</li>\n<li>ziê / zio：招、蕉、少、照</li>\n<li>ziêh / zioh：質、借、石</li>\n</ol>\n<h2 id=\"潮州-ien-甲子-ion\"><a href=\"#潮州-ien-甲子-ion\" class=\"headerlink\" title=\"潮州 iên / 甲子 ion\"></a>潮州 iên / 甲子 ion</h2><p>例如：</p>\n<ol>\n<li>iên / ion：鴦、羊、陽、楊、洋、樣</li>\n<li>ciên / cion：槍、鯧、搶、牆、象、匠</li>\n<li>diên / dion：張、長、帳、脹、賬、場、丈、趙</li>\n<li>giên / gion： 姜、強、彊</li>\n<li>hiên / hion：香、鄉</li>\n<li>kiên / kion：腔</li>\n<li>siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗</li>\n<li>ziên / zion 漿、章、樟、蔣、掌、醬、上、癢</li>\n</ol>\n<p>例外： </p>\n<ol>\n<li>diên / dio 釣（☞ 鼻音完全脫落）</li>\n</ol>\n<h2 id=\"潮州-ieng-ieg-iang-iag\"><a href=\"#潮州-ieng-ieg-iang-iag\" class=\"headerlink\" title=\"潮州 iêng(iêg) / iang(iag)\"></a>潮州 iêng(iêg) / iang(iag)</h2><p>例如：</p>\n<ol>\n<li>iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援</li>\n<li>biêng / biang：邊、砭、鞭、變、遍、便、辯</li>\n<li>ciêng / ciang：阡、遷、芊、纖、淺</li>\n<li>ciêg / ciag：切</li>\n<li>diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍</li>\n<li>giêng /giang：堅、捐、鵑、見、建、鍵</li>\n<li>hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇</li>\n<li>kiêng /kiang：虔、愆、騫、犬、乾</li>\n<li>liêng / liang：臉、連、憐、蓮、吝、躪、練</li>\n<li>miêng /miang：免、勉、娩、憫、敏、緬、腼、綿</li>\n<li>ngiêng / ngiang：妍、研、齴</li>\n<li>ngiêg / ngiag：嚙（～齒）</li>\n</ol>\n<h2 id=\"潮州-ing-ig-甲子eng-eg-、-iang-iag\"><a href=\"#潮州-ing-ig-甲子eng-eg-、-iang-iag\" class=\"headerlink\" title=\"潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\"></a>潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)</h2><p>例如：</p>\n<ol>\n<li>mig / mêg：默、陌</li>\n<li>ing / iang：沿、鉛</li>\n<li>mig / miag：滅、蔑</li>\n<li>zing / ziang：薦</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演</li>\n<li>ing / hing：暈</li>\n<li>bing / bing：乒、賓、彬、斌、稟</li>\n<li>big / big：筆、必、畢、蓽、篳、弼</li>\n<li>bhig / bhig：蜜</li>\n<li>cing / cing：親、臣、秦</li>\n<li>cig / cig：七</li>\n<li>ding / ding：顛、振、鎮、塵、藤、陣</li>\n<li>cing / cim：襯</li>\n<li>king / king：輕、氫</li>\n<li>ling / ling：鄰、遴、嶙、麟</li>\n<li>ming / ming：民、氓、泯、眠、面</li>\n<li>mig / mig 密、蜜、冪、覓、謐</li>\n<li>ning / ning 恁</li>\n<li>ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻</li>\n<li>bing / ping：品</li>\n<li>ring / ring：人、仁、認</li>\n<li>sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛</li>\n<li>ting / ting： 烴、陳、澄</li>\n<li>zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼</li>\n<li>zing / ding 珍</li>\n</ol>\n<h2 id=\"潮州-iou-iouh-甲子-iao-iaoh\"><a href=\"#潮州-iou-iouh-甲子-iao-iaoh\" class=\"headerlink\" title=\"潮州 iou(iouh) / 甲子 iao(iaoh)\"></a>潮州 iou(iouh) / 甲子 iao(iaoh)</h2><p>例如：</p>\n<ol>\n<li>iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀</li>\n<li>biou / biao：表、婊</li>\n<li>ciou / ciao：悄、稍、朝、嘲、瞧、晁</li>\n<li>diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉</li>\n<li>giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬</li>\n<li>hiou / hiao：僥、梟、驍、曉</li>\n<li>kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑</li>\n<li>liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺</li>\n<li>miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）</li>\n<li>niou / niao：撓、裊、皺</li>\n<li>ngiou / ngiao：貓、堯</li>\n<li>piou / piao：飄、漂、嫖、樸</li>\n<li>piou / biao：標</li>\n<li>riou / riao：爪、擾、嬈、繞、饒</li>\n<li>siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶</li>\n<li>tiou / tiao：迢、挑、超、窕、柱</li>\n<li>ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭</li>\n</ol>\n<h2 id=\"潮州-iong-甲子-eng\"><a href=\"#潮州-iong-甲子-eng\" class=\"headerlink\" title=\"潮州 iong / 甲子 êng\"></a>潮州 iong / 甲子 êng</h2><p>例如：</p>\n<ol>\n<li>iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴</li>\n</ol>\n<h2 id=\"潮州-ong-iong\"><a href=\"#潮州-ong-iong\" class=\"headerlink\" title=\"潮州 ong / iong\"></a>潮州 ong / iong</h2><p>例如：</p>\n<ol>\n<li>dong / diong：重、中、忠、仲</li>\n<li>rong / riong：戎、絨、茸</li>\n<li>zong / ziong：眾</li>\n<li>rong / riong：仍、扔</li>\n<li>song / siong：松、訟、誦、頌</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>cong / cong：從、充、衝</li>\n</ol>\n<h2 id=\"潮州-ng-甲子-ing\"><a href=\"#潮州-ng-甲子-ing\" class=\"headerlink\" title=\"潮州 ng / 甲子 ing\"></a>潮州 ng / 甲子 ing</h2><p>例如：</p>\n<ol>\n<li>ng / ing：尹、隱</li>\n<li>hng / hing：軒、欣、鍁、勳、殷</li>\n</ol>\n<h2 id=\"潮州-oin-甲子-ain\"><a href=\"#潮州-oin-甲子-ain\" class=\"headerlink\" title=\"潮州 oin / 甲子 ain\"></a>潮州 oin / 甲子 ain</h2><p>例如：</p>\n<ol>\n<li>oin / ain：閒</li>\n<li>boin / bain：斑、反、板、爿</li>\n<li>coin / cain：千、蠶</li>\n<li>doin / dain：殿</li>\n<li>goin / gain：間、肩、繭</li>\n<li>hoin / hain：蜆、還、莧</li>\n<li>koin / kain：蓋</li>\n<li>soin / sain：先</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>toin / toin：睇</li>\n<li>noin / nai：蓮（☞ 鼻音完全脫落）</li>\n</ol>\n<p>☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。</p>\n<h2 id=\"潮州-ue-ueh-甲子-oi-oih\"><a href=\"#潮州-ue-ueh-甲子-oi-oih\" class=\"headerlink\" title=\"潮州 uê(uêh) / 甲子 oi(oih)\"></a>潮州 uê(uêh) / 甲子 oi(oih)</h2><p>例如：</p>\n<ol>\n<li>uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛</li>\n<li>uêh / oih：划、畫</li>\n<li>buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩</li>\n<li>buê / poi：陪</li>\n<li>bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未</li>\n<li>cuê / coi：吹、炊、髓、覓</li>\n<li>duê / doi：綴、兌</li>\n<li>guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）</li>\n<li>guêh / goih：郭、橛</li>\n<li>ghuêh / ghoih8：月</li>\n<li>huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）</li>\n<li>huêh / hoih：血</li>\n<li>kuê / koi：科、蝌、課、稞、瘸</li>\n<li>kuêh / koih：缺、闕、闋</li>\n<li>muêh / moih：物</li>\n<li>muê / moi：每、糜、妹、昧、寐、魅、袂</li>\n<li>nuê / noi：餒</li>\n<li>puê / poi：皮、被、坯、胚、配、裴</li>\n<li>puêh / poih：詖、坺</li>\n<li>ruê / roi：枘、蚋、銳、睿</li>\n<li>suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅</li>\n<li>suêh / soih：說</li>\n<li>tuê / toi：頹</li>\n<li>zuê / zoi：最、襊、罪、㩼</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêh / ghoih：襪</li>\n<li>kuê / kui：盔</li>\n<li>suêh / suah：刷、涮</li>\n</ol>\n<h2 id=\"潮州-uen-甲子-oin\"><a href=\"#潮州-uen-甲子-oin\" class=\"headerlink\" title=\"潮州 uên / 甲子 oin\"></a>潮州 uên / 甲子 oin</h2><p>例如：</p>\n<ol>\n<li>guên / goin：關、果</li>\n<li>huên / hoin：橫</li>\n</ol>\n<h2 id=\"潮州-ueng-ueg-甲子-uang-uag\"><a href=\"#潮州-ueng-ueg-甲子-uang-uag\" class=\"headerlink\" title=\"潮州 uêng(uêg) / 甲子 uang(uag)\"></a>潮州 uêng(uêg) / 甲子 uang(uag)</h2><p>例如：</p>\n<ol>\n<li>uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣</li>\n<li>uêg / uag：曰、斡、鉞、越、粵</li>\n<li>buêng / puang：叛</li>\n<li>buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤</li>\n<li>bhuêng / muan：幔（☞ 後鼻音退成鼻化音）</li>\n<li>cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓</li>\n<li>cuêg / cuag：啜、綴、輟</li>\n<li>duêng / duang：端、斷、鍛、段（又音deng）、篆</li>\n<li>guêng / guang：關、觀、冠、鰥</li>\n<li>guêg / guag：決、訣、抉、玦、聒、譎</li>\n<li>guêg / kuag：括</li>\n<li>huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢</li>\n<li>huêg / huag：發、髮、乏、穴、伐、罰、閥</li>\n<li>kuêng / kuang：寬、圈、髖、權、款、蜷</li>\n<li>kuêg / kuag：擴</li>\n<li>luêng / luang：暖、戀、巒、孿、鸞、亂</li>\n<li>luêg / luag：劣</li>\n<li>muêg / muag：末、沫、秣</li>\n<li>nguêng / nguang：阮、玩、頑、元、原、源、願</li>\n<li>puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣</li>\n<li>puêng / puan：般（☞ 後鼻音退成鼻化音）</li>\n<li>puêg / puag：潑、銖</li>\n<li>ruêng / ruang：亂</li>\n<li>ruêg / ruag：悅</li>\n<li>suêng / suang：選、算（又音 seng）、旋、漩</li>\n<li>tuêng / tuang：湍、團、傳</li>\n<li>zuêng / zuang： 專、轉、鐫、顓、撰</li>\n<li>zuêg / zuag：拙、茁、咄、絀</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêng/mang：萬、饅、慢、漫</li>\n<li>kuêng /  kêng：傾、頃、卿</li>\n<li>huêng / hoin：衡</li>\n<li>huêg / hoig：或 、惑</li>\n<li>uêg / oig：獲 、域、役、鑊</li>\n<li>guêng / goin：囧、炯、耿、穎</li>\n<li>nguêng / ngiang：顏</li>\n<li>nguêng / iang：芫</li>\n</ol>\n<h2 id=\"其餘\"><a href=\"#其餘\" class=\"headerlink\" title=\"其餘\"></a>其餘</h2><ol>\n<li>宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³</li>\n<li>唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²</li>\n<li>言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²</li>\n<li>瓊、煢：潮州kuang⁵ / 甲子kêng⁵</li>\n<li>舀：潮州 io² / 甲子ion² </li>\n</ol>"},{"title":"Go 基礎","p":"it/go/go-basic.md","_content":"\nGo 又稱 Golang，是 Google 公司 2009 年發佈的一款開源編程語言，以簡潔而高效的代碼著稱。Go 目前使用 GOPATH 或 Go modules 管理項目中的第三方依賴，且不支持循環依賴。\n\nGo 的基本數據類型有 16 種(不包含別名)，可謂豐富。要注意的是 string 也是基本數據類型，表示一個 UTF-8 字符串，底層是 byte 數組。單個字符使用一個 int32 的別名 rune 表示，其值爲 Unicode 字符碼點。\n\nGo 的變量使用 var 關鍵字聲明，也可以使用短變量聲明；常量則是使用 const 關鍵字聲明。\n\nGo 有 if 條件語句、for 循環語句、switch 選擇語句和 defer 延遲執行語句。Go 的 for 語句兼具其他語言的 while 語句；switch 語句每個 case 條件都支持運算，且默認自動 break；defer 語句可以立即計算參數值，然後在函數 return 前執行。\n\nGo 的可見性跟標識符的首字母是否大寫相關，大寫則是導出的，包外可見；小寫則是非導出的，包外不可見。\n\nGo 有指針，要注意 `&` 是生成指向操作數的指針，而 `*` 是獲取指針指向的底層值。\n\nGo 將一些字段組合成一個結構體(struct) 。結構體支持隱式間接調用，即 p.X 等價於 (*p).X（p 爲結構體指針）。\n\nGo 支持數組，更重要的是支持一種名爲切片(slice) 的動態數組。切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量。\n\nGo 支持映射(map)。\n\nGo 支持函數(function)的命名返回值、多值返回、作爲值傳遞和閉包。還有一種稱爲方法(method)的特殊函數，其帶有接收者參數，接收者可以是值接收者也可以是指針接收者，指針接收者可以更改接收者的值。\n\nGo 支持將一些方法簽名組成接口(interface)。接口的實現是隱式的，不需要「implements」。一個結構體作爲接收者定義了接口中的所有方法，那麼該結構體就是實現了該接口。因爲隱式的緣故，建議接口方法盡可能少，以便管理。接口是值，可以傳遞。底層值是 nil 的接口，其方法可以被調用；接口本身爲 nil ，則意味著其不保存值也不保存具體類型；空接口(interface{})是包含零個函數的接口，不是爲 nil 接口。\n\nGo 的異常處理很簡單，只有 Error，沒有 throws。\n\nGo 支持 Go 程，一種 Go運行時管理的輕量級線程。Go 程之間可以通過信道(channel) 通信，通過 Mutex 或 RWMutex 共享互斥變量，通過 WaitGroup 等待執行完成。 \n\nGo 中的信道還支持通過 for-range 循環讀取數據，當信道關閉時該循環自動退出。記住，只有發送方可以關閉信道，接收方不能。信道還支持 select 語句，其會**阻塞到某一分支可以執行爲止**，如沒有分支可以執行且設定了default 語句，會一直執行 default 語句。\n\n<!-- more -->\n\n以下內容多來自[《Go 指南》](https://tour.go-zh.org/)，內容有所改動。\n\n## 歷史\n\nGo 又稱 Golang，是 Google 公司開發的一款靜態強類型、編譯型、並發型，並具有垃圾回收功能的編程語言。\n\n1. 2007.9.21 罗伯特·格瑞史莫(Robert Griesemer)、罗勃·派克(Rob Pike)和肯·汤普逊(Ken Thompson) 開始設計 Go。\n2. 2009.11 Google 發佈 Go 語言。\n3. 2012.3 Go 1.0 發佈。\n4. 2018.8 Go 1.11 發佈，預支持 modules 進行依賴管理。\n\n## 入門\n\n### 安裝\n\n按照[官方教程](https://golang.org/doc/install)安裝即可。\n\n### Hello World\n\n直接在系統 Home 目錄，新建一一個 hello.go 文件，寫入代碼如下：\n\n```go\npackage main //程序從 main 包的 main 函數開始運行\nimport \"fmt\" //導入 fmt 包\n\nfunc main() { //main函數\n    fmt.Println(\"Hello, World!\") //打印日誌\n}\n```\n\n然後執行 `go run hello.go` 即可。\n\n### GOPATH\n\n當項目未啟用 Go modules 時，Go 使用 `GOPATH` 環境變量解析 import 語句。`GOPATH` 的值默認爲 `$HOME/go` ， `GOPATH` 目錄結構如下：\n\n```go\nGOPATH=/home/user/go\n\nsrc/\n    foo/\n        bar/               (go code in package bar)\n            x.go\n        quux/              (go code in package main)\n            y.go\nbin/\n    quux                   (installed command)\npkg/\n    linux_amd64/\n        foo/\n            bar.a          (installed package object)\n```\n\n- src：存放依賴的源代碼\n- bin：存放安裝的命令\n- pkg：存法安裝的包對象\n\n啟用 Go modules 後雖然不通過 `GOPATH` 解析 import 語句，但下載的源代碼和安裝的命令都會存在`GOPATH`目錄下。\n\n### Vendor\n\nVendor 就是使用本地依賴包的模式，Go 1.5 作爲實驗特性，Go 1.6 正式支持，Go 1.14 正式終結。命名爲 vender(小商販) 是一種比喻，並將 GOPATH 隱喻爲有固定地址的商舖。啟用 Vendor 模式很簡單，在項目中創建一個名爲 vendor 的文件夾然後拷貝依賴的源代碼進入其中即可。比如有如下的項目使用了 Vendor：\n\n```go\n$GOPATH\n|\tsrc/\n|\t|\tgithub.com/constabulary/example-gsftp/\n|\t|\t|\tcmd/\n|\t|\t|\t|\tgsftp/\n|\t|\t|\t|\t|\tmain.go\n|\t|\t|\tvendor/\n|\t|\t|\t|\tgithub.com/pkg/sftp/\n|\t|\t|\t|\tgolang.org/x/crypto/ssh/\n|\t|\t|\t|\t|\tagent/\n```\n\n在文件 `github.com/constabulary/example-gsftp/cmd/gsftp/main.go` 中應這樣 import 依賴（不需要加入 vendor 前綴）：\n\n```go\nimport (\n\t...\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/agent\"\n\t\"github.com/pkg/sftp\"\n)\n```\n\n這種方式顯然會帶來代碼膨脹，特別是N個庫同時用 Vendor 模式依賴一個通用庫時，那麼該通用庫的代碼將會出現N次。\n\n### Go modules\n\nGo 官方推出的依賴管理系統，在 Go 1.11 和 1.12中已經有初步支持，但默認關閉；從 1.13 開始默認啟用，1.14 開始可用於生產。\n\n**（1）使用 Go modules**\n\n使用 Go modules 很簡單，只需要在項目根路徑(不可以在 `$GOPATH/src` 裏面)執行 `go mod init example.com/m` 即可初始化一個名爲 `example.com/m` 的模塊，之後會在項目根路徑生成一個名爲 `go.mod` 的依賴文件，其內容結構如下：\n\n```go\nmodule example.com/hello //模塊名\n\ngo 1.12 //使用的 Go 版本\n\nrequire rsc.io/quote v1.5.2 //依賴項\n```\n\n此外，Go modules 還生成和維護著一個名爲 `go.sum` 的文件，該文件包含了期望的指定模塊版本的內容的加密哈希。\n\n爲保證依賴的一致性，需要同時將 `go.mod` 和 `go.sum` 加入版本管理。\n\n**（2）更新依賴**\n\n更新小版本很簡單，一個 `go get` 命令就完了。更新大版本比更新小版本複雜，因爲大版本通常會帶來 API 的變化，Go 要求更改大版本號後，模塊名也要加上版本號。例如原本是 `rsc.io/quote` 的依賴，升級到 v3 後依賴要改成 `rsc.io/quote/v3` ，因此代碼中的 import 語句要改成 `rsc.io/quote/v3` ，然後清理掉舊版本的依賴，有點麻煩。\n\n```bash\n# 列出當前項目的模塊和依賴項\ngo list -m all\n# 直接更新到最新的小版本\ngo get rsc.io/sampler\n# 列出所有小版本\ngo list -m -versions rsc.io/sampler\n# 更新到指定版本\ngo get rsc.io/sampler@v1.3.1\n\n# 查看模塊的所有版本\ngo list -m rsc.io/q...\n# 清除未使用的依賴\ngo mod tidy\n```\n\n### 循環依賴\n\nGo 不支持循環依賴，Go設計者Rob Pike認爲如果出現兩個包循環依賴，那麼是你的設計問題。\n\n筆者就出現過一次循環依賴，場景是：封裝了一個打印日誌的庫A和一個解析配置的庫B，庫A需要通過庫B配置，庫B需要用庫A打印日誌。最後選擇在庫B使用原始的日誌打印。\n\n## 語法\n\n### 數據類型\n\n**（1）基本類型**\n\n```go\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的別名\n    // 表示一個 Unicode 碼點\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\n其中 int, uint 和 uintptr 在 32 位系統上通常為 32 位寬，在 64 位系統上則為 64 位寬。\n\nstring 表示一個 UTF-8 類型的字符串，底層是一個字節數組。\n\nrune 表示一個 Unicode 碼點，是 int32 的別名。讀取 string 中的每個字符，只需要將 string 轉爲 rune 數組即可\n\nJava 中的 char 類型，每個字符對應一個 Unicode 碼點，可以表示BMP範圍內（即[U+0000, U+FFFF]之間）的Unicode字符。String 是 UTF-8 類型。\n\n**（2）零值**\n\n没有明确初始值的变量声明会被赋予它们的 **零值**。\n\n零值是：\n\n- 数值类型为 `0`，\n- 布尔类型为 `false`，\n- 字符串为 `\"\"`（空字符串）。\n\n**（3）類型轉換**\n\n數值之間可以通過表達式 T(v) 將值 v 轉換為類型 T，如：\n\n```go\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n**（4）类型推导**\n\n在聲明一個變量而不指定其類型時（即使用不帶類型的 := 語法或 var = 表達式語法），變量的類型由右值推導得出。\n\n```go\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n```\n\n### 變量\n\n**（1）聲明語句**\n\n```go\n// var 開頭，逗號(,)分割變量名，最後寫數據類型 \nvar c, python, java bool\n```\n\n**（2）賦值語句**\n\n```go\nvar c, python, java = true,false,\"no\"\n```\n\n或直接使用**短變量聲明**，注意短變量聲明只能在函數內使用，因爲函數外的每個語句要求必須以關鍵字開始。\n\n```go\nc, python, java := true,false,\"no\"\n```\n\n### 常量\n\n常量聲明使用 const 關鍵字。常量可以是字符、字符串、布尔值或数值。常量不能用 `:=` 语法声明。\n\n```go\nconst Pi = 3.14\n```\n\n`iota` 可以用來創建順序遞增的常量。\n\n```go\nconst (\n\tLow = iota //0\n\tMedium     //1\n\tHigh       //2\n)\n```\n\n### 風格\n\n1. 每行程序結束後不需要撰寫分號（;）。\n2. 大括號（{）不能夠換行放置。\n3. if判斷式和for循環不需要以小括號包覆起來。\n4. 使用 tab 做排版\n\n### 流程控制\n\n**（1）if-else**\n\n不需要小括號，可以使用簡短語句。\n\n```go\n_,ok := sendMsg();\nif ok {\n  // do something\n}else{\n  // do other thing\n}\n// 等價於以下簡短語句\nif _,ok := sendMsg(); ok {\n  // do something\n}else{\n  // do other thing\n}\n```\n\n**（2）for**\n\nGo 中的 for 語句，還包含了其他語言的 while 的功能。特別的不用括號包裹。\n\n```go\n// 功能：遍歷 10 次\nfor i:=0;i<10;i++{\n}\n// 功能：類似於其他語言 while 的功能\nvar i = 0\nfor i<10{\n}\n// 功能：無限循環，類似於其他語言中的 while(true)\nfor{\n}\n// 功能：for range 循環，返回當前元素的下標及副本\n// 可通過 _ 忽略其中的某個值\npow := []int{1, 2, 4, 8}\nfor i, v := range pow {\n\tfmt.Printf(\"%d,%d\\n\", i, v)\n}\nfor _,v := range pow {\n\tfmt.Printf(\"%d\\n\", v)\n}\nfor i := range pow {\n\tfmt.Printf(\"%d\\n\", i)\n}\n```\n\n**（3）switch**\n\nGo 中的 switch 語句是自動 break 的。如果不想要break，需要在 case 後面協商 fallthrough。\n\nGo 中的 switch 的 case 無需為常量，且取值不必為整數。\n\n```go\n// 功能：選擇顏色\nswitch color {\n    case Red:\n    // do something\n    case Green:\n    // do something\n    default:\n    // do something\n}\n// 功能：替代 if-then-else，更整齊\nresult := request()\nswitch {\n    case result > 0:\n    case result <0:\n    default:\n}\n// 或者\nswitch result := request(); {\n    case result > 0:\n    case result <0:\n    default:\n}\n```\n\n**（4）defer**\n\ndefer 語句會將函數推遲到外層函數返回之後執行。\n\n推遲調用的函數其參數會立即求值，但直到外層函數返回前該函數都不會被調用。\n\n推遲的函數調用會被壓入一個棧中。當外層函數返回時，被推遲的函數會按照後進先出的順序調用。\n\n```go\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n```\n\ndefer 並不是免費的。defer 底層會調用 `runtime.deferproc` 去設置要延遲調用的函數，調用 `runtime.deferreturn` 會依次執行先前延遲調用的函數。參考：https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32\n\n### 可見性\n\n- 導出：大寫字母開頭的標識符，包外可訪問。\n- 未導出：非大寫字母開頭的標識符，包外不可訪問。\n\n### 指針\n\nGo 擁有指針。指針保存了值的內存地址。\n\n- 類型 `*T` 是指向 `T` 類型值的指針。其零值為 `nil`。\n- `&` 操作符會**生成一個指向其操作數的指針**。（注意：把`&` 理解爲取地址符號是錯誤的）\n- `*` 操作符**表示指針指向的底層值**。（注意：把`*` 理解爲取值符號是錯誤的）\n\n```go\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := &i         // 指向 i\n\tfmt.Println(*p) // 通過指針讀取 i 的值\n\t*p = 21         // 通過指針設置 i 的值\n\tfmt.Println(i)  // 查看 i 的值\n\n\tp = &j         // 重定向到 j\n\t*p = *p / 37   // 通過指針對 j 進行除法運算\n\tfmt.Println(j) // 查看 j 的值\n}\n```\n\n### 結構體\n\n一個結構體（struct）就是一組字段（field）。外界使用點號來訪問結構體字段。\n\n結構體字段可以通過結構體指針來訪問。如果我們有一個指向結構體的指針 p，那麼可以通過 `(*p).X` 來訪問其字段 X。不過這麼寫太囉嗦了，所以語言也允許我們使用**隱式間接引用**，直接寫 `p.X` 就可以。\n\n```go\ntype Vertex struct {\n\tX, Y int\n}\n\nfunc main() {\n  v := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n  \n  p := &v\n\tp.X = 1e9\n\tfmt.Println(v)\n\n\tv2 = Vertex{X: 1}  // Y:0 被隱式地賦予\n\tv3 = Vertex{}      // X:0 Y:0\n\tp  = &Vertex{1, 2} // 創建一個 *Vertex 類型的結構體（指針）\n}\n```\n\n### 數組\n\n類型 [n]T 表示擁有 n 個 T 類型的值的數組。\n\n表达式\n\n```go\nvar a [10]int\n```\n\n會將變量 `a` 聲明為擁有 10 個整數的數組。\n\n### 切片\n\n**（1）定義**\n\n類型 []T 表示一個元素類型為 T 的切片。T 可以是任何類型，包括切片本身。\n\n切片通過兩個下標來界定，即一個上界和一個下界，二者以冒號分隔：\n\n```go\na[low : high]\n```\n\n它會選擇一個半開區間，包括第一個元素，但排除最後一個元素。\n\n切片下界的默認值爲 0，上界則是其底層數組的長度。\n\n對於數組 `var a [10]int` 來說，以下切片是等價的：\n\n```go\na[0:10]\na[:10]\na[0:]\na[:]\n```\n\n**（2）切片的本質**\n\n一個切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量，其結構如下：\n\n![](go-basic/Untitled.png)\n\n![](go-basic/Untitled%201.png)\n\n切片的長度就是它所包含的元素個數。\n切片的容量是從它的第一個元素開始數，到其底層數組元素末尾的個數。\n切片 s 的長度和容量可通過表達式 `len(s)` 和 `cap(s)` 來獲取。\n\n更改切片的元素會修改其底層數組中對應的元素。與它共享底層數組的切片都會觀測到這些修改。\n\n```go\nfunc main() {\n\tnames := [4]string{\n\t\t\"John\",\n\t\t\"Paul\",\n\t\t\"George\",\n\t\t\"Ringo\",\n\t}\n\tfmt.Println(names)\n\n\ta := names[0:2]\n\tb := names[1:3]\n\tfmt.Println(a, b)\n\n\tb[0] = \"XXX\"\n\tfmt.Println(a, b)\n\tfmt.Println(names)\n}\n```\n\n注意：切片的零值爲 nil，其長度和容量爲 0 且沒有底層數組。\n\n**（3）通過 make 創建切片**\n\n```go\na := make([]int, 5)  // len(a)=5\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n```\n\n**（4）通過 append 追加元素**\n\n```go\nfunc append(s []T, vs ...T) []T\n```\n\n`append` 的第一個參數 `s` 是一個元素類型為 `T` 的切片，其餘類型為 `T`的值將會追加到該切片的末尾。\n\n`append` 的結果是一個包含原切片所有元素加上新添加元素的切片。\n\n當 `s` 的底層數組太小，不足以容納所有給定的值時，它就會分配一個更大的數組。返回的切片會指向這個新分配的數組。\n\n當引用一個原始數組時，GC不會釋放該數組的空間，即使只用到其中一小部分數據。因此函數返回切片的時候要特別注意，最好拷貝需要數據到新的切片再返回。\n\n```go\n// 使用 copy 函數\nfunc CopyDigits(filename string) []byte {\n    b, _ := ioutil.ReadFile(filename)\n    b = digitRegexp.Find(b)\n    c := make([]byte, len(b))\n    copy(c, b)\n    return c\n}\n// 或使用 append 函數\nfunc CopyDigits(filename string) []byte {\n    b, _ := ioutil.ReadFile(filename)\n    b = digitRegexp.Find(b)\n    var c []byte\n    return append(c, b...)\n}\n```\n\n### 映射\n\n映射將鍵映射到值。\n\n映射的零值為 `nil` 。`nil` 映射既沒有鍵，也不能添加鍵。\n\n`make` 函數會返回給定類型的映射，並將其初始化備用。\n\n```go\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": {40.68433, -74.39967},\n\t\"Google\":    {37.42202, -122.08408},\n}\n```\n\n 常用操作：\n\n1. 插入或修改元素：`m[key] = elem`\n2. 獲取元素：`elem = m[key]`\n3. 通過雙賦值檢測某個鍵是否存在：`elem, ok := m[key]`\n4. 刪除元素：`delete(m, key)`\n\n### 函數(function)\n\n**（1）概述**\n\n函數可以沒有參數或接受多個參數。當連續兩個或多個函數的已命名形參類型相同時，除最後一個類型以外，其它都可以省略。\n\n```go\nfunc add(x, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n```\n\n**（2）命名返回值**\n\nGo 的返回值可被命名，它們會被視作**定義在函數頂部的變量**。返回值的名稱應當具有一定的意義，它可以作為文檔使用。沒有參數的 `return` 語句返回已命名的返回值。也就是 `直接` 返回。直接返回語句應當僅用在下面這樣的短函數中。在長的函數中它們會影響代碼的可讀性。\n\n```go\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(split(17))\n}\n```\n\n**（3）多值返回**\n\n函數可以返回任意數量的返回值。\n\n```go\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n```\n\n**（4）函數值**\n\n函數也是值，可以作爲函數的參數或返回值。\n\n```go\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\nfmt.Println(compute(math.Pow))\n```\n\n**（5）閉包(closure)**\n\n閉包是指一個函數引用了其函數體之外的變量，該函數可以訪問並賦予其引用的變量的值。換句話說就是該函數跟函數體之外的變量綑綁在一起了。每次調用閉包中的函數可以改變閉包中變量的值。例如斐波那契閉包：\n\n```go\nfunc fibonacci() func() int {\n\tx,y := 0,1\n\treturn func() int {\n\t\tres := x\n\t\tx,y = y,x+y\n\t\treturn res\n\t}\n}\n\nfunc main() {\n\tf := fibonacci()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(f())\n\t}\n}\n```\n\n### 方法(method)\n\n方法就是一類帶特殊的**接收者參數**的函數。方法接收者在它自己的參數列表內，**位於 func 關鍵字和方法名之間**。\n\n```go\ntype Vertex struct {\n\tX, Y float64\n}\n// 這就是方法\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n```\n\n值得注意的是：接收者的類型定義和方法聲明必須在同一包內；不能爲內建類型聲明方法。\n\n接收者除了是**值接收者**外，還支持**指針接收者**，使用 `*T` (不能是 `*int` 之類的) 的文法即可。指針接收者可以修改接收者指向的值。如下：\n\n```go\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(10) // 此時 Go 會解釋爲 (&v).Scale(10)，這就是指針重定向\n\tfmt.Println(v.Abs())\n}\n```\n\n使用指針接收者的好處：\n\n1. 方法能夠修改其接收者指向的值。\n2. 避免在每次調用方法時複製該值。該值佔用的空間越大，則越顯得高效。\n\n注意：一個結構體採用值接收者的方式實現了接口的方法，則隱含著採用指針接收者的方式實現了接口的方法。（接收者是指針類型的方法，很可能在方法中會對接收者的屬性進行更改操作，從而影響接收者；而對於接收者是值類型的方法，在方法中不會對接收者本身產生影響）\n\n### 接口\n\n**（1）定義**\n\n接口類型是**由一組方法簽名定義的集合**。接口類型的變量可以保存**任何**實現了這些方法的值。\n\n**（2）隱式實現**\n\n類型通過實現一個接口的所有方法來實現該接口。既然無需專門顯式聲明，也就沒有「implements」關鍵字。\n\n```go\ntype Animal interface {\n\teat()\n}\n\ntype John struct{}\n\nfunc (j *John) eat() {\n\tfmt.Println(\"eat...\")\n}\n\ntype Person interface {\n\teat()\n\ttalk()\n}\n\nfunc (j *John) talk() {\n\tfmt.Println(\"talk...\")\n}\n\nfunc main() {\n\tvar a Animal = &John{}\n\ta.eat()\n\tvar b Person = &John{}\n\tb.eat()\n\tb.talk()\n}\n```\n\n**（4）接口值**\n\n接口也是值，可以作爲函數的參數或返回值。在內部，接口值可以看做包含值和具體類型的元組：`(value, type)` 。接口值保存了一個具體底層類型的具體值。接口值調用方法時會執行其底層類型的同名方法。\n\n```go\n// Animal、John 見上面的代碼\nj := John{}\ndescribe(j)\n\nfunc describe(i Animal){\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n**（5）底層值爲 nil 的接口值**\n\n即便接口內的具體值為 nil，方法仍然會被 nil 接收者調用。\n\n```go\n// 改造上面的代碼\nfunc (j *John) talk() {\n\tif j == nil {\n\t\tfmt.Println(\"j is <nil>\")\n\t\treturn\n\t}\n\tfmt.Println(\"talk...\")\n}\n\nfunc main() {\n\tvar x Person\n\tvar y John\n\tx = &y\n\tdescribe(x)\n\tx.talk() // 正常調用\n}\n```\n\n判斷接口的底層值是否爲 nil 的方法：\n\n```go\n// 接上\nprintln( x == nil || reflect.ValueOf(x).IsNil())\n```\n\n**（6）nil 接口值**\n\nnil 接口值既不保存值也不保存具體類型。\n\n為 nil 接口調用方法會產生運行時錯誤，因為接口的元組內並未包含能夠指明該調用哪個 **具體** 方法的類型。\n\n```go\ntype I interface {\n\tM()\n}\n\nfunc main() {\n\tvar i I\n\tdescribe(i)\n\ti.M() // 此處拋出 panic: runtime error: invalid memory address or nil pointer dereference\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i) // (<nil>, <nil>)\n}\n```\n\n**（7）空接口**\n\n指定了**零個方法**的接口值被稱為空接口，即 `interface{}` 。空接口可保存任何類型的值。（因為每個類型都至少實現了零個方法。）空接口被用來處理未知類型的值。例如，`fmt.Print` 可接受類型為 `interface{}` 的任意數量的參數。\n\n```go\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42 // 保存 int值\n\tdescribe(i)\n\n\ti = \"hello\" // 保存 string值\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n**（8）類型斷言**\n\n類型斷言提供了訪問**接口值底層具體值**的方式。\n\n```go\n// 判斷接口i的底層值類型是否爲T，如是返回其底層值和true，否則返回T類型的零值和false\nt, ok := i.(T)\n```\n\n```go\nvar i interface{} = \"hello\"\ns, ok := i.(string)\nfmt.Println(s, ok)\nf, ok := i.(int)\nfmt.Println(f, ok)\n// 支持類型選擇\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n\tcase string:\n\t\tfmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n\tdefault:\n\t\tfmt.Printf(\"I don't know about type %T!\\n\", v)\n\t}\n}\n```\n\n### 異常處理\n\nGo 程序使用 `error` 值來表示錯誤狀態。\n\n```go\ntype error interface {\n    Error() string\n}\n```\n\n通常函數會返回一個 `error` 值，調用的它的代碼應當判斷這個錯誤是否等於 `nil` 來進行錯誤處理。`error` 為 nil 時表示成功；非 nil 的 `error` 表示失敗。\n\n```go\nif i, err := strconv.Atoi(\"42\"); err == nil {\n    fmt.Println(\"Converted integer:\", i)\n}\n```\n\n### Go 程(goroutine)\n\n**（1）定義**\n\n**Go 程（goroutine）是由 Go 運行時管理的輕量級線程**。\n\n```go\n// x,y,z 的求值發生在當前 Go 程中，f 的執行則是在新的 Go 程中\ngo f(x, y, z)\n```\n\n（**2）信道**\n\n**信道是帶有類型的管道**，你可以通過它用**信道操作符** `<-` (箭頭就是數據流的方向)來發送或者接收值。\n\n默認情況下，發送和接收操作在另一端準備好之前都會阻塞。這使得 Go 程可以在沒有顯式的鎖或競態變量的情況下進行同步。\n\n```go\n// 創建信道\nch := make(chan int)\n// 將 v 發送至信道 ch。\nch <- v\n// 從 ch 接收值並賦予 v。\nv := <-ch\n```\n\n**信道可以是帶緩衝，**將緩衝長度作為第二個參數提供給 `make` 來初始化一個帶緩衝的信道。\n\n```go\nch := make(chan int, 100)\n```\n\n**僅當信道的緩衝區填滿後，向其發送數據時才會阻塞。當緩衝區為空時，接受方會阻塞。**\n\n**（3）range 和 close**\n\n有且僅有發送者可以通過 close 方法關閉一個信道。接收者讀取值的時候可以通過 `v, ok := <-ch`  的 ok 值判斷是否信道關閉了。更簡單的是使用 for-range 不斷從信道接收值，直到信道關閉，循環自動退出。\n\n```go\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n```\n\n**（4）select**\n\nselect 語句使一個 Go 程可以等待多個通信操作。select 會阻塞到某個分支可以繼續執行為止，這時就會執行該分支。當多個分支都準備好時會隨機選擇一個執行。當 select 中的其它分支都沒有準備好時，default 分支就會執行。\n\n```go\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n    default:\n      // 當 c 和 quit 阻塞時會執行到此處\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci(c, quit)\n}\n```\n\n- 練習：等價二叉查找樹\n\n    函數 tree.New(k) 用於構造一個隨機結構的已排序二叉查找樹，它保存了值 k, 2k, 3k, ..., 10k。\n\n    Walk 步進 tree t 將所有的值從 tree 發送到 channel ch。\n\n    用 Walk 實現 Same 函數來檢測 t1 和 t2 是否存儲了相同的值。\n\n    ```go\n    package main\n\n    import \"golang.org/x/tour/tree\"\n\n    func Walk(t *tree.Tree, ch chan int){\n    \tif t.Left != nil{\n    \t\tWalk(t.Left, ch)\n    \t}\n    \tch <- t.Value\n    \tif t.Right != nil{\n    \t\tWalk(t.Right, ch)\n    \t}\n    }\n\n    // Same 检测树 t1 和 t2 是否含有相同的值。\n    func Same(t1, t2 *tree.Tree) bool{\n    \tch1,ch2 := make(chan int),make(chan int)\n    \tgo func(){\n    \t\tWalk(t1, ch1)\n    \t\tclose(ch1)\n    \t}()\n    \tgo func(){\n    \t\tWalk(t2, ch2)\n    \t\tclose(ch2)\n    \t}()\n    \tfor i := range ch1{\n    \t\tif i != <-ch2 {\n    \t\t\treturn false\n    \t\t}\n    \t}\n    \treturn true\n    }\n\n    func main() {\n    \tprintln(Same(tree.New(1),tree.New(1)))\n    }\n    ```\n\n**（5）sync.Mutex**\n\n互斥鎖可以保證每次只有一個 Go 程訪問一個共享變量。\n\nGo 標準庫中的 **Mutex** 就是一個互斥鎖，可以創建為其他結構體的字段；零值為解鎖狀態。Mutex類型的鎖和線程無關，可以由不同的線程加鎖和解鎖。在代碼前調用 Lock 方法，並在代碼後調用 Unlock 方法來保證一段代碼互斥執行。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\nfunc (c *SafeCounter) Increase(key string) {\n\tc.mux.Lock()\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\")\n\t}\n\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n}\n```\n\n爲了提升讀寫性能，常用 **RWMutex** 代替 **Mutex。**RWMutex是讀寫互斥鎖。該鎖可以被同時多個讀取者持有或唯一個寫入者持有。RWMutex可以創建為其他結構體的字段；零值為解鎖狀態。RWMutex類型的鎖也和線程無關，可以由不同的線程加讀取鎖/寫入和解讀取鎖/寫入鎖。\n\n下面的代碼效果不明顯，因爲讀的次數不多。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.RWMutex\n}\n\nfunc (c *SafeCounter) Increase(key string) {\n\tc.mux.Lock()\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.RLock()\n\tdefer c.mux.RUnlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tnow := time.Now()\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\")\n\t}\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n\tprint(time.Now().Sub(now))\n}\n```\n\n**（6）WaitGroup**\n\nWaitGroup 可以等待一組 Go 程結束。通過調用 Add 方法設定要等待的 Go 程數量。然後各個 Go 程通過調用 Done 方法結束等待。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.RWMutex\n}\n\nfunc (c *SafeCounter) Increase(key string, wg *sync.WaitGroup) {\n\tc.mux.Lock()\n\tc.v[key]++\n\twg.Done()\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.RLock()\n\tdefer c.mux.RUnlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\twg.Add(1000)\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\", &wg)\n\t}\n\twg.Wait()\n\tfmt.Println(c.Value(\"somekey\"))\n}\n```","source":"_posts/it/go/go-basic.md","raw":"---\ntitle: Go 基礎\np: it/go/go-basic.md\ntags:\n- Go\n---\n\nGo 又稱 Golang，是 Google 公司 2009 年發佈的一款開源編程語言，以簡潔而高效的代碼著稱。Go 目前使用 GOPATH 或 Go modules 管理項目中的第三方依賴，且不支持循環依賴。\n\nGo 的基本數據類型有 16 種(不包含別名)，可謂豐富。要注意的是 string 也是基本數據類型，表示一個 UTF-8 字符串，底層是 byte 數組。單個字符使用一個 int32 的別名 rune 表示，其值爲 Unicode 字符碼點。\n\nGo 的變量使用 var 關鍵字聲明，也可以使用短變量聲明；常量則是使用 const 關鍵字聲明。\n\nGo 有 if 條件語句、for 循環語句、switch 選擇語句和 defer 延遲執行語句。Go 的 for 語句兼具其他語言的 while 語句；switch 語句每個 case 條件都支持運算，且默認自動 break；defer 語句可以立即計算參數值，然後在函數 return 前執行。\n\nGo 的可見性跟標識符的首字母是否大寫相關，大寫則是導出的，包外可見；小寫則是非導出的，包外不可見。\n\nGo 有指針，要注意 `&` 是生成指向操作數的指針，而 `*` 是獲取指針指向的底層值。\n\nGo 將一些字段組合成一個結構體(struct) 。結構體支持隱式間接調用，即 p.X 等價於 (*p).X（p 爲結構體指針）。\n\nGo 支持數組，更重要的是支持一種名爲切片(slice) 的動態數組。切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量。\n\nGo 支持映射(map)。\n\nGo 支持函數(function)的命名返回值、多值返回、作爲值傳遞和閉包。還有一種稱爲方法(method)的特殊函數，其帶有接收者參數，接收者可以是值接收者也可以是指針接收者，指針接收者可以更改接收者的值。\n\nGo 支持將一些方法簽名組成接口(interface)。接口的實現是隱式的，不需要「implements」。一個結構體作爲接收者定義了接口中的所有方法，那麼該結構體就是實現了該接口。因爲隱式的緣故，建議接口方法盡可能少，以便管理。接口是值，可以傳遞。底層值是 nil 的接口，其方法可以被調用；接口本身爲 nil ，則意味著其不保存值也不保存具體類型；空接口(interface{})是包含零個函數的接口，不是爲 nil 接口。\n\nGo 的異常處理很簡單，只有 Error，沒有 throws。\n\nGo 支持 Go 程，一種 Go運行時管理的輕量級線程。Go 程之間可以通過信道(channel) 通信，通過 Mutex 或 RWMutex 共享互斥變量，通過 WaitGroup 等待執行完成。 \n\nGo 中的信道還支持通過 for-range 循環讀取數據，當信道關閉時該循環自動退出。記住，只有發送方可以關閉信道，接收方不能。信道還支持 select 語句，其會**阻塞到某一分支可以執行爲止**，如沒有分支可以執行且設定了default 語句，會一直執行 default 語句。\n\n<!-- more -->\n\n以下內容多來自[《Go 指南》](https://tour.go-zh.org/)，內容有所改動。\n\n## 歷史\n\nGo 又稱 Golang，是 Google 公司開發的一款靜態強類型、編譯型、並發型，並具有垃圾回收功能的編程語言。\n\n1. 2007.9.21 罗伯特·格瑞史莫(Robert Griesemer)、罗勃·派克(Rob Pike)和肯·汤普逊(Ken Thompson) 開始設計 Go。\n2. 2009.11 Google 發佈 Go 語言。\n3. 2012.3 Go 1.0 發佈。\n4. 2018.8 Go 1.11 發佈，預支持 modules 進行依賴管理。\n\n## 入門\n\n### 安裝\n\n按照[官方教程](https://golang.org/doc/install)安裝即可。\n\n### Hello World\n\n直接在系統 Home 目錄，新建一一個 hello.go 文件，寫入代碼如下：\n\n```go\npackage main //程序從 main 包的 main 函數開始運行\nimport \"fmt\" //導入 fmt 包\n\nfunc main() { //main函數\n    fmt.Println(\"Hello, World!\") //打印日誌\n}\n```\n\n然後執行 `go run hello.go` 即可。\n\n### GOPATH\n\n當項目未啟用 Go modules 時，Go 使用 `GOPATH` 環境變量解析 import 語句。`GOPATH` 的值默認爲 `$HOME/go` ， `GOPATH` 目錄結構如下：\n\n```go\nGOPATH=/home/user/go\n\nsrc/\n    foo/\n        bar/               (go code in package bar)\n            x.go\n        quux/              (go code in package main)\n            y.go\nbin/\n    quux                   (installed command)\npkg/\n    linux_amd64/\n        foo/\n            bar.a          (installed package object)\n```\n\n- src：存放依賴的源代碼\n- bin：存放安裝的命令\n- pkg：存法安裝的包對象\n\n啟用 Go modules 後雖然不通過 `GOPATH` 解析 import 語句，但下載的源代碼和安裝的命令都會存在`GOPATH`目錄下。\n\n### Vendor\n\nVendor 就是使用本地依賴包的模式，Go 1.5 作爲實驗特性，Go 1.6 正式支持，Go 1.14 正式終結。命名爲 vender(小商販) 是一種比喻，並將 GOPATH 隱喻爲有固定地址的商舖。啟用 Vendor 模式很簡單，在項目中創建一個名爲 vendor 的文件夾然後拷貝依賴的源代碼進入其中即可。比如有如下的項目使用了 Vendor：\n\n```go\n$GOPATH\n|\tsrc/\n|\t|\tgithub.com/constabulary/example-gsftp/\n|\t|\t|\tcmd/\n|\t|\t|\t|\tgsftp/\n|\t|\t|\t|\t|\tmain.go\n|\t|\t|\tvendor/\n|\t|\t|\t|\tgithub.com/pkg/sftp/\n|\t|\t|\t|\tgolang.org/x/crypto/ssh/\n|\t|\t|\t|\t|\tagent/\n```\n\n在文件 `github.com/constabulary/example-gsftp/cmd/gsftp/main.go` 中應這樣 import 依賴（不需要加入 vendor 前綴）：\n\n```go\nimport (\n\t...\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/agent\"\n\t\"github.com/pkg/sftp\"\n)\n```\n\n這種方式顯然會帶來代碼膨脹，特別是N個庫同時用 Vendor 模式依賴一個通用庫時，那麼該通用庫的代碼將會出現N次。\n\n### Go modules\n\nGo 官方推出的依賴管理系統，在 Go 1.11 和 1.12中已經有初步支持，但默認關閉；從 1.13 開始默認啟用，1.14 開始可用於生產。\n\n**（1）使用 Go modules**\n\n使用 Go modules 很簡單，只需要在項目根路徑(不可以在 `$GOPATH/src` 裏面)執行 `go mod init example.com/m` 即可初始化一個名爲 `example.com/m` 的模塊，之後會在項目根路徑生成一個名爲 `go.mod` 的依賴文件，其內容結構如下：\n\n```go\nmodule example.com/hello //模塊名\n\ngo 1.12 //使用的 Go 版本\n\nrequire rsc.io/quote v1.5.2 //依賴項\n```\n\n此外，Go modules 還生成和維護著一個名爲 `go.sum` 的文件，該文件包含了期望的指定模塊版本的內容的加密哈希。\n\n爲保證依賴的一致性，需要同時將 `go.mod` 和 `go.sum` 加入版本管理。\n\n**（2）更新依賴**\n\n更新小版本很簡單，一個 `go get` 命令就完了。更新大版本比更新小版本複雜，因爲大版本通常會帶來 API 的變化，Go 要求更改大版本號後，模塊名也要加上版本號。例如原本是 `rsc.io/quote` 的依賴，升級到 v3 後依賴要改成 `rsc.io/quote/v3` ，因此代碼中的 import 語句要改成 `rsc.io/quote/v3` ，然後清理掉舊版本的依賴，有點麻煩。\n\n```bash\n# 列出當前項目的模塊和依賴項\ngo list -m all\n# 直接更新到最新的小版本\ngo get rsc.io/sampler\n# 列出所有小版本\ngo list -m -versions rsc.io/sampler\n# 更新到指定版本\ngo get rsc.io/sampler@v1.3.1\n\n# 查看模塊的所有版本\ngo list -m rsc.io/q...\n# 清除未使用的依賴\ngo mod tidy\n```\n\n### 循環依賴\n\nGo 不支持循環依賴，Go設計者Rob Pike認爲如果出現兩個包循環依賴，那麼是你的設計問題。\n\n筆者就出現過一次循環依賴，場景是：封裝了一個打印日誌的庫A和一個解析配置的庫B，庫A需要通過庫B配置，庫B需要用庫A打印日誌。最後選擇在庫B使用原始的日誌打印。\n\n## 語法\n\n### 數據類型\n\n**（1）基本類型**\n\n```go\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的別名\n    // 表示一個 Unicode 碼點\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\n其中 int, uint 和 uintptr 在 32 位系統上通常為 32 位寬，在 64 位系統上則為 64 位寬。\n\nstring 表示一個 UTF-8 類型的字符串，底層是一個字節數組。\n\nrune 表示一個 Unicode 碼點，是 int32 的別名。讀取 string 中的每個字符，只需要將 string 轉爲 rune 數組即可\n\nJava 中的 char 類型，每個字符對應一個 Unicode 碼點，可以表示BMP範圍內（即[U+0000, U+FFFF]之間）的Unicode字符。String 是 UTF-8 類型。\n\n**（2）零值**\n\n没有明确初始值的变量声明会被赋予它们的 **零值**。\n\n零值是：\n\n- 数值类型为 `0`，\n- 布尔类型为 `false`，\n- 字符串为 `\"\"`（空字符串）。\n\n**（3）類型轉換**\n\n數值之間可以通過表達式 T(v) 將值 v 轉換為類型 T，如：\n\n```go\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n**（4）类型推导**\n\n在聲明一個變量而不指定其類型時（即使用不帶類型的 := 語法或 var = 表達式語法），變量的類型由右值推導得出。\n\n```go\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n```\n\n### 變量\n\n**（1）聲明語句**\n\n```go\n// var 開頭，逗號(,)分割變量名，最後寫數據類型 \nvar c, python, java bool\n```\n\n**（2）賦值語句**\n\n```go\nvar c, python, java = true,false,\"no\"\n```\n\n或直接使用**短變量聲明**，注意短變量聲明只能在函數內使用，因爲函數外的每個語句要求必須以關鍵字開始。\n\n```go\nc, python, java := true,false,\"no\"\n```\n\n### 常量\n\n常量聲明使用 const 關鍵字。常量可以是字符、字符串、布尔值或数值。常量不能用 `:=` 语法声明。\n\n```go\nconst Pi = 3.14\n```\n\n`iota` 可以用來創建順序遞增的常量。\n\n```go\nconst (\n\tLow = iota //0\n\tMedium     //1\n\tHigh       //2\n)\n```\n\n### 風格\n\n1. 每行程序結束後不需要撰寫分號（;）。\n2. 大括號（{）不能夠換行放置。\n3. if判斷式和for循環不需要以小括號包覆起來。\n4. 使用 tab 做排版\n\n### 流程控制\n\n**（1）if-else**\n\n不需要小括號，可以使用簡短語句。\n\n```go\n_,ok := sendMsg();\nif ok {\n  // do something\n}else{\n  // do other thing\n}\n// 等價於以下簡短語句\nif _,ok := sendMsg(); ok {\n  // do something\n}else{\n  // do other thing\n}\n```\n\n**（2）for**\n\nGo 中的 for 語句，還包含了其他語言的 while 的功能。特別的不用括號包裹。\n\n```go\n// 功能：遍歷 10 次\nfor i:=0;i<10;i++{\n}\n// 功能：類似於其他語言 while 的功能\nvar i = 0\nfor i<10{\n}\n// 功能：無限循環，類似於其他語言中的 while(true)\nfor{\n}\n// 功能：for range 循環，返回當前元素的下標及副本\n// 可通過 _ 忽略其中的某個值\npow := []int{1, 2, 4, 8}\nfor i, v := range pow {\n\tfmt.Printf(\"%d,%d\\n\", i, v)\n}\nfor _,v := range pow {\n\tfmt.Printf(\"%d\\n\", v)\n}\nfor i := range pow {\n\tfmt.Printf(\"%d\\n\", i)\n}\n```\n\n**（3）switch**\n\nGo 中的 switch 語句是自動 break 的。如果不想要break，需要在 case 後面協商 fallthrough。\n\nGo 中的 switch 的 case 無需為常量，且取值不必為整數。\n\n```go\n// 功能：選擇顏色\nswitch color {\n    case Red:\n    // do something\n    case Green:\n    // do something\n    default:\n    // do something\n}\n// 功能：替代 if-then-else，更整齊\nresult := request()\nswitch {\n    case result > 0:\n    case result <0:\n    default:\n}\n// 或者\nswitch result := request(); {\n    case result > 0:\n    case result <0:\n    default:\n}\n```\n\n**（4）defer**\n\ndefer 語句會將函數推遲到外層函數返回之後執行。\n\n推遲調用的函數其參數會立即求值，但直到外層函數返回前該函數都不會被調用。\n\n推遲的函數調用會被壓入一個棧中。當外層函數返回時，被推遲的函數會按照後進先出的順序調用。\n\n```go\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n```\n\ndefer 並不是免費的。defer 底層會調用 `runtime.deferproc` 去設置要延遲調用的函數，調用 `runtime.deferreturn` 會依次執行先前延遲調用的函數。參考：https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32\n\n### 可見性\n\n- 導出：大寫字母開頭的標識符，包外可訪問。\n- 未導出：非大寫字母開頭的標識符，包外不可訪問。\n\n### 指針\n\nGo 擁有指針。指針保存了值的內存地址。\n\n- 類型 `*T` 是指向 `T` 類型值的指針。其零值為 `nil`。\n- `&` 操作符會**生成一個指向其操作數的指針**。（注意：把`&` 理解爲取地址符號是錯誤的）\n- `*` 操作符**表示指針指向的底層值**。（注意：把`*` 理解爲取值符號是錯誤的）\n\n```go\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := &i         // 指向 i\n\tfmt.Println(*p) // 通過指針讀取 i 的值\n\t*p = 21         // 通過指針設置 i 的值\n\tfmt.Println(i)  // 查看 i 的值\n\n\tp = &j         // 重定向到 j\n\t*p = *p / 37   // 通過指針對 j 進行除法運算\n\tfmt.Println(j) // 查看 j 的值\n}\n```\n\n### 結構體\n\n一個結構體（struct）就是一組字段（field）。外界使用點號來訪問結構體字段。\n\n結構體字段可以通過結構體指針來訪問。如果我們有一個指向結構體的指針 p，那麼可以通過 `(*p).X` 來訪問其字段 X。不過這麼寫太囉嗦了，所以語言也允許我們使用**隱式間接引用**，直接寫 `p.X` 就可以。\n\n```go\ntype Vertex struct {\n\tX, Y int\n}\n\nfunc main() {\n  v := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n  \n  p := &v\n\tp.X = 1e9\n\tfmt.Println(v)\n\n\tv2 = Vertex{X: 1}  // Y:0 被隱式地賦予\n\tv3 = Vertex{}      // X:0 Y:0\n\tp  = &Vertex{1, 2} // 創建一個 *Vertex 類型的結構體（指針）\n}\n```\n\n### 數組\n\n類型 [n]T 表示擁有 n 個 T 類型的值的數組。\n\n表达式\n\n```go\nvar a [10]int\n```\n\n會將變量 `a` 聲明為擁有 10 個整數的數組。\n\n### 切片\n\n**（1）定義**\n\n類型 []T 表示一個元素類型為 T 的切片。T 可以是任何類型，包括切片本身。\n\n切片通過兩個下標來界定，即一個上界和一個下界，二者以冒號分隔：\n\n```go\na[low : high]\n```\n\n它會選擇一個半開區間，包括第一個元素，但排除最後一個元素。\n\n切片下界的默認值爲 0，上界則是其底層數組的長度。\n\n對於數組 `var a [10]int` 來說，以下切片是等價的：\n\n```go\na[0:10]\na[:10]\na[0:]\na[:]\n```\n\n**（2）切片的本質**\n\n一個切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量，其結構如下：\n\n![](go-basic/Untitled.png)\n\n![](go-basic/Untitled%201.png)\n\n切片的長度就是它所包含的元素個數。\n切片的容量是從它的第一個元素開始數，到其底層數組元素末尾的個數。\n切片 s 的長度和容量可通過表達式 `len(s)` 和 `cap(s)` 來獲取。\n\n更改切片的元素會修改其底層數組中對應的元素。與它共享底層數組的切片都會觀測到這些修改。\n\n```go\nfunc main() {\n\tnames := [4]string{\n\t\t\"John\",\n\t\t\"Paul\",\n\t\t\"George\",\n\t\t\"Ringo\",\n\t}\n\tfmt.Println(names)\n\n\ta := names[0:2]\n\tb := names[1:3]\n\tfmt.Println(a, b)\n\n\tb[0] = \"XXX\"\n\tfmt.Println(a, b)\n\tfmt.Println(names)\n}\n```\n\n注意：切片的零值爲 nil，其長度和容量爲 0 且沒有底層數組。\n\n**（3）通過 make 創建切片**\n\n```go\na := make([]int, 5)  // len(a)=5\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n```\n\n**（4）通過 append 追加元素**\n\n```go\nfunc append(s []T, vs ...T) []T\n```\n\n`append` 的第一個參數 `s` 是一個元素類型為 `T` 的切片，其餘類型為 `T`的值將會追加到該切片的末尾。\n\n`append` 的結果是一個包含原切片所有元素加上新添加元素的切片。\n\n當 `s` 的底層數組太小，不足以容納所有給定的值時，它就會分配一個更大的數組。返回的切片會指向這個新分配的數組。\n\n當引用一個原始數組時，GC不會釋放該數組的空間，即使只用到其中一小部分數據。因此函數返回切片的時候要特別注意，最好拷貝需要數據到新的切片再返回。\n\n```go\n// 使用 copy 函數\nfunc CopyDigits(filename string) []byte {\n    b, _ := ioutil.ReadFile(filename)\n    b = digitRegexp.Find(b)\n    c := make([]byte, len(b))\n    copy(c, b)\n    return c\n}\n// 或使用 append 函數\nfunc CopyDigits(filename string) []byte {\n    b, _ := ioutil.ReadFile(filename)\n    b = digitRegexp.Find(b)\n    var c []byte\n    return append(c, b...)\n}\n```\n\n### 映射\n\n映射將鍵映射到值。\n\n映射的零值為 `nil` 。`nil` 映射既沒有鍵，也不能添加鍵。\n\n`make` 函數會返回給定類型的映射，並將其初始化備用。\n\n```go\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": {40.68433, -74.39967},\n\t\"Google\":    {37.42202, -122.08408},\n}\n```\n\n 常用操作：\n\n1. 插入或修改元素：`m[key] = elem`\n2. 獲取元素：`elem = m[key]`\n3. 通過雙賦值檢測某個鍵是否存在：`elem, ok := m[key]`\n4. 刪除元素：`delete(m, key)`\n\n### 函數(function)\n\n**（1）概述**\n\n函數可以沒有參數或接受多個參數。當連續兩個或多個函數的已命名形參類型相同時，除最後一個類型以外，其它都可以省略。\n\n```go\nfunc add(x, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n```\n\n**（2）命名返回值**\n\nGo 的返回值可被命名，它們會被視作**定義在函數頂部的變量**。返回值的名稱應當具有一定的意義，它可以作為文檔使用。沒有參數的 `return` 語句返回已命名的返回值。也就是 `直接` 返回。直接返回語句應當僅用在下面這樣的短函數中。在長的函數中它們會影響代碼的可讀性。\n\n```go\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(split(17))\n}\n```\n\n**（3）多值返回**\n\n函數可以返回任意數量的返回值。\n\n```go\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n```\n\n**（4）函數值**\n\n函數也是值，可以作爲函數的參數或返回值。\n\n```go\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\nfmt.Println(compute(math.Pow))\n```\n\n**（5）閉包(closure)**\n\n閉包是指一個函數引用了其函數體之外的變量，該函數可以訪問並賦予其引用的變量的值。換句話說就是該函數跟函數體之外的變量綑綁在一起了。每次調用閉包中的函數可以改變閉包中變量的值。例如斐波那契閉包：\n\n```go\nfunc fibonacci() func() int {\n\tx,y := 0,1\n\treturn func() int {\n\t\tres := x\n\t\tx,y = y,x+y\n\t\treturn res\n\t}\n}\n\nfunc main() {\n\tf := fibonacci()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(f())\n\t}\n}\n```\n\n### 方法(method)\n\n方法就是一類帶特殊的**接收者參數**的函數。方法接收者在它自己的參數列表內，**位於 func 關鍵字和方法名之間**。\n\n```go\ntype Vertex struct {\n\tX, Y float64\n}\n// 這就是方法\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n```\n\n值得注意的是：接收者的類型定義和方法聲明必須在同一包內；不能爲內建類型聲明方法。\n\n接收者除了是**值接收者**外，還支持**指針接收者**，使用 `*T` (不能是 `*int` 之類的) 的文法即可。指針接收者可以修改接收者指向的值。如下：\n\n```go\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(10) // 此時 Go 會解釋爲 (&v).Scale(10)，這就是指針重定向\n\tfmt.Println(v.Abs())\n}\n```\n\n使用指針接收者的好處：\n\n1. 方法能夠修改其接收者指向的值。\n2. 避免在每次調用方法時複製該值。該值佔用的空間越大，則越顯得高效。\n\n注意：一個結構體採用值接收者的方式實現了接口的方法，則隱含著採用指針接收者的方式實現了接口的方法。（接收者是指針類型的方法，很可能在方法中會對接收者的屬性進行更改操作，從而影響接收者；而對於接收者是值類型的方法，在方法中不會對接收者本身產生影響）\n\n### 接口\n\n**（1）定義**\n\n接口類型是**由一組方法簽名定義的集合**。接口類型的變量可以保存**任何**實現了這些方法的值。\n\n**（2）隱式實現**\n\n類型通過實現一個接口的所有方法來實現該接口。既然無需專門顯式聲明，也就沒有「implements」關鍵字。\n\n```go\ntype Animal interface {\n\teat()\n}\n\ntype John struct{}\n\nfunc (j *John) eat() {\n\tfmt.Println(\"eat...\")\n}\n\ntype Person interface {\n\teat()\n\ttalk()\n}\n\nfunc (j *John) talk() {\n\tfmt.Println(\"talk...\")\n}\n\nfunc main() {\n\tvar a Animal = &John{}\n\ta.eat()\n\tvar b Person = &John{}\n\tb.eat()\n\tb.talk()\n}\n```\n\n**（4）接口值**\n\n接口也是值，可以作爲函數的參數或返回值。在內部，接口值可以看做包含值和具體類型的元組：`(value, type)` 。接口值保存了一個具體底層類型的具體值。接口值調用方法時會執行其底層類型的同名方法。\n\n```go\n// Animal、John 見上面的代碼\nj := John{}\ndescribe(j)\n\nfunc describe(i Animal){\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n**（5）底層值爲 nil 的接口值**\n\n即便接口內的具體值為 nil，方法仍然會被 nil 接收者調用。\n\n```go\n// 改造上面的代碼\nfunc (j *John) talk() {\n\tif j == nil {\n\t\tfmt.Println(\"j is <nil>\")\n\t\treturn\n\t}\n\tfmt.Println(\"talk...\")\n}\n\nfunc main() {\n\tvar x Person\n\tvar y John\n\tx = &y\n\tdescribe(x)\n\tx.talk() // 正常調用\n}\n```\n\n判斷接口的底層值是否爲 nil 的方法：\n\n```go\n// 接上\nprintln( x == nil || reflect.ValueOf(x).IsNil())\n```\n\n**（6）nil 接口值**\n\nnil 接口值既不保存值也不保存具體類型。\n\n為 nil 接口調用方法會產生運行時錯誤，因為接口的元組內並未包含能夠指明該調用哪個 **具體** 方法的類型。\n\n```go\ntype I interface {\n\tM()\n}\n\nfunc main() {\n\tvar i I\n\tdescribe(i)\n\ti.M() // 此處拋出 panic: runtime error: invalid memory address or nil pointer dereference\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i) // (<nil>, <nil>)\n}\n```\n\n**（7）空接口**\n\n指定了**零個方法**的接口值被稱為空接口，即 `interface{}` 。空接口可保存任何類型的值。（因為每個類型都至少實現了零個方法。）空接口被用來處理未知類型的值。例如，`fmt.Print` 可接受類型為 `interface{}` 的任意數量的參數。\n\n```go\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42 // 保存 int值\n\tdescribe(i)\n\n\ti = \"hello\" // 保存 string值\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n**（8）類型斷言**\n\n類型斷言提供了訪問**接口值底層具體值**的方式。\n\n```go\n// 判斷接口i的底層值類型是否爲T，如是返回其底層值和true，否則返回T類型的零值和false\nt, ok := i.(T)\n```\n\n```go\nvar i interface{} = \"hello\"\ns, ok := i.(string)\nfmt.Println(s, ok)\nf, ok := i.(int)\nfmt.Println(f, ok)\n// 支持類型選擇\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n\tcase string:\n\t\tfmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n\tdefault:\n\t\tfmt.Printf(\"I don't know about type %T!\\n\", v)\n\t}\n}\n```\n\n### 異常處理\n\nGo 程序使用 `error` 值來表示錯誤狀態。\n\n```go\ntype error interface {\n    Error() string\n}\n```\n\n通常函數會返回一個 `error` 值，調用的它的代碼應當判斷這個錯誤是否等於 `nil` 來進行錯誤處理。`error` 為 nil 時表示成功；非 nil 的 `error` 表示失敗。\n\n```go\nif i, err := strconv.Atoi(\"42\"); err == nil {\n    fmt.Println(\"Converted integer:\", i)\n}\n```\n\n### Go 程(goroutine)\n\n**（1）定義**\n\n**Go 程（goroutine）是由 Go 運行時管理的輕量級線程**。\n\n```go\n// x,y,z 的求值發生在當前 Go 程中，f 的執行則是在新的 Go 程中\ngo f(x, y, z)\n```\n\n（**2）信道**\n\n**信道是帶有類型的管道**，你可以通過它用**信道操作符** `<-` (箭頭就是數據流的方向)來發送或者接收值。\n\n默認情況下，發送和接收操作在另一端準備好之前都會阻塞。這使得 Go 程可以在沒有顯式的鎖或競態變量的情況下進行同步。\n\n```go\n// 創建信道\nch := make(chan int)\n// 將 v 發送至信道 ch。\nch <- v\n// 從 ch 接收值並賦予 v。\nv := <-ch\n```\n\n**信道可以是帶緩衝，**將緩衝長度作為第二個參數提供給 `make` 來初始化一個帶緩衝的信道。\n\n```go\nch := make(chan int, 100)\n```\n\n**僅當信道的緩衝區填滿後，向其發送數據時才會阻塞。當緩衝區為空時，接受方會阻塞。**\n\n**（3）range 和 close**\n\n有且僅有發送者可以通過 close 方法關閉一個信道。接收者讀取值的時候可以通過 `v, ok := <-ch`  的 ok 值判斷是否信道關閉了。更簡單的是使用 for-range 不斷從信道接收值，直到信道關閉，循環自動退出。\n\n```go\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n```\n\n**（4）select**\n\nselect 語句使一個 Go 程可以等待多個通信操作。select 會阻塞到某個分支可以繼續執行為止，這時就會執行該分支。當多個分支都準備好時會隨機選擇一個執行。當 select 中的其它分支都沒有準備好時，default 分支就會執行。\n\n```go\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n    default:\n      // 當 c 和 quit 阻塞時會執行到此處\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci(c, quit)\n}\n```\n\n- 練習：等價二叉查找樹\n\n    函數 tree.New(k) 用於構造一個隨機結構的已排序二叉查找樹，它保存了值 k, 2k, 3k, ..., 10k。\n\n    Walk 步進 tree t 將所有的值從 tree 發送到 channel ch。\n\n    用 Walk 實現 Same 函數來檢測 t1 和 t2 是否存儲了相同的值。\n\n    ```go\n    package main\n\n    import \"golang.org/x/tour/tree\"\n\n    func Walk(t *tree.Tree, ch chan int){\n    \tif t.Left != nil{\n    \t\tWalk(t.Left, ch)\n    \t}\n    \tch <- t.Value\n    \tif t.Right != nil{\n    \t\tWalk(t.Right, ch)\n    \t}\n    }\n\n    // Same 检测树 t1 和 t2 是否含有相同的值。\n    func Same(t1, t2 *tree.Tree) bool{\n    \tch1,ch2 := make(chan int),make(chan int)\n    \tgo func(){\n    \t\tWalk(t1, ch1)\n    \t\tclose(ch1)\n    \t}()\n    \tgo func(){\n    \t\tWalk(t2, ch2)\n    \t\tclose(ch2)\n    \t}()\n    \tfor i := range ch1{\n    \t\tif i != <-ch2 {\n    \t\t\treturn false\n    \t\t}\n    \t}\n    \treturn true\n    }\n\n    func main() {\n    \tprintln(Same(tree.New(1),tree.New(1)))\n    }\n    ```\n\n**（5）sync.Mutex**\n\n互斥鎖可以保證每次只有一個 Go 程訪問一個共享變量。\n\nGo 標準庫中的 **Mutex** 就是一個互斥鎖，可以創建為其他結構體的字段；零值為解鎖狀態。Mutex類型的鎖和線程無關，可以由不同的線程加鎖和解鎖。在代碼前調用 Lock 方法，並在代碼後調用 Unlock 方法來保證一段代碼互斥執行。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\nfunc (c *SafeCounter) Increase(key string) {\n\tc.mux.Lock()\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\tdefer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\")\n\t}\n\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n}\n```\n\n爲了提升讀寫性能，常用 **RWMutex** 代替 **Mutex。**RWMutex是讀寫互斥鎖。該鎖可以被同時多個讀取者持有或唯一個寫入者持有。RWMutex可以創建為其他結構體的字段；零值為解鎖狀態。RWMutex類型的鎖也和線程無關，可以由不同的線程加讀取鎖/寫入和解讀取鎖/寫入鎖。\n\n下面的代碼效果不明顯，因爲讀的次數不多。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.RWMutex\n}\n\nfunc (c *SafeCounter) Increase(key string) {\n\tc.mux.Lock()\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.RLock()\n\tdefer c.mux.RUnlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tnow := time.Now()\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\")\n\t}\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n\tprint(time.Now().Sub(now))\n}\n```\n\n**（6）WaitGroup**\n\nWaitGroup 可以等待一組 Go 程結束。通過調用 Add 方法設定要等待的 Go 程數量。然後各個 Go 程通過調用 Done 方法結束等待。\n\n```go\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.RWMutex\n}\n\nfunc (c *SafeCounter) Increase(key string, wg *sync.WaitGroup) {\n\tc.mux.Lock()\n\tc.v[key]++\n\twg.Done()\n\tc.mux.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.RLock()\n\tdefer c.mux.RUnlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\twg := sync.WaitGroup{}\n\twg.Add(1000)\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Increase(\"somekey\", &wg)\n\t}\n\twg.Wait()\n\tfmt.Println(c.Value(\"somekey\"))\n}\n```","slug":"it/go/go-basic","published":1,"date":"2021-02-05T16:21:16.428Z","updated":"2021-02-05T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7woo00119a9k5flu72j4","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>Go 又稱 Golang，是 Google 公司 2009 年發佈的一款開源編程語言，以簡潔而高效的代碼著稱。Go 目前使用 GOPATH 或 Go modules 管理項目中的第三方依賴，且不支持循環依賴。</p>\n<p>Go 的基本數據類型有 16 種(不包含別名)，可謂豐富。要注意的是 string 也是基本數據類型，表示一個 UTF-8 字符串，底層是 byte 數組。單個字符使用一個 int32 的別名 rune 表示，其值爲 Unicode 字符碼點。</p>\n<p>Go 的變量使用 var 關鍵字聲明，也可以使用短變量聲明；常量則是使用 const 關鍵字聲明。</p>\n<p>Go 有 if 條件語句、for 循環語句、switch 選擇語句和 defer 延遲執行語句。Go 的 for 語句兼具其他語言的 while 語句；switch 語句每個 case 條件都支持運算，且默認自動 break；defer 語句可以立即計算參數值，然後在函數 return 前執行。</p>\n<p>Go 的可見性跟標識符的首字母是否大寫相關，大寫則是導出的，包外可見；小寫則是非導出的，包外不可見。</p>\n<p>Go 有指針，要注意 <code>&amp;</code> 是生成指向操作數的指針，而 <code>*</code> 是獲取指針指向的底層值。</p>\n<p>Go 將一些字段組合成一個結構體(struct) 。結構體支持隱式間接調用，即 p.X 等價於 (*p).X（p 爲結構體指針）。</p>\n<p>Go 支持數組，更重要的是支持一種名爲切片(slice) 的動態數組。切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量。</p>\n<p>Go 支持映射(map)。</p>\n<p>Go 支持函數(function)的命名返回值、多值返回、作爲值傳遞和閉包。還有一種稱爲方法(method)的特殊函數，其帶有接收者參數，接收者可以是值接收者也可以是指針接收者，指針接收者可以更改接收者的值。</p>\n<p>Go 支持將一些方法簽名組成接口(interface)。接口的實現是隱式的，不需要「implements」。一個結構體作爲接收者定義了接口中的所有方法，那麼該結構體就是實現了該接口。因爲隱式的緣故，建議接口方法盡可能少，以便管理。接口是值，可以傳遞。底層值是 nil 的接口，其方法可以被調用；接口本身爲 nil ，則意味著其不保存值也不保存具體類型；空接口(interface{})是包含零個函數的接口，不是爲 nil 接口。</p>\n<p>Go 的異常處理很簡單，只有 Error，沒有 throws。</p>\n<p>Go 支持 Go 程，一種 Go運行時管理的輕量級線程。Go 程之間可以通過信道(channel) 通信，通過 Mutex 或 RWMutex 共享互斥變量，通過 WaitGroup 等待執行完成。 </p>\n<p>Go 中的信道還支持通過 for-range 循環讀取數據，當信道關閉時該循環自動退出。記住，只有發送方可以關閉信道，接收方不能。信道還支持 select 語句，其會<strong>阻塞到某一分支可以執行爲止</strong>，如沒有分支可以執行且設定了default 語句，會一直執行 default 語句。</p>\n<span id=\"more\"></span>\n\n<p>以下內容多來自<a href=\"https://tour.go-zh.org/\">《Go 指南》</a>，內容有所改動。</p>\n<h2 id=\"歷史\"><a href=\"#歷史\" class=\"headerlink\" title=\"歷史\"></a>歷史</h2><p>Go 又稱 Golang，是 Google 公司開發的一款靜態強類型、編譯型、並發型，並具有垃圾回收功能的編程語言。</p>\n<ol>\n<li>2007.9.21 罗伯特·格瑞史莫(Robert Griesemer)、罗勃·派克(Rob Pike)和肯·汤普逊(Ken Thompson) 開始設計 Go。</li>\n<li>2009.11 Google 發佈 Go 語言。</li>\n<li>2012.3 Go 1.0 發佈。</li>\n<li>2018.8 Go 1.11 發佈，預支持 modules 進行依賴管理。</li>\n</ol>\n<h2 id=\"入門\"><a href=\"#入門\" class=\"headerlink\" title=\"入門\"></a>入門</h2><h3 id=\"安裝\"><a href=\"#安裝\" class=\"headerlink\" title=\"安裝\"></a>安裝</h3><p>按照<a href=\"https://golang.org/doc/install\">官方教程</a>安裝即可。</p>\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>直接在系統 Home 目錄，新建一一個 hello.go 文件，寫入代碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main <span class=\"comment\">//程序從 main 包的 main 函數開始運行</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span> <span class=\"comment\">//導入 fmt 包</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//main函數</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Hello, World!&quot;</span>) <span class=\"comment\">//打印日誌</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然後執行 <code>go run hello.go</code> 即可。</p>\n<h3 id=\"GOPATH\"><a href=\"#GOPATH\" class=\"headerlink\" title=\"GOPATH\"></a>GOPATH</h3><p>當項目未啟用 Go modules 時，Go 使用 <code>GOPATH</code> 環境變量解析 import 語句。<code>GOPATH</code> 的值默認爲 <code>$HOME/go</code> ， <code>GOPATH</code> 目錄結構如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">GOPATH=/home/user/<span class=\"keyword\">go</span></span><br><span class=\"line\"></span><br><span class=\"line\">src/</span><br><span class=\"line\">    foo/</span><br><span class=\"line\">        bar/               (<span class=\"keyword\">go</span> code in <span class=\"keyword\">package</span> bar)</span><br><span class=\"line\">            x.<span class=\"keyword\">go</span></span><br><span class=\"line\">        quux/              (<span class=\"keyword\">go</span> code in <span class=\"keyword\">package</span> main)</span><br><span class=\"line\">            y.<span class=\"keyword\">go</span></span><br><span class=\"line\">bin/</span><br><span class=\"line\">    quux                   (installed command)</span><br><span class=\"line\">pkg/</span><br><span class=\"line\">    linux_amd64/</span><br><span class=\"line\">        foo/</span><br><span class=\"line\">            bar.a          (installed <span class=\"keyword\">package</span> object)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>src：存放依賴的源代碼</li>\n<li>bin：存放安裝的命令</li>\n<li>pkg：存法安裝的包對象</li>\n</ul>\n<p>啟用 Go modules 後雖然不通過 <code>GOPATH</code> 解析 import 語句，但下載的源代碼和安裝的命令都會存在<code>GOPATH</code>目錄下。</p>\n<h3 id=\"Vendor\"><a href=\"#Vendor\" class=\"headerlink\" title=\"Vendor\"></a>Vendor</h3><p>Vendor 就是使用本地依賴包的模式，Go 1.5 作爲實驗特性，Go 1.6 正式支持，Go 1.14 正式終結。命名爲 vender(小商販) 是一種比喻，並將 GOPATH 隱喻爲有固定地址的商舖。啟用 Vendor 模式很簡單，在項目中創建一個名爲 vendor 的文件夾然後拷貝依賴的源代碼進入其中即可。比如有如下的項目使用了 Vendor：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">$GOPATH</span><br><span class=\"line\">|\tsrc/</span><br><span class=\"line\">|\t|\tgithub.com/constabulary/example-gsftp/</span><br><span class=\"line\">|\t|\t|\tcmd/</span><br><span class=\"line\">|\t|\t|\t|\tgsftp/</span><br><span class=\"line\">|\t|\t|\t|\t|\tmain.<span class=\"keyword\">go</span></span><br><span class=\"line\">|\t|\t|\tvendor/</span><br><span class=\"line\">|\t|\t|\t|\tgithub.com/pkg/sftp/</span><br><span class=\"line\">|\t|\t|\t|\tgolang.org/x/crypto/ssh/</span><br><span class=\"line\">|\t|\t|\t|\t|\tagent/</span><br></pre></td></tr></table></figure>\n\n<p>在文件 <code>github.com/constabulary/example-gsftp/cmd/gsftp/main.go</code> 中應這樣 import 依賴（不需要加入 vendor 前綴）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"string\">&quot;golang.org/x/crypto/ssh&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;golang.org/x/crypto/ssh/agent&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/pkg/sftp&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>這種方式顯然會帶來代碼膨脹，特別是N個庫同時用 Vendor 模式依賴一個通用庫時，那麼該通用庫的代碼將會出現N次。</p>\n<h3 id=\"Go-modules\"><a href=\"#Go-modules\" class=\"headerlink\" title=\"Go modules\"></a>Go modules</h3><p>Go 官方推出的依賴管理系統，在 Go 1.11 和 1.12中已經有初步支持，但默認關閉；從 1.13 開始默認啟用，1.14 開始可用於生產。</p>\n<p><strong>（1）使用 Go modules</strong></p>\n<p>使用 Go modules 很簡單，只需要在項目根路徑(不可以在 <code>$GOPATH/src</code> 裏面)執行 <code>go mod init example.com/m</code> 即可初始化一個名爲 <code>example.com/m</code> 的模塊，之後會在項目根路徑生成一個名爲 <code>go.mod</code> 的依賴文件，其內容結構如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">module example.com/hello <span class=\"comment\">//模塊名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"number\">1.12</span> <span class=\"comment\">//使用的 Go 版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">require rsc.io/quote v1<span class=\"number\">.5</span><span class=\"number\">.2</span> <span class=\"comment\">//依賴項</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，Go modules 還生成和維護著一個名爲 <code>go.sum</code> 的文件，該文件包含了期望的指定模塊版本的內容的加密哈希。</p>\n<p>爲保證依賴的一致性，需要同時將 <code>go.mod</code> 和 <code>go.sum</code> 加入版本管理。</p>\n<p><strong>（2）更新依賴</strong></p>\n<p>更新小版本很簡單，一個 <code>go get</code> 命令就完了。更新大版本比更新小版本複雜，因爲大版本通常會帶來 API 的變化，Go 要求更改大版本號後，模塊名也要加上版本號。例如原本是 <code>rsc.io/quote</code> 的依賴，升級到 v3 後依賴要改成 <code>rsc.io/quote/v3</code> ，因此代碼中的 import 語句要改成 <code>rsc.io/quote/v3</code> ，然後清理掉舊版本的依賴，有點麻煩。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出當前項目的模塊和依賴項</span></span><br><span class=\"line\">go list -m all</span><br><span class=\"line\"><span class=\"comment\"># 直接更新到最新的小版本</span></span><br><span class=\"line\">go get rsc.io/sampler</span><br><span class=\"line\"><span class=\"comment\"># 列出所有小版本</span></span><br><span class=\"line\">go list -m -versions rsc.io/sampler</span><br><span class=\"line\"><span class=\"comment\"># 更新到指定版本</span></span><br><span class=\"line\">go get rsc.io/sampler@v1.3.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看模塊的所有版本</span></span><br><span class=\"line\">go list -m rsc.io/q...</span><br><span class=\"line\"><span class=\"comment\"># 清除未使用的依賴</span></span><br><span class=\"line\">go mod tidy</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循環依賴\"><a href=\"#循環依賴\" class=\"headerlink\" title=\"循環依賴\"></a>循環依賴</h3><p>Go 不支持循環依賴，Go設計者Rob Pike認爲如果出現兩個包循環依賴，那麼是你的設計問題。</p>\n<p>筆者就出現過一次循環依賴，場景是：封裝了一個打印日誌的庫A和一個解析配置的庫B，庫A需要通過庫B配置，庫B需要用庫A打印日誌。最後選擇在庫B使用原始的日誌打印。</p>\n<h2 id=\"語法\"><a href=\"#語法\" class=\"headerlink\" title=\"語法\"></a>語法</h2><h3 id=\"數據類型\"><a href=\"#數據類型\" class=\"headerlink\" title=\"數據類型\"></a>數據類型</h3><p><strong>（1）基本類型</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>  <span class=\"keyword\">int8</span>  <span class=\"keyword\">int16</span>  <span class=\"keyword\">int32</span>  <span class=\"keyword\">int64</span></span><br><span class=\"line\"><span class=\"keyword\">uint</span> <span class=\"keyword\">uint8</span> <span class=\"keyword\">uint16</span> <span class=\"keyword\">uint32</span> <span class=\"keyword\">uint64</span> <span class=\"keyword\">uintptr</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">byte</span> <span class=\"comment\">// uint8 的别名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">rune</span> <span class=\"comment\">// int32 的別名</span></span><br><span class=\"line\">    <span class=\"comment\">// 表示一個 Unicode 碼點</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">float32</span> <span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">complex64</span> <span class=\"keyword\">complex128</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 int, uint 和 uintptr 在 32 位系統上通常為 32 位寬，在 64 位系統上則為 64 位寬。</p>\n<p>string 表示一個 UTF-8 類型的字符串，底層是一個字節數組。</p>\n<p>rune 表示一個 Unicode 碼點，是 int32 的別名。讀取 string 中的每個字符，只需要將 string 轉爲 rune 數組即可</p>\n<p>Java 中的 char 類型，每個字符對應一個 Unicode 碼點，可以表示BMP範圍內（即[U+0000, U+FFFF]之間）的Unicode字符。String 是 UTF-8 類型。</p>\n<p><strong>（2）零值</strong></p>\n<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>\n<p>零值是：</p>\n<ul>\n<li>数值类型为 <code>0</code>，</li>\n<li>布尔类型为 <code>false</code>，</li>\n<li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li>\n</ul>\n<p><strong>（3）類型轉換</strong></p>\n<p>數值之間可以通過表達式 T(v) 將值 v 轉換為類型 T，如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">42</span></span><br><span class=\"line\">f := <span class=\"keyword\">float64</span>(i)</span><br><span class=\"line\">u := <span class=\"keyword\">uint</span>(f)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）类型推导</strong></p>\n<p>在聲明一個變量而不指定其類型時（即使用不帶類型的 := 語法或 var = 表達式語法），變量的類型由右值推導得出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">42</span>           <span class=\"comment\">// int</span></span><br><span class=\"line\">f := <span class=\"number\">3.142</span>        <span class=\"comment\">// float64</span></span><br><span class=\"line\">g := <span class=\"number\">0.867</span> + <span class=\"number\">0.5i</span> <span class=\"comment\">// complex128</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"變量\"><a href=\"#變量\" class=\"headerlink\" title=\"變量\"></a>變量</h3><p><strong>（1）聲明語句</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 開頭，逗號(,)分割變量名，最後寫數據類型 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c, python, java <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）賦值語句</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c, python, java = <span class=\"literal\">true</span>,<span class=\"literal\">false</span>,<span class=\"string\">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>或直接使用<strong>短變量聲明</strong>，注意短變量聲明只能在函數內使用，因爲函數外的每個語句要求必須以關鍵字開始。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">c, python, java := <span class=\"literal\">true</span>,<span class=\"literal\">false</span>,<span class=\"string\">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量聲明使用 const 關鍵字。常量可以是字符、字符串、布尔值或数值。常量不能用 <code>:=</code> 语法声明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Pi = <span class=\"number\">3.14</span></span><br></pre></td></tr></table></figure>\n\n<p><code>iota</code> 可以用來創建順序遞增的常量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  Low = <span class=\"literal\">iota</span> <span class=\"comment\">//0</span></span><br><span class=\"line\">  Medium     <span class=\"comment\">//1</span></span><br><span class=\"line\">  High       <span class=\"comment\">//2</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"風格\"><a href=\"#風格\" class=\"headerlink\" title=\"風格\"></a>風格</h3><ol>\n<li>每行程序結束後不需要撰寫分號（;）。</li>\n<li>大括號（{）不能夠換行放置。</li>\n<li>if判斷式和for循環不需要以小括號包覆起來。</li>\n<li>使用 tab 做排版</li>\n</ol>\n<h3 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h3><p><strong>（1）if-else</strong></p>\n<p>不需要小括號，可以使用簡短語句。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">_,ok := sendMsg();</span><br><span class=\"line\"><span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do other thing</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等價於以下簡短語句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> _,ok := sendMsg(); ok &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do other thing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）for</strong></p>\n<p>Go 中的 for 語句，還包含了其他語言的 while 的功能。特別的不用括號包裹。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 功能：遍歷 10 次</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：類似於其他語言 while 的功能</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i&lt;<span class=\"number\">10</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：無限循環，類似於其他語言中的 while(true)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：for range 循環，返回當前元素的下標及副本</span></span><br><span class=\"line\"><span class=\"comment\">// 可通過 _ 忽略其中的某個值</span></span><br><span class=\"line\">pow := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d,%d\\n&quot;</span>, i, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> _,v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）switch</strong></p>\n<p>Go 中的 switch 語句是自動 break 的。如果不想要break，需要在 case 後面協商 fallthrough。</p>\n<p>Go 中的 switch 的 case 無需為常量，且取值不必為整數。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 功能：選擇顏色</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> color &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> Red:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Green:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：替代 if-then-else，更整齊</span></span><br><span class=\"line\">result := request()</span><br><span class=\"line\"><span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> result := request(); &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）defer</strong></p>\n<p>defer 語句會將函數推遲到外層函數返回之後執行。</p>\n<p>推遲調用的函數其參數會立即求值，但直到外層函數返回前該函數都不會被調用。</p>\n<p>推遲的函數調用會被壓入一個棧中。當外層函數返回時，被推遲的函數會按照後進先出的順序調用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> fmt.Println(<span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>defer 並不是免費的。defer 底層會調用 <code>runtime.deferproc</code> 去設置要延遲調用的函數，調用 <code>runtime.deferreturn</code> 會依次執行先前延遲調用的函數。參考：<a href=\"https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32\">https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32</a></p>\n<h3 id=\"可見性\"><a href=\"#可見性\" class=\"headerlink\" title=\"可見性\"></a>可見性</h3><ul>\n<li>導出：大寫字母開頭的標識符，包外可訪問。</li>\n<li>未導出：非大寫字母開頭的標識符，包外不可訪問。</li>\n</ul>\n<h3 id=\"指針\"><a href=\"#指針\" class=\"headerlink\" title=\"指針\"></a>指針</h3><p>Go 擁有指針。指針保存了值的內存地址。</p>\n<ul>\n<li>類型 <code>*T</code> 是指向 <code>T</code> 類型值的指針。其零值為 <code>nil</code>。</li>\n<li><code>&amp;</code> 操作符會<strong>生成一個指向其操作數的指針</strong>。（注意：把<code>&amp;</code> 理解爲取地址符號是錯誤的）</li>\n<li><code>*</code> 操作符<strong>表示指針指向的底層值</strong>。（注意：把<code>*</code> 理解爲取值符號是錯誤的）</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  i, j := <span class=\"number\">42</span>, <span class=\"number\">2701</span></span><br><span class=\"line\"></span><br><span class=\"line\">  p := &amp;i         <span class=\"comment\">// 指向 i</span></span><br><span class=\"line\">  fmt.Println(*p) <span class=\"comment\">// 通過指針讀取 i 的值</span></span><br><span class=\"line\">  *p = <span class=\"number\">21</span>         <span class=\"comment\">// 通過指針設置 i 的值</span></span><br><span class=\"line\">  fmt.Println(i)  <span class=\"comment\">// 查看 i 的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  p = &amp;j         <span class=\"comment\">// 重定向到 j</span></span><br><span class=\"line\">  *p = *p / <span class=\"number\">37</span>   <span class=\"comment\">// 通過指針對 j 進行除法運算</span></span><br><span class=\"line\">  fmt.Println(j) <span class=\"comment\">// 查看 j 的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"結構體\"><a href=\"#結構體\" class=\"headerlink\" title=\"結構體\"></a>結構體</h3><p>一個結構體（struct）就是一組字段（field）。外界使用點號來訪問結構體字段。</p>\n<p>結構體字段可以通過結構體指針來訪問。如果我們有一個指向結構體的指針 p，那麼可以通過 <code>(*p).X</code> 來訪問其字段 X。不過這麼寫太囉嗦了，所以語言也允許我們使用<strong>隱式間接引用</strong>，直接寫 <code>p.X</code> 就可以。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">  v.X = <span class=\"number\">4</span></span><br><span class=\"line\">  fmt.Println(v.X)</span><br><span class=\"line\">  </span><br><span class=\"line\">  p := &amp;v</span><br><span class=\"line\">  p.X = <span class=\"number\">1e9</span></span><br><span class=\"line\">  fmt.Println(v)</span><br><span class=\"line\"></span><br><span class=\"line\">  v2 = Vertex&#123;X: <span class=\"number\">1</span>&#125;  <span class=\"comment\">// Y:0 被隱式地賦予</span></span><br><span class=\"line\">  v3 = Vertex&#123;&#125;      <span class=\"comment\">// X:0 Y:0</span></span><br><span class=\"line\">  p  = &amp;Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// 創建一個 *Vertex 類型的結構體（指針）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"數組\"><a href=\"#數組\" class=\"headerlink\" title=\"數組\"></a>數組</h3><p>類型 [n]T 表示擁有 n 個 T 類型的值的數組。</p>\n<p>表达式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">10</span>]<span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure>\n\n<p>會將變量 <code>a</code> 聲明為擁有 10 個整數的數組。</p>\n<h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><p><strong>（1）定義</strong></p>\n<p>類型 []T 表示一個元素類型為 T 的切片。T 可以是任何類型，包括切片本身。</p>\n<p>切片通過兩個下標來界定，即一個上界和一個下界，二者以冒號分隔：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a[low : high]</span><br></pre></td></tr></table></figure>\n\n<p>它會選擇一個半開區間，包括第一個元素，但排除最後一個元素。</p>\n<p>切片下界的默認值爲 0，上界則是其底層數組的長度。</p>\n<p>對於數組 <code>var a [10]int</code> 來說，以下切片是等價的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a[<span class=\"number\">0</span>:<span class=\"number\">10</span>]</span><br><span class=\"line\">a[:<span class=\"number\">10</span>]</span><br><span class=\"line\">a[<span class=\"number\">0</span>:]</span><br><span class=\"line\">a[:]</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）切片的本質</strong></p>\n<p>一個切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量，其結構如下：</p>\n<p><img src=\"/2021/02/06/it/go/go-basic/Untitled.png\" alt></p>\n<p><img src=\"/2021/02/06/it/go/go-basic/Untitled%201.png\" alt></p>\n<p>切片的長度就是它所包含的元素個數。<br>切片的容量是從它的第一個元素開始數，到其底層數組元素末尾的個數。<br>切片 s 的長度和容量可通過表達式 <code>len(s)</code> 和 <code>cap(s)</code> 來獲取。</p>\n<p>更改切片的元素會修改其底層數組中對應的元素。與它共享底層數組的切片都會觀測到這些修改。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  names := [<span class=\"number\">4</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;John&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Paul&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;George&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Ringo&quot;</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(names)</span><br><span class=\"line\"></span><br><span class=\"line\">  a := names[<span class=\"number\">0</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\">  b := names[<span class=\"number\">1</span>:<span class=\"number\">3</span>]</span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">  b[<span class=\"number\">0</span>] = <span class=\"string\">&quot;XXX&quot;</span></span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\">  fmt.Println(names)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：切片的零值爲 nil，其長度和容量爲 0 且沒有底層數組。</p>\n<p><strong>（3）通過 make 創建切片</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">5</span>)  <span class=\"comment\">// len(a)=5</span></span><br><span class=\"line\">b := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>) <span class=\"comment\">// len(b)=0, cap(b)=5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）通過 append 追加元素</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">append</span><span class=\"params\">(s []T, vs ...T)</span> []<span class=\"title\">T</span></span></span><br></pre></td></tr></table></figure>\n\n<p><code>append</code> 的第一個參數 <code>s</code> 是一個元素類型為 <code>T</code> 的切片，其餘類型為 <code>T</code>的值將會追加到該切片的末尾。</p>\n<p><code>append</code> 的結果是一個包含原切片所有元素加上新添加元素的切片。</p>\n<p>當 <code>s</code> 的底層數組太小，不足以容納所有給定的值時，它就會分配一個更大的數組。返回的切片會指向這個新分配的數組。</p>\n<p>當引用一個原始數組時，GC不會釋放該數組的空間，即使只用到其中一小部分數據。因此函數返回切片的時候要特別注意，最好拷貝需要數據到新的切片再返回。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 copy 函數</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyDigits</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">    b, _ := ioutil.ReadFile(filename)</span><br><span class=\"line\">    b = digitRegexp.Find(b)</span><br><span class=\"line\">    c := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(b))</span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(c, b)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或使用 append 函數</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyDigits</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">    b, _ := ioutil.ReadFile(filename)</span><br><span class=\"line\">    b = digitRegexp.Find(b)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c []<span class=\"keyword\">byte</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">append</span>(c, b...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>映射將鍵映射到值。</p>\n<p>映射的零值為 <code>nil</code> 。<code>nil</code> 映射既沒有鍵，也不能添加鍵。</p>\n<p><code>make</code> 函數會返回給定類型的映射，並將其初始化備用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Lat, Long <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Vertex&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;Bell Labs&quot;</span>: &#123;<span class=\"number\">40.68433</span>, <span class=\"number\">-74.39967</span>&#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;Google&quot;</span>:    &#123;<span class=\"number\">37.42202</span>, <span class=\"number\">-122.08408</span>&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 常用操作：</p>\n<ol>\n<li>插入或修改元素：<code>m[key] = elem</code></li>\n<li>獲取元素：<code>elem = m[key]</code></li>\n<li>通過雙賦值檢測某個鍵是否存在：<code>elem, ok := m[key]</code></li>\n<li>刪除元素：<code>delete(m, key)</code></li>\n</ol>\n<h3 id=\"函數-function\"><a href=\"#函數-function\" class=\"headerlink\" title=\"函數(function)\"></a>函數(function)</h3><p><strong>（1）概述</strong></p>\n<p>函數可以沒有參數或接受多個參數。當連續兩個或多個函數的已命名形參類型相同時，除最後一個類型以外，其它都可以省略。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(add(<span class=\"number\">42</span>, <span class=\"number\">13</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）命名返回值</strong></p>\n<p>Go 的返回值可被命名，它們會被視作<strong>定義在函數頂部的變量</strong>。返回值的名稱應當具有一定的意義，它可以作為文檔使用。沒有參數的 <code>return</code> 語句返回已命名的返回值。也就是 <code>直接</code> 返回。直接返回語句應當僅用在下面這樣的短函數中。在長的函數中它們會影響代碼的可讀性。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">split</span><span class=\"params\">(sum <span class=\"keyword\">int</span>)</span> <span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x = sum * <span class=\"number\">4</span> / <span class=\"number\">9</span></span><br><span class=\"line\">  y = sum - x</span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(split(<span class=\"number\">17</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）多值返回</strong></p>\n<p>函數可以返回任意數量的返回值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  a, b := swap(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）函數值</strong></p>\n<p>函數也是值，可以作爲函數的參數或返回值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compute</span><span class=\"params\">(fn <span class=\"keyword\">func</span>(<span class=\"keyword\">float64</span>, <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span>) <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(compute(math.Pow))</span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）閉包(closure)</strong></p>\n<p>閉包是指一個函數引用了其函數體之外的變量，該函數可以訪問並賦予其引用的變量的值。換句話說就是該函數跟函數體之外的變量綑綁在一起了。每次調用閉包中的函數可以改變閉包中變量的值。例如斐波那契閉包：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  x,y := <span class=\"number\">0</span>,<span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    res := x</span><br><span class=\"line\">    x,y = y,x+y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  f := fibonacci()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    fmt.Println(f())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法-method\"><a href=\"#方法-method\" class=\"headerlink\" title=\"方法(method)\"></a>方法(method)</h3><p>方法就是一類帶特殊的<strong>接收者參數</strong>的函數。方法接收者在它自己的參數列表內，<strong>位於 func 關鍵字和方法名之間</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 這就是方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span> <span class=\"title\">Abs</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">  fmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是：接收者的類型定義和方法聲明必須在同一包內；不能爲內建類型聲明方法。</p>\n<p>接收者除了是<strong>值接收者</strong>外，還支持<strong>指針接收者</strong>，使用 <code>*T</code> (不能是 <code>*int</code> 之類的) 的文法即可。指針接收者可以修改接收者指向的值。如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span> <span class=\"title\">Abs</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span> <span class=\"title\">Scale</span><span class=\"params\">(f <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">  v.X = v.X * f</span><br><span class=\"line\">  v.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">  v.Scale(<span class=\"number\">10</span>) <span class=\"comment\">// 此時 Go 會解釋爲 (&amp;v).Scale(10)，這就是指針重定向</span></span><br><span class=\"line\">  fmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用指針接收者的好處：</p>\n<ol>\n<li>方法能夠修改其接收者指向的值。</li>\n<li>避免在每次調用方法時複製該值。該值佔用的空間越大，則越顯得高效。</li>\n</ol>\n<p>注意：一個結構體採用值接收者的方式實現了接口的方法，則隱含著採用指針接收者的方式實現了接口的方法。（接收者是指針類型的方法，很可能在方法中會對接收者的屬性進行更改操作，從而影響接收者；而對於接收者是值類型的方法，在方法中不會對接收者本身產生影響）</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p><strong>（1）定義</strong></p>\n<p>接口類型是<strong>由一組方法簽名定義的集合</strong>。接口類型的變量可以保存<strong>任何</strong>實現了這些方法的值。</p>\n<p><strong>（2）隱式實現</strong></p>\n<p>類型通過實現一個接口的所有方法來實現該接口。既然無需專門顯式聲明，也就沒有「implements」關鍵字。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  eat()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> John <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;eat...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  eat()</span><br><span class=\"line\">  talk()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">talk</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;talk...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a Animal = &amp;John&#123;&#125;</span><br><span class=\"line\">  a.eat()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b Person = &amp;John&#123;&#125;</span><br><span class=\"line\">  b.eat()</span><br><span class=\"line\">  b.talk()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）接口值</strong></p>\n<p>接口也是值，可以作爲函數的參數或返回值。在內部，接口值可以看做包含值和具體類型的元組：<code>(value, type)</code> 。接口值保存了一個具體底層類型的具體值。接口值調用方法時會執行其底層類型的同名方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Animal、John 見上面的代碼</span></span><br><span class=\"line\">j := John&#123;&#125;</span><br><span class=\"line\">describe(j)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i Animal)</span></span>&#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）底層值爲 nil 的接口值</strong></p>\n<p>即便接口內的具體值為 nil，方法仍然會被 nil 接收者調用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 改造上面的代碼</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">talk</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> j == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;j is &lt;nil&gt;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;talk...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x Person</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y John</span><br><span class=\"line\">  x = &amp;y</span><br><span class=\"line\">  describe(x)</span><br><span class=\"line\">  x.talk() <span class=\"comment\">// 正常調用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判斷接口的底層值是否爲 nil 的方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接上</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>( x == <span class=\"literal\">nil</span> || reflect.ValueOf(x).IsNil())</span><br></pre></td></tr></table></figure>\n\n<p><strong>（6）nil 接口值</strong></p>\n<p>nil 接口值既不保存值也不保存具體類型。</p>\n<p>為 nil 接口調用方法會產生運行時錯誤，因為接口的元組內並未包含能夠指明該調用哪個 <strong>具體</strong> 方法的類型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  M()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i I</span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\">  i.M() <span class=\"comment\">// 此處拋出 panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i I)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i) <span class=\"comment\">// (&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（7）空接口</strong></p>\n<p>指定了<strong>零個方法</strong>的接口值被稱為空接口，即 <code>interface&#123;&#125;</code> 。空接口可保存任何類型的值。（因為每個類型都至少實現了零個方法。）空接口被用來處理未知類型的值。例如，<code>fmt.Print</code> 可接受類型為 <code>interface&#123;&#125;</code> 的任意數量的參數。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">  i = <span class=\"number\">42</span> <span class=\"comment\">// 保存 int值</span></span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">  i = <span class=\"string\">&quot;hello&quot;</span> <span class=\"comment\">// 保存 string值</span></span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（8）類型斷言</strong></p>\n<p>類型斷言提供了訪問<strong>接口值底層具體值</strong>的方式。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判斷接口i的底層值類型是否爲T，如是返回其底層值和true，否則返回T類型的零值和false</span></span><br><span class=\"line\">t, ok := i.(T)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">s, ok := i.(<span class=\"keyword\">string</span>)</span><br><span class=\"line\">fmt.Println(s, ok)</span><br><span class=\"line\">f, ok := i.(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">fmt.Println(f, ok)</span><br><span class=\"line\"><span class=\"comment\">// 支持類型選擇</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">do</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> v := i.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"keyword\">int</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;Twice %v is %v\\n&quot;</span>, v, v*<span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"keyword\">string</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%q is %v bytes long\\n&quot;</span>, v, <span class=\"built_in\">len</span>(v))</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;I don&#x27;t know about type %T!\\n&quot;</span>, v)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"異常處理\"><a href=\"#異常處理\" class=\"headerlink\" title=\"異常處理\"></a>異常處理</h3><p>Go 程序使用 <code>error</code> 值來表示錯誤狀態。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Error() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常函數會返回一個 <code>error</code> 值，調用的它的代碼應當判斷這個錯誤是否等於 <code>nil</code> 來進行錯誤處理。<code>error</code> 為 nil 時表示成功；非 nil 的 <code>error</code> 表示失敗。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> i, err := strconv.Atoi(<span class=\"string\">&quot;42&quot;</span>); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Converted integer:&quot;</span>, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Go-程-goroutine\"><a href=\"#Go-程-goroutine\" class=\"headerlink\" title=\"Go 程(goroutine)\"></a>Go 程(goroutine)</h3><p><strong>（1）定義</strong></p>\n<p><strong>Go 程（goroutine）是由 Go 運行時管理的輕量級線程</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x,y,z 的求值發生在當前 Go 程中，f 的執行則是在新的 Go 程中</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> f(x, y, z)</span><br></pre></td></tr></table></figure>\n\n<p>（<strong>2）信道</strong></p>\n<p><strong>信道是帶有類型的管道</strong>，你可以通過它用<strong>信道操作符</strong> <code>&lt;-</code> (箭頭就是數據流的方向)來發送或者接收值。</p>\n<p>默認情況下，發送和接收操作在另一端準備好之前都會阻塞。這使得 Go 程可以在沒有顯式的鎖或競態變量的情況下進行同步。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 創建信道</span></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">// 將 v 發送至信道 ch。</span></span><br><span class=\"line\">ch &lt;- v</span><br><span class=\"line\"><span class=\"comment\">// 從 ch 接收值並賦予 v。</span></span><br><span class=\"line\">v := &lt;-ch</span><br></pre></td></tr></table></figure>\n\n<p><strong>信道可以是帶緩衝，</strong>將緩衝長度作為第二個參數提供給 <code>make</code> 來初始化一個帶緩衝的信道。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>僅當信道的緩衝區填滿後，向其發送數據時才會阻塞。當緩衝區為空時，接受方會阻塞。</strong></p>\n<p><strong>（3）range 和 close</strong></p>\n<p>有且僅有發送者可以通過 close 方法關閉一個信道。接收者讀取值的時候可以通過 <code>v, ok := &lt;-ch</code>  的 ok 值判斷是否信道關閉了。更簡單的是使用 for-range 不斷從信道接收值，直到信道關閉，循環自動退出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(n <span class=\"keyword\">int</span>, c <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">    c &lt;- x</span><br><span class=\"line\">    x, y = y, x+y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> fibonacci(<span class=\"built_in\">cap</span>(c), c)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> c &#123;</span><br><span class=\"line\">    fmt.Println(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）select</strong></p>\n<p>select 語句使一個 Go 程可以等待多個通信操作。select 會阻塞到某個分支可以繼續執行為止，這時就會執行該分支。當多個分支都準備好時會隨機選擇一個執行。當 select 中的其它分支都沒有準備好時，default 分支就會執行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(c, quit <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> c &lt;- x:</span><br><span class=\"line\">      x, y = y, x+y</span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;-quit:</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">&quot;quit&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 當 c 和 quit 阻塞時會執行到此處</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  quit := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">      fmt.Println(&lt;-c)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    quit &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  fibonacci(c, quit)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>練習：等價二叉查找樹</p>\n<p>  函數 tree.New(k) 用於構造一個隨機結構的已排序二叉查找樹，它保存了值 k, 2k, 3k, …, 10k。</p>\n<p>  Walk 步進 tree t 將所有的值從 tree 發送到 channel ch。</p>\n<p>  用 Walk 實現 Same 函數來檢測 t1 和 t2 是否存儲了相同的值。</p>\n  <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;golang.org/x/tour/tree&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Walk</span><span class=\"params\">(t *tree.Tree, ch <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> t.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    Walk(t.Left, ch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ch &lt;- t.Value</span><br><span class=\"line\">  <span class=\"keyword\">if</span> t.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    Walk(t.Right, ch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Same 检测树 t1 和 t2 是否含有相同的值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Same</span><span class=\"params\">(t1, t2 *tree.Tree)</span> <span class=\"title\">bool</span></span>&#123;</span><br><span class=\"line\">  ch1,ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>),<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Walk(t1, ch1)</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch1)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Walk(t2, ch2)</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch2)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> ch1&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i != &lt;-ch2 &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(Same(tree.New(<span class=\"number\">1</span>),tree.New(<span class=\"number\">1</span>)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（5）sync.Mutex</strong></p>\n<p>互斥鎖可以保證每次只有一個 Go 程訪問一個共享變量。</p>\n<p>Go 標準庫中的 <strong>Mutex</strong> 就是一個互斥鎖，可以創建為其他結構體的字段；零值為解鎖狀態。Mutex類型的鎖和線程無關，可以由不同的線程加鎖和解鎖。在代碼前調用 Lock 方法，並在代碼後調用 Unlock 方法來保證一段代碼互斥執行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.Unlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>爲了提升讀寫性能，常用 <strong>RWMutex</strong> 代替 <strong>Mutex。</strong>RWMutex是讀寫互斥鎖。該鎖可以被同時多個讀取者持有或唯一個寫入者持有。RWMutex可以創建為其他結構體的字段；零值為解鎖狀態。RWMutex類型的鎖也和線程無關，可以由不同的線程加讀取鎖/寫入和解讀取鎖/寫入鎖。</p>\n<p>下面的代碼效果不明顯，因爲讀的次數不多。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.RLock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.RUnlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  now := time.Now()</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(time.Now().Sub(now))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（6）WaitGroup</strong></p>\n<p>WaitGroup 可以等待一組 Go 程結束。通過調用 Add 方法設定要等待的 Go 程數量。然後各個 Go 程通過調用 Done 方法結束等待。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  wg.Done()</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.RLock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.RUnlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1000</span>)</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>, &amp;wg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Go 又稱 Golang，是 Google 公司 2009 年發佈的一款開源編程語言，以簡潔而高效的代碼著稱。Go 目前使用 GOPATH 或 Go modules 管理項目中的第三方依賴，且不支持循環依賴。</p>\n<p>Go 的基本數據類型有 16 種(不包含別名)，可謂豐富。要注意的是 string 也是基本數據類型，表示一個 UTF-8 字符串，底層是 byte 數組。單個字符使用一個 int32 的別名 rune 表示，其值爲 Unicode 字符碼點。</p>\n<p>Go 的變量使用 var 關鍵字聲明，也可以使用短變量聲明；常量則是使用 const 關鍵字聲明。</p>\n<p>Go 有 if 條件語句、for 循環語句、switch 選擇語句和 defer 延遲執行語句。Go 的 for 語句兼具其他語言的 while 語句；switch 語句每個 case 條件都支持運算，且默認自動 break；defer 語句可以立即計算參數值，然後在函數 return 前執行。</p>\n<p>Go 的可見性跟標識符的首字母是否大寫相關，大寫則是導出的，包外可見；小寫則是非導出的，包外不可見。</p>\n<p>Go 有指針，要注意 <code>&amp;</code> 是生成指向操作數的指針，而 <code>*</code> 是獲取指針指向的底層值。</p>\n<p>Go 將一些字段組合成一個結構體(struct) 。結構體支持隱式間接調用，即 p.X 等價於 (*p).X（p 爲結構體指針）。</p>\n<p>Go 支持數組，更重要的是支持一種名爲切片(slice) 的動態數組。切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量。</p>\n<p>Go 支持映射(map)。</p>\n<p>Go 支持函數(function)的命名返回值、多值返回、作爲值傳遞和閉包。還有一種稱爲方法(method)的特殊函數，其帶有接收者參數，接收者可以是值接收者也可以是指針接收者，指針接收者可以更改接收者的值。</p>\n<p>Go 支持將一些方法簽名組成接口(interface)。接口的實現是隱式的，不需要「implements」。一個結構體作爲接收者定義了接口中的所有方法，那麼該結構體就是實現了該接口。因爲隱式的緣故，建議接口方法盡可能少，以便管理。接口是值，可以傳遞。底層值是 nil 的接口，其方法可以被調用；接口本身爲 nil ，則意味著其不保存值也不保存具體類型；空接口(interface{})是包含零個函數的接口，不是爲 nil 接口。</p>\n<p>Go 的異常處理很簡單，只有 Error，沒有 throws。</p>\n<p>Go 支持 Go 程，一種 Go運行時管理的輕量級線程。Go 程之間可以通過信道(channel) 通信，通過 Mutex 或 RWMutex 共享互斥變量，通過 WaitGroup 等待執行完成。 </p>\n<p>Go 中的信道還支持通過 for-range 循環讀取數據，當信道關閉時該循環自動退出。記住，只有發送方可以關閉信道，接收方不能。信道還支持 select 語句，其會<strong>阻塞到某一分支可以執行爲止</strong>，如沒有分支可以執行且設定了default 語句，會一直執行 default 語句。</p>","more":"<p>以下內容多來自<a href=\"https://tour.go-zh.org/\">《Go 指南》</a>，內容有所改動。</p>\n<h2 id=\"歷史\"><a href=\"#歷史\" class=\"headerlink\" title=\"歷史\"></a>歷史</h2><p>Go 又稱 Golang，是 Google 公司開發的一款靜態強類型、編譯型、並發型，並具有垃圾回收功能的編程語言。</p>\n<ol>\n<li>2007.9.21 罗伯特·格瑞史莫(Robert Griesemer)、罗勃·派克(Rob Pike)和肯·汤普逊(Ken Thompson) 開始設計 Go。</li>\n<li>2009.11 Google 發佈 Go 語言。</li>\n<li>2012.3 Go 1.0 發佈。</li>\n<li>2018.8 Go 1.11 發佈，預支持 modules 進行依賴管理。</li>\n</ol>\n<h2 id=\"入門\"><a href=\"#入門\" class=\"headerlink\" title=\"入門\"></a>入門</h2><h3 id=\"安裝\"><a href=\"#安裝\" class=\"headerlink\" title=\"安裝\"></a>安裝</h3><p>按照<a href=\"https://golang.org/doc/install\">官方教程</a>安裝即可。</p>\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>直接在系統 Home 目錄，新建一一個 hello.go 文件，寫入代碼如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main <span class=\"comment\">//程序從 main 包的 main 函數開始運行</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span> <span class=\"comment\">//導入 fmt 包</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//main函數</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Hello, World!&quot;</span>) <span class=\"comment\">//打印日誌</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然後執行 <code>go run hello.go</code> 即可。</p>\n<h3 id=\"GOPATH\"><a href=\"#GOPATH\" class=\"headerlink\" title=\"GOPATH\"></a>GOPATH</h3><p>當項目未啟用 Go modules 時，Go 使用 <code>GOPATH</code> 環境變量解析 import 語句。<code>GOPATH</code> 的值默認爲 <code>$HOME/go</code> ， <code>GOPATH</code> 目錄結構如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">GOPATH=/home/user/<span class=\"keyword\">go</span></span><br><span class=\"line\"></span><br><span class=\"line\">src/</span><br><span class=\"line\">    foo/</span><br><span class=\"line\">        bar/               (<span class=\"keyword\">go</span> code in <span class=\"keyword\">package</span> bar)</span><br><span class=\"line\">            x.<span class=\"keyword\">go</span></span><br><span class=\"line\">        quux/              (<span class=\"keyword\">go</span> code in <span class=\"keyword\">package</span> main)</span><br><span class=\"line\">            y.<span class=\"keyword\">go</span></span><br><span class=\"line\">bin/</span><br><span class=\"line\">    quux                   (installed command)</span><br><span class=\"line\">pkg/</span><br><span class=\"line\">    linux_amd64/</span><br><span class=\"line\">        foo/</span><br><span class=\"line\">            bar.a          (installed <span class=\"keyword\">package</span> object)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>src：存放依賴的源代碼</li>\n<li>bin：存放安裝的命令</li>\n<li>pkg：存法安裝的包對象</li>\n</ul>\n<p>啟用 Go modules 後雖然不通過 <code>GOPATH</code> 解析 import 語句，但下載的源代碼和安裝的命令都會存在<code>GOPATH</code>目錄下。</p>\n<h3 id=\"Vendor\"><a href=\"#Vendor\" class=\"headerlink\" title=\"Vendor\"></a>Vendor</h3><p>Vendor 就是使用本地依賴包的模式，Go 1.5 作爲實驗特性，Go 1.6 正式支持，Go 1.14 正式終結。命名爲 vender(小商販) 是一種比喻，並將 GOPATH 隱喻爲有固定地址的商舖。啟用 Vendor 模式很簡單，在項目中創建一個名爲 vendor 的文件夾然後拷貝依賴的源代碼進入其中即可。比如有如下的項目使用了 Vendor：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">$GOPATH</span><br><span class=\"line\">|\tsrc/</span><br><span class=\"line\">|\t|\tgithub.com/constabulary/example-gsftp/</span><br><span class=\"line\">|\t|\t|\tcmd/</span><br><span class=\"line\">|\t|\t|\t|\tgsftp/</span><br><span class=\"line\">|\t|\t|\t|\t|\tmain.<span class=\"keyword\">go</span></span><br><span class=\"line\">|\t|\t|\tvendor/</span><br><span class=\"line\">|\t|\t|\t|\tgithub.com/pkg/sftp/</span><br><span class=\"line\">|\t|\t|\t|\tgolang.org/x/crypto/ssh/</span><br><span class=\"line\">|\t|\t|\t|\t|\tagent/</span><br></pre></td></tr></table></figure>\n\n<p>在文件 <code>github.com/constabulary/example-gsftp/cmd/gsftp/main.go</code> 中應這樣 import 依賴（不需要加入 vendor 前綴）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"string\">&quot;golang.org/x/crypto/ssh&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;golang.org/x/crypto/ssh/agent&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/pkg/sftp&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>這種方式顯然會帶來代碼膨脹，特別是N個庫同時用 Vendor 模式依賴一個通用庫時，那麼該通用庫的代碼將會出現N次。</p>\n<h3 id=\"Go-modules\"><a href=\"#Go-modules\" class=\"headerlink\" title=\"Go modules\"></a>Go modules</h3><p>Go 官方推出的依賴管理系統，在 Go 1.11 和 1.12中已經有初步支持，但默認關閉；從 1.13 開始默認啟用，1.14 開始可用於生產。</p>\n<p><strong>（1）使用 Go modules</strong></p>\n<p>使用 Go modules 很簡單，只需要在項目根路徑(不可以在 <code>$GOPATH/src</code> 裏面)執行 <code>go mod init example.com/m</code> 即可初始化一個名爲 <code>example.com/m</code> 的模塊，之後會在項目根路徑生成一個名爲 <code>go.mod</code> 的依賴文件，其內容結構如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">module example.com/hello <span class=\"comment\">//模塊名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"number\">1.12</span> <span class=\"comment\">//使用的 Go 版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">require rsc.io/quote v1<span class=\"number\">.5</span><span class=\"number\">.2</span> <span class=\"comment\">//依賴項</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，Go modules 還生成和維護著一個名爲 <code>go.sum</code> 的文件，該文件包含了期望的指定模塊版本的內容的加密哈希。</p>\n<p>爲保證依賴的一致性，需要同時將 <code>go.mod</code> 和 <code>go.sum</code> 加入版本管理。</p>\n<p><strong>（2）更新依賴</strong></p>\n<p>更新小版本很簡單，一個 <code>go get</code> 命令就完了。更新大版本比更新小版本複雜，因爲大版本通常會帶來 API 的變化，Go 要求更改大版本號後，模塊名也要加上版本號。例如原本是 <code>rsc.io/quote</code> 的依賴，升級到 v3 後依賴要改成 <code>rsc.io/quote/v3</code> ，因此代碼中的 import 語句要改成 <code>rsc.io/quote/v3</code> ，然後清理掉舊版本的依賴，有點麻煩。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出當前項目的模塊和依賴項</span></span><br><span class=\"line\">go list -m all</span><br><span class=\"line\"><span class=\"comment\"># 直接更新到最新的小版本</span></span><br><span class=\"line\">go get rsc.io/sampler</span><br><span class=\"line\"><span class=\"comment\"># 列出所有小版本</span></span><br><span class=\"line\">go list -m -versions rsc.io/sampler</span><br><span class=\"line\"><span class=\"comment\"># 更新到指定版本</span></span><br><span class=\"line\">go get rsc.io/sampler@v1.3.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看模塊的所有版本</span></span><br><span class=\"line\">go list -m rsc.io/q...</span><br><span class=\"line\"><span class=\"comment\"># 清除未使用的依賴</span></span><br><span class=\"line\">go mod tidy</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循環依賴\"><a href=\"#循環依賴\" class=\"headerlink\" title=\"循環依賴\"></a>循環依賴</h3><p>Go 不支持循環依賴，Go設計者Rob Pike認爲如果出現兩個包循環依賴，那麼是你的設計問題。</p>\n<p>筆者就出現過一次循環依賴，場景是：封裝了一個打印日誌的庫A和一個解析配置的庫B，庫A需要通過庫B配置，庫B需要用庫A打印日誌。最後選擇在庫B使用原始的日誌打印。</p>\n<h2 id=\"語法\"><a href=\"#語法\" class=\"headerlink\" title=\"語法\"></a>語法</h2><h3 id=\"數據類型\"><a href=\"#數據類型\" class=\"headerlink\" title=\"數據類型\"></a>數據類型</h3><p><strong>（1）基本類型</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>  <span class=\"keyword\">int8</span>  <span class=\"keyword\">int16</span>  <span class=\"keyword\">int32</span>  <span class=\"keyword\">int64</span></span><br><span class=\"line\"><span class=\"keyword\">uint</span> <span class=\"keyword\">uint8</span> <span class=\"keyword\">uint16</span> <span class=\"keyword\">uint32</span> <span class=\"keyword\">uint64</span> <span class=\"keyword\">uintptr</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">byte</span> <span class=\"comment\">// uint8 的别名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">rune</span> <span class=\"comment\">// int32 的別名</span></span><br><span class=\"line\">    <span class=\"comment\">// 表示一個 Unicode 碼點</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">float32</span> <span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">complex64</span> <span class=\"keyword\">complex128</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 int, uint 和 uintptr 在 32 位系統上通常為 32 位寬，在 64 位系統上則為 64 位寬。</p>\n<p>string 表示一個 UTF-8 類型的字符串，底層是一個字節數組。</p>\n<p>rune 表示一個 Unicode 碼點，是 int32 的別名。讀取 string 中的每個字符，只需要將 string 轉爲 rune 數組即可</p>\n<p>Java 中的 char 類型，每個字符對應一個 Unicode 碼點，可以表示BMP範圍內（即[U+0000, U+FFFF]之間）的Unicode字符。String 是 UTF-8 類型。</p>\n<p><strong>（2）零值</strong></p>\n<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>\n<p>零值是：</p>\n<ul>\n<li>数值类型为 <code>0</code>，</li>\n<li>布尔类型为 <code>false</code>，</li>\n<li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li>\n</ul>\n<p><strong>（3）類型轉換</strong></p>\n<p>數值之間可以通過表達式 T(v) 將值 v 轉換為類型 T，如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">42</span></span><br><span class=\"line\">f := <span class=\"keyword\">float64</span>(i)</span><br><span class=\"line\">u := <span class=\"keyword\">uint</span>(f)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）类型推导</strong></p>\n<p>在聲明一個變量而不指定其類型時（即使用不帶類型的 := 語法或 var = 表達式語法），變量的類型由右值推導得出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">42</span>           <span class=\"comment\">// int</span></span><br><span class=\"line\">f := <span class=\"number\">3.142</span>        <span class=\"comment\">// float64</span></span><br><span class=\"line\">g := <span class=\"number\">0.867</span> + <span class=\"number\">0.5i</span> <span class=\"comment\">// complex128</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"變量\"><a href=\"#變量\" class=\"headerlink\" title=\"變量\"></a>變量</h3><p><strong>（1）聲明語句</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 開頭，逗號(,)分割變量名，最後寫數據類型 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c, python, java <span class=\"keyword\">bool</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）賦值語句</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c, python, java = <span class=\"literal\">true</span>,<span class=\"literal\">false</span>,<span class=\"string\">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>或直接使用<strong>短變量聲明</strong>，注意短變量聲明只能在函數內使用，因爲函數外的每個語句要求必須以關鍵字開始。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">c, python, java := <span class=\"literal\">true</span>,<span class=\"literal\">false</span>,<span class=\"string\">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量聲明使用 const 關鍵字。常量可以是字符、字符串、布尔值或数值。常量不能用 <code>:=</code> 语法声明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Pi = <span class=\"number\">3.14</span></span><br></pre></td></tr></table></figure>\n\n<p><code>iota</code> 可以用來創建順序遞增的常量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  Low = <span class=\"literal\">iota</span> <span class=\"comment\">//0</span></span><br><span class=\"line\">  Medium     <span class=\"comment\">//1</span></span><br><span class=\"line\">  High       <span class=\"comment\">//2</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"風格\"><a href=\"#風格\" class=\"headerlink\" title=\"風格\"></a>風格</h3><ol>\n<li>每行程序結束後不需要撰寫分號（;）。</li>\n<li>大括號（{）不能夠換行放置。</li>\n<li>if判斷式和for循環不需要以小括號包覆起來。</li>\n<li>使用 tab 做排版</li>\n</ol>\n<h3 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h3><p><strong>（1）if-else</strong></p>\n<p>不需要小括號，可以使用簡短語句。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">_,ok := sendMsg();</span><br><span class=\"line\"><span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do other thing</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等價於以下簡短語句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> _,ok := sendMsg(); ok &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do other thing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）for</strong></p>\n<p>Go 中的 for 語句，還包含了其他語言的 while 的功能。特別的不用括號包裹。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 功能：遍歷 10 次</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：類似於其他語言 while 的功能</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i&lt;<span class=\"number\">10</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：無限循環，類似於其他語言中的 while(true)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：for range 循環，返回當前元素的下標及副本</span></span><br><span class=\"line\"><span class=\"comment\">// 可通過 _ 忽略其中的某個值</span></span><br><span class=\"line\">pow := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d,%d\\n&quot;</span>, i, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> _,v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）switch</strong></p>\n<p>Go 中的 switch 語句是自動 break 的。如果不想要break，需要在 case 後面協商 fallthrough。</p>\n<p>Go 中的 switch 的 case 無需為常量，且取值不必為整數。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 功能：選擇顏色</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> color &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> Red:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Green:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 功能：替代 if-then-else，更整齊</span></span><br><span class=\"line\">result := request()</span><br><span class=\"line\"><span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> result := request(); &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> result &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）defer</strong></p>\n<p>defer 語句會將函數推遲到外層函數返回之後執行。</p>\n<p>推遲調用的函數其參數會立即求值，但直到外層函數返回前該函數都不會被調用。</p>\n<p>推遲的函數調用會被壓入一個棧中。當外層函數返回時，被推遲的函數會按照後進先出的順序調用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> fmt.Println(<span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>defer 並不是免費的。defer 底層會調用 <code>runtime.deferproc</code> 去設置要延遲調用的函數，調用 <code>runtime.deferreturn</code> 會依次執行先前延遲調用的函數。參考：<a href=\"https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32\">https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32</a></p>\n<h3 id=\"可見性\"><a href=\"#可見性\" class=\"headerlink\" title=\"可見性\"></a>可見性</h3><ul>\n<li>導出：大寫字母開頭的標識符，包外可訪問。</li>\n<li>未導出：非大寫字母開頭的標識符，包外不可訪問。</li>\n</ul>\n<h3 id=\"指針\"><a href=\"#指針\" class=\"headerlink\" title=\"指針\"></a>指針</h3><p>Go 擁有指針。指針保存了值的內存地址。</p>\n<ul>\n<li>類型 <code>*T</code> 是指向 <code>T</code> 類型值的指針。其零值為 <code>nil</code>。</li>\n<li><code>&amp;</code> 操作符會<strong>生成一個指向其操作數的指針</strong>。（注意：把<code>&amp;</code> 理解爲取地址符號是錯誤的）</li>\n<li><code>*</code> 操作符<strong>表示指針指向的底層值</strong>。（注意：把<code>*</code> 理解爲取值符號是錯誤的）</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  i, j := <span class=\"number\">42</span>, <span class=\"number\">2701</span></span><br><span class=\"line\"></span><br><span class=\"line\">  p := &amp;i         <span class=\"comment\">// 指向 i</span></span><br><span class=\"line\">  fmt.Println(*p) <span class=\"comment\">// 通過指針讀取 i 的值</span></span><br><span class=\"line\">  *p = <span class=\"number\">21</span>         <span class=\"comment\">// 通過指針設置 i 的值</span></span><br><span class=\"line\">  fmt.Println(i)  <span class=\"comment\">// 查看 i 的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  p = &amp;j         <span class=\"comment\">// 重定向到 j</span></span><br><span class=\"line\">  *p = *p / <span class=\"number\">37</span>   <span class=\"comment\">// 通過指針對 j 進行除法運算</span></span><br><span class=\"line\">  fmt.Println(j) <span class=\"comment\">// 查看 j 的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"結構體\"><a href=\"#結構體\" class=\"headerlink\" title=\"結構體\"></a>結構體</h3><p>一個結構體（struct）就是一組字段（field）。外界使用點號來訪問結構體字段。</p>\n<p>結構體字段可以通過結構體指針來訪問。如果我們有一個指向結構體的指針 p，那麼可以通過 <code>(*p).X</code> 來訪問其字段 X。不過這麼寫太囉嗦了，所以語言也允許我們使用<strong>隱式間接引用</strong>，直接寫 <code>p.X</code> 就可以。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">  v.X = <span class=\"number\">4</span></span><br><span class=\"line\">  fmt.Println(v.X)</span><br><span class=\"line\">  </span><br><span class=\"line\">  p := &amp;v</span><br><span class=\"line\">  p.X = <span class=\"number\">1e9</span></span><br><span class=\"line\">  fmt.Println(v)</span><br><span class=\"line\"></span><br><span class=\"line\">  v2 = Vertex&#123;X: <span class=\"number\">1</span>&#125;  <span class=\"comment\">// Y:0 被隱式地賦予</span></span><br><span class=\"line\">  v3 = Vertex&#123;&#125;      <span class=\"comment\">// X:0 Y:0</span></span><br><span class=\"line\">  p  = &amp;Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// 創建一個 *Vertex 類型的結構體（指針）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"數組\"><a href=\"#數組\" class=\"headerlink\" title=\"數組\"></a>數組</h3><p>類型 [n]T 表示擁有 n 個 T 類型的值的數組。</p>\n<p>表达式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">10</span>]<span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure>\n\n<p>會將變量 <code>a</code> 聲明為擁有 10 個整數的數組。</p>\n<h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><p><strong>（1）定義</strong></p>\n<p>類型 []T 表示一個元素類型為 T 的切片。T 可以是任何類型，包括切片本身。</p>\n<p>切片通過兩個下標來界定，即一個上界和一個下界，二者以冒號分隔：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a[low : high]</span><br></pre></td></tr></table></figure>\n\n<p>它會選擇一個半開區間，包括第一個元素，但排除最後一個元素。</p>\n<p>切片下界的默認值爲 0，上界則是其底層數組的長度。</p>\n<p>對於數組 <code>var a [10]int</code> 來說，以下切片是等價的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a[<span class=\"number\">0</span>:<span class=\"number\">10</span>]</span><br><span class=\"line\">a[:<span class=\"number\">10</span>]</span><br><span class=\"line\">a[<span class=\"number\">0</span>:]</span><br><span class=\"line\">a[:]</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）切片的本質</strong></p>\n<p>一個切片是一個數組片段的描述，包含指向數組的指針、片段的長度和容量，其結構如下：</p>\n<p><img src=\"/2021/02/06/it/go/go-basic/Untitled.png\" alt></p>\n<p><img src=\"/2021/02/06/it/go/go-basic/Untitled%201.png\" alt></p>\n<p>切片的長度就是它所包含的元素個數。<br>切片的容量是從它的第一個元素開始數，到其底層數組元素末尾的個數。<br>切片 s 的長度和容量可通過表達式 <code>len(s)</code> 和 <code>cap(s)</code> 來獲取。</p>\n<p>更改切片的元素會修改其底層數組中對應的元素。與它共享底層數組的切片都會觀測到這些修改。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  names := [<span class=\"number\">4</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;John&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Paul&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;George&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Ringo&quot;</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(names)</span><br><span class=\"line\"></span><br><span class=\"line\">  a := names[<span class=\"number\">0</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\">  b := names[<span class=\"number\">1</span>:<span class=\"number\">3</span>]</span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">  b[<span class=\"number\">0</span>] = <span class=\"string\">&quot;XXX&quot;</span></span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\">  fmt.Println(names)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：切片的零值爲 nil，其長度和容量爲 0 且沒有底層數組。</p>\n<p><strong>（3）通過 make 創建切片</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">5</span>)  <span class=\"comment\">// len(a)=5</span></span><br><span class=\"line\">b := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>) <span class=\"comment\">// len(b)=0, cap(b)=5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）通過 append 追加元素</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">append</span><span class=\"params\">(s []T, vs ...T)</span> []<span class=\"title\">T</span></span></span><br></pre></td></tr></table></figure>\n\n<p><code>append</code> 的第一個參數 <code>s</code> 是一個元素類型為 <code>T</code> 的切片，其餘類型為 <code>T</code>的值將會追加到該切片的末尾。</p>\n<p><code>append</code> 的結果是一個包含原切片所有元素加上新添加元素的切片。</p>\n<p>當 <code>s</code> 的底層數組太小，不足以容納所有給定的值時，它就會分配一個更大的數組。返回的切片會指向這個新分配的數組。</p>\n<p>當引用一個原始數組時，GC不會釋放該數組的空間，即使只用到其中一小部分數據。因此函數返回切片的時候要特別注意，最好拷貝需要數據到新的切片再返回。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 copy 函數</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyDigits</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">    b, _ := ioutil.ReadFile(filename)</span><br><span class=\"line\">    b = digitRegexp.Find(b)</span><br><span class=\"line\">    c := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(b))</span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(c, b)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或使用 append 函數</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CopyDigits</span><span class=\"params\">(filename <span class=\"keyword\">string</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">    b, _ := ioutil.ReadFile(filename)</span><br><span class=\"line\">    b = digitRegexp.Find(b)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c []<span class=\"keyword\">byte</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">append</span>(c, b...)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>映射將鍵映射到值。</p>\n<p>映射的零值為 <code>nil</code> 。<code>nil</code> 映射既沒有鍵，也不能添加鍵。</p>\n<p><code>make</code> 函數會返回給定類型的映射，並將其初始化備用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Lat, Long <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Vertex&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;Bell Labs&quot;</span>: &#123;<span class=\"number\">40.68433</span>, <span class=\"number\">-74.39967</span>&#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;Google&quot;</span>:    &#123;<span class=\"number\">37.42202</span>, <span class=\"number\">-122.08408</span>&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 常用操作：</p>\n<ol>\n<li>插入或修改元素：<code>m[key] = elem</code></li>\n<li>獲取元素：<code>elem = m[key]</code></li>\n<li>通過雙賦值檢測某個鍵是否存在：<code>elem, ok := m[key]</code></li>\n<li>刪除元素：<code>delete(m, key)</code></li>\n</ol>\n<h3 id=\"函數-function\"><a href=\"#函數-function\" class=\"headerlink\" title=\"函數(function)\"></a>函數(function)</h3><p><strong>（1）概述</strong></p>\n<p>函數可以沒有參數或接受多個參數。當連續兩個或多個函數的已命名形參類型相同時，除最後一個類型以外，其它都可以省略。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(add(<span class=\"number\">42</span>, <span class=\"number\">13</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）命名返回值</strong></p>\n<p>Go 的返回值可被命名，它們會被視作<strong>定義在函數頂部的變量</strong>。返回值的名稱應當具有一定的意義，它可以作為文檔使用。沒有參數的 <code>return</code> 語句返回已命名的返回值。也就是 <code>直接</code> 返回。直接返回語句應當僅用在下面這樣的短函數中。在長的函數中它們會影響代碼的可讀性。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">split</span><span class=\"params\">(sum <span class=\"keyword\">int</span>)</span> <span class=\"params\">(x, y <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x = sum * <span class=\"number\">4</span> / <span class=\"number\">9</span></span><br><span class=\"line\">  y = sum - x</span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(split(<span class=\"number\">17</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）多值返回</strong></p>\n<p>函數可以返回任意數量的返回值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  a, b := swap(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\">  fmt.Println(a, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）函數值</strong></p>\n<p>函數也是值，可以作爲函數的參數或返回值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compute</span><span class=\"params\">(fn <span class=\"keyword\">func</span>(<span class=\"keyword\">float64</span>, <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span>) <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(compute(math.Pow))</span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）閉包(closure)</strong></p>\n<p>閉包是指一個函數引用了其函數體之外的變量，該函數可以訪問並賦予其引用的變量的值。換句話說就是該函數跟函數體之外的變量綑綁在一起了。每次調用閉包中的函數可以改變閉包中變量的值。例如斐波那契閉包：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  x,y := <span class=\"number\">0</span>,<span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    res := x</span><br><span class=\"line\">    x,y = y,x+y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  f := fibonacci()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    fmt.Println(f())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法-method\"><a href=\"#方法-method\" class=\"headerlink\" title=\"方法(method)\"></a>方法(method)</h3><p>方法就是一類帶特殊的<strong>接收者參數</strong>的函數。方法接收者在它自己的參數列表內，<strong>位於 func 關鍵字和方法名之間</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 這就是方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span> <span class=\"title\">Abs</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">  fmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是：接收者的類型定義和方法聲明必須在同一包內；不能爲內建類型聲明方法。</p>\n<p>接收者除了是<strong>值接收者</strong>外，還支持<strong>指針接收者</strong>，使用 <code>*T</code> (不能是 <code>*int</code> 之類的) 的文法即可。指針接收者可以修改接收者指向的值。如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  X, Y <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span> <span class=\"title\">Abs</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span> <span class=\"title\">Scale</span><span class=\"params\">(f <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">  v.X = v.X * f</span><br><span class=\"line\">  v.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  v := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">  v.Scale(<span class=\"number\">10</span>) <span class=\"comment\">// 此時 Go 會解釋爲 (&amp;v).Scale(10)，這就是指針重定向</span></span><br><span class=\"line\">  fmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用指針接收者的好處：</p>\n<ol>\n<li>方法能夠修改其接收者指向的值。</li>\n<li>避免在每次調用方法時複製該值。該值佔用的空間越大，則越顯得高效。</li>\n</ol>\n<p>注意：一個結構體採用值接收者的方式實現了接口的方法，則隱含著採用指針接收者的方式實現了接口的方法。（接收者是指針類型的方法，很可能在方法中會對接收者的屬性進行更改操作，從而影響接收者；而對於接收者是值類型的方法，在方法中不會對接收者本身產生影響）</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p><strong>（1）定義</strong></p>\n<p>接口類型是<strong>由一組方法簽名定義的集合</strong>。接口類型的變量可以保存<strong>任何</strong>實現了這些方法的值。</p>\n<p><strong>（2）隱式實現</strong></p>\n<p>類型通過實現一個接口的所有方法來實現該接口。既然無需專門顯式聲明，也就沒有「implements」關鍵字。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  eat()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> John <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;eat...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  eat()</span><br><span class=\"line\">  talk()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">talk</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;talk...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a Animal = &amp;John&#123;&#125;</span><br><span class=\"line\">  a.eat()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b Person = &amp;John&#123;&#125;</span><br><span class=\"line\">  b.eat()</span><br><span class=\"line\">  b.talk()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）接口值</strong></p>\n<p>接口也是值，可以作爲函數的參數或返回值。在內部，接口值可以看做包含值和具體類型的元組：<code>(value, type)</code> 。接口值保存了一個具體底層類型的具體值。接口值調用方法時會執行其底層類型的同名方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Animal、John 見上面的代碼</span></span><br><span class=\"line\">j := John&#123;&#125;</span><br><span class=\"line\">describe(j)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i Animal)</span></span>&#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）底層值爲 nil 的接口值</strong></p>\n<p>即便接口內的具體值為 nil，方法仍然會被 nil 接收者調用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 改造上面的代碼</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(j *John)</span> <span class=\"title\">talk</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> j == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;j is &lt;nil&gt;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;talk...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x Person</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y John</span><br><span class=\"line\">  x = &amp;y</span><br><span class=\"line\">  describe(x)</span><br><span class=\"line\">  x.talk() <span class=\"comment\">// 正常調用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判斷接口的底層值是否爲 nil 的方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接上</span></span><br><span class=\"line\"><span class=\"built_in\">println</span>( x == <span class=\"literal\">nil</span> || reflect.ValueOf(x).IsNil())</span><br></pre></td></tr></table></figure>\n\n<p><strong>（6）nil 接口值</strong></p>\n<p>nil 接口值既不保存值也不保存具體類型。</p>\n<p>為 nil 接口調用方法會產生運行時錯誤，因為接口的元組內並未包含能夠指明該調用哪個 <strong>具體</strong> 方法的類型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  M()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i I</span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\">  i.M() <span class=\"comment\">// 此處拋出 panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i I)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i) <span class=\"comment\">// (&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（7）空接口</strong></p>\n<p>指定了<strong>零個方法</strong>的接口值被稱為空接口，即 <code>interface&#123;&#125;</code> 。空接口可保存任何類型的值。（因為每個類型都至少實現了零個方法。）空接口被用來處理未知類型的值。例如，<code>fmt.Print</code> 可接受類型為 <code>interface&#123;&#125;</code> 的任意數量的參數。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">  i = <span class=\"number\">42</span> <span class=\"comment\">// 保存 int值</span></span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">  i = <span class=\"string\">&quot;hello&quot;</span> <span class=\"comment\">// 保存 string值</span></span><br><span class=\"line\">  describe(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（8）類型斷言</strong></p>\n<p>類型斷言提供了訪問<strong>接口值底層具體值</strong>的方式。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判斷接口i的底層值類型是否爲T，如是返回其底層值和true，否則返回T類型的零值和false</span></span><br><span class=\"line\">t, ok := i.(T)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">s, ok := i.(<span class=\"keyword\">string</span>)</span><br><span class=\"line\">fmt.Println(s, ok)</span><br><span class=\"line\">f, ok := i.(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">fmt.Println(f, ok)</span><br><span class=\"line\"><span class=\"comment\">// 支持類型選擇</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">do</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> v := i.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"keyword\">int</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;Twice %v is %v\\n&quot;</span>, v, v*<span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"keyword\">string</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%q is %v bytes long\\n&quot;</span>, v, <span class=\"built_in\">len</span>(v))</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;I don&#x27;t know about type %T!\\n&quot;</span>, v)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"異常處理\"><a href=\"#異常處理\" class=\"headerlink\" title=\"異常處理\"></a>異常處理</h3><p>Go 程序使用 <code>error</code> 值來表示錯誤狀態。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Error() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常函數會返回一個 <code>error</code> 值，調用的它的代碼應當判斷這個錯誤是否等於 <code>nil</code> 來進行錯誤處理。<code>error</code> 為 nil 時表示成功；非 nil 的 <code>error</code> 表示失敗。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> i, err := strconv.Atoi(<span class=\"string\">&quot;42&quot;</span>); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;Converted integer:&quot;</span>, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Go-程-goroutine\"><a href=\"#Go-程-goroutine\" class=\"headerlink\" title=\"Go 程(goroutine)\"></a>Go 程(goroutine)</h3><p><strong>（1）定義</strong></p>\n<p><strong>Go 程（goroutine）是由 Go 運行時管理的輕量級線程</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x,y,z 的求值發生在當前 Go 程中，f 的執行則是在新的 Go 程中</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> f(x, y, z)</span><br></pre></td></tr></table></figure>\n\n<p>（<strong>2）信道</strong></p>\n<p><strong>信道是帶有類型的管道</strong>，你可以通過它用<strong>信道操作符</strong> <code>&lt;-</code> (箭頭就是數據流的方向)來發送或者接收值。</p>\n<p>默認情況下，發送和接收操作在另一端準備好之前都會阻塞。這使得 Go 程可以在沒有顯式的鎖或競態變量的情況下進行同步。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 創建信道</span></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">// 將 v 發送至信道 ch。</span></span><br><span class=\"line\">ch &lt;- v</span><br><span class=\"line\"><span class=\"comment\">// 從 ch 接收值並賦予 v。</span></span><br><span class=\"line\">v := &lt;-ch</span><br></pre></td></tr></table></figure>\n\n<p><strong>信道可以是帶緩衝，</strong>將緩衝長度作為第二個參數提供給 <code>make</code> 來初始化一個帶緩衝的信道。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>僅當信道的緩衝區填滿後，向其發送數據時才會阻塞。當緩衝區為空時，接受方會阻塞。</strong></p>\n<p><strong>（3）range 和 close</strong></p>\n<p>有且僅有發送者可以通過 close 方法關閉一個信道。接收者讀取值的時候可以通過 <code>v, ok := &lt;-ch</code>  的 ok 值判斷是否信道關閉了。更簡單的是使用 for-range 不斷從信道接收值，直到信道關閉，循環自動退出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(n <span class=\"keyword\">int</span>, c <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">    c &lt;- x</span><br><span class=\"line\">    x, y = y, x+y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> fibonacci(<span class=\"built_in\">cap</span>(c), c)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> c &#123;</span><br><span class=\"line\">    fmt.Println(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）select</strong></p>\n<p>select 語句使一個 Go 程可以等待多個通信操作。select 會阻塞到某個分支可以繼續執行為止，這時就會執行該分支。當多個分支都準備好時會隨機選擇一個執行。當 select 中的其它分支都沒有準備好時，default 分支就會執行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(c, quit <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  x, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> c &lt;- x:</span><br><span class=\"line\">      x, y = y, x+y</span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;-quit:</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">&quot;quit&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 當 c 和 quit 阻塞時會執行到此處</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  quit := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">      fmt.Println(&lt;-c)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    quit &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  fibonacci(c, quit)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>練習：等價二叉查找樹</p>\n<p>  函數 tree.New(k) 用於構造一個隨機結構的已排序二叉查找樹，它保存了值 k, 2k, 3k, …, 10k。</p>\n<p>  Walk 步進 tree t 將所有的值從 tree 發送到 channel ch。</p>\n<p>  用 Walk 實現 Same 函數來檢測 t1 和 t2 是否存儲了相同的值。</p>\n  <figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;golang.org/x/tour/tree&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Walk</span><span class=\"params\">(t *tree.Tree, ch <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> t.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    Walk(t.Left, ch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ch &lt;- t.Value</span><br><span class=\"line\">  <span class=\"keyword\">if</span> t.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    Walk(t.Right, ch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Same 检测树 t1 和 t2 是否含有相同的值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Same</span><span class=\"params\">(t1, t2 *tree.Tree)</span> <span class=\"title\">bool</span></span>&#123;</span><br><span class=\"line\">  ch1,ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>),<span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Walk(t1, ch1)</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch1)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Walk(t2, ch2)</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch2)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> ch1&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i != &lt;-ch2 &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(Same(tree.New(<span class=\"number\">1</span>),tree.New(<span class=\"number\">1</span>)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（5）sync.Mutex</strong></p>\n<p>互斥鎖可以保證每次只有一個 Go 程訪問一個共享變量。</p>\n<p>Go 標準庫中的 <strong>Mutex</strong> 就是一個互斥鎖，可以創建為其他結構體的字段；零值為解鎖狀態。Mutex類型的鎖和線程無關，可以由不同的線程加鎖和解鎖。在代碼前調用 Lock 方法，並在代碼後調用 Unlock 方法來保證一段代碼互斥執行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.Unlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>爲了提升讀寫性能，常用 <strong>RWMutex</strong> 代替 <strong>Mutex。</strong>RWMutex是讀寫互斥鎖。該鎖可以被同時多個讀取者持有或唯一個寫入者持有。RWMutex可以創建為其他結構體的字段；零值為解鎖狀態。RWMutex類型的鎖也和線程無關，可以由不同的線程加讀取鎖/寫入和解讀取鎖/寫入鎖。</p>\n<p>下面的代碼效果不明顯，因爲讀的次數不多。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.RLock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.RUnlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  now := time.Now()</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(time.Now().Sub(now))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（6）WaitGroup</strong></p>\n<p>WaitGroup 可以等待一組 Go 程結束。通過調用 Add 方法設定要等待的 Go 程數量。然後各個 Go 程通過調用 Done 方法結束等待。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  v   <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  mux sync.RWMutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Increase</span><span class=\"params\">(key <span class=\"keyword\">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">  c.mux.Lock()</span><br><span class=\"line\">  c.v[key]++</span><br><span class=\"line\">  wg.Done()</span><br><span class=\"line\">  c.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  c.mux.RLock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mux.RUnlock()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1000</span>)</span><br><span class=\"line\">  c := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> c.Increase(<span class=\"string\">&quot;somekey&quot;</span>, &amp;wg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  fmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java 集合","p":"it/java/java-collection.md","_content":"\nJava 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。\n\nList 有一實現 `ArrayList`，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數。\n\nSet 有一實現 `HashSet`，其底層實現是 `HashMap` ，其檢查重複的機制有賴於 `hashCode` 和 `equals` 方法。\n\nMap 有一實現 `HashMap` ，JDK 1.8 之後其底層實現是：**數組 + 鏈表 + 紅黑二叉樹**。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 `hash & (length-1)` 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。\n\n總結下 HashMap 中解決哈希衝突的方式：\n\n1. 使用鏈表 — 拉鍊法；\n2. 使用紅黑二叉樹；\n3. 擴容底層數組；\n4. 強制數組容量爲 2 之幂次；\n5. 將元素的 hash 值的高位分散到低位等等。\n\n`ArrayList`、`HashSet`、`HashMap` 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 `CopyOnWriteArrayList` 、`ConcurrentHashMap` （`HashSet` 用`ConcurrentHashMap` 的 keySet 可得 Set 視圖）。`CopyOnWriteArrayList` 會在寫時加鎖並複製集合進行操作；`ConcurrentHashMap` 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。\n\n<!-- more -->\n\n## 概覽\n\n集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。\n\n![](java-collection/Untitled.png)\n\n### List、Set、Map 三者之區別\n\n1. List：存儲的元素有序、可重複。\n2. Set：存儲的元素無序、不可重複。\n3. Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。\n\n### List、Set、Map 三者之底層數據結構\n\n1. List\n    - ArrayList：Object 數組\n    - Vector：Object 數組\n    - LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）\n2. Set\n    - HashSet（無序、唯一）：基於 HashMap\n    - LinkedHashSet：基於 LinkedHashMap\n    - TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）\n3. Map\n    - HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）\n    - LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表\n    - Hashtable：數組 + 鏈表\n    - TreeMap：紅黑樹（自平衡的排序二叉樹）\n\n### Iterator 迭代器\n\n迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，`hasNext()` 和 `next()` 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 `ConcurrentModificationException` 了。\n\n爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 `modCount` 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 `expectedModCount` 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 `modCount` 和 `expectedModCount`，兩者相等，不會拋出異常。\n\n```java\nMap<Integer, String> map = new HashMap();\nmap.put(1, \"Java\");\nmap.put(2, \"Python\");\nmap.put(2, \"Go\");\nIterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<Integer, String> entry = iterator.next();\n  System.out.println(entry.getKey() + entry.getValue());\n}\n```\n\n### 有哪些集合是線程不安全的？怎麼解決？\n\n常用的 `ArrayList`、`LinkedList`、`HashMap`、`HashSet`、`TreeSet`、`TreeMap`、`PriorityQueue` 都不是線程安全的。解決方法就是用 `java.util.concurrent` 包提供的線程安全的集合來代替：\n\n1. `ConcurrentHashMap` 代替 `HashMap`；\n2. `CopyOnWriteArrayList` 代替 `ArrayList`；\n3. `ConcurrentLinkedQueue` 代替 `LinkedList` ；\n4. `BlockingQueue` 接口下的 `PriorityBlockingQueue`、`LinkedBlockingQueue` 等阻塞隊列代替 `PriorityQueue`  等；\n5. `ConcurrentSkipListMap`  代替 `TreeMap` ，實現多線程下保證按 Key 的順序存儲元素。\n\n### `length`、`length()`、`size()` 三者用途\n\n1. `length`：用於數組。\n2. `length()`：用於字符串。\n3. `size()`：用於集合。\n\n### Collections 工具類的使用\n\n- 排序\n\n    ```java\n    //反轉\n    void reverse(List list)\n    //隨機排序\n    void shuffle(List list)\n    //按自然排序的升序排序\n    void sort(List list)\n    //定制排序，由Comparator控制排序邏輯\n    void sort(List list, Comparator c)\n    //交換兩個索引位置的元素\n    void swap(List list, int i , int j)\n    //旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面\n    void rotate(List list, int distance)\n    ```\n\n- 查找替換統計\n\n    ```java\n    //對List進行二分查找，返回索引，注意List必須是有序的\n    int binarySearch(List list, Object key)\n    //根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)\n    int max(Collection coll)\n    //根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)\n    int max(Collection coll, Comparator c)\n    //用指定的元素代替指定list中的所有元素\n    void fill(List list, Object obj)\n    //用新元素替換舊元素\n    boolean replaceAll(List list, Object oldVal, Object newVal) \n    //統計元素出現次數\n    int frequency(Collection c, Object o)\n    //統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)\n    int indexOfSubList(List list, List target)\n    ```\n\n## List\n\n### 比較 ArrayList 與 LinkedList\n\n共同點：\n\n1. 都實現了 List 接口；\n2. 都是不同步的，不保證線程安全。\n\n不同點：\n\n1. **底層數據結構不同**。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。\n2. **插入和刪除的時間複雜度不同**。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。\n3. **對快速隨機訪問的支持不同**。ArrayList 支持快速隨機訪問；LinkedList 不支持。\n4. **對空間的利用不同**。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。\n- 比較雙向鏈表與雙向循環鏈表\n\n    ![](java-collection/Untitled%201.png)\n\n    ![](java-collection/Untitled%202.png)\n\n### ArrayList 擴容機制\n\nArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。\n\n其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是**等到首次添加元素時才開始初始化**一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，**容量會擴充到原來的 1.5 倍**（`newCapacity = oldCapacity + oldCapacity >> 2`），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。\n\n### 快速隨機訪問 RandomAccess\n\nRandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。\n\n```java\npublic interface RandomAccess {\n}\n```\n\n### `System.arraycopy()` 與 `Arrays.copyOf()` 方法\n\n1. `System.arraycopy()` 方法用於源數組到目標數組之間的數據拷貝；\n2. `Arrays.copyOf()` 方法用於給源數組擴容，底層調用`System.arraycopy()` 。\n\n### CopyOnWriteArrayList 的特點\n\n1. 寫時會加鎖並複製整個集合；\n2. 讀時可能讀到舊數據。\n\n### **如何移除列表中的元素**\n\n首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 `ConcurrentModificationException` （並發修改異常）。\n\n可以採用 `iterator` 或者 `Collection.removeIf()` 方法移除列表元素。\n\n```java\nString[] arrs = {\"a\", \"b\", \"c\"};\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n\n// 採用 iterator\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    if (\"a\".equals(iterator.next())) {\n        iterator.remove();\n        break;\n    }\n}\n\n// 採用 removeIf 方法，\"a\"::equals 等價於 x -> \"a\".equals(x)\nlist.removeIf(\"a\"::equals); \n\nSystem.out.println(list);\n```\n\n### **正確使用 Arrays.asList**\n\n如果非要在 `foreach` 循環中刪除元素，還可以使用 `CopyOnWriteArrayList`，此集合是 `fail-safe` 的。`CopyOnWriteArrayList` 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。\n\nArrays 工具類有一個靜態方法 `asList(T... a)`，能將**對象**數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 `add`/`remove`/`clear` 並不可用，調用會拋出 `UnsupportedOperationException`。\n\nArrays 類中關於 `asList` 方法的代碼如下：\n\n```java\npublic static <T> List<T> asList(T... a) {\n\t\t// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList\n    return new ArrayList<>(a);\n}\n```\n\n爲什麼 `asList` 方法傳入的必須是對象數組呢？\n\n你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。\n\n傳入基本類型的數組會怎樣呢？請看下面代碼：\n\n```java\nint[] ints = {1, 3, 4};\n// 此時的泛型是 int[] 對象，而非 int\nList<int[]> list = Arrays.asList(ints);\n// list 的大小爲 1，就是 ints 這個數組對象\nSystem.out.println(list.size());\n```\n\n### **把數組轉爲 `java.util.ArrayList`**\n\n那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？\n\n```java\n// 1) 使用 ArrayList 的帶參構造方法\nList<String> list = new ArrayList<>(Arrays.asList(arrs));\n\n// 2) 使用 Java 8 的 Stream API\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n// boxed 方法可以把基本類型轉成包裝類型\nList<Integer> intList = Arrays.stream(ints).boxed().collect(Collectors.toList());\n\n// 3) 使用 Guava 包的 API\nImmutableList<String[]> list = ImmutableList.of(arrs);\nImmutableList<String> list1 = ImmutableList.copyOf(arrs);\nArrayList<String> list2 = Lists.newArrayList(arrs);\n\n// 4) 使用 Java 9 的 API\nList<String> list = List.of(arrs);\n```\n\n### **將 List 轉爲數組**\n\n使用 List 的 `toArray` 方法可以將 List 轉爲數組，代碼如下：\n\n```java\n// new String[0] 僅僅爲了告知類型返回數組的類型\nString[] strings = list.toArray(new String[0]);\n```\n\n## Set\n\n### 無序性和不可重複性的含義\n\n無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。\n\n不可重複性是指添加的元素按 equals 方法判斷結果爲 false。\n\n### 比較 HashSet、LinkedHashSet 和 TreeSet\n\n共同點：\n\n1. 都實現了 Set 接口；\n2. 元素不可重複；\n3. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據接口不同**。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。\n2. **有序性不同**。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。\n\n### 自定義排序的實現\n\n自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。\n\n### HashSet 如何檢查重複\n\nHashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n## Map\n\n### 比較 HashMap 與 TreeMap\n\n共同點：\n\n1. 都繼承自 AbstractMap，間接實現了 Map 接口；\n2. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據結構不同**。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。\n2. **HashMap 無搜索和排序的能力**。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。\n\n### HashMap 底層實現\n\nJDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：\n\n```java\ntransient Node<K,V>[] table;\n```\n\nNode 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。\n\n![](java-collection/Untitled%203.png)\n\n該數組默認大小是 `1 << 4 = 16` 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過**拉鍊法**解決。當 Map 中包含的元素數量大於等於 `threshold = loadFactor * capacity` （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。\n\nJDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，**當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。**\n\n![](java-collection/Untitled%204.png)\n\n**（1）散列算法**\n\n首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。\n\n```java\n// JDK 1.7\nstatic int hash(int h) {\n  // This function ensures that hashCodes that differ only by\n  // constant multiples at each bit position have a bounded\n  // number of collisions (approximately 8 at default load factor).\n  h ^= (h >>> 20) ^ (h >>> 12);\n  return h ^ (h >>> 7) ^ (h >>> 4);\n}\n// JDK 1.8\nstatic final int hash(Object key) {\n  int h;\n  return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n**（2）插入算法**\n\n如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 `hash % length` 等價於 `h & (length-1)`。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 `hash % length` = 0000 0010 = `h & (length-1)`。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。\n\n```java\n/**\n* Returns index for hash code h.\n*/\nstatic int indexFor(int h, int length) {\n  return h & (length-1);\n}\n```\n\n**（3）拉鍊法**\n\n將衝突的值加到鏈表中。\n\n**（4）保證數組長度爲 2 之幂次的方法**\n\n- 方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。\n\n    ```java\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n    ```\n\n- 方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。\n\n    ```java\n    // HashMap.java\n    static final int tableSizeFor(int cap) {\n      int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\n      return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n\n    // Integer.java\n    // 取得整數二進制表示前面的零位數量\n    public static int numberOfLeadingZeros(int i) {\n      // HD, Count leading 0's\n      if (i <= 0)\n          return i == 0 ? 32 : 0;\n      int n = 31;\n      if (i >= 1 << 16) { n -= 16; i >>>= 16; }\n      if (i >= 1 <<  8) { n -=  8; i >>>=  8; }\n      if (i >= 1 <<  4) { n -=  4; i >>>=  4; }\n      if (i >= 1 <<  2) { n -=  2; i >>>=  2; }\n      return n - (i >>> 1);\n    }\n    ```\n\n- 方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。\n\n    ```java\n    int n = (int) Math.pow(2, (int) Math.ceil(Math.log(cap) / Math.log(2)));\n    ```\n\n### 遍歷 HashMap 的幾種方式\n\nHashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 `iterator.remove`方法刪除元素或者用 stream 的 `filter` 過濾不需要的數據再進行循環。參見 [https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow](https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow)\n\n```java\nMap<String, String> map = new HashMap<>();\nmap.put(\"lang\", \"java\");\nmap.put(\"sys\", \"linux\");\n// iterator\nIterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<String, String> entry = iterator.next();\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// for，增強 for 循環，使用了迭代器\nfor (Map.Entry<String, String> entry : map.entrySet()) {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// lambda\nmap.forEach((key, value) -> {\n  System.out.println(key + \":\" + value);\n});\n// stream\nmap.entrySet().parallelStream().forEach((entry) -> {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n});\n```\n\n### ConcurrentHashMap 線程安全的原因\n\n我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？\n\nJDK 1.7 時，採用**分段鎖**，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。\n\n![](java-collection/Untitled%205.png)\n\nJDK 1.8 開始取消了分段鎖，採用 **CAS（樂觀鎖） 和 synchronized（悲觀鎖）** 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。\n\n![](java-collection/Untitled%206.png)","source":"_posts/it/java/java-collection.md","raw":"---\ntitle: Java 集合\np: it/java/java-collection.md\ntags:\n- Java\n---\n\nJava 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。\n\nList 有一實現 `ArrayList`，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數。\n\nSet 有一實現 `HashSet`，其底層實現是 `HashMap` ，其檢查重複的機制有賴於 `hashCode` 和 `equals` 方法。\n\nMap 有一實現 `HashMap` ，JDK 1.8 之後其底層實現是：**數組 + 鏈表 + 紅黑二叉樹**。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 `hash & (length-1)` 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。\n\n總結下 HashMap 中解決哈希衝突的方式：\n\n1. 使用鏈表 — 拉鍊法；\n2. 使用紅黑二叉樹；\n3. 擴容底層數組；\n4. 強制數組容量爲 2 之幂次；\n5. 將元素的 hash 值的高位分散到低位等等。\n\n`ArrayList`、`HashSet`、`HashMap` 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 `CopyOnWriteArrayList` 、`ConcurrentHashMap` （`HashSet` 用`ConcurrentHashMap` 的 keySet 可得 Set 視圖）。`CopyOnWriteArrayList` 會在寫時加鎖並複製集合進行操作；`ConcurrentHashMap` 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。\n\n<!-- more -->\n\n## 概覽\n\n集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。\n\n![](java-collection/Untitled.png)\n\n### List、Set、Map 三者之區別\n\n1. List：存儲的元素有序、可重複。\n2. Set：存儲的元素無序、不可重複。\n3. Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。\n\n### List、Set、Map 三者之底層數據結構\n\n1. List\n    - ArrayList：Object 數組\n    - Vector：Object 數組\n    - LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）\n2. Set\n    - HashSet（無序、唯一）：基於 HashMap\n    - LinkedHashSet：基於 LinkedHashMap\n    - TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）\n3. Map\n    - HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）\n    - LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表\n    - Hashtable：數組 + 鏈表\n    - TreeMap：紅黑樹（自平衡的排序二叉樹）\n\n### Iterator 迭代器\n\n迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，`hasNext()` 和 `next()` 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 `ConcurrentModificationException` 了。\n\n爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 `modCount` 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 `expectedModCount` 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 `modCount` 和 `expectedModCount`，兩者相等，不會拋出異常。\n\n```java\nMap<Integer, String> map = new HashMap();\nmap.put(1, \"Java\");\nmap.put(2, \"Python\");\nmap.put(2, \"Go\");\nIterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<Integer, String> entry = iterator.next();\n  System.out.println(entry.getKey() + entry.getValue());\n}\n```\n\n### 有哪些集合是線程不安全的？怎麼解決？\n\n常用的 `ArrayList`、`LinkedList`、`HashMap`、`HashSet`、`TreeSet`、`TreeMap`、`PriorityQueue` 都不是線程安全的。解決方法就是用 `java.util.concurrent` 包提供的線程安全的集合來代替：\n\n1. `ConcurrentHashMap` 代替 `HashMap`；\n2. `CopyOnWriteArrayList` 代替 `ArrayList`；\n3. `ConcurrentLinkedQueue` 代替 `LinkedList` ；\n4. `BlockingQueue` 接口下的 `PriorityBlockingQueue`、`LinkedBlockingQueue` 等阻塞隊列代替 `PriorityQueue`  等；\n5. `ConcurrentSkipListMap`  代替 `TreeMap` ，實現多線程下保證按 Key 的順序存儲元素。\n\n### `length`、`length()`、`size()` 三者用途\n\n1. `length`：用於數組。\n2. `length()`：用於字符串。\n3. `size()`：用於集合。\n\n### Collections 工具類的使用\n\n- 排序\n\n    ```java\n    //反轉\n    void reverse(List list)\n    //隨機排序\n    void shuffle(List list)\n    //按自然排序的升序排序\n    void sort(List list)\n    //定制排序，由Comparator控制排序邏輯\n    void sort(List list, Comparator c)\n    //交換兩個索引位置的元素\n    void swap(List list, int i , int j)\n    //旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面\n    void rotate(List list, int distance)\n    ```\n\n- 查找替換統計\n\n    ```java\n    //對List進行二分查找，返回索引，注意List必須是有序的\n    int binarySearch(List list, Object key)\n    //根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)\n    int max(Collection coll)\n    //根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)\n    int max(Collection coll, Comparator c)\n    //用指定的元素代替指定list中的所有元素\n    void fill(List list, Object obj)\n    //用新元素替換舊元素\n    boolean replaceAll(List list, Object oldVal, Object newVal) \n    //統計元素出現次數\n    int frequency(Collection c, Object o)\n    //統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)\n    int indexOfSubList(List list, List target)\n    ```\n\n## List\n\n### 比較 ArrayList 與 LinkedList\n\n共同點：\n\n1. 都實現了 List 接口；\n2. 都是不同步的，不保證線程安全。\n\n不同點：\n\n1. **底層數據結構不同**。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。\n2. **插入和刪除的時間複雜度不同**。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。\n3. **對快速隨機訪問的支持不同**。ArrayList 支持快速隨機訪問；LinkedList 不支持。\n4. **對空間的利用不同**。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。\n- 比較雙向鏈表與雙向循環鏈表\n\n    ![](java-collection/Untitled%201.png)\n\n    ![](java-collection/Untitled%202.png)\n\n### ArrayList 擴容機制\n\nArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。\n\n其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是**等到首次添加元素時才開始初始化**一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，**容量會擴充到原來的 1.5 倍**（`newCapacity = oldCapacity + oldCapacity >> 2`），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。\n\n### 快速隨機訪問 RandomAccess\n\nRandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。\n\n```java\npublic interface RandomAccess {\n}\n```\n\n### `System.arraycopy()` 與 `Arrays.copyOf()` 方法\n\n1. `System.arraycopy()` 方法用於源數組到目標數組之間的數據拷貝；\n2. `Arrays.copyOf()` 方法用於給源數組擴容，底層調用`System.arraycopy()` 。\n\n### CopyOnWriteArrayList 的特點\n\n1. 寫時會加鎖並複製整個集合；\n2. 讀時可能讀到舊數據。\n\n### **如何移除列表中的元素**\n\n首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 `ConcurrentModificationException` （並發修改異常）。\n\n可以採用 `iterator` 或者 `Collection.removeIf()` 方法移除列表元素。\n\n```java\nString[] arrs = {\"a\", \"b\", \"c\"};\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n\n// 採用 iterator\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    if (\"a\".equals(iterator.next())) {\n        iterator.remove();\n        break;\n    }\n}\n\n// 採用 removeIf 方法，\"a\"::equals 等價於 x -> \"a\".equals(x)\nlist.removeIf(\"a\"::equals); \n\nSystem.out.println(list);\n```\n\n### **正確使用 Arrays.asList**\n\n如果非要在 `foreach` 循環中刪除元素，還可以使用 `CopyOnWriteArrayList`，此集合是 `fail-safe` 的。`CopyOnWriteArrayList` 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。\n\nArrays 工具類有一個靜態方法 `asList(T... a)`，能將**對象**數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 `add`/`remove`/`clear` 並不可用，調用會拋出 `UnsupportedOperationException`。\n\nArrays 類中關於 `asList` 方法的代碼如下：\n\n```java\npublic static <T> List<T> asList(T... a) {\n\t\t// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList\n    return new ArrayList<>(a);\n}\n```\n\n爲什麼 `asList` 方法傳入的必須是對象數組呢？\n\n你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。\n\n傳入基本類型的數組會怎樣呢？請看下面代碼：\n\n```java\nint[] ints = {1, 3, 4};\n// 此時的泛型是 int[] 對象，而非 int\nList<int[]> list = Arrays.asList(ints);\n// list 的大小爲 1，就是 ints 這個數組對象\nSystem.out.println(list.size());\n```\n\n### **把數組轉爲 `java.util.ArrayList`**\n\n那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？\n\n```java\n// 1) 使用 ArrayList 的帶參構造方法\nList<String> list = new ArrayList<>(Arrays.asList(arrs));\n\n// 2) 使用 Java 8 的 Stream API\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n// boxed 方法可以把基本類型轉成包裝類型\nList<Integer> intList = Arrays.stream(ints).boxed().collect(Collectors.toList());\n\n// 3) 使用 Guava 包的 API\nImmutableList<String[]> list = ImmutableList.of(arrs);\nImmutableList<String> list1 = ImmutableList.copyOf(arrs);\nArrayList<String> list2 = Lists.newArrayList(arrs);\n\n// 4) 使用 Java 9 的 API\nList<String> list = List.of(arrs);\n```\n\n### **將 List 轉爲數組**\n\n使用 List 的 `toArray` 方法可以將 List 轉爲數組，代碼如下：\n\n```java\n// new String[0] 僅僅爲了告知類型返回數組的類型\nString[] strings = list.toArray(new String[0]);\n```\n\n## Set\n\n### 無序性和不可重複性的含義\n\n無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。\n\n不可重複性是指添加的元素按 equals 方法判斷結果爲 false。\n\n### 比較 HashSet、LinkedHashSet 和 TreeSet\n\n共同點：\n\n1. 都實現了 Set 接口；\n2. 元素不可重複；\n3. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據接口不同**。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。\n2. **有序性不同**。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。\n\n### 自定義排序的實現\n\n自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。\n\n### HashSet 如何檢查重複\n\nHashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n## Map\n\n### 比較 HashMap 與 TreeMap\n\n共同點：\n\n1. 都繼承自 AbstractMap，間接實現了 Map 接口；\n2. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據結構不同**。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。\n2. **HashMap 無搜索和排序的能力**。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。\n\n### HashMap 底層實現\n\nJDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：\n\n```java\ntransient Node<K,V>[] table;\n```\n\nNode 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。\n\n![](java-collection/Untitled%203.png)\n\n該數組默認大小是 `1 << 4 = 16` 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過**拉鍊法**解決。當 Map 中包含的元素數量大於等於 `threshold = loadFactor * capacity` （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。\n\nJDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，**當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。**\n\n![](java-collection/Untitled%204.png)\n\n**（1）散列算法**\n\n首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。\n\n```java\n// JDK 1.7\nstatic int hash(int h) {\n  // This function ensures that hashCodes that differ only by\n  // constant multiples at each bit position have a bounded\n  // number of collisions (approximately 8 at default load factor).\n  h ^= (h >>> 20) ^ (h >>> 12);\n  return h ^ (h >>> 7) ^ (h >>> 4);\n}\n// JDK 1.8\nstatic final int hash(Object key) {\n  int h;\n  return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n**（2）插入算法**\n\n如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 `hash % length` 等價於 `h & (length-1)`。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 `hash % length` = 0000 0010 = `h & (length-1)`。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。\n\n```java\n/**\n* Returns index for hash code h.\n*/\nstatic int indexFor(int h, int length) {\n  return h & (length-1);\n}\n```\n\n**（3）拉鍊法**\n\n將衝突的值加到鏈表中。\n\n**（4）保證數組長度爲 2 之幂次的方法**\n\n- 方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。\n\n    ```java\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n    ```\n\n- 方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。\n\n    ```java\n    // HashMap.java\n    static final int tableSizeFor(int cap) {\n      int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\n      return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n\n    // Integer.java\n    // 取得整數二進制表示前面的零位數量\n    public static int numberOfLeadingZeros(int i) {\n      // HD, Count leading 0's\n      if (i <= 0)\n          return i == 0 ? 32 : 0;\n      int n = 31;\n      if (i >= 1 << 16) { n -= 16; i >>>= 16; }\n      if (i >= 1 <<  8) { n -=  8; i >>>=  8; }\n      if (i >= 1 <<  4) { n -=  4; i >>>=  4; }\n      if (i >= 1 <<  2) { n -=  2; i >>>=  2; }\n      return n - (i >>> 1);\n    }\n    ```\n\n- 方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。\n\n    ```java\n    int n = (int) Math.pow(2, (int) Math.ceil(Math.log(cap) / Math.log(2)));\n    ```\n\n### 遍歷 HashMap 的幾種方式\n\nHashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 `iterator.remove`方法刪除元素或者用 stream 的 `filter` 過濾不需要的數據再進行循環。參見 [https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow](https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow)\n\n```java\nMap<String, String> map = new HashMap<>();\nmap.put(\"lang\", \"java\");\nmap.put(\"sys\", \"linux\");\n// iterator\nIterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<String, String> entry = iterator.next();\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// for，增強 for 循環，使用了迭代器\nfor (Map.Entry<String, String> entry : map.entrySet()) {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// lambda\nmap.forEach((key, value) -> {\n  System.out.println(key + \":\" + value);\n});\n// stream\nmap.entrySet().parallelStream().forEach((entry) -> {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n});\n```\n\n### ConcurrentHashMap 線程安全的原因\n\n我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？\n\nJDK 1.7 時，採用**分段鎖**，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。\n\n![](java-collection/Untitled%205.png)\n\nJDK 1.8 開始取消了分段鎖，採用 **CAS（樂觀鎖） 和 synchronized（悲觀鎖）** 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。\n\n![](java-collection/Untitled%206.png)","slug":"it/java/java-collection","published":1,"date":"2021-02-05T16:21:16.664Z","updated":"2021-02-05T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7woo00129a9kdsh31etv","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>Java 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。</p>\n<p>List 有一實現 <code>ArrayList</code>，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數。</p>\n<p>Set 有一實現 <code>HashSet</code>，其底層實現是 <code>HashMap</code> ，其檢查重複的機制有賴於 <code>hashCode</code> 和 <code>equals</code> 方法。</p>\n<p>Map 有一實現 <code>HashMap</code> ，JDK 1.8 之後其底層實現是：<strong>數組 + 鏈表 + 紅黑二叉樹</strong>。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 <code>hash &amp; (length-1)</code> 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。</p>\n<p>總結下 HashMap 中解決哈希衝突的方式：</p>\n<ol>\n<li>使用鏈表 — 拉鍊法；</li>\n<li>使用紅黑二叉樹；</li>\n<li>擴容底層數組；</li>\n<li>強制數組容量爲 2 之幂次；</li>\n<li>將元素的 hash 值的高位分散到低位等等。</li>\n</ol>\n<p><code>ArrayList</code>、<code>HashSet</code>、<code>HashMap</code> 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 <code>CopyOnWriteArrayList</code> 、<code>ConcurrentHashMap</code> （<code>HashSet</code> 用<code>ConcurrentHashMap</code> 的 keySet 可得 Set 視圖）。<code>CopyOnWriteArrayList</code> 會在寫時加鎖並複製集合進行操作；<code>ConcurrentHashMap</code> 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"概覽\"><a href=\"#概覽\" class=\"headerlink\" title=\"概覽\"></a>概覽</h2><p>集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。</p>\n<p><img src=\"/2021/02/06/it/java/java-collection/Untitled.png\" alt></p>\n<h3 id=\"List、Set、Map-三者之區別\"><a href=\"#List、Set、Map-三者之區別\" class=\"headerlink\" title=\"List、Set、Map 三者之區別\"></a>List、Set、Map 三者之區別</h3><ol>\n<li>List：存儲的元素有序、可重複。</li>\n<li>Set：存儲的元素無序、不可重複。</li>\n<li>Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。</li>\n</ol>\n<h3 id=\"List、Set、Map-三者之底層數據結構\"><a href=\"#List、Set、Map-三者之底層數據結構\" class=\"headerlink\" title=\"List、Set、Map 三者之底層數據結構\"></a>List、Set、Map 三者之底層數據結構</h3><ol>\n<li>List<ul>\n<li>ArrayList：Object 數組</li>\n<li>Vector：Object 數組</li>\n<li>LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）</li>\n</ul>\n</li>\n<li>Set<ul>\n<li>HashSet（無序、唯一）：基於 HashMap</li>\n<li>LinkedHashSet：基於 LinkedHashMap</li>\n<li>TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n<li>Map<ul>\n<li>HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）</li>\n<li>LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表</li>\n<li>Hashtable：數組 + 鏈表</li>\n<li>TreeMap：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Iterator-迭代器\"><a href=\"#Iterator-迭代器\" class=\"headerlink\" title=\"Iterator 迭代器\"></a>Iterator 迭代器</h3><p>迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，<code>hasNext()</code> 和 <code>next()</code> 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 <code>ConcurrentModificationException</code> 了。</p>\n<p>爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 <code>modCount</code> 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 <code>expectedModCount</code> 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 <code>modCount</code> 和 <code>expectedModCount</code>，兩者相等，不會拋出異常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">&quot;Java&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Python&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Go&quot;</span>);</span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有哪些集合是線程不安全的？怎麼解決？\"><a href=\"#有哪些集合是線程不安全的？怎麼解決？\" class=\"headerlink\" title=\"有哪些集合是線程不安全的？怎麼解決？\"></a>有哪些集合是線程不安全的？怎麼解決？</h3><p>常用的 <code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>HashSet</code>、<code>TreeSet</code>、<code>TreeMap</code>、<code>PriorityQueue</code> 都不是線程安全的。解決方法就是用 <code>java.util.concurrent</code> 包提供的線程安全的集合來代替：</p>\n<ol>\n<li><code>ConcurrentHashMap</code> 代替 <code>HashMap</code>；</li>\n<li><code>CopyOnWriteArrayList</code> 代替 <code>ArrayList</code>；</li>\n<li><code>ConcurrentLinkedQueue</code> 代替 <code>LinkedList</code> ；</li>\n<li><code>BlockingQueue</code> 接口下的 <code>PriorityBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等阻塞隊列代替 <code>PriorityQueue</code>  等；</li>\n<li><code>ConcurrentSkipListMap</code>  代替 <code>TreeMap</code> ，實現多線程下保證按 Key 的順序存儲元素。</li>\n</ol>\n<h3 id=\"length、length-、size-三者用途\"><a href=\"#length、length-、size-三者用途\" class=\"headerlink\" title=\"length、length()、size() 三者用途\"></a><code>length</code>、<code>length()</code>、<code>size()</code> 三者用途</h3><ol>\n<li><code>length</code>：用於數組。</li>\n<li><code>length()</code>：用於字符串。</li>\n<li><code>size()</code>：用於集合。</li>\n</ol>\n<h3 id=\"Collections-工具類的使用\"><a href=\"#Collections-工具類的使用\" class=\"headerlink\" title=\"Collections 工具類的使用\"></a>Collections 工具類的使用</h3><ul>\n<li><p>排序</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//反轉</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//隨機排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shuffle</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//按自然排序的升序排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//定制排序，由Comparator控制排序邏輯</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//交換兩個索引位置的元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> i , <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> distance)</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查找替換統計</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//對List進行二分查找，返回索引，注意List必須是有序的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(List list, Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fill</span><span class=\"params\">(List list, Object obj)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用新元素替換舊元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">replaceAll</span><span class=\"params\">(List list, Object oldVal, Object newVal)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計元素出現次數</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">frequency</span><span class=\"params\">(Collection c, Object o)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">indexOfSubList</span><span class=\"params\">(List list, List target)</span></span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"比較-ArrayList-與-LinkedList\"><a href=\"#比較-ArrayList-與-LinkedList\" class=\"headerlink\" title=\"比較 ArrayList 與 LinkedList\"></a>比較 ArrayList 與 LinkedList</h3><p>共同點：</p>\n<ol>\n<li>都實現了 List 接口；</li>\n<li>都是不同步的，不保證線程安全。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。</li>\n<li><strong>插入和刪除的時間複雜度不同</strong>。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。</li>\n<li><strong>對快速隨機訪問的支持不同</strong>。ArrayList 支持快速隨機訪問；LinkedList 不支持。</li>\n<li><strong>對空間的利用不同</strong>。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。</li>\n</ol>\n<ul>\n<li><p>比較雙向鏈表與雙向循環鏈表</p>\n<p>  <img src=\"/2021/02/06/it/java/java-collection/Untitled%201.png\" alt></p>\n<p>  <img src=\"/2021/02/06/it/java/java-collection/Untitled%202.png\" alt></p>\n</li>\n</ul>\n<h3 id=\"ArrayList-擴容機制\"><a href=\"#ArrayList-擴容機制\" class=\"headerlink\" title=\"ArrayList 擴容機制\"></a>ArrayList 擴容機制</h3><p>ArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。</p>\n<p>其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是<strong>等到首次添加元素時才開始初始化</strong>一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，<strong>容量會擴充到原來的 1.5 倍</strong>（<code>newCapacity = oldCapacity + oldCapacity &gt;&gt; 2</code>），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。</p>\n<h3 id=\"快速隨機訪問-RandomAccess\"><a href=\"#快速隨機訪問-RandomAccess\" class=\"headerlink\" title=\"快速隨機訪問 RandomAccess\"></a>快速隨機訪問 RandomAccess</h3><p>RandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RandomAccess</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"System-arraycopy-與-Arrays-copyOf-方法\"><a href=\"#System-arraycopy-與-Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy() 與 Arrays.copyOf() 方法\"></a><code>System.arraycopy()</code> 與 <code>Arrays.copyOf()</code> 方法</h3><ol>\n<li><code>System.arraycopy()</code> 方法用於源數組到目標數組之間的數據拷貝；</li>\n<li><code>Arrays.copyOf()</code> 方法用於給源數組擴容，底層調用<code>System.arraycopy()</code> 。</li>\n</ol>\n<h3 id=\"CopyOnWriteArrayList-的特點\"><a href=\"#CopyOnWriteArrayList-的特點\" class=\"headerlink\" title=\"CopyOnWriteArrayList 的特點\"></a>CopyOnWriteArrayList 的特點</h3><ol>\n<li>寫時會加鎖並複製整個集合；</li>\n<li>讀時可能讀到舊數據。</li>\n</ol>\n<h3 id=\"如何移除列表中的元素\"><a href=\"#如何移除列表中的元素\" class=\"headerlink\" title=\"如何移除列表中的元素\"></a><strong>如何移除列表中的元素</strong></h3><p>首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 <code>ConcurrentModificationException</code> （並發修改異常）。</p>\n<p>可以採用 <code>iterator</code> 或者 <code>Collection.removeIf()</code> 方法移除列表元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String[] arrs = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>&#125;;</span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 iterator</span></span><br><span class=\"line\">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;a&quot;</span>.equals(iterator.next())) &#123;</span><br><span class=\"line\">        iterator.remove();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 removeIf 方法，&quot;a&quot;::equals 等價於 x -&gt; &quot;a&quot;.equals(x)</span></span><br><span class=\"line\">list.removeIf(<span class=\"string\">&quot;a&quot;</span>::equals); </span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正確使用-Arrays-asList\"><a href=\"#正確使用-Arrays-asList\" class=\"headerlink\" title=\"正確使用 Arrays.asList\"></a><strong>正確使用 Arrays.asList</strong></h3><p>如果非要在 <code>foreach</code> 循環中刪除元素，還可以使用 <code>CopyOnWriteArrayList</code>，此集合是 <code>fail-safe</code> 的。<code>CopyOnWriteArrayList</code> 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。</p>\n<p>Arrays 工具類有一個靜態方法 <code>asList(T... a)</code>，能將<strong>對象</strong>數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 <code>add</code>/<code>remove</code>/<code>clear</code> 並不可用，調用會拋出 <code>UnsupportedOperationException</code>。</p>\n<p>Arrays 類中關於 <code>asList</code> 方法的代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>爲什麼 <code>asList</code> 方法傳入的必須是對象數組呢？</p>\n<p>你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。</p>\n<p>傳入基本類型的數組會怎樣呢？請看下面代碼：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] ints = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 此時的泛型是 int[] 對象，而非 int</span></span><br><span class=\"line\">List&lt;<span class=\"keyword\">int</span>[]&gt; list = Arrays.asList(ints);</span><br><span class=\"line\"><span class=\"comment\">// list 的大小爲 1，就是 ints 這個數組對象</span></span><br><span class=\"line\">System.out.println(list.size());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"把數組轉爲-java-util-ArrayList\"><a href=\"#把數組轉爲-java-util-ArrayList\" class=\"headerlink\" title=\"把數組轉爲 java.util.ArrayList\"></a><strong>把數組轉爲 <code>java.util.ArrayList</code></strong></h3><p>那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1) 使用 ArrayList 的帶參構造方法</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(arrs));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2) 使用 Java 8 的 Stream API</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"><span class=\"comment\">// boxed 方法可以把基本類型轉成包裝類型</span></span><br><span class=\"line\">List&lt;Integer&gt; intList = Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3) 使用 Guava 包的 API</span></span><br><span class=\"line\">ImmutableList&lt;String[]&gt; list = ImmutableList.of(arrs);</span><br><span class=\"line\">ImmutableList&lt;String&gt; list1 = ImmutableList.copyOf(arrs);</span><br><span class=\"line\">ArrayList&lt;String&gt; list2 = Lists.newArrayList(arrs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4) 使用 Java 9 的 API</span></span><br><span class=\"line\">List&lt;String&gt; list = List.of(arrs);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"將-List-轉爲數組\"><a href=\"#將-List-轉爲數組\" class=\"headerlink\" title=\"將 List 轉爲數組\"></a><strong>將 List 轉爲數組</strong></h3><p>使用 List 的 <code>toArray</code> 方法可以將 List 轉爲數組，代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new String[0] 僅僅爲了告知類型返回數組的類型</span></span><br><span class=\"line\">String[] strings = list.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"無序性和不可重複性的含義\"><a href=\"#無序性和不可重複性的含義\" class=\"headerlink\" title=\"無序性和不可重複性的含義\"></a>無序性和不可重複性的含義</h3><p>無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。</p>\n<p>不可重複性是指添加的元素按 equals 方法判斷結果爲 false。</p>\n<h3 id=\"比較-HashSet、LinkedHashSet-和-TreeSet\"><a href=\"#比較-HashSet、LinkedHashSet-和-TreeSet\" class=\"headerlink\" title=\"比較 HashSet、LinkedHashSet 和 TreeSet\"></a>比較 HashSet、LinkedHashSet 和 TreeSet</h3><p>共同點：</p>\n<ol>\n<li>都實現了 Set 接口；</li>\n<li>元素不可重複；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據接口不同</strong>。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。</li>\n<li><strong>有序性不同</strong>。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。</li>\n</ol>\n<h3 id=\"自定義排序的實現\"><a href=\"#自定義排序的實現\" class=\"headerlink\" title=\"自定義排序的實現\"></a>自定義排序的實現</h3><p>自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。</p>\n<h3 id=\"HashSet-如何檢查重複\"><a href=\"#HashSet-如何檢查重複\" class=\"headerlink\" title=\"HashSet 如何檢查重複\"></a>HashSet 如何檢查重複</h3><p>HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"比較-HashMap-與-TreeMap\"><a href=\"#比較-HashMap-與-TreeMap\" class=\"headerlink\" title=\"比較 HashMap 與 TreeMap\"></a>比較 HashMap 與 TreeMap</h3><p>共同點：</p>\n<ol>\n<li>都繼承自 AbstractMap，間接實現了 Map 接口；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。</li>\n<li><strong>HashMap 無搜索和排序的能力</strong>。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。</li>\n</ol>\n<h3 id=\"HashMap-底層實現\"><a href=\"#HashMap-底層實現\" class=\"headerlink\" title=\"HashMap 底層實現\"></a>HashMap 底層實現</h3><p>JDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n\n<p>Node 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。</p>\n<p><img src=\"/2021/02/06/it/java/java-collection/Untitled%203.png\" alt></p>\n<p>該數組默認大小是 <code>1 &lt;&lt; 4 = 16</code> 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過<strong>拉鍊法</strong>解決。當 Map 中包含的元素數量大於等於 <code>threshold = loadFactor * capacity</code> （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。</p>\n<p>JDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，<strong>當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。</strong></p>\n<p><img src=\"/2021/02/06/it/java/java-collection/Untitled%204.png\" alt></p>\n<p><strong>（1）散列算法</strong></p>\n<p>首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK 1.7</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></span><br><span class=\"line\">  <span class=\"comment\">// constant multiples at each bit position have a bounded</span></span><br><span class=\"line\">  <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></span><br><span class=\"line\">  h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// JDK 1.8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）插入算法</strong></p>\n<p>如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 <code>hash % length</code> 等價於 <code>h &amp; (length-1)</code>。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 <code>hash % length</code> = 0000 0010 = <code>h &amp; (length-1)</code>。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Returns index for hash code h.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）拉鍊法</strong></p>\n<p>將衝突的值加到鏈表中。</p>\n<p><strong>（4）保證數組長度爲 2 之幂次的方法</strong></p>\n<ul>\n<li><p>方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HashMap.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = -<span class=\"number\">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Integer.java</span></span><br><span class=\"line\"><span class=\"comment\">// 取得整數二進制表示前面的零位數量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">numberOfLeadingZeros</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// HD, Count leading 0&#x27;s</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i == <span class=\"number\">0</span> ? <span class=\"number\">32</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>) &#123; n -= <span class=\"number\">16</span>; i &gt;&gt;&gt;= <span class=\"number\">16</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">8</span>) &#123; n -=  <span class=\"number\">8</span>; i &gt;&gt;&gt;=  <span class=\"number\">8</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">4</span>) &#123; n -=  <span class=\"number\">4</span>; i &gt;&gt;&gt;=  <span class=\"number\">4</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">2</span>) &#123; n -=  <span class=\"number\">2</span>; i &gt;&gt;&gt;=  <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - (i &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = (<span class=\"keyword\">int</span>) Math.pow(<span class=\"number\">2</span>, (<span class=\"keyword\">int</span>) Math.ceil(Math.log(cap) / Math.log(<span class=\"number\">2</span>)));</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"遍歷-HashMap-的幾種方式\"><a href=\"#遍歷-HashMap-的幾種方式\" class=\"headerlink\" title=\"遍歷 HashMap 的幾種方式\"></a>遍歷 HashMap 的幾種方式</h3><p>HashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 <code>iterator.remove</code>方法刪除元素或者用 stream 的 <code>filter</code> 過濾不需要的數據再進行循環。參見 <a href=\"https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow\">https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;lang&quot;</span>, <span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;sys&quot;</span>, <span class=\"string\">&quot;linux&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// iterator</span></span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// for，增強 for 循環，使用了迭代器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lambda</span></span><br><span class=\"line\">map.forEach((key, value) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// stream</span></span><br><span class=\"line\">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ConcurrentHashMap-線程安全的原因\"><a href=\"#ConcurrentHashMap-線程安全的原因\" class=\"headerlink\" title=\"ConcurrentHashMap 線程安全的原因\"></a>ConcurrentHashMap 線程安全的原因</h3><p>我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？</p>\n<p>JDK 1.7 時，採用<strong>分段鎖</strong>，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。</p>\n<p><img src=\"/2021/02/06/it/java/java-collection/Untitled%205.png\" alt></p>\n<p>JDK 1.8 開始取消了分段鎖，採用 <strong>CAS（樂觀鎖） 和 synchronized（悲觀鎖）</strong> 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。</p>\n<p><img src=\"/2021/02/06/it/java/java-collection/Untitled%206.png\" alt></p>\n","site":{"data":{}},"excerpt":"<p>Java 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。</p>\n<p>List 有一實現 <code>ArrayList</code>，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數。</p>\n<p>Set 有一實現 <code>HashSet</code>，其底層實現是 <code>HashMap</code> ，其檢查重複的機制有賴於 <code>hashCode</code> 和 <code>equals</code> 方法。</p>\n<p>Map 有一實現 <code>HashMap</code> ，JDK 1.8 之後其底層實現是：<strong>數組 + 鏈表 + 紅黑二叉樹</strong>。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 <code>hash &amp; (length-1)</code> 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。</p>\n<p>總結下 HashMap 中解決哈希衝突的方式：</p>\n<ol>\n<li>使用鏈表 — 拉鍊法；</li>\n<li>使用紅黑二叉樹；</li>\n<li>擴容底層數組；</li>\n<li>強制數組容量爲 2 之幂次；</li>\n<li>將元素的 hash 值的高位分散到低位等等。</li>\n</ol>\n<p><code>ArrayList</code>、<code>HashSet</code>、<code>HashMap</code> 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 <code>CopyOnWriteArrayList</code> 、<code>ConcurrentHashMap</code> （<code>HashSet</code> 用<code>ConcurrentHashMap</code> 的 keySet 可得 Set 視圖）。<code>CopyOnWriteArrayList</code> 會在寫時加鎖並複製集合進行操作；<code>ConcurrentHashMap</code> 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。</p>","more":"<h2 id=\"概覽\"><a href=\"#概覽\" class=\"headerlink\" title=\"概覽\"></a>概覽</h2><p>集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。</p>\n<p><img src=\"/2021/02/06/it/java/java-collection/Untitled.png\" alt></p>\n<h3 id=\"List、Set、Map-三者之區別\"><a href=\"#List、Set、Map-三者之區別\" class=\"headerlink\" title=\"List、Set、Map 三者之區別\"></a>List、Set、Map 三者之區別</h3><ol>\n<li>List：存儲的元素有序、可重複。</li>\n<li>Set：存儲的元素無序、不可重複。</li>\n<li>Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。</li>\n</ol>\n<h3 id=\"List、Set、Map-三者之底層數據結構\"><a href=\"#List、Set、Map-三者之底層數據結構\" class=\"headerlink\" title=\"List、Set、Map 三者之底層數據結構\"></a>List、Set、Map 三者之底層數據結構</h3><ol>\n<li>List<ul>\n<li>ArrayList：Object 數組</li>\n<li>Vector：Object 數組</li>\n<li>LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）</li>\n</ul>\n</li>\n<li>Set<ul>\n<li>HashSet（無序、唯一）：基於 HashMap</li>\n<li>LinkedHashSet：基於 LinkedHashMap</li>\n<li>TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n<li>Map<ul>\n<li>HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）</li>\n<li>LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表</li>\n<li>Hashtable：數組 + 鏈表</li>\n<li>TreeMap：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Iterator-迭代器\"><a href=\"#Iterator-迭代器\" class=\"headerlink\" title=\"Iterator 迭代器\"></a>Iterator 迭代器</h3><p>迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，<code>hasNext()</code> 和 <code>next()</code> 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 <code>ConcurrentModificationException</code> 了。</p>\n<p>爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 <code>modCount</code> 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 <code>expectedModCount</code> 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 <code>modCount</code> 和 <code>expectedModCount</code>，兩者相等，不會拋出異常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">&quot;Java&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Python&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">&quot;Go&quot;</span>);</span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有哪些集合是線程不安全的？怎麼解決？\"><a href=\"#有哪些集合是線程不安全的？怎麼解決？\" class=\"headerlink\" title=\"有哪些集合是線程不安全的？怎麼解決？\"></a>有哪些集合是線程不安全的？怎麼解決？</h3><p>常用的 <code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>HashSet</code>、<code>TreeSet</code>、<code>TreeMap</code>、<code>PriorityQueue</code> 都不是線程安全的。解決方法就是用 <code>java.util.concurrent</code> 包提供的線程安全的集合來代替：</p>\n<ol>\n<li><code>ConcurrentHashMap</code> 代替 <code>HashMap</code>；</li>\n<li><code>CopyOnWriteArrayList</code> 代替 <code>ArrayList</code>；</li>\n<li><code>ConcurrentLinkedQueue</code> 代替 <code>LinkedList</code> ；</li>\n<li><code>BlockingQueue</code> 接口下的 <code>PriorityBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等阻塞隊列代替 <code>PriorityQueue</code>  等；</li>\n<li><code>ConcurrentSkipListMap</code>  代替 <code>TreeMap</code> ，實現多線程下保證按 Key 的順序存儲元素。</li>\n</ol>\n<h3 id=\"length、length-、size-三者用途\"><a href=\"#length、length-、size-三者用途\" class=\"headerlink\" title=\"length、length()、size() 三者用途\"></a><code>length</code>、<code>length()</code>、<code>size()</code> 三者用途</h3><ol>\n<li><code>length</code>：用於數組。</li>\n<li><code>length()</code>：用於字符串。</li>\n<li><code>size()</code>：用於集合。</li>\n</ol>\n<h3 id=\"Collections-工具類的使用\"><a href=\"#Collections-工具類的使用\" class=\"headerlink\" title=\"Collections 工具類的使用\"></a>Collections 工具類的使用</h3><ul>\n<li><p>排序</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//反轉</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//隨機排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shuffle</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//按自然排序的升序排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//定制排序，由Comparator控制排序邏輯</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//交換兩個索引位置的元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> i , <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> distance)</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查找替換統計</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//對List進行二分查找，返回索引，注意List必須是有序的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(List list, Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fill</span><span class=\"params\">(List list, Object obj)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用新元素替換舊元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">replaceAll</span><span class=\"params\">(List list, Object oldVal, Object newVal)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計元素出現次數</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">frequency</span><span class=\"params\">(Collection c, Object o)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">indexOfSubList</span><span class=\"params\">(List list, List target)</span></span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"比較-ArrayList-與-LinkedList\"><a href=\"#比較-ArrayList-與-LinkedList\" class=\"headerlink\" title=\"比較 ArrayList 與 LinkedList\"></a>比較 ArrayList 與 LinkedList</h3><p>共同點：</p>\n<ol>\n<li>都實現了 List 接口；</li>\n<li>都是不同步的，不保證線程安全。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。</li>\n<li><strong>插入和刪除的時間複雜度不同</strong>。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。</li>\n<li><strong>對快速隨機訪問的支持不同</strong>。ArrayList 支持快速隨機訪問；LinkedList 不支持。</li>\n<li><strong>對空間的利用不同</strong>。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。</li>\n</ol>\n<ul>\n<li><p>比較雙向鏈表與雙向循環鏈表</p>\n<p>  <img src=\"/2021/02/06/it/java/java-collection/Untitled%201.png\" alt></p>\n<p>  <img src=\"/2021/02/06/it/java/java-collection/Untitled%202.png\" alt></p>\n</li>\n</ul>\n<h3 id=\"ArrayList-擴容機制\"><a href=\"#ArrayList-擴容機制\" class=\"headerlink\" title=\"ArrayList 擴容機制\"></a>ArrayList 擴容機制</h3><p>ArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。</p>\n<p>其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是<strong>等到首次添加元素時才開始初始化</strong>一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，<strong>容量會擴充到原來的 1.5 倍</strong>（<code>newCapacity = oldCapacity + oldCapacity &gt;&gt; 2</code>），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。</p>\n<h3 id=\"快速隨機訪問-RandomAccess\"><a href=\"#快速隨機訪問-RandomAccess\" class=\"headerlink\" title=\"快速隨機訪問 RandomAccess\"></a>快速隨機訪問 RandomAccess</h3><p>RandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RandomAccess</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"System-arraycopy-與-Arrays-copyOf-方法\"><a href=\"#System-arraycopy-與-Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy() 與 Arrays.copyOf() 方法\"></a><code>System.arraycopy()</code> 與 <code>Arrays.copyOf()</code> 方法</h3><ol>\n<li><code>System.arraycopy()</code> 方法用於源數組到目標數組之間的數據拷貝；</li>\n<li><code>Arrays.copyOf()</code> 方法用於給源數組擴容，底層調用<code>System.arraycopy()</code> 。</li>\n</ol>\n<h3 id=\"CopyOnWriteArrayList-的特點\"><a href=\"#CopyOnWriteArrayList-的特點\" class=\"headerlink\" title=\"CopyOnWriteArrayList 的特點\"></a>CopyOnWriteArrayList 的特點</h3><ol>\n<li>寫時會加鎖並複製整個集合；</li>\n<li>讀時可能讀到舊數據。</li>\n</ol>\n<h3 id=\"如何移除列表中的元素\"><a href=\"#如何移除列表中的元素\" class=\"headerlink\" title=\"如何移除列表中的元素\"></a><strong>如何移除列表中的元素</strong></h3><p>首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 <code>ConcurrentModificationException</code> （並發修改異常）。</p>\n<p>可以採用 <code>iterator</code> 或者 <code>Collection.removeIf()</code> 方法移除列表元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String[] arrs = &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>&#125;;</span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 iterator</span></span><br><span class=\"line\">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;a&quot;</span>.equals(iterator.next())) &#123;</span><br><span class=\"line\">        iterator.remove();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 removeIf 方法，&quot;a&quot;::equals 等價於 x -&gt; &quot;a&quot;.equals(x)</span></span><br><span class=\"line\">list.removeIf(<span class=\"string\">&quot;a&quot;</span>::equals); </span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正確使用-Arrays-asList\"><a href=\"#正確使用-Arrays-asList\" class=\"headerlink\" title=\"正確使用 Arrays.asList\"></a><strong>正確使用 Arrays.asList</strong></h3><p>如果非要在 <code>foreach</code> 循環中刪除元素，還可以使用 <code>CopyOnWriteArrayList</code>，此集合是 <code>fail-safe</code> 的。<code>CopyOnWriteArrayList</code> 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。</p>\n<p>Arrays 工具類有一個靜態方法 <code>asList(T... a)</code>，能將<strong>對象</strong>數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 <code>add</code>/<code>remove</code>/<code>clear</code> 並不可用，調用會拋出 <code>UnsupportedOperationException</code>。</p>\n<p>Arrays 類中關於 <code>asList</code> 方法的代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>爲什麼 <code>asList</code> 方法傳入的必須是對象數組呢？</p>\n<p>你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。</p>\n<p>傳入基本類型的數組會怎樣呢？請看下面代碼：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] ints = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 此時的泛型是 int[] 對象，而非 int</span></span><br><span class=\"line\">List&lt;<span class=\"keyword\">int</span>[]&gt; list = Arrays.asList(ints);</span><br><span class=\"line\"><span class=\"comment\">// list 的大小爲 1，就是 ints 這個數組對象</span></span><br><span class=\"line\">System.out.println(list.size());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"把數組轉爲-java-util-ArrayList\"><a href=\"#把數組轉爲-java-util-ArrayList\" class=\"headerlink\" title=\"把數組轉爲 java.util.ArrayList\"></a><strong>把數組轉爲 <code>java.util.ArrayList</code></strong></h3><p>那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1) 使用 ArrayList 的帶參構造方法</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(arrs));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2) 使用 Java 8 的 Stream API</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"><span class=\"comment\">// boxed 方法可以把基本類型轉成包裝類型</span></span><br><span class=\"line\">List&lt;Integer&gt; intList = Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3) 使用 Guava 包的 API</span></span><br><span class=\"line\">ImmutableList&lt;String[]&gt; list = ImmutableList.of(arrs);</span><br><span class=\"line\">ImmutableList&lt;String&gt; list1 = ImmutableList.copyOf(arrs);</span><br><span class=\"line\">ArrayList&lt;String&gt; list2 = Lists.newArrayList(arrs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4) 使用 Java 9 的 API</span></span><br><span class=\"line\">List&lt;String&gt; list = List.of(arrs);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"將-List-轉爲數組\"><a href=\"#將-List-轉爲數組\" class=\"headerlink\" title=\"將 List 轉爲數組\"></a><strong>將 List 轉爲數組</strong></h3><p>使用 List 的 <code>toArray</code> 方法可以將 List 轉爲數組，代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new String[0] 僅僅爲了告知類型返回數組的類型</span></span><br><span class=\"line\">String[] strings = list.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"無序性和不可重複性的含義\"><a href=\"#無序性和不可重複性的含義\" class=\"headerlink\" title=\"無序性和不可重複性的含義\"></a>無序性和不可重複性的含義</h3><p>無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。</p>\n<p>不可重複性是指添加的元素按 equals 方法判斷結果爲 false。</p>\n<h3 id=\"比較-HashSet、LinkedHashSet-和-TreeSet\"><a href=\"#比較-HashSet、LinkedHashSet-和-TreeSet\" class=\"headerlink\" title=\"比較 HashSet、LinkedHashSet 和 TreeSet\"></a>比較 HashSet、LinkedHashSet 和 TreeSet</h3><p>共同點：</p>\n<ol>\n<li>都實現了 Set 接口；</li>\n<li>元素不可重複；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據接口不同</strong>。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。</li>\n<li><strong>有序性不同</strong>。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。</li>\n</ol>\n<h3 id=\"自定義排序的實現\"><a href=\"#自定義排序的實現\" class=\"headerlink\" title=\"自定義排序的實現\"></a>自定義排序的實現</h3><p>自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。</p>\n<h3 id=\"HashSet-如何檢查重複\"><a href=\"#HashSet-如何檢查重複\" class=\"headerlink\" title=\"HashSet 如何檢查重複\"></a>HashSet 如何檢查重複</h3><p>HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"比較-HashMap-與-TreeMap\"><a href=\"#比較-HashMap-與-TreeMap\" class=\"headerlink\" title=\"比較 HashMap 與 TreeMap\"></a>比較 HashMap 與 TreeMap</h3><p>共同點：</p>\n<ol>\n<li>都繼承自 AbstractMap，間接實現了 Map 接口；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。</li>\n<li><strong>HashMap 無搜索和排序的能力</strong>。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。</li>\n</ol>\n<h3 id=\"HashMap-底層實現\"><a href=\"#HashMap-底層實現\" class=\"headerlink\" title=\"HashMap 底層實現\"></a>HashMap 底層實現</h3><p>JDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n\n<p>Node 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。</p>\n<p><img src=\"/2021/02/06/it/java/java-collection/Untitled%203.png\" alt></p>\n<p>該數組默認大小是 <code>1 &lt;&lt; 4 = 16</code> 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過<strong>拉鍊法</strong>解決。當 Map 中包含的元素數量大於等於 <code>threshold = loadFactor * capacity</code> （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。</p>\n<p>JDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，<strong>當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。</strong></p>\n<p><img src=\"/2021/02/06/it/java/java-collection/Untitled%204.png\" alt></p>\n<p><strong>（1）散列算法</strong></p>\n<p>首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK 1.7</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></span><br><span class=\"line\">  <span class=\"comment\">// constant multiples at each bit position have a bounded</span></span><br><span class=\"line\">  <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></span><br><span class=\"line\">  h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// JDK 1.8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）插入算法</strong></p>\n<p>如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 <code>hash % length</code> 等價於 <code>h &amp; (length-1)</code>。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 <code>hash % length</code> = 0000 0010 = <code>h &amp; (length-1)</code>。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Returns index for hash code h.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）拉鍊法</strong></p>\n<p>將衝突的值加到鏈表中。</p>\n<p><strong>（4）保證數組長度爲 2 之幂次的方法</strong></p>\n<ul>\n<li><p>方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HashMap.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = -<span class=\"number\">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Integer.java</span></span><br><span class=\"line\"><span class=\"comment\">// 取得整數二進制表示前面的零位數量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">numberOfLeadingZeros</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// HD, Count leading 0&#x27;s</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i == <span class=\"number\">0</span> ? <span class=\"number\">32</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>) &#123; n -= <span class=\"number\">16</span>; i &gt;&gt;&gt;= <span class=\"number\">16</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">8</span>) &#123; n -=  <span class=\"number\">8</span>; i &gt;&gt;&gt;=  <span class=\"number\">8</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">4</span>) &#123; n -=  <span class=\"number\">4</span>; i &gt;&gt;&gt;=  <span class=\"number\">4</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">2</span>) &#123; n -=  <span class=\"number\">2</span>; i &gt;&gt;&gt;=  <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - (i &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = (<span class=\"keyword\">int</span>) Math.pow(<span class=\"number\">2</span>, (<span class=\"keyword\">int</span>) Math.ceil(Math.log(cap) / Math.log(<span class=\"number\">2</span>)));</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"遍歷-HashMap-的幾種方式\"><a href=\"#遍歷-HashMap-的幾種方式\" class=\"headerlink\" title=\"遍歷 HashMap 的幾種方式\"></a>遍歷 HashMap 的幾種方式</h3><p>HashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 <code>iterator.remove</code>方法刪除元素或者用 stream 的 <code>filter</code> 過濾不需要的數據再進行循環。參見 <a href=\"https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow\">https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;lang&quot;</span>, <span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;sys&quot;</span>, <span class=\"string\">&quot;linux&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// iterator</span></span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// for，增強 for 循環，使用了迭代器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lambda</span></span><br><span class=\"line\">map.forEach((key, value) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(key + <span class=\"string\">&quot;:&quot;</span> + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// stream</span></span><br><span class=\"line\">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">&quot;:&quot;</span> + entry.getValue());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ConcurrentHashMap-線程安全的原因\"><a href=\"#ConcurrentHashMap-線程安全的原因\" class=\"headerlink\" title=\"ConcurrentHashMap 線程安全的原因\"></a>ConcurrentHashMap 線程安全的原因</h3><p>我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？</p>\n<p>JDK 1.7 時，採用<strong>分段鎖</strong>，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。</p>\n<p><img src=\"/2021/02/06/it/java/java-collection/Untitled%205.png\" alt></p>\n<p>JDK 1.8 開始取消了分段鎖，採用 <strong>CAS（樂觀鎖） 和 synchronized（悲觀鎖）</strong> 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。</p>\n<p><img src=\"/2021/02/06/it/java/java-collection/Untitled%206.png\" alt></p>"},{"title":"JVM","p":"it/java/java-jvm.md","_content":"\nJVM(Java Virtual Machine)，即 Java 虛擬機，是操作系統上的一個程序，用於編譯、運行Java程序，使得 Java程序可以跨平台。關於 JVM 我們著重在內存區域、類的加載、對象的創建和內存管理四個部分。\n\n內存區域分爲堆、方法區、程序計數器、虛擬機棧和本地方法棧。其中堆和方法區是線程共享的，程序計數器、虛擬機棧和本地方法棧則是線程私有的。堆是一大塊內存，幾乎所有的對象實例都在這裡分配；方法區在JVM 規範中是堆的一部分，不同的 JVM 可以有不同的實現，就 HotSpot VM 而言，在 JDK1.8 之前使用永久代實現方法區，在JDK1.8及之後使用直接內存上的元空間實現；程序計數器存放下一條指令的地址；虛擬機棧的每一個棧幀保存著方法的局部變量表、操作數棧、動態連接和方法返回地址；本地方法棧類似虛擬機棧，不過是調用 native 方法，在 HotSpot VM中虛擬機棧和本地方法棧合而爲一。\n\n類的生命週期分爲加載、連接、初始化、使用和卸載四個過程，其中：\n\n1. 加載：將 .class 文件以二進制字節流方式讀入虛擬機，並在方法區給靜態變量分配空間，在堆中生成 Class 對象作爲訪問靜態變量的入口。\n2. 連接：分爲驗證、準備和解析三個階段，驗證階段驗證字節碼文件的合規性，準備階段將類變量賦予初始零值，解析階段將常量池中的符號引用轉爲直接引用。\n3. 初始化：執行 `<clinit>` 方法。\n\n對象的創建過程依次是類加載檢查、分配內存、初始化零值、設置對象頭和執行`<init>` 方法。\n\n1. 類加載檢查：檢查類是否加載完畢。\n2. 分配內存：對象實例一般會分配在堆中，根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。JDK1.7之後啟用逃逸分析可以將未逃逸的對象分配到棧中。\n3. 初始化零值：給對象的成員變量設置初始的零值。\n4. 設置對象頭：對象頭包括所屬的類、對象哈希碼、GC分代年齡和鎖信息。\n5. 執行 `<init>` 方法。\n\nJava 是自動內存管理的，內存的分配和回收由JVM進行控制。通常使用分代內存管理，分新生代、老年代和永久代(JDK1.8及之後無永久代)，新對象優先在新生代 Eden 區分配，大對象直接分配到老年代，持續存活的對象也會被轉移到老年代。\n\n內存回收涉及垃圾的判定、垃圾收集算法和垃圾收集器。\n\n判定垃圾通常有引用計數法和可達性分析算法。\n\n垃圾收集(GC)通常分部分收集(Partial GC)和整堆收集(Full GC)，部分收集分新生代收集(Minor GC / Young GC)、老年代收集(Major GC / Old GC)和混合收集(Mixed GC)\n\n垃圾收集算法通常有標記-清除算法、複製算法、標記-整理算法和分代收集算法。\n\n垃圾收集器中 ParNew 最早採用並行收集，CMS 最早採用並發收集。JDK1.8 中默認使用 Parallel Scavenge(新生代) + Parallel Old(老年代) 收集器，JDK9之後默認使用 G1 收集器。\n\n<!-- more -->\n\n## 內存區域\n\n內存區域可以分爲：\n\n1. 線程共享：堆、方法區（邏輯上屬於堆）、直接內存(非運行時內存)\n2. 線程私有：程序計數器、虛擬機棧和本地方法棧\n\n### 堆(Heap)\n\n堆是進程中最大的一塊內存，用於存放對象實例，**幾乎所有**的對象實例都在堆中分配。\n\nJDK 1.7 開始默認開啟了逃逸分析，如果方法中的對象引用沒有逃逸出去（對象沒有 return 或被外面使用），那麼對象可以直接在棧上分配內存，而不是堆。\n\n一般來說，Java 中的堆根據對象實例的存活時長分爲**新生代、老年代和永久代，以便於更好地回收和分配內存**。\n\n![](java-jvm/Untitled.png)\n\n- Young Generation(新生代)\n    - Eden(伊甸園)：一般情況下，新創建的對象實例默認分配到此區域。\n    - Survivor(幸存者)：包含 from 和 to 兩個區，Survivor區的對象實例來自 Eden和另一個 Survivor區，默認情況下對象**至多**在新生代中來回複製**15次**(可通過參數`-XX:MaxTenuringThreshold`設置)後才會進入 Old Generation。\n- Old Generation(老年代)\n- Permanent Generation(永久代)：在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；JDK1.7 時字符串常量池從方法區(HotSpot永久代)移到了堆中；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\n### 方法區(Method Area)\n\n根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放已被虛擬機加載的類信息、常量、靜態變量、即時編譯器編譯後的代碼等數據的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(text segmemt/code segment)，通常只讀。\n\n在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\nUNIX 中的進程將內存劃分成三個部分：\n1. text segment,文本區，例如代碼\n2. data segment，數據區，例如變量\n3. stack segment，棧區域\n\n### 直接內存(Direct Memory)\n\n直接內存不是JVM 規範中定義的內存區域，不受Java堆的限制。\n\n1. JDK1.4 加入的 NIO，引入一種基於通道(Channel)和緩存區(Buffer)的 I/O 方式，可以直接使用 native 函數分配堆外內存。\n2. JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\n### 程序計數器(Program Counter)\n\n程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。\n\n因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。\n\n### 棧(Stack)\n\n棧有兩種：\n\n1. **虛擬機棧**：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態連接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。\n\n    所謂操作數棧就是一個供常量或變量寫入寫出的棧，出棧的方向可以是局部變量表或者直接返回給調用者。\n    所謂動態連接就是在運行時將方法的符號引用轉爲直接引用的過程。\n\n2. **本地方法棧**：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。\n\n爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。\n\n## 類的加載\n\n### 類的生命週期\n\n![](java-jvm/Untitled%201.png)\n\n**（1）加載**\n\n1. 將 .class 文件轉爲**二進制字節流**裝載進**類加載器**(ClassLoader)；\n2. 將其中代表的**靜態**存儲結構轉換爲**方法區**中的**運行時數據結構**；\n3. 在**內存**中生成一個 **Class 對象**，作爲方法區中數據的訪問入口。\n\n**（2）連接**\n\n連接階段分爲驗證、準備和解析三個步驟。該階段和加載階段不是順序執行的，存在交叉，即加載未完成時連接就開始了。\n\n1. 驗證：進行文件格式驗證、元數據驗證、字節碼驗證和符號引用驗證。\n2. 準備：爲**類變量**（靜態變量）分配內存並設置初始值（默認的零值，除非有 final 字段才會設置爲最終的初始值）。\n3. 解析：將常量池內的符號引用替換爲直接引用。\n\n**符號引用**：描述目標的一組符號（字面量），包括類、接口、字段、類方法、接口方法、方法類型、方法句柄和調用限定符。\n**直接引用**：直接指向目標的指針、相對偏移量或一個間接定位到目標的句柄。\n\n**（3）初始化**\n\n初始化階段是執行初始化方法 `<clinit>` 方法的過程。初始化的時機有：\n\n1. 直接 new 一個類會觸發類的初始化。\n2. 對類進行反射調用會自動初始化。\n3. 父類會在子類初始化時自動初始化。\n4. 主類（包含main方法）會隨虛擬機啟動自動初始化。\n5. Java 8 中的默認接口方法會在其實現類初始化時自動初始化。\n6. ...\n\n**（4）卸載**\n\n卸載就是該類的 Class 對象被 GC（垃圾回收）。卸載類需要滿足：\n\n1. 該類的所有實例對象都被 GC。\n2. 該類 Class 對象沒有其他任何地方被引用。\n3. 該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。\n\n### 類加載器(ClassLoader)\n\n自帶的類加載器有以下三種，分別加載不同路徑下的類：\n\n1. **BootstrapClassLoader(啟動類加載器)**：最頂層的加載類，負責加載 `%JAVA_HOME%/lib`目錄下的類或者或被 `-Xbootclasspath`參數指定的路徑中的所有類。\n2. **ExtensionClassLoader(擴展類加載器)**：繼承自`java.lang.ClassLoader`，負責加載 `%JRE_HOME%/lib/ext` 目錄下的類，或系統變量 `java.ext.dirs` 所指定的路徑下的類。\n3. **AppClassLoader(應用程序類加載器)**：繼承自`java.lang.ClassLoader`，記載當前應用 classpath 下的類。\n\nJVM 採用**雙親委派模型(parent-delegation model)**協調類加載器加載類。所謂雙親委派模型就是當一個類要加載時會委託其父類加載器進行加載，如果父類加載器已經加載過會直接返回；如果一直沒有父類加載器處理，會最終委託到頂層類加載器 **BootstrapClassLoader**；當所有**父系類加載器**都無法處理時才會自行加載。\n\n爲何要這樣麻煩，不一開始就自己加載類呢？**避免類被重複加載，避免 Java 核心類被修改**。注意：同一個類文件被不同的類加載器加載之後會生成不同的類。\n\n## 對象的創建\n\n### 對象的創建過程\n\n![](java-jvm/Untitled%202.png)\n\n在 HotSpot 虛擬機中，一個 Java 對象的創建經歷以下幾個步驟：\n\n1. **類加載檢查**。請看「類的加載」部分。\n2. **分配內存**。在堆中分配一塊內存空間供對象使用。有兩種分配方式：\n    - 指針碰撞：當內存規整時，使用和未使用的內存中間會有一個分界指針，只要指針朝未使用內存方法移動即可分配內存。\n    - 空閒列表：當內存不規整時，虛擬機會維護一個內存的可用列表，分配時會確定一塊大小合適的內存並更新可用列表。\n3. **初始化零值**。保證對象實例字段可以不用賦予初始值就可以使用。\n4. **設置對象頭**。對象的元數據，包括所屬的類、對象哈希碼、GC分代年齡以及鎖信息。\n5. **執行 `<init>` 方法**。代碼視角的對象初始化。\n\n比較`<clinit>` 和 `<init>`方法：\n1. `<clinit>` 方法：class init 類構造器，按順序執行父類靜態變量初始化、父類靜態語句塊、子類靜態變量初始化、子類靜態語句塊。\n2. `<init>` 方法：實例構造器，按順序執行父類變量初始化、父類語句塊、父類構造函數、子類變量初始化、子類語句塊、子類構造函數。\n\n### 對象的內存佈局\n\n在 Hotspot 虛擬機中，Java對象在內存中由以下部分組成：\n\n1. 對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。\n2. 實例數據（instance data）：對象的有效信息。\n3. 對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。\n\n### 對象的訪問\n\nJava 程序通過棧上的 reference 類型數據來操作訪問堆上的實例對象。具體來說有以下兩種實現方式：\n\n1. 句柄(handle)：操作對象的中間媒介，通過句柄獲取具體對象實例的指針，進而從實例池中獲取想要訪問的對象。\n\n    ![](java-jvm/Untitled%203.png)\n\n2. 直接指針(direct pointer)：reference 存儲對象地址，直接指向對象實例。HotSpot 虛擬機採用這種方式訪問對象，相對與句柄的方式，節約了一次定位對象的時間。\n\n    ![](java-jvm/Untitled%204.png)\n\n## 內存管理\n\nJava 是自動進行內存管理的，不同於 C/C++ 需要手動進行內存分配和回收。\n\n### 內存分配\n\n1. 對象優先在新生代 Eden 區分配。\n2. 大對象直接進入老年代。\n避免大對象**分配擔保機制**帶來的複製而降低效率。\n分配擔保機制：當進行 Minor GC 時，如果 Survivor 區空間不夠用，會直接將新生代的對象提前轉移到老年代中。\n3. 長期存活的對象將進入老年代。\n每個對象都有一個對象年齡計數器，超齡的對象一般會進入老年代。\n4. 根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。\n\n### 垃圾判定\n\n1. 引用計數法\n給對象添加一個引用計數器，當有一個地方引用了該對象，計數器就加 1，引用失效則減 1。若計數爲 0 則判定該對象是垃圾。這種算法有個大缺陷就是無法解決循環引用問題：當對象 A 和對象B除了互相引用外別無引用時，A 和B的計數都不爲0不會判定爲垃圾，但顯然 A、B是垃圾啊。\n2. 可達性分析算法\n以根集合 GC Roots 爲起點向下搜索形成引用鏈，當一個對象到 GC Roots沒有引用鏈時判定其爲垃圾。\n\n    ![](java-jvm/Untitled%205.png)\n\n    可作爲 GC Roots 的對象有:\n\n    - 虛擬機棧(棧幀中的本地變量表)中引用的對象\n    - 本地方法棧(Native 方法)中引用的對象\n    - 方法區中類靜態屬性引用的對象\n    - 方法區中常量引用的對象\n3. 廢棄常量的判定\n沒有對象引用的常量就是廢棄常量。\n4. 廢棄類的判定\n\n    廢棄類需要滿足：\n\n    - 該類的所有實例對象都被 GC。\n    - 該類 Class 對象沒有其他任何地方被引用。\n    - 該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。\n\n### 垃圾收集算法\n\n垃圾收集(Garbage Collection, GC)，指對判定爲垃圾的內存區域進行收集的過程。針對 HotSpot VM，GC 可分爲：\n\n1. 部分收集 (Partial GC)：\n    - 新生代收集（Minor GC / Young GC）：只對新生代進行垃圾收集，Eden 區和 From 區的數據會進入 To 區，然後 From 和To會互換角色。\n    - 老年代收集（Major GC / Old GC）：只對老年代進行垃圾收集。需要注意的是 Major GC 在有的語境中也用於指代整堆收集。\n    - 混合收集（Mixed GC）：對整個新生代和部分老年代進行垃圾收集。\n2. 整堆收集 (Full GC)：收集整個 Java 堆和方法區。\n\n常見的垃圾收集算法有：\n\n1. 標記-清除算法\n分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一清除垃圾。缺點是造成內存碎片化。\n\n    ![](java-jvm/Untitled%206.png)\n\n2. 複製算法\n將內存分爲大小相同的兩塊，每次只使用其中的一塊。當一塊使用完後，將存活的對象複製到另一塊去，再把使用完的空間一次清理掉，避免了標記-清除算法的內存碎片化問題。\n\n    ![](java-jvm/Untitled%207.png)\n\n3. 標記-整理算法(Mark-Compact)\n分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一將存活對象向一端移動，然後清理掉端邊界之外的內存。\n\n    ![](java-jvm/Untitled%208.png)\n\n4. 分代收集算法\n便於根據各個年代的特點選擇合適的垃圾收集算法：\n* 新生代(From Survivor 和 To Survivor)：複製算法\n* 老年代：標記-清除 或 標記-整理算法\n\n### 垃圾收集器\n\n1. 新生代收集器\n    1. Serial\n    單線程，採用複製算法，串行，收集垃圾時會暫停其他所有的工作線程。\n    2. ParNew (Parallel New)\n    Serial 的多線程版本，採用複製算法，**並行—多條垃圾收集線程並行工作，仍然會暫停其他所有的工作線程(Stop the World)**。\n    3. Parallel Scavenge\n    直譯過來就是「並行清理垃圾」，也採用複製算法，這是 JDK1.8 默認的收集器。該算法關注**吞吐量，即CPU中運行用戶代碼的時間與總消耗時間的比值**。\n2. 老年代收集器\n    1. Serial Old\n    Serial 的老年代版本，採用標記-整理算法。CMS 的後備方案。\n    2. Parallel Old\n    Parallel Scavenge 的老年代版本，採用標記-整理算法。\n    3. CMS (Concurrent Mark Sweep)\n    直譯過來就是「並發標記清除」，HotSpot 虛擬機第一款真正意義上的並發收集器，JDK1.5時發佈，採用標記-清除算法，**並發—用戶線程與垃圾收集線程同時執行（但不一定是並行的，可能會交替執行），用戶程序在繼續運行**。該算法關注**用戶線程的停頓時間**，綽號**并发低停顿收集器**（Concurrent Low Pause Collector）。缺點有三：\n        - 對 ****CPU 資源敏感；\n        - 無法處理浮動垃圾；\n        - 使用的「標記-清除」算法會導致內存碎片化。\n3. G1 (Garbage-First)\n\n    面向服務端應用的垃圾收集器，JDK1.7時發佈。特點是：並發與並行、分代收集、空間整合(標記-整理)和可預測的停頓。G1 收集器在後台維護了一個優先列表，每次根據允許的收集時間，優先選擇回收價值最大的區域。\n\n4. ZGC (The Z Garbage Collector)\n\n    JDK 11時發佈，適用於大內存低延遲服務的內存管理和回收。\n\n使用以下命令可以查看JDK使用的垃圾收集器：\n\n```bash\njava -XX:+PrintCommandLineFlags\njava -XX:+PrintGCDetails\njava -Xlog:gc # 較新版本可用\n```\n\n不同 JDK 版本默認使用的垃圾收集器：\n\n- 1.8，Parallel Scavenge(新生代) + Parallel Old(老年代)\n\n    注意：PS 是「Parallel Scavenge」的簡寫，ParOld 是「Parallel Old」的簡寫。\n\n    ```bash\n    $ java -version\n    java version \"1.8.0_191\"\n    Java(TM) SE Runtime Environment (build 1.8.0_191-b12)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)\n\n    $ java -XX:+PrintCommandLineFlags\n    -XX:InitialHeapSize=266390080 -XX:MaxHeapSize=4262241280 -XX:+PrintCommandLineFlags \n    -XX:+UseCompressedClassPointers -XX:+UseCompressedOops \n    -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC\n\n    $ java -XX:+PrintGCDetails -version\n    Heap\n     \tPSYoungGen      total 76288K, used 2621K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)\n      \t\t\t\t\teden space 65536K, 4% used [0x000000076b500000,0x000000076b78f748,0x000000076f500000)\n      \t\t\t\t\tfrom space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)\n      \t\t\t\t\tto   space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)\n    \tParOldGen       total 175104K, used 0K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)\n      \t\t\t\t\tobject space 175104K, 0% used [0x00000006c1e00000,0x00000006c1e00000,0x00000006cc900000)\n     \tMetaspace       used 2291K, capacity 4480K, committed 4480K, reserved 1056768K\n      \t\t\t\t\tclass space    used 254K, capacity 384K, committed 384K, reserved 1048576K\n    ```\n\n- 9、11、15，G1\n\n    ```bash\n    $ java -version\n    java version \"15.0.1\" 2020-10-20\n    Java(TM) SE Runtime Environment (build 15.0.1+9-18)\n    Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18, mixed mode, sharing)\n\n    $ java -XX:+PrintCommandLineFlags\n    -XX:ConcGCThreads=1 -XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC\n\n    $ java -Xlog:gc\n    [0.006s][info][gc] Using G1\n    ```","source":"_posts/it/java/java-jvm.md","raw":"---\ntitle: JVM\np: it/java/java-jvm.md\ntags:\n- Java\n---\n\nJVM(Java Virtual Machine)，即 Java 虛擬機，是操作系統上的一個程序，用於編譯、運行Java程序，使得 Java程序可以跨平台。關於 JVM 我們著重在內存區域、類的加載、對象的創建和內存管理四個部分。\n\n內存區域分爲堆、方法區、程序計數器、虛擬機棧和本地方法棧。其中堆和方法區是線程共享的，程序計數器、虛擬機棧和本地方法棧則是線程私有的。堆是一大塊內存，幾乎所有的對象實例都在這裡分配；方法區在JVM 規範中是堆的一部分，不同的 JVM 可以有不同的實現，就 HotSpot VM 而言，在 JDK1.8 之前使用永久代實現方法區，在JDK1.8及之後使用直接內存上的元空間實現；程序計數器存放下一條指令的地址；虛擬機棧的每一個棧幀保存著方法的局部變量表、操作數棧、動態連接和方法返回地址；本地方法棧類似虛擬機棧，不過是調用 native 方法，在 HotSpot VM中虛擬機棧和本地方法棧合而爲一。\n\n類的生命週期分爲加載、連接、初始化、使用和卸載四個過程，其中：\n\n1. 加載：將 .class 文件以二進制字節流方式讀入虛擬機，並在方法區給靜態變量分配空間，在堆中生成 Class 對象作爲訪問靜態變量的入口。\n2. 連接：分爲驗證、準備和解析三個階段，驗證階段驗證字節碼文件的合規性，準備階段將類變量賦予初始零值，解析階段將常量池中的符號引用轉爲直接引用。\n3. 初始化：執行 `<clinit>` 方法。\n\n對象的創建過程依次是類加載檢查、分配內存、初始化零值、設置對象頭和執行`<init>` 方法。\n\n1. 類加載檢查：檢查類是否加載完畢。\n2. 分配內存：對象實例一般會分配在堆中，根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。JDK1.7之後啟用逃逸分析可以將未逃逸的對象分配到棧中。\n3. 初始化零值：給對象的成員變量設置初始的零值。\n4. 設置對象頭：對象頭包括所屬的類、對象哈希碼、GC分代年齡和鎖信息。\n5. 執行 `<init>` 方法。\n\nJava 是自動內存管理的，內存的分配和回收由JVM進行控制。通常使用分代內存管理，分新生代、老年代和永久代(JDK1.8及之後無永久代)，新對象優先在新生代 Eden 區分配，大對象直接分配到老年代，持續存活的對象也會被轉移到老年代。\n\n內存回收涉及垃圾的判定、垃圾收集算法和垃圾收集器。\n\n判定垃圾通常有引用計數法和可達性分析算法。\n\n垃圾收集(GC)通常分部分收集(Partial GC)和整堆收集(Full GC)，部分收集分新生代收集(Minor GC / Young GC)、老年代收集(Major GC / Old GC)和混合收集(Mixed GC)\n\n垃圾收集算法通常有標記-清除算法、複製算法、標記-整理算法和分代收集算法。\n\n垃圾收集器中 ParNew 最早採用並行收集，CMS 最早採用並發收集。JDK1.8 中默認使用 Parallel Scavenge(新生代) + Parallel Old(老年代) 收集器，JDK9之後默認使用 G1 收集器。\n\n<!-- more -->\n\n## 內存區域\n\n內存區域可以分爲：\n\n1. 線程共享：堆、方法區（邏輯上屬於堆）、直接內存(非運行時內存)\n2. 線程私有：程序計數器、虛擬機棧和本地方法棧\n\n### 堆(Heap)\n\n堆是進程中最大的一塊內存，用於存放對象實例，**幾乎所有**的對象實例都在堆中分配。\n\nJDK 1.7 開始默認開啟了逃逸分析，如果方法中的對象引用沒有逃逸出去（對象沒有 return 或被外面使用），那麼對象可以直接在棧上分配內存，而不是堆。\n\n一般來說，Java 中的堆根據對象實例的存活時長分爲**新生代、老年代和永久代，以便於更好地回收和分配內存**。\n\n![](java-jvm/Untitled.png)\n\n- Young Generation(新生代)\n    - Eden(伊甸園)：一般情況下，新創建的對象實例默認分配到此區域。\n    - Survivor(幸存者)：包含 from 和 to 兩個區，Survivor區的對象實例來自 Eden和另一個 Survivor區，默認情況下對象**至多**在新生代中來回複製**15次**(可通過參數`-XX:MaxTenuringThreshold`設置)後才會進入 Old Generation。\n- Old Generation(老年代)\n- Permanent Generation(永久代)：在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；JDK1.7 時字符串常量池從方法區(HotSpot永久代)移到了堆中；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\n### 方法區(Method Area)\n\n根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放已被虛擬機加載的類信息、常量、靜態變量、即時編譯器編譯後的代碼等數據的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(text segmemt/code segment)，通常只讀。\n\n在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\nUNIX 中的進程將內存劃分成三個部分：\n1. text segment,文本區，例如代碼\n2. data segment，數據區，例如變量\n3. stack segment，棧區域\n\n### 直接內存(Direct Memory)\n\n直接內存不是JVM 規範中定義的內存區域，不受Java堆的限制。\n\n1. JDK1.4 加入的 NIO，引入一種基於通道(Channel)和緩存區(Buffer)的 I/O 方式，可以直接使用 native 函數分配堆外內存。\n2. JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。\n\n### 程序計數器(Program Counter)\n\n程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。\n\n因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。\n\n### 棧(Stack)\n\n棧有兩種：\n\n1. **虛擬機棧**：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態連接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。\n\n    所謂操作數棧就是一個供常量或變量寫入寫出的棧，出棧的方向可以是局部變量表或者直接返回給調用者。\n    所謂動態連接就是在運行時將方法的符號引用轉爲直接引用的過程。\n\n2. **本地方法棧**：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。\n\n爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。\n\n## 類的加載\n\n### 類的生命週期\n\n![](java-jvm/Untitled%201.png)\n\n**（1）加載**\n\n1. 將 .class 文件轉爲**二進制字節流**裝載進**類加載器**(ClassLoader)；\n2. 將其中代表的**靜態**存儲結構轉換爲**方法區**中的**運行時數據結構**；\n3. 在**內存**中生成一個 **Class 對象**，作爲方法區中數據的訪問入口。\n\n**（2）連接**\n\n連接階段分爲驗證、準備和解析三個步驟。該階段和加載階段不是順序執行的，存在交叉，即加載未完成時連接就開始了。\n\n1. 驗證：進行文件格式驗證、元數據驗證、字節碼驗證和符號引用驗證。\n2. 準備：爲**類變量**（靜態變量）分配內存並設置初始值（默認的零值，除非有 final 字段才會設置爲最終的初始值）。\n3. 解析：將常量池內的符號引用替換爲直接引用。\n\n**符號引用**：描述目標的一組符號（字面量），包括類、接口、字段、類方法、接口方法、方法類型、方法句柄和調用限定符。\n**直接引用**：直接指向目標的指針、相對偏移量或一個間接定位到目標的句柄。\n\n**（3）初始化**\n\n初始化階段是執行初始化方法 `<clinit>` 方法的過程。初始化的時機有：\n\n1. 直接 new 一個類會觸發類的初始化。\n2. 對類進行反射調用會自動初始化。\n3. 父類會在子類初始化時自動初始化。\n4. 主類（包含main方法）會隨虛擬機啟動自動初始化。\n5. Java 8 中的默認接口方法會在其實現類初始化時自動初始化。\n6. ...\n\n**（4）卸載**\n\n卸載就是該類的 Class 對象被 GC（垃圾回收）。卸載類需要滿足：\n\n1. 該類的所有實例對象都被 GC。\n2. 該類 Class 對象沒有其他任何地方被引用。\n3. 該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。\n\n### 類加載器(ClassLoader)\n\n自帶的類加載器有以下三種，分別加載不同路徑下的類：\n\n1. **BootstrapClassLoader(啟動類加載器)**：最頂層的加載類，負責加載 `%JAVA_HOME%/lib`目錄下的類或者或被 `-Xbootclasspath`參數指定的路徑中的所有類。\n2. **ExtensionClassLoader(擴展類加載器)**：繼承自`java.lang.ClassLoader`，負責加載 `%JRE_HOME%/lib/ext` 目錄下的類，或系統變量 `java.ext.dirs` 所指定的路徑下的類。\n3. **AppClassLoader(應用程序類加載器)**：繼承自`java.lang.ClassLoader`，記載當前應用 classpath 下的類。\n\nJVM 採用**雙親委派模型(parent-delegation model)**協調類加載器加載類。所謂雙親委派模型就是當一個類要加載時會委託其父類加載器進行加載，如果父類加載器已經加載過會直接返回；如果一直沒有父類加載器處理，會最終委託到頂層類加載器 **BootstrapClassLoader**；當所有**父系類加載器**都無法處理時才會自行加載。\n\n爲何要這樣麻煩，不一開始就自己加載類呢？**避免類被重複加載，避免 Java 核心類被修改**。注意：同一個類文件被不同的類加載器加載之後會生成不同的類。\n\n## 對象的創建\n\n### 對象的創建過程\n\n![](java-jvm/Untitled%202.png)\n\n在 HotSpot 虛擬機中，一個 Java 對象的創建經歷以下幾個步驟：\n\n1. **類加載檢查**。請看「類的加載」部分。\n2. **分配內存**。在堆中分配一塊內存空間供對象使用。有兩種分配方式：\n    - 指針碰撞：當內存規整時，使用和未使用的內存中間會有一個分界指針，只要指針朝未使用內存方法移動即可分配內存。\n    - 空閒列表：當內存不規整時，虛擬機會維護一個內存的可用列表，分配時會確定一塊大小合適的內存並更新可用列表。\n3. **初始化零值**。保證對象實例字段可以不用賦予初始值就可以使用。\n4. **設置對象頭**。對象的元數據，包括所屬的類、對象哈希碼、GC分代年齡以及鎖信息。\n5. **執行 `<init>` 方法**。代碼視角的對象初始化。\n\n比較`<clinit>` 和 `<init>`方法：\n1. `<clinit>` 方法：class init 類構造器，按順序執行父類靜態變量初始化、父類靜態語句塊、子類靜態變量初始化、子類靜態語句塊。\n2. `<init>` 方法：實例構造器，按順序執行父類變量初始化、父類語句塊、父類構造函數、子類變量初始化、子類語句塊、子類構造函數。\n\n### 對象的內存佈局\n\n在 Hotspot 虛擬機中，Java對象在內存中由以下部分組成：\n\n1. 對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。\n2. 實例數據（instance data）：對象的有效信息。\n3. 對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。\n\n### 對象的訪問\n\nJava 程序通過棧上的 reference 類型數據來操作訪問堆上的實例對象。具體來說有以下兩種實現方式：\n\n1. 句柄(handle)：操作對象的中間媒介，通過句柄獲取具體對象實例的指針，進而從實例池中獲取想要訪問的對象。\n\n    ![](java-jvm/Untitled%203.png)\n\n2. 直接指針(direct pointer)：reference 存儲對象地址，直接指向對象實例。HotSpot 虛擬機採用這種方式訪問對象，相對與句柄的方式，節約了一次定位對象的時間。\n\n    ![](java-jvm/Untitled%204.png)\n\n## 內存管理\n\nJava 是自動進行內存管理的，不同於 C/C++ 需要手動進行內存分配和回收。\n\n### 內存分配\n\n1. 對象優先在新生代 Eden 區分配。\n2. 大對象直接進入老年代。\n避免大對象**分配擔保機制**帶來的複製而降低效率。\n分配擔保機制：當進行 Minor GC 時，如果 Survivor 區空間不夠用，會直接將新生代的對象提前轉移到老年代中。\n3. 長期存活的對象將進入老年代。\n每個對象都有一個對象年齡計數器，超齡的對象一般會進入老年代。\n4. 根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。\n\n### 垃圾判定\n\n1. 引用計數法\n給對象添加一個引用計數器，當有一個地方引用了該對象，計數器就加 1，引用失效則減 1。若計數爲 0 則判定該對象是垃圾。這種算法有個大缺陷就是無法解決循環引用問題：當對象 A 和對象B除了互相引用外別無引用時，A 和B的計數都不爲0不會判定爲垃圾，但顯然 A、B是垃圾啊。\n2. 可達性分析算法\n以根集合 GC Roots 爲起點向下搜索形成引用鏈，當一個對象到 GC Roots沒有引用鏈時判定其爲垃圾。\n\n    ![](java-jvm/Untitled%205.png)\n\n    可作爲 GC Roots 的對象有:\n\n    - 虛擬機棧(棧幀中的本地變量表)中引用的對象\n    - 本地方法棧(Native 方法)中引用的對象\n    - 方法區中類靜態屬性引用的對象\n    - 方法區中常量引用的對象\n3. 廢棄常量的判定\n沒有對象引用的常量就是廢棄常量。\n4. 廢棄類的判定\n\n    廢棄類需要滿足：\n\n    - 該類的所有實例對象都被 GC。\n    - 該類 Class 對象沒有其他任何地方被引用。\n    - 該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。\n\n### 垃圾收集算法\n\n垃圾收集(Garbage Collection, GC)，指對判定爲垃圾的內存區域進行收集的過程。針對 HotSpot VM，GC 可分爲：\n\n1. 部分收集 (Partial GC)：\n    - 新生代收集（Minor GC / Young GC）：只對新生代進行垃圾收集，Eden 區和 From 區的數據會進入 To 區，然後 From 和To會互換角色。\n    - 老年代收集（Major GC / Old GC）：只對老年代進行垃圾收集。需要注意的是 Major GC 在有的語境中也用於指代整堆收集。\n    - 混合收集（Mixed GC）：對整個新生代和部分老年代進行垃圾收集。\n2. 整堆收集 (Full GC)：收集整個 Java 堆和方法區。\n\n常見的垃圾收集算法有：\n\n1. 標記-清除算法\n分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一清除垃圾。缺點是造成內存碎片化。\n\n    ![](java-jvm/Untitled%206.png)\n\n2. 複製算法\n將內存分爲大小相同的兩塊，每次只使用其中的一塊。當一塊使用完後，將存活的對象複製到另一塊去，再把使用完的空間一次清理掉，避免了標記-清除算法的內存碎片化問題。\n\n    ![](java-jvm/Untitled%207.png)\n\n3. 標記-整理算法(Mark-Compact)\n分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一將存活對象向一端移動，然後清理掉端邊界之外的內存。\n\n    ![](java-jvm/Untitled%208.png)\n\n4. 分代收集算法\n便於根據各個年代的特點選擇合適的垃圾收集算法：\n* 新生代(From Survivor 和 To Survivor)：複製算法\n* 老年代：標記-清除 或 標記-整理算法\n\n### 垃圾收集器\n\n1. 新生代收集器\n    1. Serial\n    單線程，採用複製算法，串行，收集垃圾時會暫停其他所有的工作線程。\n    2. ParNew (Parallel New)\n    Serial 的多線程版本，採用複製算法，**並行—多條垃圾收集線程並行工作，仍然會暫停其他所有的工作線程(Stop the World)**。\n    3. Parallel Scavenge\n    直譯過來就是「並行清理垃圾」，也採用複製算法，這是 JDK1.8 默認的收集器。該算法關注**吞吐量，即CPU中運行用戶代碼的時間與總消耗時間的比值**。\n2. 老年代收集器\n    1. Serial Old\n    Serial 的老年代版本，採用標記-整理算法。CMS 的後備方案。\n    2. Parallel Old\n    Parallel Scavenge 的老年代版本，採用標記-整理算法。\n    3. CMS (Concurrent Mark Sweep)\n    直譯過來就是「並發標記清除」，HotSpot 虛擬機第一款真正意義上的並發收集器，JDK1.5時發佈，採用標記-清除算法，**並發—用戶線程與垃圾收集線程同時執行（但不一定是並行的，可能會交替執行），用戶程序在繼續運行**。該算法關注**用戶線程的停頓時間**，綽號**并发低停顿收集器**（Concurrent Low Pause Collector）。缺點有三：\n        - 對 ****CPU 資源敏感；\n        - 無法處理浮動垃圾；\n        - 使用的「標記-清除」算法會導致內存碎片化。\n3. G1 (Garbage-First)\n\n    面向服務端應用的垃圾收集器，JDK1.7時發佈。特點是：並發與並行、分代收集、空間整合(標記-整理)和可預測的停頓。G1 收集器在後台維護了一個優先列表，每次根據允許的收集時間，優先選擇回收價值最大的區域。\n\n4. ZGC (The Z Garbage Collector)\n\n    JDK 11時發佈，適用於大內存低延遲服務的內存管理和回收。\n\n使用以下命令可以查看JDK使用的垃圾收集器：\n\n```bash\njava -XX:+PrintCommandLineFlags\njava -XX:+PrintGCDetails\njava -Xlog:gc # 較新版本可用\n```\n\n不同 JDK 版本默認使用的垃圾收集器：\n\n- 1.8，Parallel Scavenge(新生代) + Parallel Old(老年代)\n\n    注意：PS 是「Parallel Scavenge」的簡寫，ParOld 是「Parallel Old」的簡寫。\n\n    ```bash\n    $ java -version\n    java version \"1.8.0_191\"\n    Java(TM) SE Runtime Environment (build 1.8.0_191-b12)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)\n\n    $ java -XX:+PrintCommandLineFlags\n    -XX:InitialHeapSize=266390080 -XX:MaxHeapSize=4262241280 -XX:+PrintCommandLineFlags \n    -XX:+UseCompressedClassPointers -XX:+UseCompressedOops \n    -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC\n\n    $ java -XX:+PrintGCDetails -version\n    Heap\n     \tPSYoungGen      total 76288K, used 2621K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)\n      \t\t\t\t\teden space 65536K, 4% used [0x000000076b500000,0x000000076b78f748,0x000000076f500000)\n      \t\t\t\t\tfrom space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)\n      \t\t\t\t\tto   space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)\n    \tParOldGen       total 175104K, used 0K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)\n      \t\t\t\t\tobject space 175104K, 0% used [0x00000006c1e00000,0x00000006c1e00000,0x00000006cc900000)\n     \tMetaspace       used 2291K, capacity 4480K, committed 4480K, reserved 1056768K\n      \t\t\t\t\tclass space    used 254K, capacity 384K, committed 384K, reserved 1048576K\n    ```\n\n- 9、11、15，G1\n\n    ```bash\n    $ java -version\n    java version \"15.0.1\" 2020-10-20\n    Java(TM) SE Runtime Environment (build 15.0.1+9-18)\n    Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18, mixed mode, sharing)\n\n    $ java -XX:+PrintCommandLineFlags\n    -XX:ConcGCThreads=1 -XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC\n\n    $ java -Xlog:gc\n    [0.006s][info][gc] Using G1\n    ```","slug":"it/java/java-jvm","published":1,"date":"2021-02-05T16:21:16.845Z","updated":"2021-02-05T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wop00149a9k872i7cir","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>JVM(Java Virtual Machine)，即 Java 虛擬機，是操作系統上的一個程序，用於編譯、運行Java程序，使得 Java程序可以跨平台。關於 JVM 我們著重在內存區域、類的加載、對象的創建和內存管理四個部分。</p>\n<p>內存區域分爲堆、方法區、程序計數器、虛擬機棧和本地方法棧。其中堆和方法區是線程共享的，程序計數器、虛擬機棧和本地方法棧則是線程私有的。堆是一大塊內存，幾乎所有的對象實例都在這裡分配；方法區在JVM 規範中是堆的一部分，不同的 JVM 可以有不同的實現，就 HotSpot VM 而言，在 JDK1.8 之前使用永久代實現方法區，在JDK1.8及之後使用直接內存上的元空間實現；程序計數器存放下一條指令的地址；虛擬機棧的每一個棧幀保存著方法的局部變量表、操作數棧、動態連接和方法返回地址；本地方法棧類似虛擬機棧，不過是調用 native 方法，在 HotSpot VM中虛擬機棧和本地方法棧合而爲一。</p>\n<p>類的生命週期分爲加載、連接、初始化、使用和卸載四個過程，其中：</p>\n<ol>\n<li>加載：將 .class 文件以二進制字節流方式讀入虛擬機，並在方法區給靜態變量分配空間，在堆中生成 Class 對象作爲訪問靜態變量的入口。</li>\n<li>連接：分爲驗證、準備和解析三個階段，驗證階段驗證字節碼文件的合規性，準備階段將類變量賦予初始零值，解析階段將常量池中的符號引用轉爲直接引用。</li>\n<li>初始化：執行 <code>&lt;clinit&gt;</code> 方法。</li>\n</ol>\n<p>對象的創建過程依次是類加載檢查、分配內存、初始化零值、設置對象頭和執行<code>&lt;init&gt;</code> 方法。</p>\n<ol>\n<li>類加載檢查：檢查類是否加載完畢。</li>\n<li>分配內存：對象實例一般會分配在堆中，根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。JDK1.7之後啟用逃逸分析可以將未逃逸的對象分配到棧中。</li>\n<li>初始化零值：給對象的成員變量設置初始的零值。</li>\n<li>設置對象頭：對象頭包括所屬的類、對象哈希碼、GC分代年齡和鎖信息。</li>\n<li>執行 <code>&lt;init&gt;</code> 方法。</li>\n</ol>\n<p>Java 是自動內存管理的，內存的分配和回收由JVM進行控制。通常使用分代內存管理，分新生代、老年代和永久代(JDK1.8及之後無永久代)，新對象優先在新生代 Eden 區分配，大對象直接分配到老年代，持續存活的對象也會被轉移到老年代。</p>\n<p>內存回收涉及垃圾的判定、垃圾收集算法和垃圾收集器。</p>\n<p>判定垃圾通常有引用計數法和可達性分析算法。</p>\n<p>垃圾收集(GC)通常分部分收集(Partial GC)和整堆收集(Full GC)，部分收集分新生代收集(Minor GC / Young GC)、老年代收集(Major GC / Old GC)和混合收集(Mixed GC)</p>\n<p>垃圾收集算法通常有標記-清除算法、複製算法、標記-整理算法和分代收集算法。</p>\n<p>垃圾收集器中 ParNew 最早採用並行收集，CMS 最早採用並發收集。JDK1.8 中默認使用 Parallel Scavenge(新生代) + Parallel Old(老年代) 收集器，JDK9之後默認使用 G1 收集器。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"內存區域\"><a href=\"#內存區域\" class=\"headerlink\" title=\"內存區域\"></a>內存區域</h2><p>內存區域可以分爲：</p>\n<ol>\n<li>線程共享：堆、方法區（邏輯上屬於堆）、直接內存(非運行時內存)</li>\n<li>線程私有：程序計數器、虛擬機棧和本地方法棧</li>\n</ol>\n<h3 id=\"堆-Heap\"><a href=\"#堆-Heap\" class=\"headerlink\" title=\"堆(Heap)\"></a>堆(Heap)</h3><p>堆是進程中最大的一塊內存，用於存放對象實例，<strong>幾乎所有</strong>的對象實例都在堆中分配。</p>\n<p>JDK 1.7 開始默認開啟了逃逸分析，如果方法中的對象引用沒有逃逸出去（對象沒有 return 或被外面使用），那麼對象可以直接在棧上分配內存，而不是堆。</p>\n<p>一般來說，Java 中的堆根據對象實例的存活時長分爲<strong>新生代、老年代和永久代，以便於更好地回收和分配內存</strong>。</p>\n<p><img src=\"/2021/02/06/it/java/java-jvm/Untitled.png\" alt></p>\n<ul>\n<li>Young Generation(新生代)<ul>\n<li>Eden(伊甸園)：一般情況下，新創建的對象實例默認分配到此區域。</li>\n<li>Survivor(幸存者)：包含 from 和 to 兩個區，Survivor區的對象實例來自 Eden和另一個 Survivor區，默認情況下對象<strong>至多</strong>在新生代中來回複製<strong>15次</strong>(可通過參數<code>-XX:MaxTenuringThreshold</code>設置)後才會進入 Old Generation。</li>\n</ul>\n</li>\n<li>Old Generation(老年代)</li>\n<li>Permanent Generation(永久代)：在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；JDK1.7 時字符串常量池從方法區(HotSpot永久代)移到了堆中；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</li>\n</ul>\n<h3 id=\"方法區-Method-Area\"><a href=\"#方法區-Method-Area\" class=\"headerlink\" title=\"方法區(Method Area)\"></a>方法區(Method Area)</h3><p>根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放已被虛擬機加載的類信息、常量、靜態變量、即時編譯器編譯後的代碼等數據的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(text segmemt/code segment)，通常只讀。</p>\n<p>在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</p>\n<p>UNIX 中的進程將內存劃分成三個部分：</p>\n<ol>\n<li>text segment,文本區，例如代碼</li>\n<li>data segment，數據區，例如變量</li>\n<li>stack segment，棧區域</li>\n</ol>\n<h3 id=\"直接內存-Direct-Memory\"><a href=\"#直接內存-Direct-Memory\" class=\"headerlink\" title=\"直接內存(Direct Memory)\"></a>直接內存(Direct Memory)</h3><p>直接內存不是JVM 規範中定義的內存區域，不受Java堆的限制。</p>\n<ol>\n<li>JDK1.4 加入的 NIO，引入一種基於通道(Channel)和緩存區(Buffer)的 I/O 方式，可以直接使用 native 函數分配堆外內存。</li>\n<li>JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</li>\n</ol>\n<h3 id=\"程序計數器-Program-Counter\"><a href=\"#程序計數器-Program-Counter\" class=\"headerlink\" title=\"程序計數器(Program Counter)\"></a>程序計數器(Program Counter)</h3><p>程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。</p>\n<p>因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。</p>\n<h3 id=\"棧-Stack\"><a href=\"#棧-Stack\" class=\"headerlink\" title=\"棧(Stack)\"></a>棧(Stack)</h3><p>棧有兩種：</p>\n<ol>\n<li><p><strong>虛擬機棧</strong>：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態連接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。</p>\n<p> 所謂操作數棧就是一個供常量或變量寫入寫出的棧，出棧的方向可以是局部變量表或者直接返回給調用者。<br> 所謂動態連接就是在運行時將方法的符號引用轉爲直接引用的過程。</p>\n</li>\n<li><p><strong>本地方法棧</strong>：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。</p>\n</li>\n</ol>\n<p>爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。</p>\n<h2 id=\"類的加載\"><a href=\"#類的加載\" class=\"headerlink\" title=\"類的加載\"></a>類的加載</h2><h3 id=\"類的生命週期\"><a href=\"#類的生命週期\" class=\"headerlink\" title=\"類的生命週期\"></a>類的生命週期</h3><p><img src=\"/2021/02/06/it/java/java-jvm/Untitled%201.png\" alt></p>\n<p><strong>（1）加載</strong></p>\n<ol>\n<li>將 .class 文件轉爲<strong>二進制字節流</strong>裝載進<strong>類加載器</strong>(ClassLoader)；</li>\n<li>將其中代表的<strong>靜態</strong>存儲結構轉換爲<strong>方法區</strong>中的<strong>運行時數據結構</strong>；</li>\n<li>在<strong>內存</strong>中生成一個 <strong>Class 對象</strong>，作爲方法區中數據的訪問入口。</li>\n</ol>\n<p><strong>（2）連接</strong></p>\n<p>連接階段分爲驗證、準備和解析三個步驟。該階段和加載階段不是順序執行的，存在交叉，即加載未完成時連接就開始了。</p>\n<ol>\n<li>驗證：進行文件格式驗證、元數據驗證、字節碼驗證和符號引用驗證。</li>\n<li>準備：爲<strong>類變量</strong>（靜態變量）分配內存並設置初始值（默認的零值，除非有 final 字段才會設置爲最終的初始值）。</li>\n<li>解析：將常量池內的符號引用替換爲直接引用。</li>\n</ol>\n<p><strong>符號引用</strong>：描述目標的一組符號（字面量），包括類、接口、字段、類方法、接口方法、方法類型、方法句柄和調用限定符。<br><strong>直接引用</strong>：直接指向目標的指針、相對偏移量或一個間接定位到目標的句柄。</p>\n<p><strong>（3）初始化</strong></p>\n<p>初始化階段是執行初始化方法 <code>&lt;clinit&gt;</code> 方法的過程。初始化的時機有：</p>\n<ol>\n<li>直接 new 一個類會觸發類的初始化。</li>\n<li>對類進行反射調用會自動初始化。</li>\n<li>父類會在子類初始化時自動初始化。</li>\n<li>主類（包含main方法）會隨虛擬機啟動自動初始化。</li>\n<li>Java 8 中的默認接口方法會在其實現類初始化時自動初始化。</li>\n<li>…</li>\n</ol>\n<p><strong>（4）卸載</strong></p>\n<p>卸載就是該類的 Class 對象被 GC（垃圾回收）。卸載類需要滿足：</p>\n<ol>\n<li>該類的所有實例對象都被 GC。</li>\n<li>該類 Class 對象沒有其他任何地方被引用。</li>\n<li>該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。</li>\n</ol>\n<h3 id=\"類加載器-ClassLoader\"><a href=\"#類加載器-ClassLoader\" class=\"headerlink\" title=\"類加載器(ClassLoader)\"></a>類加載器(ClassLoader)</h3><p>自帶的類加載器有以下三種，分別加載不同路徑下的類：</p>\n<ol>\n<li><strong>BootstrapClassLoader(啟動類加載器)</strong>：最頂層的加載類，負責加載 <code>%JAVA_HOME%/lib</code>目錄下的類或者或被 <code>-Xbootclasspath</code>參數指定的路徑中的所有類。</li>\n<li><strong>ExtensionClassLoader(擴展類加載器)</strong>：繼承自<code>java.lang.ClassLoader</code>，負責加載 <code>%JRE_HOME%/lib/ext</code> 目錄下的類，或系統變量 <code>java.ext.dirs</code> 所指定的路徑下的類。</li>\n<li><strong>AppClassLoader(應用程序類加載器)</strong>：繼承自<code>java.lang.ClassLoader</code>，記載當前應用 classpath 下的類。</li>\n</ol>\n<p>JVM 採用<strong>雙親委派模型(parent-delegation model)</strong>協調類加載器加載類。所謂雙親委派模型就是當一個類要加載時會委託其父類加載器進行加載，如果父類加載器已經加載過會直接返回；如果一直沒有父類加載器處理，會最終委託到頂層類加載器 <strong>BootstrapClassLoader</strong>；當所有<strong>父系類加載器</strong>都無法處理時才會自行加載。</p>\n<p>爲何要這樣麻煩，不一開始就自己加載類呢？<strong>避免類被重複加載，避免 Java 核心類被修改</strong>。注意：同一個類文件被不同的類加載器加載之後會生成不同的類。</p>\n<h2 id=\"對象的創建\"><a href=\"#對象的創建\" class=\"headerlink\" title=\"對象的創建\"></a>對象的創建</h2><h3 id=\"對象的創建過程\"><a href=\"#對象的創建過程\" class=\"headerlink\" title=\"對象的創建過程\"></a>對象的創建過程</h3><p><img src=\"/2021/02/06/it/java/java-jvm/Untitled%202.png\" alt></p>\n<p>在 HotSpot 虛擬機中，一個 Java 對象的創建經歷以下幾個步驟：</p>\n<ol>\n<li><strong>類加載檢查</strong>。請看「類的加載」部分。</li>\n<li><strong>分配內存</strong>。在堆中分配一塊內存空間供對象使用。有兩種分配方式：<ul>\n<li>指針碰撞：當內存規整時，使用和未使用的內存中間會有一個分界指針，只要指針朝未使用內存方法移動即可分配內存。</li>\n<li>空閒列表：當內存不規整時，虛擬機會維護一個內存的可用列表，分配時會確定一塊大小合適的內存並更新可用列表。</li>\n</ul>\n</li>\n<li><strong>初始化零值</strong>。保證對象實例字段可以不用賦予初始值就可以使用。</li>\n<li><strong>設置對象頭</strong>。對象的元數據，包括所屬的類、對象哈希碼、GC分代年齡以及鎖信息。</li>\n<li><strong>執行 <code>&lt;init&gt;</code> 方法</strong>。代碼視角的對象初始化。</li>\n</ol>\n<p>比較<code>&lt;clinit&gt;</code> 和 <code>&lt;init&gt;</code>方法：</p>\n<ol>\n<li><code>&lt;clinit&gt;</code> 方法：class init 類構造器，按順序執行父類靜態變量初始化、父類靜態語句塊、子類靜態變量初始化、子類靜態語句塊。</li>\n<li><code>&lt;init&gt;</code> 方法：實例構造器，按順序執行父類變量初始化、父類語句塊、父類構造函數、子類變量初始化、子類語句塊、子類構造函數。</li>\n</ol>\n<h3 id=\"對象的內存佈局\"><a href=\"#對象的內存佈局\" class=\"headerlink\" title=\"對象的內存佈局\"></a>對象的內存佈局</h3><p>在 Hotspot 虛擬機中，Java對象在內存中由以下部分組成：</p>\n<ol>\n<li>對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。</li>\n<li>實例數據（instance data）：對象的有效信息。</li>\n<li>對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。</li>\n</ol>\n<h3 id=\"對象的訪問\"><a href=\"#對象的訪問\" class=\"headerlink\" title=\"對象的訪問\"></a>對象的訪問</h3><p>Java 程序通過棧上的 reference 類型數據來操作訪問堆上的實例對象。具體來說有以下兩種實現方式：</p>\n<ol>\n<li><p>句柄(handle)：操作對象的中間媒介，通過句柄獲取具體對象實例的指針，進而從實例池中獲取想要訪問的對象。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%203.png\" alt></p>\n</li>\n<li><p>直接指針(direct pointer)：reference 存儲對象地址，直接指向對象實例。HotSpot 虛擬機採用這種方式訪問對象，相對與句柄的方式，節約了一次定位對象的時間。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%204.png\" alt></p>\n</li>\n</ol>\n<h2 id=\"內存管理\"><a href=\"#內存管理\" class=\"headerlink\" title=\"內存管理\"></a>內存管理</h2><p>Java 是自動進行內存管理的，不同於 C/C++ 需要手動進行內存分配和回收。</p>\n<h3 id=\"內存分配\"><a href=\"#內存分配\" class=\"headerlink\" title=\"內存分配\"></a>內存分配</h3><ol>\n<li>對象優先在新生代 Eden 區分配。</li>\n<li>大對象直接進入老年代。<br>避免大對象<strong>分配擔保機制</strong>帶來的複製而降低效率。<br>分配擔保機制：當進行 Minor GC 時，如果 Survivor 區空間不夠用，會直接將新生代的對象提前轉移到老年代中。</li>\n<li>長期存活的對象將進入老年代。<br>每個對象都有一個對象年齡計數器，超齡的對象一般會進入老年代。</li>\n<li>根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。</li>\n</ol>\n<h3 id=\"垃圾判定\"><a href=\"#垃圾判定\" class=\"headerlink\" title=\"垃圾判定\"></a>垃圾判定</h3><ol>\n<li><p>引用計數法<br>給對象添加一個引用計數器，當有一個地方引用了該對象，計數器就加 1，引用失效則減 1。若計數爲 0 則判定該對象是垃圾。這種算法有個大缺陷就是無法解決循環引用問題：當對象 A 和對象B除了互相引用外別無引用時，A 和B的計數都不爲0不會判定爲垃圾，但顯然 A、B是垃圾啊。</p>\n</li>\n<li><p>可達性分析算法<br>以根集合 GC Roots 爲起點向下搜索形成引用鏈，當一個對象到 GC Roots沒有引用鏈時判定其爲垃圾。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%205.png\" alt></p>\n<p> 可作爲 GC Roots 的對象有:</p>\n<ul>\n<li>虛擬機棧(棧幀中的本地變量表)中引用的對象</li>\n<li>本地方法棧(Native 方法)中引用的對象</li>\n<li>方法區中類靜態屬性引用的對象</li>\n<li>方法區中常量引用的對象</li>\n</ul>\n</li>\n<li><p>廢棄常量的判定<br>沒有對象引用的常量就是廢棄常量。</p>\n</li>\n<li><p>廢棄類的判定</p>\n<p> 廢棄類需要滿足：</p>\n<ul>\n<li>該類的所有實例對象都被 GC。</li>\n<li>該類 Class 對象沒有其他任何地方被引用。</li>\n<li>該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><p>垃圾收集(Garbage Collection, GC)，指對判定爲垃圾的內存區域進行收集的過程。針對 HotSpot VM，GC 可分爲：</p>\n<ol>\n<li>部分收集 (Partial GC)：<ul>\n<li>新生代收集（Minor GC / Young GC）：只對新生代進行垃圾收集，Eden 區和 From 區的數據會進入 To 區，然後 From 和To會互換角色。</li>\n<li>老年代收集（Major GC / Old GC）：只對老年代進行垃圾收集。需要注意的是 Major GC 在有的語境中也用於指代整堆收集。</li>\n<li>混合收集（Mixed GC）：對整個新生代和部分老年代進行垃圾收集。</li>\n</ul>\n</li>\n<li>整堆收集 (Full GC)：收集整個 Java 堆和方法區。</li>\n</ol>\n<p>常見的垃圾收集算法有：</p>\n<ol>\n<li><p>標記-清除算法<br>分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一清除垃圾。缺點是造成內存碎片化。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%206.png\" alt></p>\n</li>\n<li><p>複製算法<br>將內存分爲大小相同的兩塊，每次只使用其中的一塊。當一塊使用完後，將存活的對象複製到另一塊去，再把使用完的空間一次清理掉，避免了標記-清除算法的內存碎片化問題。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%207.png\" alt></p>\n</li>\n<li><p>標記-整理算法(Mark-Compact)<br>分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一將存活對象向一端移動，然後清理掉端邊界之外的內存。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%208.png\" alt></p>\n</li>\n<li><p>分代收集算法<br>便於根據各個年代的特點選擇合適的垃圾收集算法：</p>\n</li>\n</ol>\n<ul>\n<li>新生代(From Survivor 和 To Survivor)：複製算法</li>\n<li>老年代：標記-清除 或 標記-整理算法</li>\n</ul>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><ol>\n<li><p>新生代收集器</p>\n<ol>\n<li>Serial<br>單線程，採用複製算法，串行，收集垃圾時會暫停其他所有的工作線程。</li>\n<li>ParNew (Parallel New)<br>Serial 的多線程版本，採用複製算法，<strong>並行—多條垃圾收集線程並行工作，仍然會暫停其他所有的工作線程(Stop the World)</strong>。</li>\n<li>Parallel Scavenge<br>直譯過來就是「並行清理垃圾」，也採用複製算法，這是 JDK1.8 默認的收集器。該算法關注<strong>吞吐量，即CPU中運行用戶代碼的時間與總消耗時間的比值</strong>。</li>\n</ol>\n</li>\n<li><p>老年代收集器</p>\n<ol>\n<li>Serial Old<br>Serial 的老年代版本，採用標記-整理算法。CMS 的後備方案。</li>\n<li>Parallel Old<br>Parallel Scavenge 的老年代版本，採用標記-整理算法。</li>\n<li>CMS (Concurrent Mark Sweep)<br>直譯過來就是「並發標記清除」，HotSpot 虛擬機第一款真正意義上的並發收集器，JDK1.5時發佈，採用標記-清除算法，<strong>並發—用戶線程與垃圾收集線程同時執行（但不一定是並行的，可能會交替執行），用戶程序在繼續運行</strong>。該算法關注<strong>用戶線程的停頓時間</strong>，綽號<strong>并发低停顿收集器</strong>（Concurrent Low Pause Collector）。缺點有三：<ul>\n<li>對 ****CPU 資源敏感；</li>\n<li>無法處理浮動垃圾；</li>\n<li>使用的「標記-清除」算法會導致內存碎片化。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>G1 (Garbage-First)</p>\n<p> 面向服務端應用的垃圾收集器，JDK1.7時發佈。特點是：並發與並行、分代收集、空間整合(標記-整理)和可預測的停頓。G1 收集器在後台維護了一個優先列表，每次根據允許的收集時間，優先選擇回收價值最大的區域。</p>\n</li>\n<li><p>ZGC (The Z Garbage Collector)</p>\n<p> JDK 11時發佈，適用於大內存低延遲服務的內存管理和回收。</p>\n</li>\n</ol>\n<p>使用以下命令可以查看JDK使用的垃圾收集器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">java -XX:+PrintGCDetails</span><br><span class=\"line\">java -Xlog:gc <span class=\"comment\"># 較新版本可用</span></span><br></pre></td></tr></table></figure>\n\n<p>不同 JDK 版本默認使用的垃圾收集器：</p>\n<ul>\n<li><p>1.8，Parallel Scavenge(新生代) + Parallel Old(老年代)</p>\n<p>  注意：PS 是「Parallel Scavenge」的簡寫，ParOld 是「Parallel Old」的簡寫。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br><span class=\"line\">java version <span class=\"string\">&quot;1.8.0_191&quot;</span></span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 1.8.0_191-b12)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">-XX:InitialHeapSize=266390080 -XX:MaxHeapSize=4262241280 -XX:+PrintCommandLineFlags </span><br><span class=\"line\">-XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class=\"line\">-XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintGCDetails -version</span><br><span class=\"line\">Heap</span><br><span class=\"line\"> \tPSYoungGen      total 76288K, used 2621K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)</span><br><span class=\"line\">  \t\t\t\t\teden space 65536K, 4% used [0x000000076b500000,0x000000076b78f748,0x000000076f500000)</span><br><span class=\"line\">  \t\t\t\t\tfrom space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)</span><br><span class=\"line\">  \t\t\t\t\tto   space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)</span><br><span class=\"line\">  ParOldGen       total 175104K, used 0K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)</span><br><span class=\"line\">  \t\t\t\t\tobject space 175104K, 0% used [0x00000006c1e00000,0x00000006c1e00000,0x00000006cc900000)</span><br><span class=\"line\"> \tMetaspace       used 2291K, capacity 4480K, committed 4480K, reserved 1056768K</span><br><span class=\"line\">  \t\t\t\t\tclass space    used 254K, capacity 384K, committed 384K, reserved 1048576K</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>9、11、15，G1</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br><span class=\"line\">java version <span class=\"string\">&quot;15.0.1&quot;</span> 2020-10-20</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 15.0.1+9-18)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18, mixed mode, sharing)</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">-XX:ConcGCThreads=1 -XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -Xlog:gc</span><br><span class=\"line\">[0.006s][info][gc] Using G1</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>JVM(Java Virtual Machine)，即 Java 虛擬機，是操作系統上的一個程序，用於編譯、運行Java程序，使得 Java程序可以跨平台。關於 JVM 我們著重在內存區域、類的加載、對象的創建和內存管理四個部分。</p>\n<p>內存區域分爲堆、方法區、程序計數器、虛擬機棧和本地方法棧。其中堆和方法區是線程共享的，程序計數器、虛擬機棧和本地方法棧則是線程私有的。堆是一大塊內存，幾乎所有的對象實例都在這裡分配；方法區在JVM 規範中是堆的一部分，不同的 JVM 可以有不同的實現，就 HotSpot VM 而言，在 JDK1.8 之前使用永久代實現方法區，在JDK1.8及之後使用直接內存上的元空間實現；程序計數器存放下一條指令的地址；虛擬機棧的每一個棧幀保存著方法的局部變量表、操作數棧、動態連接和方法返回地址；本地方法棧類似虛擬機棧，不過是調用 native 方法，在 HotSpot VM中虛擬機棧和本地方法棧合而爲一。</p>\n<p>類的生命週期分爲加載、連接、初始化、使用和卸載四個過程，其中：</p>\n<ol>\n<li>加載：將 .class 文件以二進制字節流方式讀入虛擬機，並在方法區給靜態變量分配空間，在堆中生成 Class 對象作爲訪問靜態變量的入口。</li>\n<li>連接：分爲驗證、準備和解析三個階段，驗證階段驗證字節碼文件的合規性，準備階段將類變量賦予初始零值，解析階段將常量池中的符號引用轉爲直接引用。</li>\n<li>初始化：執行 <code>&lt;clinit&gt;</code> 方法。</li>\n</ol>\n<p>對象的創建過程依次是類加載檢查、分配內存、初始化零值、設置對象頭和執行<code>&lt;init&gt;</code> 方法。</p>\n<ol>\n<li>類加載檢查：檢查類是否加載完畢。</li>\n<li>分配內存：對象實例一般會分配在堆中，根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。JDK1.7之後啟用逃逸分析可以將未逃逸的對象分配到棧中。</li>\n<li>初始化零值：給對象的成員變量設置初始的零值。</li>\n<li>設置對象頭：對象頭包括所屬的類、對象哈希碼、GC分代年齡和鎖信息。</li>\n<li>執行 <code>&lt;init&gt;</code> 方法。</li>\n</ol>\n<p>Java 是自動內存管理的，內存的分配和回收由JVM進行控制。通常使用分代內存管理，分新生代、老年代和永久代(JDK1.8及之後無永久代)，新對象優先在新生代 Eden 區分配，大對象直接分配到老年代，持續存活的對象也會被轉移到老年代。</p>\n<p>內存回收涉及垃圾的判定、垃圾收集算法和垃圾收集器。</p>\n<p>判定垃圾通常有引用計數法和可達性分析算法。</p>\n<p>垃圾收集(GC)通常分部分收集(Partial GC)和整堆收集(Full GC)，部分收集分新生代收集(Minor GC / Young GC)、老年代收集(Major GC / Old GC)和混合收集(Mixed GC)</p>\n<p>垃圾收集算法通常有標記-清除算法、複製算法、標記-整理算法和分代收集算法。</p>\n<p>垃圾收集器中 ParNew 最早採用並行收集，CMS 最早採用並發收集。JDK1.8 中默認使用 Parallel Scavenge(新生代) + Parallel Old(老年代) 收集器，JDK9之後默認使用 G1 收集器。</p>","more":"<h2 id=\"內存區域\"><a href=\"#內存區域\" class=\"headerlink\" title=\"內存區域\"></a>內存區域</h2><p>內存區域可以分爲：</p>\n<ol>\n<li>線程共享：堆、方法區（邏輯上屬於堆）、直接內存(非運行時內存)</li>\n<li>線程私有：程序計數器、虛擬機棧和本地方法棧</li>\n</ol>\n<h3 id=\"堆-Heap\"><a href=\"#堆-Heap\" class=\"headerlink\" title=\"堆(Heap)\"></a>堆(Heap)</h3><p>堆是進程中最大的一塊內存，用於存放對象實例，<strong>幾乎所有</strong>的對象實例都在堆中分配。</p>\n<p>JDK 1.7 開始默認開啟了逃逸分析，如果方法中的對象引用沒有逃逸出去（對象沒有 return 或被外面使用），那麼對象可以直接在棧上分配內存，而不是堆。</p>\n<p>一般來說，Java 中的堆根據對象實例的存活時長分爲<strong>新生代、老年代和永久代，以便於更好地回收和分配內存</strong>。</p>\n<p><img src=\"/2021/02/06/it/java/java-jvm/Untitled.png\" alt></p>\n<ul>\n<li>Young Generation(新生代)<ul>\n<li>Eden(伊甸園)：一般情況下，新創建的對象實例默認分配到此區域。</li>\n<li>Survivor(幸存者)：包含 from 和 to 兩個區，Survivor區的對象實例來自 Eden和另一個 Survivor區，默認情況下對象<strong>至多</strong>在新生代中來回複製<strong>15次</strong>(可通過參數<code>-XX:MaxTenuringThreshold</code>設置)後才會進入 Old Generation。</li>\n</ul>\n</li>\n<li>Old Generation(老年代)</li>\n<li>Permanent Generation(永久代)：在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；JDK1.7 時字符串常量池從方法區(HotSpot永久代)移到了堆中；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</li>\n</ul>\n<h3 id=\"方法區-Method-Area\"><a href=\"#方法區-Method-Area\" class=\"headerlink\" title=\"方法區(Method Area)\"></a>方法區(Method Area)</h3><p>根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放已被虛擬機加載的類信息、常量、靜態變量、即時編譯器編譯後的代碼等數據的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(text segmemt/code segment)，通常只讀。</p>\n<p>在 JDK1.8之前，HotSpot 虛擬機中使用永久代實現JVM規範中的方法區；在 JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</p>\n<p>UNIX 中的進程將內存劃分成三個部分：</p>\n<ol>\n<li>text segment,文本區，例如代碼</li>\n<li>data segment，數據區，例如變量</li>\n<li>stack segment，棧區域</li>\n</ol>\n<h3 id=\"直接內存-Direct-Memory\"><a href=\"#直接內存-Direct-Memory\" class=\"headerlink\" title=\"直接內存(Direct Memory)\"></a>直接內存(Direct Memory)</h3><p>直接內存不是JVM 規範中定義的內存區域，不受Java堆的限制。</p>\n<ol>\n<li>JDK1.4 加入的 NIO，引入一種基於通道(Channel)和緩存區(Buffer)的 I/O 方式，可以直接使用 native 函數分配堆外內存。</li>\n<li>JDK1.8時永久代被移除，採用元空間(Metaspace)在直接內存中實現了JVM規範中的方法區。</li>\n</ol>\n<h3 id=\"程序計數器-Program-Counter\"><a href=\"#程序計數器-Program-Counter\" class=\"headerlink\" title=\"程序計數器(Program Counter)\"></a>程序計數器(Program Counter)</h3><p>程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。</p>\n<p>因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。</p>\n<h3 id=\"棧-Stack\"><a href=\"#棧-Stack\" class=\"headerlink\" title=\"棧(Stack)\"></a>棧(Stack)</h3><p>棧有兩種：</p>\n<ol>\n<li><p><strong>虛擬機棧</strong>：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態連接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。</p>\n<p> 所謂操作數棧就是一個供常量或變量寫入寫出的棧，出棧的方向可以是局部變量表或者直接返回給調用者。<br> 所謂動態連接就是在運行時將方法的符號引用轉爲直接引用的過程。</p>\n</li>\n<li><p><strong>本地方法棧</strong>：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。</p>\n</li>\n</ol>\n<p>爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。</p>\n<h2 id=\"類的加載\"><a href=\"#類的加載\" class=\"headerlink\" title=\"類的加載\"></a>類的加載</h2><h3 id=\"類的生命週期\"><a href=\"#類的生命週期\" class=\"headerlink\" title=\"類的生命週期\"></a>類的生命週期</h3><p><img src=\"/2021/02/06/it/java/java-jvm/Untitled%201.png\" alt></p>\n<p><strong>（1）加載</strong></p>\n<ol>\n<li>將 .class 文件轉爲<strong>二進制字節流</strong>裝載進<strong>類加載器</strong>(ClassLoader)；</li>\n<li>將其中代表的<strong>靜態</strong>存儲結構轉換爲<strong>方法區</strong>中的<strong>運行時數據結構</strong>；</li>\n<li>在<strong>內存</strong>中生成一個 <strong>Class 對象</strong>，作爲方法區中數據的訪問入口。</li>\n</ol>\n<p><strong>（2）連接</strong></p>\n<p>連接階段分爲驗證、準備和解析三個步驟。該階段和加載階段不是順序執行的，存在交叉，即加載未完成時連接就開始了。</p>\n<ol>\n<li>驗證：進行文件格式驗證、元數據驗證、字節碼驗證和符號引用驗證。</li>\n<li>準備：爲<strong>類變量</strong>（靜態變量）分配內存並設置初始值（默認的零值，除非有 final 字段才會設置爲最終的初始值）。</li>\n<li>解析：將常量池內的符號引用替換爲直接引用。</li>\n</ol>\n<p><strong>符號引用</strong>：描述目標的一組符號（字面量），包括類、接口、字段、類方法、接口方法、方法類型、方法句柄和調用限定符。<br><strong>直接引用</strong>：直接指向目標的指針、相對偏移量或一個間接定位到目標的句柄。</p>\n<p><strong>（3）初始化</strong></p>\n<p>初始化階段是執行初始化方法 <code>&lt;clinit&gt;</code> 方法的過程。初始化的時機有：</p>\n<ol>\n<li>直接 new 一個類會觸發類的初始化。</li>\n<li>對類進行反射調用會自動初始化。</li>\n<li>父類會在子類初始化時自動初始化。</li>\n<li>主類（包含main方法）會隨虛擬機啟動自動初始化。</li>\n<li>Java 8 中的默認接口方法會在其實現類初始化時自動初始化。</li>\n<li>…</li>\n</ol>\n<p><strong>（4）卸載</strong></p>\n<p>卸載就是該類的 Class 對象被 GC（垃圾回收）。卸載類需要滿足：</p>\n<ol>\n<li>該類的所有實例對象都被 GC。</li>\n<li>該類 Class 對象沒有其他任何地方被引用。</li>\n<li>該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。</li>\n</ol>\n<h3 id=\"類加載器-ClassLoader\"><a href=\"#類加載器-ClassLoader\" class=\"headerlink\" title=\"類加載器(ClassLoader)\"></a>類加載器(ClassLoader)</h3><p>自帶的類加載器有以下三種，分別加載不同路徑下的類：</p>\n<ol>\n<li><strong>BootstrapClassLoader(啟動類加載器)</strong>：最頂層的加載類，負責加載 <code>%JAVA_HOME%/lib</code>目錄下的類或者或被 <code>-Xbootclasspath</code>參數指定的路徑中的所有類。</li>\n<li><strong>ExtensionClassLoader(擴展類加載器)</strong>：繼承自<code>java.lang.ClassLoader</code>，負責加載 <code>%JRE_HOME%/lib/ext</code> 目錄下的類，或系統變量 <code>java.ext.dirs</code> 所指定的路徑下的類。</li>\n<li><strong>AppClassLoader(應用程序類加載器)</strong>：繼承自<code>java.lang.ClassLoader</code>，記載當前應用 classpath 下的類。</li>\n</ol>\n<p>JVM 採用<strong>雙親委派模型(parent-delegation model)</strong>協調類加載器加載類。所謂雙親委派模型就是當一個類要加載時會委託其父類加載器進行加載，如果父類加載器已經加載過會直接返回；如果一直沒有父類加載器處理，會最終委託到頂層類加載器 <strong>BootstrapClassLoader</strong>；當所有<strong>父系類加載器</strong>都無法處理時才會自行加載。</p>\n<p>爲何要這樣麻煩，不一開始就自己加載類呢？<strong>避免類被重複加載，避免 Java 核心類被修改</strong>。注意：同一個類文件被不同的類加載器加載之後會生成不同的類。</p>\n<h2 id=\"對象的創建\"><a href=\"#對象的創建\" class=\"headerlink\" title=\"對象的創建\"></a>對象的創建</h2><h3 id=\"對象的創建過程\"><a href=\"#對象的創建過程\" class=\"headerlink\" title=\"對象的創建過程\"></a>對象的創建過程</h3><p><img src=\"/2021/02/06/it/java/java-jvm/Untitled%202.png\" alt></p>\n<p>在 HotSpot 虛擬機中，一個 Java 對象的創建經歷以下幾個步驟：</p>\n<ol>\n<li><strong>類加載檢查</strong>。請看「類的加載」部分。</li>\n<li><strong>分配內存</strong>。在堆中分配一塊內存空間供對象使用。有兩種分配方式：<ul>\n<li>指針碰撞：當內存規整時，使用和未使用的內存中間會有一個分界指針，只要指針朝未使用內存方法移動即可分配內存。</li>\n<li>空閒列表：當內存不規整時，虛擬機會維護一個內存的可用列表，分配時會確定一塊大小合適的內存並更新可用列表。</li>\n</ul>\n</li>\n<li><strong>初始化零值</strong>。保證對象實例字段可以不用賦予初始值就可以使用。</li>\n<li><strong>設置對象頭</strong>。對象的元數據，包括所屬的類、對象哈希碼、GC分代年齡以及鎖信息。</li>\n<li><strong>執行 <code>&lt;init&gt;</code> 方法</strong>。代碼視角的對象初始化。</li>\n</ol>\n<p>比較<code>&lt;clinit&gt;</code> 和 <code>&lt;init&gt;</code>方法：</p>\n<ol>\n<li><code>&lt;clinit&gt;</code> 方法：class init 類構造器，按順序執行父類靜態變量初始化、父類靜態語句塊、子類靜態變量初始化、子類靜態語句塊。</li>\n<li><code>&lt;init&gt;</code> 方法：實例構造器，按順序執行父類變量初始化、父類語句塊、父類構造函數、子類變量初始化、子類語句塊、子類構造函數。</li>\n</ol>\n<h3 id=\"對象的內存佈局\"><a href=\"#對象的內存佈局\" class=\"headerlink\" title=\"對象的內存佈局\"></a>對象的內存佈局</h3><p>在 Hotspot 虛擬機中，Java對象在內存中由以下部分組成：</p>\n<ol>\n<li>對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。</li>\n<li>實例數據（instance data）：對象的有效信息。</li>\n<li>對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。</li>\n</ol>\n<h3 id=\"對象的訪問\"><a href=\"#對象的訪問\" class=\"headerlink\" title=\"對象的訪問\"></a>對象的訪問</h3><p>Java 程序通過棧上的 reference 類型數據來操作訪問堆上的實例對象。具體來說有以下兩種實現方式：</p>\n<ol>\n<li><p>句柄(handle)：操作對象的中間媒介，通過句柄獲取具體對象實例的指針，進而從實例池中獲取想要訪問的對象。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%203.png\" alt></p>\n</li>\n<li><p>直接指針(direct pointer)：reference 存儲對象地址，直接指向對象實例。HotSpot 虛擬機採用這種方式訪問對象，相對與句柄的方式，節約了一次定位對象的時間。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%204.png\" alt></p>\n</li>\n</ol>\n<h2 id=\"內存管理\"><a href=\"#內存管理\" class=\"headerlink\" title=\"內存管理\"></a>內存管理</h2><p>Java 是自動進行內存管理的，不同於 C/C++ 需要手動進行內存分配和回收。</p>\n<h3 id=\"內存分配\"><a href=\"#內存分配\" class=\"headerlink\" title=\"內存分配\"></a>內存分配</h3><ol>\n<li>對象優先在新生代 Eden 區分配。</li>\n<li>大對象直接進入老年代。<br>避免大對象<strong>分配擔保機制</strong>帶來的複製而降低效率。<br>分配擔保機制：當進行 Minor GC 時，如果 Survivor 區空間不夠用，會直接將新生代的對象提前轉移到老年代中。</li>\n<li>長期存活的對象將進入老年代。<br>每個對象都有一個對象年齡計數器，超齡的對象一般會進入老年代。</li>\n<li>根據採用的垃圾回收器會選擇指針碰撞或空閒類表方式分配。</li>\n</ol>\n<h3 id=\"垃圾判定\"><a href=\"#垃圾判定\" class=\"headerlink\" title=\"垃圾判定\"></a>垃圾判定</h3><ol>\n<li><p>引用計數法<br>給對象添加一個引用計數器，當有一個地方引用了該對象，計數器就加 1，引用失效則減 1。若計數爲 0 則判定該對象是垃圾。這種算法有個大缺陷就是無法解決循環引用問題：當對象 A 和對象B除了互相引用外別無引用時，A 和B的計數都不爲0不會判定爲垃圾，但顯然 A、B是垃圾啊。</p>\n</li>\n<li><p>可達性分析算法<br>以根集合 GC Roots 爲起點向下搜索形成引用鏈，當一個對象到 GC Roots沒有引用鏈時判定其爲垃圾。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%205.png\" alt></p>\n<p> 可作爲 GC Roots 的對象有:</p>\n<ul>\n<li>虛擬機棧(棧幀中的本地變量表)中引用的對象</li>\n<li>本地方法棧(Native 方法)中引用的對象</li>\n<li>方法區中類靜態屬性引用的對象</li>\n<li>方法區中常量引用的對象</li>\n</ul>\n</li>\n<li><p>廢棄常量的判定<br>沒有對象引用的常量就是廢棄常量。</p>\n</li>\n<li><p>廢棄類的判定</p>\n<p> 廢棄類需要滿足：</p>\n<ul>\n<li>該類的所有實例對象都被 GC。</li>\n<li>該類 Class 對象沒有其他任何地方被引用。</li>\n<li>該類的類加載器的實例被 GC（自帶的類加載器在JVM生命週期中不會被卸載，因此由之加載的類也不會被卸載，除非是自定義的類加載器，由之加載的類才有可能被卸載）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><p>垃圾收集(Garbage Collection, GC)，指對判定爲垃圾的內存區域進行收集的過程。針對 HotSpot VM，GC 可分爲：</p>\n<ol>\n<li>部分收集 (Partial GC)：<ul>\n<li>新生代收集（Minor GC / Young GC）：只對新生代進行垃圾收集，Eden 區和 From 區的數據會進入 To 區，然後 From 和To會互換角色。</li>\n<li>老年代收集（Major GC / Old GC）：只對老年代進行垃圾收集。需要注意的是 Major GC 在有的語境中也用於指代整堆收集。</li>\n<li>混合收集（Mixed GC）：對整個新生代和部分老年代進行垃圾收集。</li>\n</ul>\n</li>\n<li>整堆收集 (Full GC)：收集整個 Java 堆和方法區。</li>\n</ol>\n<p>常見的垃圾收集算法有：</p>\n<ol>\n<li><p>標記-清除算法<br>分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一清除垃圾。缺點是造成內存碎片化。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%206.png\" alt></p>\n</li>\n<li><p>複製算法<br>將內存分爲大小相同的兩塊，每次只使用其中的一塊。當一塊使用完後，將存活的對象複製到另一塊去，再把使用完的空間一次清理掉，避免了標記-清除算法的內存碎片化問題。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%207.png\" alt></p>\n</li>\n<li><p>標記-整理算法(Mark-Compact)<br>分兩個階段進行，第一個階段標記要回收的垃圾；第二個階段統一將存活對象向一端移動，然後清理掉端邊界之外的內存。</p>\n<p> <img src=\"/2021/02/06/it/java/java-jvm/Untitled%208.png\" alt></p>\n</li>\n<li><p>分代收集算法<br>便於根據各個年代的特點選擇合適的垃圾收集算法：</p>\n</li>\n</ol>\n<ul>\n<li>新生代(From Survivor 和 To Survivor)：複製算法</li>\n<li>老年代：標記-清除 或 標記-整理算法</li>\n</ul>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><ol>\n<li><p>新生代收集器</p>\n<ol>\n<li>Serial<br>單線程，採用複製算法，串行，收集垃圾時會暫停其他所有的工作線程。</li>\n<li>ParNew (Parallel New)<br>Serial 的多線程版本，採用複製算法，<strong>並行—多條垃圾收集線程並行工作，仍然會暫停其他所有的工作線程(Stop the World)</strong>。</li>\n<li>Parallel Scavenge<br>直譯過來就是「並行清理垃圾」，也採用複製算法，這是 JDK1.8 默認的收集器。該算法關注<strong>吞吐量，即CPU中運行用戶代碼的時間與總消耗時間的比值</strong>。</li>\n</ol>\n</li>\n<li><p>老年代收集器</p>\n<ol>\n<li>Serial Old<br>Serial 的老年代版本，採用標記-整理算法。CMS 的後備方案。</li>\n<li>Parallel Old<br>Parallel Scavenge 的老年代版本，採用標記-整理算法。</li>\n<li>CMS (Concurrent Mark Sweep)<br>直譯過來就是「並發標記清除」，HotSpot 虛擬機第一款真正意義上的並發收集器，JDK1.5時發佈，採用標記-清除算法，<strong>並發—用戶線程與垃圾收集線程同時執行（但不一定是並行的，可能會交替執行），用戶程序在繼續運行</strong>。該算法關注<strong>用戶線程的停頓時間</strong>，綽號<strong>并发低停顿收集器</strong>（Concurrent Low Pause Collector）。缺點有三：<ul>\n<li>對 ****CPU 資源敏感；</li>\n<li>無法處理浮動垃圾；</li>\n<li>使用的「標記-清除」算法會導致內存碎片化。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>G1 (Garbage-First)</p>\n<p> 面向服務端應用的垃圾收集器，JDK1.7時發佈。特點是：並發與並行、分代收集、空間整合(標記-整理)和可預測的停頓。G1 收集器在後台維護了一個優先列表，每次根據允許的收集時間，優先選擇回收價值最大的區域。</p>\n</li>\n<li><p>ZGC (The Z Garbage Collector)</p>\n<p> JDK 11時發佈，適用於大內存低延遲服務的內存管理和回收。</p>\n</li>\n</ol>\n<p>使用以下命令可以查看JDK使用的垃圾收集器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">java -XX:+PrintGCDetails</span><br><span class=\"line\">java -Xlog:gc <span class=\"comment\"># 較新版本可用</span></span><br></pre></td></tr></table></figure>\n\n<p>不同 JDK 版本默認使用的垃圾收集器：</p>\n<ul>\n<li><p>1.8，Parallel Scavenge(新生代) + Parallel Old(老年代)</p>\n<p>  注意：PS 是「Parallel Scavenge」的簡寫，ParOld 是「Parallel Old」的簡寫。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br><span class=\"line\">java version <span class=\"string\">&quot;1.8.0_191&quot;</span></span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 1.8.0_191-b12)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">-XX:InitialHeapSize=266390080 -XX:MaxHeapSize=4262241280 -XX:+PrintCommandLineFlags </span><br><span class=\"line\">-XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class=\"line\">-XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintGCDetails -version</span><br><span class=\"line\">Heap</span><br><span class=\"line\"> \tPSYoungGen      total 76288K, used 2621K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)</span><br><span class=\"line\">  \t\t\t\t\teden space 65536K, 4% used [0x000000076b500000,0x000000076b78f748,0x000000076f500000)</span><br><span class=\"line\">  \t\t\t\t\tfrom space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)</span><br><span class=\"line\">  \t\t\t\t\tto   space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)</span><br><span class=\"line\">  ParOldGen       total 175104K, used 0K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)</span><br><span class=\"line\">  \t\t\t\t\tobject space 175104K, 0% used [0x00000006c1e00000,0x00000006c1e00000,0x00000006cc900000)</span><br><span class=\"line\"> \tMetaspace       used 2291K, capacity 4480K, committed 4480K, reserved 1056768K</span><br><span class=\"line\">  \t\t\t\t\tclass space    used 254K, capacity 384K, committed 384K, reserved 1048576K</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>9、11、15，G1</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br><span class=\"line\">java version <span class=\"string\">&quot;15.0.1&quot;</span> 2020-10-20</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 15.0.1+9-18)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 15.0.1+9-18, mixed mode, sharing)</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -XX:+PrintCommandLineFlags</span><br><span class=\"line\">-XX:ConcGCThreads=1 -XX:G1ConcRefinementThreads=4 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MinHeapSize=6815736 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br><span class=\"line\"></span><br><span class=\"line\">$ java -Xlog:gc</span><br><span class=\"line\">[0.006s][info][gc] Using G1</span><br></pre></td></tr></table></figure></li>\n</ul>"},{"title":"Java 基礎","p":"it/java/java-basic.md","_content":"\nJava 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。\n\n- 它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。\n- 它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。\n- 它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。\n- 它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。\n- 它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。\n- 它提供了豐富的集合類、迭代器及工具類。\n- 它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。\n- 它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。\n- 它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。\n- 另外，目前有兩大項目管理工具，Maven 和 Gradle。\n\n<!-- more -->\n\n## Java 入門（基礎概念與常識）\n\n### 歷史\n\nJava 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 `CA FE BA BE` ，即 cafe babe （咖啡寶貝）。\n\n```java\n$ hexdump Test.class\n0000000 ca fe ba be 00 00 00 3b 00 51 0a 00 02 00 03 07\n```\n\n- 1994 年完成 1.0 版本。\n- 1995 年首次對外發佈，Java 語言誕生。\n- 1996 年JDK 1.0 誕生。\n- 2004 年 SUN 公司發佈 Java SE 5。\n- 2005 年 SUN 公司發佈 Java SE 6。\n- 2006 年 SUN 公司推出 OpenJDK 計劃。\n- 2014年 Oracle 公司發佈 Java SE 8。\n- 2017年 Oracle公司發佈 Java SE 9。\n- 2020 年 Oracle 公司發佈 Java SE 15。\n\n### 安裝與卸載JDK\n\n在 Mac 環境下，從 [Oracle JavaSE 下載地址](https://www.oracle.com/tw/java/technologies/javase-downloads.html) 下載並安裝。安裝完成後執行 `java -version`  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 `/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home` 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。\n\n```bash\nsudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin\nsudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane\n\nls /Library/Java/JavaVirtualMachines/\n输出：jdk-9.0.1.jdk\n\nsudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk\n```\n\n### Hello World\n\n運行以下代碼，將輸出 `Hello World`。\n\n```java\npackage hello;\n\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n```\n\n### Java 語言的特點\n\n1. 面向對象（封裝，繼承，多態）\n2. 平台無關性（ Java 虛擬機實現平台無關性）\n3. 支持多線程\n4. 編譯與解釋並存\n\n編譯：生成字節碼(.class文件)，javac 指令。\n解釋：解釋字節碼成機器碼，java 指令。\n\n### JVM、JDK 和  JRE\n\n1. JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。\n2. JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。\n3. JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。\n\n### Java 與 C++ 對比\n\n1. 皆支持面向對象編程（封裝、繼承和多態）。\n2. Java 不提供指針來直接訪問內存；C++ 提供。\n3. Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。\n4. Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。\n5. Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符`\\0` 來表示結束。\n\n## Java 語法\n\n### 基本類型及其大小\n\nJava 共 8 種數據類型（不包括 void），具體如下表：\n\n![](java_basic/20201202_24328.png)\n\nboolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。\n\nchar 值是一個 16 位的 Unicode 字符，最小值是 '\\u0000' ，最大值是 '\\uffff'，即 0～65535，每個數字對應一個字符。\n\n- 代碼\n\n    ```java\n    char a = '中';\n    System.out.println((int)a);\n    // 輸出 20013\n    System.out.println(Integer.toHexString(a));\n    // 輸出 4e2d\n    System.out.println('\\u4e2d');\n    // 輸出 中\n    ```\n\nbyte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。\n\n- 二進制補碼\n    - 過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。\n    - 原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 [https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm](https://www.ruanyifeng.com/blog/2009/08/twos_complement.html)l\n\nlong 類型的數據後面一定要加上 L，否則會被認為是整型。\n\nchar 類型值使用單引號括起來，String 使用雙引號。\n\nJava 有**自動拆裝箱機制**，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。\n\n### 包裝類型及常量池技術\n\n1. Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。\n2. Character 創建了數值在 [0, 127] 的緩存數據。\n3. Boolean 直接返回 True 和 False。\n4. Float 和 Double 沒有實現常量池技術。\n\n使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。\n\n```java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\nInteger i11 = 333;\nInteger i22 = 333;\nSystem.out.println(i11 == i22);// 输出 false\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n```\n\n《阿里巴巴Java開發手冊》規定：\n\n- 【強制】**所有的 POJO 類屬性必須使用包裝數據類型**。\n- 【強制】RPC 方法的返回值和參數必須使用包裝數據類型。\n- 【推薦】所有的局部變量使用基本數據類型。\n\n### BigDecimal\n\n**（1）使用 BigDecimal 進行浮點數比較和精度取捨**\n\n**（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象**\n\n```java\nfloat a = 1.0f - 0.9f;\nfloat b = 0.9f - 0.8f;\nSystem.out.println(a);\nSystem.out.println(b);\nSystem.out.println(a == b); // false\n\nBigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\nSystem.out.println(a.subtract(b));\nSystem.out.println(b.subtract(c));\nSystem.out.println(a.subtract(b).equals(b.subtract(c))); // true\n\nBigDecimal a = new BigDecimal(\"1.1252312\");\n// 取小數點後 2 位，四捨五入\nBigDecimal scale = a.setScale(2, RoundingMode.HALF_UP);\nSystem.out.println(scale.toString()); // 1.13\n```\n\n### 對象及其大小\n\n基本類型的封裝類型是對象，Java 中的對象由以下部分組成：\n\n1. 對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。\n2. 實例數據（instance data）：對象的有效信息。\n3. 對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。\n\n可使用 `org.openjdk.jol` 工具查看一個對象佔用的字節大小，\n\n- 如下：\n\n    ```java\n    public static void main(String[] args){\n        System.out.println(VM.current().details());\n        System.out.println(ClassLayout.parseClass(Object.class).toPrintable());\n        System.out.println(ClassLayout.parseInstance(Integer.valueOf(1)).toPrintable());\n    }\n    ```\n\n    輸出結果：\n\n    ```bash\n    # Running 64-bit HotSpot VM.\n    # Using compressed oop with 3-bit shift.\n    # Using compressed klass with 3-bit shift.\n    # WARNING | Compressed references base/shifts are guessed by the experiment!\n    # WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.\n    # WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.\n    # Objects are 8 bytes aligned.\n    # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n    # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n\n    java.lang.Object object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0    12        (object header)                           N/A\n         12     4        (loss due to the next object alignment)\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 4 bytes external = 4 bytes total\n\n    java.lang.Integer object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)\n          4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)\n          8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)\n         12     4    int Integer.value                             1\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total\n    ```\n\n結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。\n\n### String、StringBuffer 和 String Builder 的區別\n\nString 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。\n\n```java\npublic final class String {\n\t// Java 9 之前\n\tprivate final char[] value;\n\t// Java 9 之後\n\tprivate final byte[] value;\n}\n```\n\nStringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。\n\n下面從不同角度比較下此三者：\n\n1. 線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。\n2. 性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。\n\n### 注釋\n\n代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。\n\n### 標識符和關鍵字的區別\n\n標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：\n\n1. 訪問控制：private、protected、public\n2. 類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile\n3. 程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default\n4. 錯誤處理：try、catch、throw、throws、finally\n5. 包相關：import、package\n6. 基本類型：boolean、byte、char、double、float、int、short、null、true、false\n7. 變量引用：super、this、void\n8. 保留字：goto、const\n\n### 自增自減運算符\n\n符號在前先加減再賦值，符號在後先賦值後加減。假定 `a = 1; b = a++` 最後 a 值爲 2，b 值爲 1。\n\n### == 和 equals 的區別\n\n1. 基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。\n2. equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。\n3. 整型包裝類都應使用 equals 比較大小。\n4. 浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。\n- 重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？\n\n    hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n    HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。\n\n### 序列化時如果有些字段不想序列化，怎麼辦？\n\n使用 transient 關鍵字修飾不想序列化的字段。\n\n### continue、break 和 return 的區別\n\n1. continue：跳出當前這一次循環，繼續下一次循環。\n2. break：跳出整個循環體，繼續執行循環外的語句。\n3. return：跳出所在的方法，結束方法，可以帶一個返回值。\n\n### 泛型、類型擦除和通配符\n\n**泛型的本質是將類型參數化。**Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲**僞泛型**。下面的例子展示了如何在運行期加入非法類型。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(12);\n//這裡直接添加會報錯\n// list.add(\"a\");\nClass<? extends List> clazz = list.getClass();\nMethod add = clazz.getDeclaredMethod(\"add\", Object.class);\n//但是通過反射添加，是可以的\nadd.invoke(list, \"kl\");\nSystem.out.println(list);\n```\n\n泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。\n\n泛型通配符約定：\n\n1. ？ 表示不確定的 Java 類型，用於泛型方法\n2. T（Type）表示確定的一個 Java 類型\n3. K V（Key Value）分別表示映射中的鍵、值\n4. E（Element）表示集合中的一個元素\n5. <? extends A> 上界通配符，表示 A 類型或其子類\n6. <? super A> 下界通配符，表示 A 類型或其父類\n7. <T extends A> 表示 A 類型或其子類的一種\n8. <T extends A & B> 表示 A 類型且B類型的子類的一種\n9. ~~<T super A>~~ \n\n泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<Apple> 的引用並不能傳遞給 Plate<Fruit>，但可以傳遞給 Plate<? extends Fruit>。\n\n元素爲 <? extends E> 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。\n\n```java\npublic static void main(String[] args) {\n  List<? extends A> list = Arrays.asList(new A(), new B());\n  list.add(new A()); // 報錯\n  list.add(new B()); // 報錯\n  A a = list.get(1);\n  System.out.println(a.toString());\n}\n\nstatic class A {\n}\n\nstatic class B extends A {\n}\n```\n\n元素爲 <? super E> 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。\n\n```java\npublic static void main(String[] args) {\n  List<? super B> list = new ArrayList<>();\n  list.add(new A()); // 報錯\n  list.add(new B());\n  list.add(new C());\n  Object object = list.get(1);\n  System.out.println(object.toString());\n}\n\nstatic class A {\n}\nstatic class B extends A {\n}\nstatic class C extends B{\n}\n```\n\n### 獲取鍵盤輸入數據的常用方法\n\n```java\n// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據\nScanner scanner = new Scanner(System.in);\nString s = scanner.nextLine();\nSystem.out.println(s);\n\n// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\nString s1 = bufferedReader.readLine();\nSystem.out.println(s1);\n```\n\n## 方法（函數）\n\n### 爲什麼 Java 只有值傳遞？\n\n首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：\n\n1. 按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。\n2. 按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。\n\n**Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝**。\n\n```java\npublic static void main(String[] args) {\n  String s1 = \"Hello\";\n  String s2 = \"World\";\n  swap(s1, s2);\n  System.out.printf(\"main s1: %s, s2: %s%n\", s1, s2);\n}\n\nstatic void swap(String s1, String s2) {\n  String tmp = s1;\n  s1 = s2;\n  s2 = tmp;\n  System.out.printf(\"swap s1: %s, s2: %s%n\", s1, s2);\n}\n// 運行結果：\n// swap s1: World, s2: Hello\n// main s1: Hello, s2: World\n```\n\n結論：\n\n1. 一個方法不能修改一個基本類型的實參。\n2. 一個方法可以改變一個對象類型的實參狀態。\n3. 一個方法不能讓對象類型的實參引用一個新對象。\n\n### 深拷貝和淺拷貝有什麼不同？\n\n1. 淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。\n2. 深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。\n\n![](java-basic/Untitled.png)\n\n### 重載和重寫有什麼區別？\n\n1. 重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。\n2. 重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。\n\n## Java 面向對象\n\n### 面向對象和面向過程\n\n1. 面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。\n2. 面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。\n\nJava 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。\n\n### 構造方法\n\n1. 特點：名字跟類名相同，沒有返回值，不可重寫但可重載。\n2. 作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。\n3. 子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。\n\n### 成員變量和局部變量的區別\n\n1. 成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。\n2. 局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。\n\n### 對象實例和對象引用的區別\n\n1. 對象實例：存在於堆內存，一個對象實例可以被多個引用指向。\n2. 對象引用：存在於棧內存，一個引用指向一個對象實例。\n\n### 面向對象的三大特徵\n\n**（1）封裝**\n\n封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。\n\n**（2）繼承**\n\n繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：\n\n1. 子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），**僅僅擁有**。\n2. 子類可以對父類進行擴展，增加新的屬性和方法。\n3. 子類可以重寫父類的方法。\n\n**（3）多態**\n\n多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：\n\n1. 對象類型和引用類型之間具有繼承/實現關係。\n2. 對象類型不可變，引用類型可變。\n3. 方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。\n4. 父類的引用不能調用「只有子類存在但在父類不存在」的方法。\n5. 如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。\n\n### **靜態方法內爲什麼不能調用非靜態成員？**\n\n因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。\n\n### 接口和抽象類的區別\n\n1. 方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。\n2. 變量上：接口只能有 static、final 變量；而抽象類沒有限制。\n3. 繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。\n4. 設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。\n\n## Java 核心技術\n\n### 集合\n\n見 [Java 集合](https://tsunhua.github.io/2020/12/02/it/java/java-collection/) \n\n### 反射機制\n\n**（1）什麼是反射**\n\nJava 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。\n\n**（2）反射的優缺點**\n\n1. 優點：運行時確定類型，動態加載類，提高代碼靈活度。\n2. 缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。\n\n反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。\n\n**（3）反射的應用場景**\n\n反射是框架設計的靈魂。其應用場景有：\n\n1. 模塊化開發；\n2. 動態代理設計模式；\n3. Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；\n4. JDBC 連接數據庫等等。\n\n### 異常\n\n**（1）簡介**\n\nJava 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。**Error 通常是 JVM 錯誤，程序無法處理**；**而 Exception 是程序本身可以處理的異常**。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。\n\n![](java-basic/Untitled%201.png)\n\n**Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）**，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：\n\n- *IOException*\n- *EOFException*\n- *MalFormedURLException*\n- *IntruptedException*\n\n**Unchecked Exception 又名 Runtime Exceptions（運行時異常）**，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：\n\n- *ArithmaticException*\n- *NullPointerException*\n- *IndexOutOfBoundsException*\n- *ClassCastException*\n- *ArrayIndexOutOfBoundsException*\n- *NumberFormatException*\n\n**（2）Throwable 類常用方法**\n\n1. `getMessage`：返回異常的簡要描述\n2. `toString`：返回異常的詳細信息\n3. `getLocalizedMessage`：返回異常的本地化信息（需要子類覆蓋該方法，否則與 `getMessage` 一樣）\n4. `printStackTrace`：在控制台打印 Throwable 对象封装的异常信息\n\n**（3）try-catch-finally**\n\n1. try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。\n2. catch 代碼塊：處理捕獲到的異常。\n3. finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。\n\n```java\npublic static int f(int value) {\n  try {\n      return value * value;\n  } finally {\n      if (value == 2) {\n          return 0;\n      }\n  }\n}\n// f(2) 將返回 0 ，而不是 4.\n```\n\n以下情況，finally 代碼塊不會被執行或只部分執行：\n\n1. finally 代碼塊中有異常，代碼會中異常處中止；\n2. 在 catch 代碼塊或 finally 塊中調用了 `System.exit` 函數退出程序；\n3. 程序所在的線程死亡等等不可預料的系統和硬件問題。\n\n**（4）try-witch-resources**\n\nJava 7 中新增了 ****try-witch-resources 語法糖，適用於實現`java.lang.AutoCloseable` 或者 `java.io.Closeable` 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。\n\n```java\n// try-catch-finally\nScanner scanner = null;\ntry {\n    scanner = new Scanner(new File(\"src/main/resources/test.txt\"));\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (scanner != null) {\n        scanner.close();\n    }\n}\n// try-witch-resources\ntry (Scanner scanner = new Scanner(new File(\"src/main/resources/test.txt\"))) {\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n### 多線程\n\n見 [Java 多線程](https://tsunhua.github.io/2020/12/10/it/java/java-concurrent/) \n\n### 文件與 I/O 流\n\n**（1）Java 中 I/O 流分爲幾種？**\n\n按不同的分類方法有不同的分類：\n\n1. 按流向分：輸入流、輸出流。\n2. 按操作單元分：字節流、字符流。\n3. 按角色分：節點流、處理流。\n\nJava 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：\n\n1. InputStream：字節輸入流\n2. Reader：字符輸入流\n3. OutputStream：字節輸出流\n4. Writer：字符輸出流\n\n![](java-basic/Untitled%202.png)\n\n![](java-basic/Untitled%203.png)\n\n**（2）爲什麼有了字節流還需要字符流？**\n\n不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？\n\n字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。\n\n**（3）BIO、NIO、AIO 有什麼區別？**\n\n1. **BIO**（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（< 單機 1000）的情況，結合線程池一起使用。\n2. **NIO**（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 `java.nio` 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。\n3. **AIO**（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。\n\nNIO 模型：\n\n![](java-basic/Untitled%204.png)\n\n- NIO 服務端代碼\n\n    ```java\n    public class MultiplexerNioServer implements Runnable {\n\n        private Selector selector;\n        private volatile boolean stop = false;\n\n        /**\n         * 初始化多路复用器 绑定监听端口\n         *\n         * @param port\n         */\n        public MultiplexerNioServer(int port) {\n            try {\n                ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//获得一个serverChannel\n                selector = Selector.open();////创建选择器  获得一个多路复用器\n                serverSocketChannel.configureBlocking(false);//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                serverSocketChannel.socket().bind(new InetSocketAddress(port), 1024);//绑定一个端口和等待队列长度\n                serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//把selector注册到channel，关注链接事件\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void stop() {\n            this.stop = true; // 优雅停机\n        }\n\n        public void run() {\n            while (!stop) {\n                try {\n                    //无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的\n                    int client = selector.select(1000);\n                    System.out.println(\"1:\" + client);\n                    // 阻塞,只有当至少一个注册的事件发生的时候才会继续.\n                    // int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪\n                    if (client == 0) {\n                        continue;\n                    }\n                    System.out.println(\"2:\" + client);\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            //处理事件\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (selector != null) {\n                // selector关闭后会自动释放里面管理的资源\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                //连接事件\n                if (key.isAcceptable()) {\n                    ServerSocketChannel ssc = (ServerSocketChannel) key.channel();\n                    // 通过ServerSocketChannel的accept创建SocketChannel实例\n                    // 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立\n                    SocketChannel sc = ssc.accept();//3次握手\n                    sc.configureBlocking(false);\n                    sc.register(selector, SelectionKey.OP_READ);//连接建立后关注读事件\n                }\n\n                //读事件\n                if (key.isReadable()) {\n                    SocketChannel socketChannel = (SocketChannel) key.channel();\n                    ByteBuffer readbuffer = ByteBuffer.allocate(1024);//写 0 1024  1024\n    //                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存\n                    // 读取请求码流，返回读取到的字节数\n                    while (true) {\n                        int readBytes = socketChannel.read(readbuffer);\n                        // 读取到字节，对字节进行编解码\n                        if (readBytes > 0) {\n                            // 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作\n                            readbuffer.flip();//读写模式反转\n                            // 将缓冲区可读字节数组复制到新建的数组中\n                            byte[] bytes = new byte[readbuffer.remaining()];\n                            readbuffer.get(bytes);\n                            String body = new String(bytes, StandardCharsets.UTF_8);\n                            System.out.println(\"input is:\" + body);\n                            res(socketChannel, body);\n                        } else if (readBytes < 0) {\n                            // 链路已经关闭 释放资源\n                            key.cancel();\n                            socketChannel.close();\n                        } else {\n                            // 没有读到字节忽略\n                            return;\n                        }\n                    }\n\n                }\n\n            }\n        }\n\n        private void res(SocketChannel channel, String response) throws IOException {\n            if (response != null && response.length() > 0) {\n                byte[] bytes = response.getBytes();\n                ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);\n                writeBuffer.put(bytes);\n                writeBuffer.flip();\n                channel.write(writeBuffer);\n                System.out.println(\"res end\");\n            }\n        }\n    }\n    ```\n\n- NIO 客戶端代碼\n\n    ```java\n    public class NioClientHandler implements Runnable {\n        private final String host;\n        private final int port;\n        private Selector selector;\n        private SocketChannel socketChannel;\n        private volatile boolean stop;\n\n        public NioClientHandler(String host, int port) {\n            this.host = host;\n            this.port = port;\n            try {\n                // 创建选择器\n                selector = Selector.open();\n                // 打开监听通道\n                socketChannel = SocketChannel.open();\n                // 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                socketChannel.configureBlocking(false); // 开启非阻塞模式\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void run() {\n            try {\n                doConnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n            while (!stop) {\n                try {\n                    int wait = selector.select(1000);\n                    if (wait == 0) {\n                        continue;\n                    }\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n            if (selector != null) {\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void doConnect() throws IOException {\n            if (socketChannel.connect(new InetSocketAddress(host, port))) {\n                socketChannel.register(selector, SelectionKey.OP_READ);\n                doWrite(socketChannel);\n            } else {\n                socketChannel.register(selector, SelectionKey.OP_CONNECT);\n            }\n        }\n\n        private void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                SocketChannel sc = (SocketChannel) key.channel();\n                if (key.isConnectable()) {\n                    if (sc.finishConnect()) {\n                        sc.register(selector, SelectionKey.OP_READ);\n                        doWrite(sc);\n                    } else {\n                        System.exit(1);\n                    }\n                }\n                if (key.isReadable()) {\n                    ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n                    int readBytes = sc.read(readBuffer);\n                    if (readBytes > 0) {\n                        readBuffer.flip();\n                        byte[] bytes = new byte[readBuffer.remaining()];\n                        readBuffer.get(bytes);\n                        String body = new String(bytes, StandardCharsets.UTF_8);\n                        System.out.println(\"res\" + body);\n                        this.stop = true;\n                    } else if (readBytes < 0) {\n                        key.cancel();\n                        sc.close();\n                    }\n\n                }\n            }\n        }\n\n        private void doWrite(SocketChannel sc) throws IOException {\n            // 将消息编码为字节数组\n            byte[] request = \"Hello\".getBytes();\n            // 根据数组容量创建ByteBuffer\n            ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);\n            // 将字节数组复制到缓冲区\n            writeBuffer.put(request);\n            // flip读写切换操作\n            writeBuffer.flip();\n            sc.write(writeBuffer);\n            if (!writeBuffer.hasRemaining()) {\n                System.out.println(\"写入完成\");\n            }\n        }\n    }\n    ```\n\n## Java 項目管理和構建\n\n### Maven 项目\n\n**（1）安装**\n\n從 [Maven 官網](https://maven.apache.org/download.cgi)下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。\n\n**（2）初始化一個 Maven 項目**\n\n使用以下命令：\n\n```bash\nmvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4\n```\n\n或者用 IDEA 直接新建一個 Maven 項目，其結構如下：\n\n![](java-basic/20201114_101407.png)\n\n其中 pom.xml 的內容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>testmaven</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <!--  添加以下屬性，解決編譯報錯  -->\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.encoding>UTF-8</maven.compiler.encoding>\n        <java.version>15</java.version>\n        <maven.compiler.source>15</maven.compiler.source>\n        <maven.compiler.target>15</maven.compiler.target>\n    </properties>\n    <!-- 新增依賴在下方 -->\n    <dependencies>\n        <dependency>\n            <groupId>org.openjdk.jol</groupId>\n            <artifactId>jol-core</artifactId>\n            <version>0.14</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n- 為什麼叫 Maven？\n\n    Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。\n\n- POM 又是指什麼？\n\n    POM（project object model）項目對象模型，maven 使用 `pom.xml` 定義了整個項目的構建、報告和文檔。\n\n**（3）編譯測試打包**\n\n```bash\n# 清理 target 中的文件\nmvn clean\n# 編譯 java 文件成 class 文件，置於 target/classes 文件夾中\nmvn compile\n# 進行單元測試\nmvn test\n# 打包成 jar 文件，置於 target 文件夾中\nmvn package\n# 安裝 jar 包到本地存儲庫（${user.home}/.m2/repository）\nmvn install\n# 生成自己的 maven 站點\nmvn site\n```\n\n- SNAPSHOT 是什麼？\n\n    snapshot 簡要的意思，在版本號之後添加 `-SNAPSHOT` 是說明該版本仍處於開發階段，不是最終的發行版本。以 `x.y-SNAPSHOT` 版本為例，發行時會去除 `-SNAPSHOT`  後綴，然後將最新的開發版本升爲`x.(y+1)-SNAPSHOT` 。\n\n- 使用 mvn compile 生成的 jar 包，其內容是怎樣的？\n\n    除了 class 文件外，還有 `META-INF` 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（`main/resources` ）的文件也會被打包到`META-INF` 文件夾中，代碼中可通過`getClass().getResourceAsStream( \"/application.properties\" )` 調用。\n\n    ```bash\n    $ jar tf target/testmaven-1.0-SNAPSHOT.jar \n    META-INF/\n    META-INF/MANIFEST.MF\n    B.class\n    MemoryLayoutTest.class\n    A.class\n    C.class\n    META-INF/maven/\n    META-INF/maven/org.example/\n    META-INF/maven/org.example/testmaven/\n    META-INF/maven/org.example/testmaven/pom.xml\n    META-INF/maven/org.example/testmaven/pom.properties\n    ```\n\n### Gradle 项目\n\n**（1）安裝**\n\n可從 [gradle 官網](https://www.gradle.org/downloads)下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 `brew install gradle` 的方式安裝。或者直接使用 IDEA 項目中的 `gradle-wrapper` ，此時對應的 `gradle` 命令變爲 `gradlew`。\n\n**（2）gradle 命令能做什麼？**\n\ngradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。\n\n```bash\n$ gradle tasks\n\n:tasks\n\n== All tasks runnable from root project\n\n== Build Setup tasks\nsetupBuild - Initializes a new Gradle build. [incubating]\n\n== Help tasks\ndependencies - Displays all dependencies declared in root project 'gs-gradle'.\ndependencyInsight - Displays the insight into a specific dependency in root project 'gs-gradle'.\nhelp - Displays a help message\nprojects - Displays the sub-projects of root project 'gs-gradle'.\nproperties - Displays the properties of root project 'gs-gradle'.\ntasks - Displays the tasks runnable from root project 'gs-gradle'.\n\nTo see all tasks and more detail, run with --all.\n\nBUILD SUCCESSFUL\n\nTotal time: 3.077 secs\n```\n\n**（3）初始化一個 Gradle 項目**\n\n在項目文件夾中新建一個名爲 `build.gradle` 的文件，其內容如下：\n\n```groovy\napply plugin: 'java'\n```\n\n隨後新建一個名爲 `settings.gradle` 的文件，其內容可暫時爲空。\n\n在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 `gradle-wrapper` ，其過程等價於執行以下命令：\n\n```bash\ngradle wrapper --gradle-version 6.5\n```\n\n**（4）編譯打包**\n\n```bash\n# 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包\ngradle build\n# 或使用 gradle wrapper\n./gradlew build\n\n# 清理生成的文件\ngradle clean\n\n# 生成 jar 文件\ngradle jar\n\n# 運行生成的 jar 文件\ngradle run\n\n# 進行單元測試\ngradle test\n```\n\n**（5）`build.gradle` 中可配置什麼？**\n\n```groovy\n// 配置插件，插件提供語法定義\napply plugin: 'java'\napply plugin: 'application'\n\n// 配置入口類\nmainClassName = 'hello.HelloWorld'\n\n// 配置依賴倉庫\nrepositories {\n    mavenCentral()\n}\n\n// 配置生成的 jar 文件的入口類\njar {\n    manifest {\n        attributes 'Main-Class': mainClassName\n    }\n}\n\n// 配置 JDK 兼容性\nsourceCompatibility = 1.8\ntargetCompatibility = 1.8\n\n// 配置依賴\ndependencies {\n    compile \"joda-time:joda-time:2.2\"\n    testCompile \"junit:junit:4.12\"\n}\n```\n\n如需將所有依賴 jar 打進同一個 jar 包，可使用 [shadow 插件](https://github.com/johnrengelman/shadow)或使用 [spring boot 插件](https://spring.io/quickstart)。","source":"_posts/it/java/java-basic.md","raw":"---\ntitle: Java 基礎\np: it/java/java-basic.md\ntags:\n- Java\n---\n\nJava 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。\n\n- 它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。\n- 它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。\n- 它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。\n- 它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。\n- 它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。\n- 它提供了豐富的集合類、迭代器及工具類。\n- 它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。\n- 它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。\n- 它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。\n- 另外，目前有兩大項目管理工具，Maven 和 Gradle。\n\n<!-- more -->\n\n## Java 入門（基礎概念與常識）\n\n### 歷史\n\nJava 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 `CA FE BA BE` ，即 cafe babe （咖啡寶貝）。\n\n```java\n$ hexdump Test.class\n0000000 ca fe ba be 00 00 00 3b 00 51 0a 00 02 00 03 07\n```\n\n- 1994 年完成 1.0 版本。\n- 1995 年首次對外發佈，Java 語言誕生。\n- 1996 年JDK 1.0 誕生。\n- 2004 年 SUN 公司發佈 Java SE 5。\n- 2005 年 SUN 公司發佈 Java SE 6。\n- 2006 年 SUN 公司推出 OpenJDK 計劃。\n- 2014年 Oracle 公司發佈 Java SE 8。\n- 2017年 Oracle公司發佈 Java SE 9。\n- 2020 年 Oracle 公司發佈 Java SE 15。\n\n### 安裝與卸載JDK\n\n在 Mac 環境下，從 [Oracle JavaSE 下載地址](https://www.oracle.com/tw/java/technologies/javase-downloads.html) 下載並安裝。安裝完成後執行 `java -version`  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 `/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home` 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。\n\n```bash\nsudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin\nsudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane\n\nls /Library/Java/JavaVirtualMachines/\n输出：jdk-9.0.1.jdk\n\nsudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk\n```\n\n### Hello World\n\n運行以下代碼，將輸出 `Hello World`。\n\n```java\npackage hello;\n\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n```\n\n### Java 語言的特點\n\n1. 面向對象（封裝，繼承，多態）\n2. 平台無關性（ Java 虛擬機實現平台無關性）\n3. 支持多線程\n4. 編譯與解釋並存\n\n編譯：生成字節碼(.class文件)，javac 指令。\n解釋：解釋字節碼成機器碼，java 指令。\n\n### JVM、JDK 和  JRE\n\n1. JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。\n2. JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。\n3. JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。\n\n### Java 與 C++ 對比\n\n1. 皆支持面向對象編程（封裝、繼承和多態）。\n2. Java 不提供指針來直接訪問內存；C++ 提供。\n3. Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。\n4. Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。\n5. Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符`\\0` 來表示結束。\n\n## Java 語法\n\n### 基本類型及其大小\n\nJava 共 8 種數據類型（不包括 void），具體如下表：\n\n![](java_basic/20201202_24328.png)\n\nboolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。\n\nchar 值是一個 16 位的 Unicode 字符，最小值是 '\\u0000' ，最大值是 '\\uffff'，即 0～65535，每個數字對應一個字符。\n\n- 代碼\n\n    ```java\n    char a = '中';\n    System.out.println((int)a);\n    // 輸出 20013\n    System.out.println(Integer.toHexString(a));\n    // 輸出 4e2d\n    System.out.println('\\u4e2d');\n    // 輸出 中\n    ```\n\nbyte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。\n\n- 二進制補碼\n    - 過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。\n    - 原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 [https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm](https://www.ruanyifeng.com/blog/2009/08/twos_complement.html)l\n\nlong 類型的數據後面一定要加上 L，否則會被認為是整型。\n\nchar 類型值使用單引號括起來，String 使用雙引號。\n\nJava 有**自動拆裝箱機制**，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。\n\n### 包裝類型及常量池技術\n\n1. Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。\n2. Character 創建了數值在 [0, 127] 的緩存數據。\n3. Boolean 直接返回 True 和 False。\n4. Float 和 Double 沒有實現常量池技術。\n\n使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。\n\n```java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\nInteger i11 = 333;\nInteger i22 = 333;\nSystem.out.println(i11 == i22);// 输出 false\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n```\n\n《阿里巴巴Java開發手冊》規定：\n\n- 【強制】**所有的 POJO 類屬性必須使用包裝數據類型**。\n- 【強制】RPC 方法的返回值和參數必須使用包裝數據類型。\n- 【推薦】所有的局部變量使用基本數據類型。\n\n### BigDecimal\n\n**（1）使用 BigDecimal 進行浮點數比較和精度取捨**\n\n**（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象**\n\n```java\nfloat a = 1.0f - 0.9f;\nfloat b = 0.9f - 0.8f;\nSystem.out.println(a);\nSystem.out.println(b);\nSystem.out.println(a == b); // false\n\nBigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\nSystem.out.println(a.subtract(b));\nSystem.out.println(b.subtract(c));\nSystem.out.println(a.subtract(b).equals(b.subtract(c))); // true\n\nBigDecimal a = new BigDecimal(\"1.1252312\");\n// 取小數點後 2 位，四捨五入\nBigDecimal scale = a.setScale(2, RoundingMode.HALF_UP);\nSystem.out.println(scale.toString()); // 1.13\n```\n\n### 對象及其大小\n\n基本類型的封裝類型是對象，Java 中的對象由以下部分組成：\n\n1. 對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。\n2. 實例數據（instance data）：對象的有效信息。\n3. 對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。\n\n可使用 `org.openjdk.jol` 工具查看一個對象佔用的字節大小，\n\n- 如下：\n\n    ```java\n    public static void main(String[] args){\n        System.out.println(VM.current().details());\n        System.out.println(ClassLayout.parseClass(Object.class).toPrintable());\n        System.out.println(ClassLayout.parseInstance(Integer.valueOf(1)).toPrintable());\n    }\n    ```\n\n    輸出結果：\n\n    ```bash\n    # Running 64-bit HotSpot VM.\n    # Using compressed oop with 3-bit shift.\n    # Using compressed klass with 3-bit shift.\n    # WARNING | Compressed references base/shifts are guessed by the experiment!\n    # WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.\n    # WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.\n    # Objects are 8 bytes aligned.\n    # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n    # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n\n    java.lang.Object object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0    12        (object header)                           N/A\n         12     4        (loss due to the next object alignment)\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 4 bytes external = 4 bytes total\n\n    java.lang.Integer object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)\n          4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)\n          8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)\n         12     4    int Integer.value                             1\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total\n    ```\n\n結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。\n\n### String、StringBuffer 和 String Builder 的區別\n\nString 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。\n\n```java\npublic final class String {\n\t// Java 9 之前\n\tprivate final char[] value;\n\t// Java 9 之後\n\tprivate final byte[] value;\n}\n```\n\nStringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。\n\n下面從不同角度比較下此三者：\n\n1. 線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。\n2. 性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。\n\n### 注釋\n\n代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。\n\n### 標識符和關鍵字的區別\n\n標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：\n\n1. 訪問控制：private、protected、public\n2. 類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile\n3. 程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default\n4. 錯誤處理：try、catch、throw、throws、finally\n5. 包相關：import、package\n6. 基本類型：boolean、byte、char、double、float、int、short、null、true、false\n7. 變量引用：super、this、void\n8. 保留字：goto、const\n\n### 自增自減運算符\n\n符號在前先加減再賦值，符號在後先賦值後加減。假定 `a = 1; b = a++` 最後 a 值爲 2，b 值爲 1。\n\n### == 和 equals 的區別\n\n1. 基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。\n2. equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。\n3. 整型包裝類都應使用 equals 比較大小。\n4. 浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。\n- 重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？\n\n    hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n    HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。\n\n### 序列化時如果有些字段不想序列化，怎麼辦？\n\n使用 transient 關鍵字修飾不想序列化的字段。\n\n### continue、break 和 return 的區別\n\n1. continue：跳出當前這一次循環，繼續下一次循環。\n2. break：跳出整個循環體，繼續執行循環外的語句。\n3. return：跳出所在的方法，結束方法，可以帶一個返回值。\n\n### 泛型、類型擦除和通配符\n\n**泛型的本質是將類型參數化。**Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲**僞泛型**。下面的例子展示了如何在運行期加入非法類型。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(12);\n//這裡直接添加會報錯\n// list.add(\"a\");\nClass<? extends List> clazz = list.getClass();\nMethod add = clazz.getDeclaredMethod(\"add\", Object.class);\n//但是通過反射添加，是可以的\nadd.invoke(list, \"kl\");\nSystem.out.println(list);\n```\n\n泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。\n\n泛型通配符約定：\n\n1. ？ 表示不確定的 Java 類型，用於泛型方法\n2. T（Type）表示確定的一個 Java 類型\n3. K V（Key Value）分別表示映射中的鍵、值\n4. E（Element）表示集合中的一個元素\n5. <? extends A> 上界通配符，表示 A 類型或其子類\n6. <? super A> 下界通配符，表示 A 類型或其父類\n7. <T extends A> 表示 A 類型或其子類的一種\n8. <T extends A & B> 表示 A 類型且B類型的子類的一種\n9. ~~<T super A>~~ \n\n泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<Apple> 的引用並不能傳遞給 Plate<Fruit>，但可以傳遞給 Plate<? extends Fruit>。\n\n元素爲 <? extends E> 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。\n\n```java\npublic static void main(String[] args) {\n  List<? extends A> list = Arrays.asList(new A(), new B());\n  list.add(new A()); // 報錯\n  list.add(new B()); // 報錯\n  A a = list.get(1);\n  System.out.println(a.toString());\n}\n\nstatic class A {\n}\n\nstatic class B extends A {\n}\n```\n\n元素爲 <? super E> 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。\n\n```java\npublic static void main(String[] args) {\n  List<? super B> list = new ArrayList<>();\n  list.add(new A()); // 報錯\n  list.add(new B());\n  list.add(new C());\n  Object object = list.get(1);\n  System.out.println(object.toString());\n}\n\nstatic class A {\n}\nstatic class B extends A {\n}\nstatic class C extends B{\n}\n```\n\n### 獲取鍵盤輸入數據的常用方法\n\n```java\n// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據\nScanner scanner = new Scanner(System.in);\nString s = scanner.nextLine();\nSystem.out.println(s);\n\n// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\nString s1 = bufferedReader.readLine();\nSystem.out.println(s1);\n```\n\n## 方法（函數）\n\n### 爲什麼 Java 只有值傳遞？\n\n首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：\n\n1. 按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。\n2. 按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。\n\n**Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝**。\n\n```java\npublic static void main(String[] args) {\n  String s1 = \"Hello\";\n  String s2 = \"World\";\n  swap(s1, s2);\n  System.out.printf(\"main s1: %s, s2: %s%n\", s1, s2);\n}\n\nstatic void swap(String s1, String s2) {\n  String tmp = s1;\n  s1 = s2;\n  s2 = tmp;\n  System.out.printf(\"swap s1: %s, s2: %s%n\", s1, s2);\n}\n// 運行結果：\n// swap s1: World, s2: Hello\n// main s1: Hello, s2: World\n```\n\n結論：\n\n1. 一個方法不能修改一個基本類型的實參。\n2. 一個方法可以改變一個對象類型的實參狀態。\n3. 一個方法不能讓對象類型的實參引用一個新對象。\n\n### 深拷貝和淺拷貝有什麼不同？\n\n1. 淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。\n2. 深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。\n\n![](java-basic/Untitled.png)\n\n### 重載和重寫有什麼區別？\n\n1. 重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。\n2. 重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。\n\n## Java 面向對象\n\n### 面向對象和面向過程\n\n1. 面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。\n2. 面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。\n\nJava 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。\n\n### 構造方法\n\n1. 特點：名字跟類名相同，沒有返回值，不可重寫但可重載。\n2. 作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。\n3. 子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。\n\n### 成員變量和局部變量的區別\n\n1. 成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。\n2. 局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。\n\n### 對象實例和對象引用的區別\n\n1. 對象實例：存在於堆內存，一個對象實例可以被多個引用指向。\n2. 對象引用：存在於棧內存，一個引用指向一個對象實例。\n\n### 面向對象的三大特徵\n\n**（1）封裝**\n\n封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。\n\n**（2）繼承**\n\n繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：\n\n1. 子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），**僅僅擁有**。\n2. 子類可以對父類進行擴展，增加新的屬性和方法。\n3. 子類可以重寫父類的方法。\n\n**（3）多態**\n\n多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：\n\n1. 對象類型和引用類型之間具有繼承/實現關係。\n2. 對象類型不可變，引用類型可變。\n3. 方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。\n4. 父類的引用不能調用「只有子類存在但在父類不存在」的方法。\n5. 如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。\n\n### **靜態方法內爲什麼不能調用非靜態成員？**\n\n因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。\n\n### 接口和抽象類的區別\n\n1. 方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。\n2. 變量上：接口只能有 static、final 變量；而抽象類沒有限制。\n3. 繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。\n4. 設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。\n\n## Java 核心技術\n\n### 集合\n\n見 [Java 集合](https://tsunhua.github.io/2020/12/02/it/java/java-collection/) \n\n### 反射機制\n\n**（1）什麼是反射**\n\nJava 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。\n\n**（2）反射的優缺點**\n\n1. 優點：運行時確定類型，動態加載類，提高代碼靈活度。\n2. 缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。\n\n反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。\n\n**（3）反射的應用場景**\n\n反射是框架設計的靈魂。其應用場景有：\n\n1. 模塊化開發；\n2. 動態代理設計模式；\n3. Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；\n4. JDBC 連接數據庫等等。\n\n### 異常\n\n**（1）簡介**\n\nJava 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。**Error 通常是 JVM 錯誤，程序無法處理**；**而 Exception 是程序本身可以處理的異常**。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。\n\n![](java-basic/Untitled%201.png)\n\n**Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）**，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：\n\n- *IOException*\n- *EOFException*\n- *MalFormedURLException*\n- *IntruptedException*\n\n**Unchecked Exception 又名 Runtime Exceptions（運行時異常）**，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：\n\n- *ArithmaticException*\n- *NullPointerException*\n- *IndexOutOfBoundsException*\n- *ClassCastException*\n- *ArrayIndexOutOfBoundsException*\n- *NumberFormatException*\n\n**（2）Throwable 類常用方法**\n\n1. `getMessage`：返回異常的簡要描述\n2. `toString`：返回異常的詳細信息\n3. `getLocalizedMessage`：返回異常的本地化信息（需要子類覆蓋該方法，否則與 `getMessage` 一樣）\n4. `printStackTrace`：在控制台打印 Throwable 对象封装的异常信息\n\n**（3）try-catch-finally**\n\n1. try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。\n2. catch 代碼塊：處理捕獲到的異常。\n3. finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。\n\n```java\npublic static int f(int value) {\n  try {\n      return value * value;\n  } finally {\n      if (value == 2) {\n          return 0;\n      }\n  }\n}\n// f(2) 將返回 0 ，而不是 4.\n```\n\n以下情況，finally 代碼塊不會被執行或只部分執行：\n\n1. finally 代碼塊中有異常，代碼會中異常處中止；\n2. 在 catch 代碼塊或 finally 塊中調用了 `System.exit` 函數退出程序；\n3. 程序所在的線程死亡等等不可預料的系統和硬件問題。\n\n**（4）try-witch-resources**\n\nJava 7 中新增了 ****try-witch-resources 語法糖，適用於實現`java.lang.AutoCloseable` 或者 `java.io.Closeable` 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。\n\n```java\n// try-catch-finally\nScanner scanner = null;\ntry {\n    scanner = new Scanner(new File(\"src/main/resources/test.txt\"));\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (scanner != null) {\n        scanner.close();\n    }\n}\n// try-witch-resources\ntry (Scanner scanner = new Scanner(new File(\"src/main/resources/test.txt\"))) {\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n### 多線程\n\n見 [Java 多線程](https://tsunhua.github.io/2020/12/10/it/java/java-concurrent/) \n\n### 文件與 I/O 流\n\n**（1）Java 中 I/O 流分爲幾種？**\n\n按不同的分類方法有不同的分類：\n\n1. 按流向分：輸入流、輸出流。\n2. 按操作單元分：字節流、字符流。\n3. 按角色分：節點流、處理流。\n\nJava 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：\n\n1. InputStream：字節輸入流\n2. Reader：字符輸入流\n3. OutputStream：字節輸出流\n4. Writer：字符輸出流\n\n![](java-basic/Untitled%202.png)\n\n![](java-basic/Untitled%203.png)\n\n**（2）爲什麼有了字節流還需要字符流？**\n\n不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？\n\n字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。\n\n**（3）BIO、NIO、AIO 有什麼區別？**\n\n1. **BIO**（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（< 單機 1000）的情況，結合線程池一起使用。\n2. **NIO**（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 `java.nio` 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。\n3. **AIO**（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。\n\nNIO 模型：\n\n![](java-basic/Untitled%204.png)\n\n- NIO 服務端代碼\n\n    ```java\n    public class MultiplexerNioServer implements Runnable {\n\n        private Selector selector;\n        private volatile boolean stop = false;\n\n        /**\n         * 初始化多路复用器 绑定监听端口\n         *\n         * @param port\n         */\n        public MultiplexerNioServer(int port) {\n            try {\n                ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//获得一个serverChannel\n                selector = Selector.open();////创建选择器  获得一个多路复用器\n                serverSocketChannel.configureBlocking(false);//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                serverSocketChannel.socket().bind(new InetSocketAddress(port), 1024);//绑定一个端口和等待队列长度\n                serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//把selector注册到channel，关注链接事件\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void stop() {\n            this.stop = true; // 优雅停机\n        }\n\n        public void run() {\n            while (!stop) {\n                try {\n                    //无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的\n                    int client = selector.select(1000);\n                    System.out.println(\"1:\" + client);\n                    // 阻塞,只有当至少一个注册的事件发生的时候才会继续.\n                    // int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪\n                    if (client == 0) {\n                        continue;\n                    }\n                    System.out.println(\"2:\" + client);\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            //处理事件\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (selector != null) {\n                // selector关闭后会自动释放里面管理的资源\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                //连接事件\n                if (key.isAcceptable()) {\n                    ServerSocketChannel ssc = (ServerSocketChannel) key.channel();\n                    // 通过ServerSocketChannel的accept创建SocketChannel实例\n                    // 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立\n                    SocketChannel sc = ssc.accept();//3次握手\n                    sc.configureBlocking(false);\n                    sc.register(selector, SelectionKey.OP_READ);//连接建立后关注读事件\n                }\n\n                //读事件\n                if (key.isReadable()) {\n                    SocketChannel socketChannel = (SocketChannel) key.channel();\n                    ByteBuffer readbuffer = ByteBuffer.allocate(1024);//写 0 1024  1024\n    //                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存\n                    // 读取请求码流，返回读取到的字节数\n                    while (true) {\n                        int readBytes = socketChannel.read(readbuffer);\n                        // 读取到字节，对字节进行编解码\n                        if (readBytes > 0) {\n                            // 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作\n                            readbuffer.flip();//读写模式反转\n                            // 将缓冲区可读字节数组复制到新建的数组中\n                            byte[] bytes = new byte[readbuffer.remaining()];\n                            readbuffer.get(bytes);\n                            String body = new String(bytes, StandardCharsets.UTF_8);\n                            System.out.println(\"input is:\" + body);\n                            res(socketChannel, body);\n                        } else if (readBytes < 0) {\n                            // 链路已经关闭 释放资源\n                            key.cancel();\n                            socketChannel.close();\n                        } else {\n                            // 没有读到字节忽略\n                            return;\n                        }\n                    }\n\n                }\n\n            }\n        }\n\n        private void res(SocketChannel channel, String response) throws IOException {\n            if (response != null && response.length() > 0) {\n                byte[] bytes = response.getBytes();\n                ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);\n                writeBuffer.put(bytes);\n                writeBuffer.flip();\n                channel.write(writeBuffer);\n                System.out.println(\"res end\");\n            }\n        }\n    }\n    ```\n\n- NIO 客戶端代碼\n\n    ```java\n    public class NioClientHandler implements Runnable {\n        private final String host;\n        private final int port;\n        private Selector selector;\n        private SocketChannel socketChannel;\n        private volatile boolean stop;\n\n        public NioClientHandler(String host, int port) {\n            this.host = host;\n            this.port = port;\n            try {\n                // 创建选择器\n                selector = Selector.open();\n                // 打开监听通道\n                socketChannel = SocketChannel.open();\n                // 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                socketChannel.configureBlocking(false); // 开启非阻塞模式\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void run() {\n            try {\n                doConnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n            while (!stop) {\n                try {\n                    int wait = selector.select(1000);\n                    if (wait == 0) {\n                        continue;\n                    }\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n            if (selector != null) {\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void doConnect() throws IOException {\n            if (socketChannel.connect(new InetSocketAddress(host, port))) {\n                socketChannel.register(selector, SelectionKey.OP_READ);\n                doWrite(socketChannel);\n            } else {\n                socketChannel.register(selector, SelectionKey.OP_CONNECT);\n            }\n        }\n\n        private void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                SocketChannel sc = (SocketChannel) key.channel();\n                if (key.isConnectable()) {\n                    if (sc.finishConnect()) {\n                        sc.register(selector, SelectionKey.OP_READ);\n                        doWrite(sc);\n                    } else {\n                        System.exit(1);\n                    }\n                }\n                if (key.isReadable()) {\n                    ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n                    int readBytes = sc.read(readBuffer);\n                    if (readBytes > 0) {\n                        readBuffer.flip();\n                        byte[] bytes = new byte[readBuffer.remaining()];\n                        readBuffer.get(bytes);\n                        String body = new String(bytes, StandardCharsets.UTF_8);\n                        System.out.println(\"res\" + body);\n                        this.stop = true;\n                    } else if (readBytes < 0) {\n                        key.cancel();\n                        sc.close();\n                    }\n\n                }\n            }\n        }\n\n        private void doWrite(SocketChannel sc) throws IOException {\n            // 将消息编码为字节数组\n            byte[] request = \"Hello\".getBytes();\n            // 根据数组容量创建ByteBuffer\n            ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);\n            // 将字节数组复制到缓冲区\n            writeBuffer.put(request);\n            // flip读写切换操作\n            writeBuffer.flip();\n            sc.write(writeBuffer);\n            if (!writeBuffer.hasRemaining()) {\n                System.out.println(\"写入完成\");\n            }\n        }\n    }\n    ```\n\n## Java 項目管理和構建\n\n### Maven 项目\n\n**（1）安装**\n\n從 [Maven 官網](https://maven.apache.org/download.cgi)下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。\n\n**（2）初始化一個 Maven 項目**\n\n使用以下命令：\n\n```bash\nmvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4\n```\n\n或者用 IDEA 直接新建一個 Maven 項目，其結構如下：\n\n![](java-basic/20201114_101407.png)\n\n其中 pom.xml 的內容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>testmaven</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <!--  添加以下屬性，解決編譯報錯  -->\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.encoding>UTF-8</maven.compiler.encoding>\n        <java.version>15</java.version>\n        <maven.compiler.source>15</maven.compiler.source>\n        <maven.compiler.target>15</maven.compiler.target>\n    </properties>\n    <!-- 新增依賴在下方 -->\n    <dependencies>\n        <dependency>\n            <groupId>org.openjdk.jol</groupId>\n            <artifactId>jol-core</artifactId>\n            <version>0.14</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n- 為什麼叫 Maven？\n\n    Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。\n\n- POM 又是指什麼？\n\n    POM（project object model）項目對象模型，maven 使用 `pom.xml` 定義了整個項目的構建、報告和文檔。\n\n**（3）編譯測試打包**\n\n```bash\n# 清理 target 中的文件\nmvn clean\n# 編譯 java 文件成 class 文件，置於 target/classes 文件夾中\nmvn compile\n# 進行單元測試\nmvn test\n# 打包成 jar 文件，置於 target 文件夾中\nmvn package\n# 安裝 jar 包到本地存儲庫（${user.home}/.m2/repository）\nmvn install\n# 生成自己的 maven 站點\nmvn site\n```\n\n- SNAPSHOT 是什麼？\n\n    snapshot 簡要的意思，在版本號之後添加 `-SNAPSHOT` 是說明該版本仍處於開發階段，不是最終的發行版本。以 `x.y-SNAPSHOT` 版本為例，發行時會去除 `-SNAPSHOT`  後綴，然後將最新的開發版本升爲`x.(y+1)-SNAPSHOT` 。\n\n- 使用 mvn compile 生成的 jar 包，其內容是怎樣的？\n\n    除了 class 文件外，還有 `META-INF` 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（`main/resources` ）的文件也會被打包到`META-INF` 文件夾中，代碼中可通過`getClass().getResourceAsStream( \"/application.properties\" )` 調用。\n\n    ```bash\n    $ jar tf target/testmaven-1.0-SNAPSHOT.jar \n    META-INF/\n    META-INF/MANIFEST.MF\n    B.class\n    MemoryLayoutTest.class\n    A.class\n    C.class\n    META-INF/maven/\n    META-INF/maven/org.example/\n    META-INF/maven/org.example/testmaven/\n    META-INF/maven/org.example/testmaven/pom.xml\n    META-INF/maven/org.example/testmaven/pom.properties\n    ```\n\n### Gradle 项目\n\n**（1）安裝**\n\n可從 [gradle 官網](https://www.gradle.org/downloads)下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 `brew install gradle` 的方式安裝。或者直接使用 IDEA 項目中的 `gradle-wrapper` ，此時對應的 `gradle` 命令變爲 `gradlew`。\n\n**（2）gradle 命令能做什麼？**\n\ngradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。\n\n```bash\n$ gradle tasks\n\n:tasks\n\n== All tasks runnable from root project\n\n== Build Setup tasks\nsetupBuild - Initializes a new Gradle build. [incubating]\n\n== Help tasks\ndependencies - Displays all dependencies declared in root project 'gs-gradle'.\ndependencyInsight - Displays the insight into a specific dependency in root project 'gs-gradle'.\nhelp - Displays a help message\nprojects - Displays the sub-projects of root project 'gs-gradle'.\nproperties - Displays the properties of root project 'gs-gradle'.\ntasks - Displays the tasks runnable from root project 'gs-gradle'.\n\nTo see all tasks and more detail, run with --all.\n\nBUILD SUCCESSFUL\n\nTotal time: 3.077 secs\n```\n\n**（3）初始化一個 Gradle 項目**\n\n在項目文件夾中新建一個名爲 `build.gradle` 的文件，其內容如下：\n\n```groovy\napply plugin: 'java'\n```\n\n隨後新建一個名爲 `settings.gradle` 的文件，其內容可暫時爲空。\n\n在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 `gradle-wrapper` ，其過程等價於執行以下命令：\n\n```bash\ngradle wrapper --gradle-version 6.5\n```\n\n**（4）編譯打包**\n\n```bash\n# 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包\ngradle build\n# 或使用 gradle wrapper\n./gradlew build\n\n# 清理生成的文件\ngradle clean\n\n# 生成 jar 文件\ngradle jar\n\n# 運行生成的 jar 文件\ngradle run\n\n# 進行單元測試\ngradle test\n```\n\n**（5）`build.gradle` 中可配置什麼？**\n\n```groovy\n// 配置插件，插件提供語法定義\napply plugin: 'java'\napply plugin: 'application'\n\n// 配置入口類\nmainClassName = 'hello.HelloWorld'\n\n// 配置依賴倉庫\nrepositories {\n    mavenCentral()\n}\n\n// 配置生成的 jar 文件的入口類\njar {\n    manifest {\n        attributes 'Main-Class': mainClassName\n    }\n}\n\n// 配置 JDK 兼容性\nsourceCompatibility = 1.8\ntargetCompatibility = 1.8\n\n// 配置依賴\ndependencies {\n    compile \"joda-time:joda-time:2.2\"\n    testCompile \"junit:junit:4.12\"\n}\n```\n\n如需將所有依賴 jar 打進同一個 jar 包，可使用 [shadow 插件](https://github.com/johnrengelman/shadow)或使用 [spring boot 插件](https://spring.io/quickstart)。","slug":"it/java/java-basic","published":1,"date":"2021-02-05T16:21:16.565Z","updated":"2021-06-14T15:54:20.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wov001h9a9k0sjk7tvr","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>Java 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。</p>\n<ul>\n<li>它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。</li>\n<li>它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。</li>\n<li>它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。</li>\n<li>它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。</li>\n<li>它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。</li>\n<li>它提供了豐富的集合類、迭代器及工具類。</li>\n<li>它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。</li>\n<li>它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。</li>\n<li>它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。</li>\n<li>另外，目前有兩大項目管理工具，Maven 和 Gradle。</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"Java-入門（基礎概念與常識）\"><a href=\"#Java-入門（基礎概念與常識）\" class=\"headerlink\" title=\"Java 入門（基礎概念與常識）\"></a>Java 入門（基礎概念與常識）</h2><h3 id=\"歷史\"><a href=\"#歷史\" class=\"headerlink\" title=\"歷史\"></a>歷史</h3><p>Java 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 <code>CA FE BA BE</code> ，即 cafe babe （咖啡寶貝）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexdump Test.class</span><br><span class=\"line\"><span class=\"number\">0000000</span> ca fe ba be <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> 3b <span class=\"number\">00</span> <span class=\"number\">51</span> 0a <span class=\"number\">00</span> <span class=\"number\">02</span> <span class=\"number\">00</span> <span class=\"number\">03</span> <span class=\"number\">07</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1994 年完成 1.0 版本。</li>\n<li>1995 年首次對外發佈，Java 語言誕生。</li>\n<li>1996 年JDK 1.0 誕生。</li>\n<li>2004 年 SUN 公司發佈 Java SE 5。</li>\n<li>2005 年 SUN 公司發佈 Java SE 6。</li>\n<li>2006 年 SUN 公司推出 OpenJDK 計劃。</li>\n<li>2014年 Oracle 公司發佈 Java SE 8。</li>\n<li>2017年 Oracle公司發佈 Java SE 9。</li>\n<li>2020 年 Oracle 公司發佈 Java SE 15。</li>\n</ul>\n<h3 id=\"安裝與卸載JDK\"><a href=\"#安裝與卸載JDK\" class=\"headerlink\" title=\"安裝與卸載JDK\"></a>安裝與卸載JDK</h3><p>在 Mac 環境下，從 <a href=\"https://www.oracle.com/tw/java/technologies/javase-downloads.html\">Oracle JavaSE 下載地址</a> 下載並安裝。安裝完成後執行 <code>java -version</code>  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 <code>/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home</code> 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin</span><br><span class=\"line\">sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane</span><br><span class=\"line\"></span><br><span class=\"line\">ls /Library/Java/JavaVirtualMachines/</span><br><span class=\"line\">输出：jdk-9.0.1.jdk</span><br><span class=\"line\"></span><br><span class=\"line\">sudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>運行以下代碼，將輸出 <code>Hello World</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java-語言的特點\"><a href=\"#Java-語言的特點\" class=\"headerlink\" title=\"Java 語言的特點\"></a>Java 語言的特點</h3><ol>\n<li>面向對象（封裝，繼承，多態）</li>\n<li>平台無關性（ Java 虛擬機實現平台無關性）</li>\n<li>支持多線程</li>\n<li>編譯與解釋並存</li>\n</ol>\n<p>編譯：生成字節碼(.class文件)，javac 指令。<br>解釋：解釋字節碼成機器碼，java 指令。</p>\n<h3 id=\"JVM、JDK-和-JRE\"><a href=\"#JVM、JDK-和-JRE\" class=\"headerlink\" title=\"JVM、JDK 和  JRE\"></a>JVM、JDK 和  JRE</h3><ol>\n<li>JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。</li>\n<li>JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。</li>\n<li>JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。</li>\n</ol>\n<h3 id=\"Java-與-C-對比\"><a href=\"#Java-與-C-對比\" class=\"headerlink\" title=\"Java 與 C++ 對比\"></a>Java 與 C++ 對比</h3><ol>\n<li>皆支持面向對象編程（封裝、繼承和多態）。</li>\n<li>Java 不提供指針來直接訪問內存；C++ 提供。</li>\n<li>Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。</li>\n<li>Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。</li>\n<li>Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符<code>\\0</code> 來表示結束。</li>\n</ol>\n<h2 id=\"Java-語法\"><a href=\"#Java-語法\" class=\"headerlink\" title=\"Java 語法\"></a>Java 語法</h2><h3 id=\"基本類型及其大小\"><a href=\"#基本類型及其大小\" class=\"headerlink\" title=\"基本類型及其大小\"></a>基本類型及其大小</h3><p>Java 共 8 種數據類型（不包括 void），具體如下表：</p>\n<p><img src=\"/2021/02/06/it/java/java-basic/20201202_24328.png\" alt></p>\n<p>boolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。</p>\n<p>char 值是一個 16 位的 Unicode 字符，最小值是 ‘\\u0000’ ，最大值是 ‘\\uffff’，即 0～65535，每個數字對應一個字符。</p>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a = <span class=\"string\">&#x27;中&#x27;</span>;</span><br><span class=\"line\">System.out.println((<span class=\"keyword\">int</span>)a);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 20013</span></span><br><span class=\"line\">System.out.println(Integer.toHexString(a));</span><br><span class=\"line\"><span class=\"comment\">// 輸出 4e2d</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&#x27;\\u4e2d&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 中</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>byte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。</p>\n<ul>\n<li>二進制補碼<ul>\n<li>過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。</li>\n<li>原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 <a href=\"https://www.ruanyifeng.com/blog/2009/08/twos_complement.html\">https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm</a>l</li>\n</ul>\n</li>\n</ul>\n<p>long 類型的數據後面一定要加上 L，否則會被認為是整型。</p>\n<p>char 類型值使用單引號括起來，String 使用雙引號。</p>\n<p>Java 有<strong>自動拆裝箱機制</strong>，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。</p>\n<h3 id=\"包裝類型及常量池技術\"><a href=\"#包裝類型及常量池技術\" class=\"headerlink\" title=\"包裝類型及常量池技術\"></a>包裝類型及常量池技術</h3><ol>\n<li>Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。</li>\n<li>Character 創建了數值在 [0, 127] 的緩存數據。</li>\n<li>Boolean 直接返回 True 和 False。</li>\n<li>Float 和 Double 沒有實現常量池技術。</li>\n</ol>\n<p>使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">33</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">Integer i11 = <span class=\"number\">333</span>;</span><br><span class=\"line\">Integer i22 = <span class=\"number\">333</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">Double i3 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">Double i4 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p>《阿里巴巴Java開發手冊》規定：</p>\n<ul>\n<li>【強制】<strong>所有的 POJO 類屬性必須使用包裝數據類型</strong>。</li>\n<li>【強制】RPC 方法的返回值和參數必須使用包裝數據類型。</li>\n<li>【推薦】所有的局部變量使用基本數據類型。</li>\n</ul>\n<h3 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h3><p><strong>（1）使用 BigDecimal 進行浮點數比較和精度取捨</strong></p>\n<p><strong>（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> a = <span class=\"number\">1.0f</span> - <span class=\"number\">0.9f</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> b = <span class=\"number\">0.9f</span> - <span class=\"number\">0.8f</span>;</span><br><span class=\"line\">System.out.println(a);</span><br><span class=\"line\">System.out.println(b);</span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1.0&quot;</span>);</span><br><span class=\"line\">BigDecimal b = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;0.9&quot;</span>);</span><br><span class=\"line\">BigDecimal c = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;0.8&quot;</span>);</span><br><span class=\"line\">System.out.println(a.subtract(b));</span><br><span class=\"line\">System.out.println(b.subtract(c));</span><br><span class=\"line\">System.out.println(a.subtract(b).equals(b.subtract(c))); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1.1252312&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 取小數點後 2 位，四捨五入</span></span><br><span class=\"line\">BigDecimal scale = a.setScale(<span class=\"number\">2</span>, RoundingMode.HALF_UP);</span><br><span class=\"line\">System.out.println(scale.toString()); <span class=\"comment\">// 1.13</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"對象及其大小\"><a href=\"#對象及其大小\" class=\"headerlink\" title=\"對象及其大小\"></a>對象及其大小</h3><p>基本類型的封裝類型是對象，Java 中的對象由以下部分組成：</p>\n<ol>\n<li>對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。</li>\n<li>實例數據（instance data）：對象的有效信息。</li>\n<li>對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。</li>\n</ol>\n<p>可使用 <code>org.openjdk.jol</code> 工具查看一個對象佔用的字節大小，</p>\n<ul>\n<li><p>如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(VM.current().details());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseClass(Object.class).toPrintable());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseInstance(Integer.valueOf(<span class=\"number\">1</span>)).toPrintable());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  輸出結果：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Running 64-bit HotSpot VM.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed oop with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed klass with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Compressed references base/shifts are guessed by the experiment!</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.</span></span><br><span class=\"line\"><span class=\"comment\"># Objects are 8 bytes aligned.</span></span><br><span class=\"line\"><span class=\"comment\"># Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"><span class=\"comment\"># Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Object object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0    12        (object header)                           N/A</span><br><span class=\"line\">     12     4        (loss due to the next object alignment)</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Integer object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)</span><br><span class=\"line\">      4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)</span><br><span class=\"line\">      8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)</span><br><span class=\"line\">     12     4    int Integer.value                             1</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。</p>\n<h3 id=\"String、StringBuffer-和-String-Builder-的區別\"><a href=\"#String、StringBuffer-和-String-Builder-的區別\" class=\"headerlink\" title=\"String、StringBuffer 和 String Builder 的區別\"></a>String、StringBuffer 和 String Builder 的區別</h3><p>String 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Java 9 之前</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\">  <span class=\"comment\">// Java 9 之後</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>StringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。</p>\n<p>下面從不同角度比較下此三者：</p>\n<ol>\n<li>線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。</li>\n<li>性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。</li>\n</ol>\n<h3 id=\"注釋\"><a href=\"#注釋\" class=\"headerlink\" title=\"注釋\"></a>注釋</h3><p>代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。</p>\n<h3 id=\"標識符和關鍵字的區別\"><a href=\"#標識符和關鍵字的區別\" class=\"headerlink\" title=\"標識符和關鍵字的區別\"></a>標識符和關鍵字的區別</h3><p>標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：</p>\n<ol>\n<li>訪問控制：private、protected、public</li>\n<li>類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile</li>\n<li>程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default</li>\n<li>錯誤處理：try、catch、throw、throws、finally</li>\n<li>包相關：import、package</li>\n<li>基本類型：boolean、byte、char、double、float、int、short、null、true、false</li>\n<li>變量引用：super、this、void</li>\n<li>保留字：goto、const</li>\n</ol>\n<h3 id=\"自增自減運算符\"><a href=\"#自增自減運算符\" class=\"headerlink\" title=\"自增自減運算符\"></a>自增自減運算符</h3><p>符號在前先加減再賦值，符號在後先賦值後加減。假定 <code>a = 1; b = a++</code> 最後 a 值爲 2，b 值爲 1。</p>\n<h3 id=\"和-equals-的區別\"><a href=\"#和-equals-的區別\" class=\"headerlink\" title=\"== 和 equals 的區別\"></a>== 和 equals 的區別</h3><ol>\n<li>基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。</li>\n<li>equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。</li>\n<li>整型包裝類都應使用 equals 比較大小。</li>\n<li>浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。</li>\n</ol>\n<ul>\n<li><p>重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？</p>\n<p>  hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<p>  HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。</p>\n</li>\n</ul>\n<h3 id=\"序列化時如果有些字段不想序列化，怎麼辦？\"><a href=\"#序列化時如果有些字段不想序列化，怎麼辦？\" class=\"headerlink\" title=\"序列化時如果有些字段不想序列化，怎麼辦？\"></a>序列化時如果有些字段不想序列化，怎麼辦？</h3><p>使用 transient 關鍵字修飾不想序列化的字段。</p>\n<h3 id=\"continue、break-和-return-的區別\"><a href=\"#continue、break-和-return-的區別\" class=\"headerlink\" title=\"continue、break 和 return 的區別\"></a>continue、break 和 return 的區別</h3><ol>\n<li>continue：跳出當前這一次循環，繼續下一次循環。</li>\n<li>break：跳出整個循環體，繼續執行循環外的語句。</li>\n<li>return：跳出所在的方法，結束方法，可以帶一個返回值。</li>\n</ol>\n<h3 id=\"泛型、類型擦除和通配符\"><a href=\"#泛型、類型擦除和通配符\" class=\"headerlink\" title=\"泛型、類型擦除和通配符\"></a>泛型、類型擦除和通配符</h3><p><strong>泛型的本質是將類型參數化。</strong>Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲<strong>僞泛型</strong>。下面的例子展示了如何在運行期加入非法類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"comment\">//這裡直接添加會報錯</span></span><br><span class=\"line\"><span class=\"comment\">// list.add(&quot;a&quot;);</span></span><br><span class=\"line\">Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class=\"line\">Method add = clazz.getDeclaredMethod(<span class=\"string\">&quot;add&quot;</span>, Object.class);</span><br><span class=\"line\"><span class=\"comment\">//但是通過反射添加，是可以的</span></span><br><span class=\"line\">add.invoke(list, <span class=\"string\">&quot;kl&quot;</span>);</span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<p>泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。</p>\n<p>泛型通配符約定：</p>\n<ol>\n<li>？ 表示不確定的 Java 類型，用於泛型方法</li>\n<li>T（Type）表示確定的一個 Java 類型</li>\n<li>K V（Key Value）分別表示映射中的鍵、值</li>\n<li>E（Element）表示集合中的一個元素</li>\n<li>&lt;? extends A&gt; 上界通配符，表示 A 類型或其子類</li>\n<li>&lt;? super A&gt; 下界通配符，表示 A 類型或其父類</li>\n<li><T extends a> 表示 A 類型或其子類的一種</T></li>\n<li>&lt;T extends A &amp; B&gt; 表示 A 類型且B類型的子類的一種</li>\n<li><del><T super a></T></del> </li>\n</ol>\n<p>泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<Apple> 的引用並不能傳遞給 Plate<Fruit>，但可以傳遞給 Plate&lt;? extends Fruit&gt;。</Fruit></Apple></p>\n<p>元素爲 &lt;? extends E&gt; 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? extends A&gt; list = Arrays.asList(<span class=\"keyword\">new</span> A(), <span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  A a = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(a.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>元素爲 &lt;? super E&gt; 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? <span class=\"keyword\">super</span> B&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> C());</span><br><span class=\"line\">  Object object = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(object.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"獲取鍵盤輸入數據的常用方法\"><a href=\"#獲取鍵盤輸入數據的常用方法\" class=\"headerlink\" title=\"獲取鍵盤輸入數據的常用方法\"></a>獲取鍵盤輸入數據的常用方法</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">String s = scanner.nextLine();</span><br><span class=\"line\">System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException</span></span><br><span class=\"line\">BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">String s1 = bufferedReader.readLine();</span><br><span class=\"line\">System.out.println(s1);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法（函數）\"><a href=\"#方法（函數）\" class=\"headerlink\" title=\"方法（函數）\"></a>方法（函數）</h2><h3 id=\"爲什麼-Java-只有值傳遞？\"><a href=\"#爲什麼-Java-只有值傳遞？\" class=\"headerlink\" title=\"爲什麼 Java 只有值傳遞？\"></a>爲什麼 Java 只有值傳遞？</h3><p>首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：</p>\n<ol>\n<li>按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。</li>\n<li>按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。</li>\n</ol>\n<p><strong>Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  String s1 = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">  String s2 = <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">  swap(s1, s2);</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">&quot;main s1: %s, s2: %s%n&quot;</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">  String tmp = s1;</span><br><span class=\"line\">  s1 = s2;</span><br><span class=\"line\">  s2 = tmp;</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">&quot;swap s1: %s, s2: %s%n&quot;</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 運行結果：</span></span><br><span class=\"line\"><span class=\"comment\">// swap s1: World, s2: Hello</span></span><br><span class=\"line\"><span class=\"comment\">// main s1: Hello, s2: World</span></span><br></pre></td></tr></table></figure>\n\n<p>結論：</p>\n<ol>\n<li>一個方法不能修改一個基本類型的實參。</li>\n<li>一個方法可以改變一個對象類型的實參狀態。</li>\n<li>一個方法不能讓對象類型的實參引用一個新對象。</li>\n</ol>\n<h3 id=\"深拷貝和淺拷貝有什麼不同？\"><a href=\"#深拷貝和淺拷貝有什麼不同？\" class=\"headerlink\" title=\"深拷貝和淺拷貝有什麼不同？\"></a>深拷貝和淺拷貝有什麼不同？</h3><ol>\n<li>淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。</li>\n<li>深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。</li>\n</ol>\n<p><img src=\"/2021/02/06/it/java/java-basic/Untitled.png\" alt></p>\n<h3 id=\"重載和重寫有什麼區別？\"><a href=\"#重載和重寫有什麼區別？\" class=\"headerlink\" title=\"重載和重寫有什麼區別？\"></a>重載和重寫有什麼區別？</h3><ol>\n<li>重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。</li>\n<li>重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。</li>\n</ol>\n<h2 id=\"Java-面向對象\"><a href=\"#Java-面向對象\" class=\"headerlink\" title=\"Java 面向對象\"></a>Java 面向對象</h2><h3 id=\"面向對象和面向過程\"><a href=\"#面向對象和面向過程\" class=\"headerlink\" title=\"面向對象和面向過程\"></a>面向對象和面向過程</h3><ol>\n<li>面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。</li>\n<li>面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。</li>\n</ol>\n<p>Java 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。</p>\n<h3 id=\"構造方法\"><a href=\"#構造方法\" class=\"headerlink\" title=\"構造方法\"></a>構造方法</h3><ol>\n<li>特點：名字跟類名相同，沒有返回值，不可重寫但可重載。</li>\n<li>作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。</li>\n<li>子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。</li>\n</ol>\n<h3 id=\"成員變量和局部變量的區別\"><a href=\"#成員變量和局部變量的區別\" class=\"headerlink\" title=\"成員變量和局部變量的區別\"></a>成員變量和局部變量的區別</h3><ol>\n<li>成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。</li>\n<li>局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。</li>\n</ol>\n<h3 id=\"對象實例和對象引用的區別\"><a href=\"#對象實例和對象引用的區別\" class=\"headerlink\" title=\"對象實例和對象引用的區別\"></a>對象實例和對象引用的區別</h3><ol>\n<li>對象實例：存在於堆內存，一個對象實例可以被多個引用指向。</li>\n<li>對象引用：存在於棧內存，一個引用指向一個對象實例。</li>\n</ol>\n<h3 id=\"面向對象的三大特徵\"><a href=\"#面向對象的三大特徵\" class=\"headerlink\" title=\"面向對象的三大特徵\"></a>面向對象的三大特徵</h3><p><strong>（1）封裝</strong></p>\n<p>封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。</p>\n<p><strong>（2）繼承</strong></p>\n<p>繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：</p>\n<ol>\n<li>子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），<strong>僅僅擁有</strong>。</li>\n<li>子類可以對父類進行擴展，增加新的屬性和方法。</li>\n<li>子類可以重寫父類的方法。</li>\n</ol>\n<p><strong>（3）多態</strong></p>\n<p>多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：</p>\n<ol>\n<li>對象類型和引用類型之間具有繼承/實現關係。</li>\n<li>對象類型不可變，引用類型可變。</li>\n<li>方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。</li>\n<li>父類的引用不能調用「只有子類存在但在父類不存在」的方法。</li>\n<li>如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。</li>\n</ol>\n<h3 id=\"靜態方法內爲什麼不能調用非靜態成員？\"><a href=\"#靜態方法內爲什麼不能調用非靜態成員？\" class=\"headerlink\" title=\"靜態方法內爲什麼不能調用非靜態成員？\"></a><strong>靜態方法內爲什麼不能調用非靜態成員？</strong></h3><p>因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。</p>\n<h3 id=\"接口和抽象類的區別\"><a href=\"#接口和抽象類的區別\" class=\"headerlink\" title=\"接口和抽象類的區別\"></a>接口和抽象類的區別</h3><ol>\n<li>方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。</li>\n<li>變量上：接口只能有 static、final 變量；而抽象類沒有限制。</li>\n<li>繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。</li>\n<li>設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。</li>\n</ol>\n<h2 id=\"Java-核心技術\"><a href=\"#Java-核心技術\" class=\"headerlink\" title=\"Java 核心技術\"></a>Java 核心技術</h2><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>見 <a href=\"https://tsunhua.github.io/2020/12/02/it/java/java-collection/\">Java 集合</a> </p>\n<h3 id=\"反射機制\"><a href=\"#反射機制\" class=\"headerlink\" title=\"反射機制\"></a>反射機制</h3><p><strong>（1）什麼是反射</strong></p>\n<p>Java 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。</p>\n<p><strong>（2）反射的優缺點</strong></p>\n<ol>\n<li>優點：運行時確定類型，動態加載類，提高代碼靈活度。</li>\n<li>缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。</li>\n</ol>\n<p>反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。</p>\n<p><strong>（3）反射的應用場景</strong></p>\n<p>反射是框架設計的靈魂。其應用場景有：</p>\n<ol>\n<li>模塊化開發；</li>\n<li>動態代理設計模式；</li>\n<li>Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；</li>\n<li>JDBC 連接數據庫等等。</li>\n</ol>\n<h3 id=\"異常\"><a href=\"#異常\" class=\"headerlink\" title=\"異常\"></a>異常</h3><p><strong>（1）簡介</strong></p>\n<p>Java 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。<strong>Error 通常是 JVM 錯誤，程序無法處理</strong>；<strong>而 Exception 是程序本身可以處理的異常</strong>。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。</p>\n<p><img src=\"/2021/02/06/it/java/java-basic/Untitled%201.png\" alt></p>\n<p><strong>Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）</strong>，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：</p>\n<ul>\n<li><em>IOException</em></li>\n<li><em>EOFException</em></li>\n<li><em>MalFormedURLException</em></li>\n<li><em>IntruptedException</em></li>\n</ul>\n<p><strong>Unchecked Exception 又名 Runtime Exceptions（運行時異常）</strong>，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：</p>\n<ul>\n<li><em>ArithmaticException</em></li>\n<li><em>NullPointerException</em></li>\n<li><em>IndexOutOfBoundsException</em></li>\n<li><em>ClassCastException</em></li>\n<li><em>ArrayIndexOutOfBoundsException</em></li>\n<li><em>NumberFormatException</em></li>\n</ul>\n<p><strong>（2）Throwable 類常用方法</strong></p>\n<ol>\n<li><code>getMessage</code>：返回異常的簡要描述</li>\n<li><code>toString</code>：返回異常的詳細信息</li>\n<li><code>getLocalizedMessage</code>：返回異常的本地化信息（需要子類覆蓋該方法，否則與 <code>getMessage</code> 一樣）</li>\n<li><code>printStackTrace</code>：在控制台打印 Throwable 对象封装的异常信息</li>\n</ol>\n<p><strong>（3）try-catch-finally</strong></p>\n<ol>\n<li>try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。</li>\n<li>catch 代碼塊：處理捕獲到的異常。</li>\n<li>finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value * value;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// f(2) 將返回 0 ，而不是 4.</span></span><br></pre></td></tr></table></figure>\n\n<p>以下情況，finally 代碼塊不會被執行或只部分執行：</p>\n<ol>\n<li>finally 代碼塊中有異常，代碼會中異常處中止；</li>\n<li>在 catch 代碼塊或 finally 塊中調用了 <code>System.exit</code> 函數退出程序；</li>\n<li>程序所在的線程死亡等等不可預料的系統和硬件問題。</li>\n</ol>\n<p><strong>（4）try-witch-resources</strong></p>\n<p>Java 7 中新增了 ****try-witch-resources 語法糖，適用於實現<code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try-catch-finally</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;src/main/resources/test.txt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (scanner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        scanner.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// try-witch-resources</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (Scanner scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;src/main/resources/test.txt&quot;</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多線程\"><a href=\"#多線程\" class=\"headerlink\" title=\"多線程\"></a>多線程</h3><p>見 <a href=\"https://tsunhua.github.io/2020/12/10/it/java/java-concurrent/\">Java 多線程</a> </p>\n<h3 id=\"文件與-I-O-流\"><a href=\"#文件與-I-O-流\" class=\"headerlink\" title=\"文件與 I/O 流\"></a>文件與 I/O 流</h3><p><strong>（1）Java 中 I/O 流分爲幾種？</strong></p>\n<p>按不同的分類方法有不同的分類：</p>\n<ol>\n<li>按流向分：輸入流、輸出流。</li>\n<li>按操作單元分：字節流、字符流。</li>\n<li>按角色分：節點流、處理流。</li>\n</ol>\n<p>Java 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：</p>\n<ol>\n<li>InputStream：字節輸入流</li>\n<li>Reader：字符輸入流</li>\n<li>OutputStream：字節輸出流</li>\n<li>Writer：字符輸出流</li>\n</ol>\n<p><img src=\"/2021/02/06/it/java/java-basic/Untitled%202.png\" alt></p>\n<p><img src=\"/2021/02/06/it/java/java-basic/Untitled%203.png\" alt></p>\n<p><strong>（2）爲什麼有了字節流還需要字符流？</strong></p>\n<p>不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？</p>\n<p>字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。</p>\n<p><strong>（3）BIO、NIO、AIO 有什麼區別？</strong></p>\n<ol>\n<li><strong>BIO</strong>（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（&lt; 單機 1000）的情況，結合線程池一起使用。</li>\n<li><strong>NIO</strong>（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 <code>java.nio</code> 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。</li>\n<li><strong>AIO</strong>（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。</li>\n</ol>\n<p>NIO 模型：</p>\n<p><img src=\"/2021/02/06/it/java/java-basic/Untitled%204.png\" alt></p>\n<ul>\n<li><p>NIO 服務端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiplexerNioServer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化多路复用器 绑定监听端口</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> port</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MultiplexerNioServer</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<span class=\"comment\">//获得一个serverChannel</span></span><br><span class=\"line\">            selector = Selector.open();<span class=\"comment\">////创建选择器  获得一个多路复用器</span></span><br><span class=\"line\">            serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);<span class=\"comment\">//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(port), <span class=\"number\">1024</span>);<span class=\"comment\">//绑定一个端口和等待队列长度</span></span><br><span class=\"line\">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<span class=\"comment\">//把selector注册到channel，关注链接事件</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>; <span class=\"comment\">// 优雅停机</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> client = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;1:&quot;</span> + client);</span><br><span class=\"line\">                <span class=\"comment\">// 阻塞,只有当至少一个注册的事件发生的时候才会继续.</span></span><br><span class=\"line\">                <span class=\"comment\">// int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;2:&quot;</span> + client);</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//处理事件</span></span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// selector关闭后会自动释放里面管理的资源</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//连接事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                <span class=\"comment\">// 通过ServerSocketChannel的accept创建SocketChannel实例</span></span><br><span class=\"line\">                <span class=\"comment\">// 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span></span><br><span class=\"line\">                SocketChannel sc = ssc.accept();<span class=\"comment\">//3次握手</span></span><br><span class=\"line\">                sc.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                sc.register(selector, SelectionKey.OP_READ);<span class=\"comment\">//连接建立后关注读事件</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//读事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">                ByteBuffer readbuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);<span class=\"comment\">//写 0 1024  1024</span></span><br><span class=\"line\"><span class=\"comment\">//                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存</span></span><br><span class=\"line\">                <span class=\"comment\">// 读取请求码流，返回读取到的字节数</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> readBytes = socketChannel.read(readbuffer);</span><br><span class=\"line\">                    <span class=\"comment\">// 读取到字节，对字节进行编解码</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span></span><br><span class=\"line\">                        readbuffer.flip();<span class=\"comment\">//读写模式反转</span></span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区可读字节数组复制到新建的数组中</span></span><br><span class=\"line\">                        <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readbuffer.remaining()];</span><br><span class=\"line\">                        readbuffer.get(bytes);</span><br><span class=\"line\">                        String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;input is:&quot;</span> + body);</span><br><span class=\"line\">                        res(socketChannel, body);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 链路已经关闭 释放资源</span></span><br><span class=\"line\">                        key.cancel();</span><br><span class=\"line\">                        socketChannel.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 没有读到字节忽略</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">res</span><span class=\"params\">(SocketChannel channel, String response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span> &amp;&amp; response.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = response.getBytes();</span><br><span class=\"line\">            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class=\"line\">            writeBuffer.put(bytes);</span><br><span class=\"line\">            writeBuffer.flip();</span><br><span class=\"line\">            channel.write(writeBuffer);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;res end&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NIO 客戶端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioClientHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String host;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SocketChannel socketChannel;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NioClientHandler</span><span class=\"params\">(String host, <span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.host = host;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建选择器</span></span><br><span class=\"line\">            selector = Selector.open();</span><br><span class=\"line\">            <span class=\"comment\">// 打开监听通道</span></span><br><span class=\"line\">            socketChannel = SocketChannel.open();</span><br><span class=\"line\">            <span class=\"comment\">// 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            socketChannel.configureBlocking(<span class=\"keyword\">false</span>); <span class=\"comment\">// 开启非阻塞模式</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doConnect();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> wait = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wait == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doConnect</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(host, port))) &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">            doWrite(socketChannel);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc.finishConnect()) &#123;</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    doWrite(sc);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                ByteBuffer readBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> readBytes = sc.read(readBuffer);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    readBuffer.flip();</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readBuffer.remaining()];</span><br><span class=\"line\">                    readBuffer.get(bytes);</span><br><span class=\"line\">                    String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;res&quot;</span> + body);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    key.cancel();</span><br><span class=\"line\">                    sc.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doWrite</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将消息编码为字节数组</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] request = <span class=\"string\">&quot;Hello&quot;</span>.getBytes();</span><br><span class=\"line\">        <span class=\"comment\">// 根据数组容量创建ByteBuffer</span></span><br><span class=\"line\">        ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);</span><br><span class=\"line\">        <span class=\"comment\">// 将字节数组复制到缓冲区</span></span><br><span class=\"line\">        writeBuffer.put(request);</span><br><span class=\"line\">        <span class=\"comment\">// flip读写切换操作</span></span><br><span class=\"line\">        writeBuffer.flip();</span><br><span class=\"line\">        sc.write(writeBuffer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!writeBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;写入完成&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"Java-項目管理和構建\"><a href=\"#Java-項目管理和構建\" class=\"headerlink\" title=\"Java 項目管理和構建\"></a>Java 項目管理和構建</h2><h3 id=\"Maven-项目\"><a href=\"#Maven-项目\" class=\"headerlink\" title=\"Maven 项目\"></a>Maven 项目</h3><p><strong>（1）安装</strong></p>\n<p>從 <a href=\"https://maven.apache.org/download.cgi\">Maven 官網</a>下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。</p>\n<p><strong>（2）初始化一個 Maven 項目</strong></p>\n<p>使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure>\n\n<p>或者用 IDEA 直接新建一個 Maven 項目，其結構如下：</p>\n<p><img src=\"/2021/02/06/it/java/java-basic/20201114_101407.png\" alt></p>\n<p>其中 pom.xml 的內容如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.example<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>testmaven<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--  添加以下屬性，解決編譯報錯  --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.encoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.encoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 新增依賴在下方 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.openjdk.jol<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jol-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.14<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>為什麼叫 Maven？</p>\n<p>  Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。</p>\n</li>\n<li><p>POM 又是指什麼？</p>\n<p>  POM（project object model）項目對象模型，maven 使用 <code>pom.xml</code> 定義了整個項目的構建、報告和文檔。</p>\n</li>\n</ul>\n<p><strong>（3）編譯測試打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理 target 中的文件</span></span><br><span class=\"line\">mvn clean</span><br><span class=\"line\"><span class=\"comment\"># 編譯 java 文件成 class 文件，置於 target/classes 文件夾中</span></span><br><span class=\"line\">mvn compile</span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">mvn <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># 打包成 jar 文件，置於 target 文件夾中</span></span><br><span class=\"line\">mvn package</span><br><span class=\"line\"><span class=\"comment\"># 安裝 jar 包到本地存儲庫（$&#123;user.home&#125;/.m2/repository）</span></span><br><span class=\"line\">mvn install</span><br><span class=\"line\"><span class=\"comment\"># 生成自己的 maven 站點</span></span><br><span class=\"line\">mvn site</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>SNAPSHOT 是什麼？</p>\n<p>  snapshot 簡要的意思，在版本號之後添加 <code>-SNAPSHOT</code> 是說明該版本仍處於開發階段，不是最終的發行版本。以 <code>x.y-SNAPSHOT</code> 版本為例，發行時會去除 <code>-SNAPSHOT</code>  後綴，然後將最新的開發版本升爲<code>x.(y+1)-SNAPSHOT</code> 。</p>\n</li>\n<li><p>使用 mvn compile 生成的 jar 包，其內容是怎樣的？</p>\n<p>  除了 class 文件外，還有 <code>META-INF</code> 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（<code>main/resources</code> ）的文件也會被打包到<code>META-INF</code> 文件夾中，代碼中可通過<code>getClass().getResourceAsStream( &quot;/application.properties&quot; )</code> 調用。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ jar tf target/testmaven-1.0-SNAPSHOT.jar </span><br><span class=\"line\">META-INF/</span><br><span class=\"line\">META-INF/MANIFEST.MF</span><br><span class=\"line\">B.class</span><br><span class=\"line\">MemoryLayoutTest.class</span><br><span class=\"line\">A.class</span><br><span class=\"line\">C.class</span><br><span class=\"line\">META-INF/maven/</span><br><span class=\"line\">META-INF/maven/org.example/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.xml</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.properties</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"Gradle-项目\"><a href=\"#Gradle-项目\" class=\"headerlink\" title=\"Gradle 项目\"></a>Gradle 项目</h3><p><strong>（1）安裝</strong></p>\n<p>可從 <a href=\"https://www.gradle.org/downloads\">gradle 官網</a>下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 <code>brew install gradle</code> 的方式安裝。或者直接使用 IDEA 項目中的 <code>gradle-wrapper</code> ，此時對應的 <code>gradle</code> 命令變爲 <code>gradlew</code>。</p>\n<p><strong>（2）gradle 命令能做什麼？</strong></p>\n<p>gradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gradle tasks</span><br><span class=\"line\"></span><br><span class=\"line\">:tasks</span><br><span class=\"line\"></span><br><span class=\"line\">== All tasks runnable from root project</span><br><span class=\"line\"></span><br><span class=\"line\">== Build Setup tasks</span><br><span class=\"line\">setupBuild - Initializes a new Gradle build. [incubating]</span><br><span class=\"line\"></span><br><span class=\"line\">== Help tasks</span><br><span class=\"line\">dependencies - Displays all dependencies declared <span class=\"keyword\">in</span> root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">dependencyInsight - Displays the insight into a specific dependency <span class=\"keyword\">in</span> root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\"><span class=\"built_in\">help</span> - Displays a <span class=\"built_in\">help</span> message</span><br><span class=\"line\">projects - Displays the sub-projects of root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">properties - Displays the properties of root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">tasks - Displays the tasks runnable from root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">To see all tasks and more detail, run with --all.</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL</span><br><span class=\"line\"></span><br><span class=\"line\">Total time: 3.077 secs</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）初始化一個 Gradle 項目</strong></p>\n<p>在項目文件夾中新建一個名爲 <code>build.gradle</code> 的文件，其內容如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;java&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>隨後新建一個名爲 <code>settings.gradle</code> 的文件，其內容可暫時爲空。</p>\n<p>在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 <code>gradle-wrapper</code> ，其過程等價於執行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gradle wrapper --gradle-version 6.5</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）編譯打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包</span></span><br><span class=\"line\">gradle build</span><br><span class=\"line\"><span class=\"comment\"># 或使用 gradle wrapper</span></span><br><span class=\"line\">./gradlew build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理生成的文件</span></span><br><span class=\"line\">gradle clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成 jar 文件</span></span><br><span class=\"line\">gradle jar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 運行生成的 jar 文件</span></span><br><span class=\"line\">gradle run</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">gradle <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）<code>build.gradle</code> 中可配置什麼？</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置插件，插件提供語法定義</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;application&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置入口類</span></span><br><span class=\"line\">mainClassName = <span class=\"string\">&#x27;hello.HelloWorld&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴倉庫</span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置生成的 jar 文件的入口類</span></span><br><span class=\"line\">jar &#123;</span><br><span class=\"line\">    manifest &#123;</span><br><span class=\"line\">        attributes <span class=\"string\">&#x27;Main-Class&#x27;</span>: mainClassName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置 JDK 兼容性</span></span><br><span class=\"line\">sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">targetCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile <span class=\"string\">&quot;joda-time:joda-time:2.2&quot;</span></span><br><span class=\"line\">    testCompile <span class=\"string\">&quot;junit:junit:4.12&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如需將所有依賴 jar 打進同一個 jar 包，可使用 <a href=\"https://github.com/johnrengelman/shadow\">shadow 插件</a>或使用 <a href=\"https://spring.io/quickstart\">spring boot 插件</a>。</p>\n","site":{"data":{}},"excerpt":"<p>Java 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。</p>\n<ul>\n<li>它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。</li>\n<li>它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。</li>\n<li>它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。</li>\n<li>它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。</li>\n<li>它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。</li>\n<li>它提供了豐富的集合類、迭代器及工具類。</li>\n<li>它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。</li>\n<li>它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。</li>\n<li>它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。</li>\n<li>另外，目前有兩大項目管理工具，Maven 和 Gradle。</li>\n</ul>","more":"<h2 id=\"Java-入門（基礎概念與常識）\"><a href=\"#Java-入門（基礎概念與常識）\" class=\"headerlink\" title=\"Java 入門（基礎概念與常識）\"></a>Java 入門（基礎概念與常識）</h2><h3 id=\"歷史\"><a href=\"#歷史\" class=\"headerlink\" title=\"歷史\"></a>歷史</h3><p>Java 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 <code>CA FE BA BE</code> ，即 cafe babe （咖啡寶貝）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexdump Test.class</span><br><span class=\"line\"><span class=\"number\">0000000</span> ca fe ba be <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> 3b <span class=\"number\">00</span> <span class=\"number\">51</span> 0a <span class=\"number\">00</span> <span class=\"number\">02</span> <span class=\"number\">00</span> <span class=\"number\">03</span> <span class=\"number\">07</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1994 年完成 1.0 版本。</li>\n<li>1995 年首次對外發佈，Java 語言誕生。</li>\n<li>1996 年JDK 1.0 誕生。</li>\n<li>2004 年 SUN 公司發佈 Java SE 5。</li>\n<li>2005 年 SUN 公司發佈 Java SE 6。</li>\n<li>2006 年 SUN 公司推出 OpenJDK 計劃。</li>\n<li>2014年 Oracle 公司發佈 Java SE 8。</li>\n<li>2017年 Oracle公司發佈 Java SE 9。</li>\n<li>2020 年 Oracle 公司發佈 Java SE 15。</li>\n</ul>\n<h3 id=\"安裝與卸載JDK\"><a href=\"#安裝與卸載JDK\" class=\"headerlink\" title=\"安裝與卸載JDK\"></a>安裝與卸載JDK</h3><p>在 Mac 環境下，從 <a href=\"https://www.oracle.com/tw/java/technologies/javase-downloads.html\">Oracle JavaSE 下載地址</a> 下載並安裝。安裝完成後執行 <code>java -version</code>  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 <code>/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home</code> 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin</span><br><span class=\"line\">sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane</span><br><span class=\"line\"></span><br><span class=\"line\">ls /Library/Java/JavaVirtualMachines/</span><br><span class=\"line\">输出：jdk-9.0.1.jdk</span><br><span class=\"line\"></span><br><span class=\"line\">sudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>運行以下代碼，將輸出 <code>Hello World</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java-語言的特點\"><a href=\"#Java-語言的特點\" class=\"headerlink\" title=\"Java 語言的特點\"></a>Java 語言的特點</h3><ol>\n<li>面向對象（封裝，繼承，多態）</li>\n<li>平台無關性（ Java 虛擬機實現平台無關性）</li>\n<li>支持多線程</li>\n<li>編譯與解釋並存</li>\n</ol>\n<p>編譯：生成字節碼(.class文件)，javac 指令。<br>解釋：解釋字節碼成機器碼，java 指令。</p>\n<h3 id=\"JVM、JDK-和-JRE\"><a href=\"#JVM、JDK-和-JRE\" class=\"headerlink\" title=\"JVM、JDK 和  JRE\"></a>JVM、JDK 和  JRE</h3><ol>\n<li>JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。</li>\n<li>JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。</li>\n<li>JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。</li>\n</ol>\n<h3 id=\"Java-與-C-對比\"><a href=\"#Java-與-C-對比\" class=\"headerlink\" title=\"Java 與 C++ 對比\"></a>Java 與 C++ 對比</h3><ol>\n<li>皆支持面向對象編程（封裝、繼承和多態）。</li>\n<li>Java 不提供指針來直接訪問內存；C++ 提供。</li>\n<li>Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。</li>\n<li>Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。</li>\n<li>Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符<code>\\0</code> 來表示結束。</li>\n</ol>\n<h2 id=\"Java-語法\"><a href=\"#Java-語法\" class=\"headerlink\" title=\"Java 語法\"></a>Java 語法</h2><h3 id=\"基本類型及其大小\"><a href=\"#基本類型及其大小\" class=\"headerlink\" title=\"基本類型及其大小\"></a>基本類型及其大小</h3><p>Java 共 8 種數據類型（不包括 void），具體如下表：</p>\n<p><img src=\"/2021/02/06/it/java/java-basic/20201202_24328.png\" alt></p>\n<p>boolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。</p>\n<p>char 值是一個 16 位的 Unicode 字符，最小值是 ‘\\u0000’ ，最大值是 ‘\\uffff’，即 0～65535，每個數字對應一個字符。</p>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a = <span class=\"string\">&#x27;中&#x27;</span>;</span><br><span class=\"line\">System.out.println((<span class=\"keyword\">int</span>)a);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 20013</span></span><br><span class=\"line\">System.out.println(Integer.toHexString(a));</span><br><span class=\"line\"><span class=\"comment\">// 輸出 4e2d</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&#x27;\\u4e2d&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 中</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>byte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。</p>\n<ul>\n<li>二進制補碼<ul>\n<li>過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。</li>\n<li>原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 <a href=\"https://www.ruanyifeng.com/blog/2009/08/twos_complement.html\">https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm</a>l</li>\n</ul>\n</li>\n</ul>\n<p>long 類型的數據後面一定要加上 L，否則會被認為是整型。</p>\n<p>char 類型值使用單引號括起來，String 使用雙引號。</p>\n<p>Java 有<strong>自動拆裝箱機制</strong>，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。</p>\n<h3 id=\"包裝類型及常量池技術\"><a href=\"#包裝類型及常量池技術\" class=\"headerlink\" title=\"包裝類型及常量池技術\"></a>包裝類型及常量池技術</h3><ol>\n<li>Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。</li>\n<li>Character 創建了數值在 [0, 127] 的緩存數據。</li>\n<li>Boolean 直接返回 True 和 False。</li>\n<li>Float 和 Double 沒有實現常量池技術。</li>\n</ol>\n<p>使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">33</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">Integer i11 = <span class=\"number\">333</span>;</span><br><span class=\"line\">Integer i22 = <span class=\"number\">333</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">Double i3 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">Double i4 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p>《阿里巴巴Java開發手冊》規定：</p>\n<ul>\n<li>【強制】<strong>所有的 POJO 類屬性必須使用包裝數據類型</strong>。</li>\n<li>【強制】RPC 方法的返回值和參數必須使用包裝數據類型。</li>\n<li>【推薦】所有的局部變量使用基本數據類型。</li>\n</ul>\n<h3 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h3><p><strong>（1）使用 BigDecimal 進行浮點數比較和精度取捨</strong></p>\n<p><strong>（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> a = <span class=\"number\">1.0f</span> - <span class=\"number\">0.9f</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> b = <span class=\"number\">0.9f</span> - <span class=\"number\">0.8f</span>;</span><br><span class=\"line\">System.out.println(a);</span><br><span class=\"line\">System.out.println(b);</span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1.0&quot;</span>);</span><br><span class=\"line\">BigDecimal b = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;0.9&quot;</span>);</span><br><span class=\"line\">BigDecimal c = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;0.8&quot;</span>);</span><br><span class=\"line\">System.out.println(a.subtract(b));</span><br><span class=\"line\">System.out.println(b.subtract(c));</span><br><span class=\"line\">System.out.println(a.subtract(b).equals(b.subtract(c))); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1.1252312&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 取小數點後 2 位，四捨五入</span></span><br><span class=\"line\">BigDecimal scale = a.setScale(<span class=\"number\">2</span>, RoundingMode.HALF_UP);</span><br><span class=\"line\">System.out.println(scale.toString()); <span class=\"comment\">// 1.13</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"對象及其大小\"><a href=\"#對象及其大小\" class=\"headerlink\" title=\"對象及其大小\"></a>對象及其大小</h3><p>基本類型的封裝類型是對象，Java 中的對象由以下部分組成：</p>\n<ol>\n<li>對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。</li>\n<li>實例數據（instance data）：對象的有效信息。</li>\n<li>對齊填充（padding）：Hotspot 虛擬機的自動內存管理系統要求對象起始地址必須是 8 字節的整數倍，當實例數據不足時需要進行對齊填充。</li>\n</ol>\n<p>可使用 <code>org.openjdk.jol</code> 工具查看一個對象佔用的字節大小，</p>\n<ul>\n<li><p>如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(VM.current().details());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseClass(Object.class).toPrintable());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseInstance(Integer.valueOf(<span class=\"number\">1</span>)).toPrintable());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  輸出結果：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Running 64-bit HotSpot VM.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed oop with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed klass with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Compressed references base/shifts are guessed by the experiment!</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.</span></span><br><span class=\"line\"><span class=\"comment\"># Objects are 8 bytes aligned.</span></span><br><span class=\"line\"><span class=\"comment\"># Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"><span class=\"comment\"># Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Object object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0    12        (object header)                           N/A</span><br><span class=\"line\">     12     4        (loss due to the next object alignment)</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Integer object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)</span><br><span class=\"line\">      4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)</span><br><span class=\"line\">      8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)</span><br><span class=\"line\">     12     4    int Integer.value                             1</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。</p>\n<h3 id=\"String、StringBuffer-和-String-Builder-的區別\"><a href=\"#String、StringBuffer-和-String-Builder-的區別\" class=\"headerlink\" title=\"String、StringBuffer 和 String Builder 的區別\"></a>String、StringBuffer 和 String Builder 的區別</h3><p>String 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Java 9 之前</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\">  <span class=\"comment\">// Java 9 之後</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>StringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。</p>\n<p>下面從不同角度比較下此三者：</p>\n<ol>\n<li>線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。</li>\n<li>性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。</li>\n</ol>\n<h3 id=\"注釋\"><a href=\"#注釋\" class=\"headerlink\" title=\"注釋\"></a>注釋</h3><p>代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。</p>\n<h3 id=\"標識符和關鍵字的區別\"><a href=\"#標識符和關鍵字的區別\" class=\"headerlink\" title=\"標識符和關鍵字的區別\"></a>標識符和關鍵字的區別</h3><p>標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：</p>\n<ol>\n<li>訪問控制：private、protected、public</li>\n<li>類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile</li>\n<li>程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default</li>\n<li>錯誤處理：try、catch、throw、throws、finally</li>\n<li>包相關：import、package</li>\n<li>基本類型：boolean、byte、char、double、float、int、short、null、true、false</li>\n<li>變量引用：super、this、void</li>\n<li>保留字：goto、const</li>\n</ol>\n<h3 id=\"自增自減運算符\"><a href=\"#自增自減運算符\" class=\"headerlink\" title=\"自增自減運算符\"></a>自增自減運算符</h3><p>符號在前先加減再賦值，符號在後先賦值後加減。假定 <code>a = 1; b = a++</code> 最後 a 值爲 2，b 值爲 1。</p>\n<h3 id=\"和-equals-的區別\"><a href=\"#和-equals-的區別\" class=\"headerlink\" title=\"== 和 equals 的區別\"></a>== 和 equals 的區別</h3><ol>\n<li>基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。</li>\n<li>equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。</li>\n<li>整型包裝類都應使用 equals 比較大小。</li>\n<li>浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。</li>\n</ol>\n<ul>\n<li><p>重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？</p>\n<p>  hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<p>  HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。</p>\n</li>\n</ul>\n<h3 id=\"序列化時如果有些字段不想序列化，怎麼辦？\"><a href=\"#序列化時如果有些字段不想序列化，怎麼辦？\" class=\"headerlink\" title=\"序列化時如果有些字段不想序列化，怎麼辦？\"></a>序列化時如果有些字段不想序列化，怎麼辦？</h3><p>使用 transient 關鍵字修飾不想序列化的字段。</p>\n<h3 id=\"continue、break-和-return-的區別\"><a href=\"#continue、break-和-return-的區別\" class=\"headerlink\" title=\"continue、break 和 return 的區別\"></a>continue、break 和 return 的區別</h3><ol>\n<li>continue：跳出當前這一次循環，繼續下一次循環。</li>\n<li>break：跳出整個循環體，繼續執行循環外的語句。</li>\n<li>return：跳出所在的方法，結束方法，可以帶一個返回值。</li>\n</ol>\n<h3 id=\"泛型、類型擦除和通配符\"><a href=\"#泛型、類型擦除和通配符\" class=\"headerlink\" title=\"泛型、類型擦除和通配符\"></a>泛型、類型擦除和通配符</h3><p><strong>泛型的本質是將類型參數化。</strong>Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲<strong>僞泛型</strong>。下面的例子展示了如何在運行期加入非法類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"comment\">//這裡直接添加會報錯</span></span><br><span class=\"line\"><span class=\"comment\">// list.add(&quot;a&quot;);</span></span><br><span class=\"line\">Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class=\"line\">Method add = clazz.getDeclaredMethod(<span class=\"string\">&quot;add&quot;</span>, Object.class);</span><br><span class=\"line\"><span class=\"comment\">//但是通過反射添加，是可以的</span></span><br><span class=\"line\">add.invoke(list, <span class=\"string\">&quot;kl&quot;</span>);</span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<p>泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。</p>\n<p>泛型通配符約定：</p>\n<ol>\n<li>？ 表示不確定的 Java 類型，用於泛型方法</li>\n<li>T（Type）表示確定的一個 Java 類型</li>\n<li>K V（Key Value）分別表示映射中的鍵、值</li>\n<li>E（Element）表示集合中的一個元素</li>\n<li>&lt;? extends A&gt; 上界通配符，表示 A 類型或其子類</li>\n<li>&lt;? super A&gt; 下界通配符，表示 A 類型或其父類</li>\n<li><T extends a> 表示 A 類型或其子類的一種</T></li>\n<li>&lt;T extends A &amp; B&gt; 表示 A 類型且B類型的子類的一種</li>\n<li><del><T super a></T></del> </li>\n</ol>\n<p>泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<Apple> 的引用並不能傳遞給 Plate<Fruit>，但可以傳遞給 Plate&lt;? extends Fruit&gt;。</Fruit></Apple></p>\n<p>元素爲 &lt;? extends E&gt; 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? extends A&gt; list = Arrays.asList(<span class=\"keyword\">new</span> A(), <span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  A a = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(a.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>元素爲 &lt;? super E&gt; 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? <span class=\"keyword\">super</span> B&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> C());</span><br><span class=\"line\">  Object object = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(object.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"獲取鍵盤輸入數據的常用方法\"><a href=\"#獲取鍵盤輸入數據的常用方法\" class=\"headerlink\" title=\"獲取鍵盤輸入數據的常用方法\"></a>獲取鍵盤輸入數據的常用方法</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">String s = scanner.nextLine();</span><br><span class=\"line\">System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException</span></span><br><span class=\"line\">BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">String s1 = bufferedReader.readLine();</span><br><span class=\"line\">System.out.println(s1);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法（函數）\"><a href=\"#方法（函數）\" class=\"headerlink\" title=\"方法（函數）\"></a>方法（函數）</h2><h3 id=\"爲什麼-Java-只有值傳遞？\"><a href=\"#爲什麼-Java-只有值傳遞？\" class=\"headerlink\" title=\"爲什麼 Java 只有值傳遞？\"></a>爲什麼 Java 只有值傳遞？</h3><p>首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：</p>\n<ol>\n<li>按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。</li>\n<li>按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。</li>\n</ol>\n<p><strong>Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  String s1 = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">  String s2 = <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\">  swap(s1, s2);</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">&quot;main s1: %s, s2: %s%n&quot;</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">  String tmp = s1;</span><br><span class=\"line\">  s1 = s2;</span><br><span class=\"line\">  s2 = tmp;</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">&quot;swap s1: %s, s2: %s%n&quot;</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 運行結果：</span></span><br><span class=\"line\"><span class=\"comment\">// swap s1: World, s2: Hello</span></span><br><span class=\"line\"><span class=\"comment\">// main s1: Hello, s2: World</span></span><br></pre></td></tr></table></figure>\n\n<p>結論：</p>\n<ol>\n<li>一個方法不能修改一個基本類型的實參。</li>\n<li>一個方法可以改變一個對象類型的實參狀態。</li>\n<li>一個方法不能讓對象類型的實參引用一個新對象。</li>\n</ol>\n<h3 id=\"深拷貝和淺拷貝有什麼不同？\"><a href=\"#深拷貝和淺拷貝有什麼不同？\" class=\"headerlink\" title=\"深拷貝和淺拷貝有什麼不同？\"></a>深拷貝和淺拷貝有什麼不同？</h3><ol>\n<li>淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。</li>\n<li>深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。</li>\n</ol>\n<p><img src=\"/2021/02/06/it/java/java-basic/Untitled.png\" alt></p>\n<h3 id=\"重載和重寫有什麼區別？\"><a href=\"#重載和重寫有什麼區別？\" class=\"headerlink\" title=\"重載和重寫有什麼區別？\"></a>重載和重寫有什麼區別？</h3><ol>\n<li>重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。</li>\n<li>重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。</li>\n</ol>\n<h2 id=\"Java-面向對象\"><a href=\"#Java-面向對象\" class=\"headerlink\" title=\"Java 面向對象\"></a>Java 面向對象</h2><h3 id=\"面向對象和面向過程\"><a href=\"#面向對象和面向過程\" class=\"headerlink\" title=\"面向對象和面向過程\"></a>面向對象和面向過程</h3><ol>\n<li>面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。</li>\n<li>面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。</li>\n</ol>\n<p>Java 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。</p>\n<h3 id=\"構造方法\"><a href=\"#構造方法\" class=\"headerlink\" title=\"構造方法\"></a>構造方法</h3><ol>\n<li>特點：名字跟類名相同，沒有返回值，不可重寫但可重載。</li>\n<li>作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。</li>\n<li>子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。</li>\n</ol>\n<h3 id=\"成員變量和局部變量的區別\"><a href=\"#成員變量和局部變量的區別\" class=\"headerlink\" title=\"成員變量和局部變量的區別\"></a>成員變量和局部變量的區別</h3><ol>\n<li>成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。</li>\n<li>局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。</li>\n</ol>\n<h3 id=\"對象實例和對象引用的區別\"><a href=\"#對象實例和對象引用的區別\" class=\"headerlink\" title=\"對象實例和對象引用的區別\"></a>對象實例和對象引用的區別</h3><ol>\n<li>對象實例：存在於堆內存，一個對象實例可以被多個引用指向。</li>\n<li>對象引用：存在於棧內存，一個引用指向一個對象實例。</li>\n</ol>\n<h3 id=\"面向對象的三大特徵\"><a href=\"#面向對象的三大特徵\" class=\"headerlink\" title=\"面向對象的三大特徵\"></a>面向對象的三大特徵</h3><p><strong>（1）封裝</strong></p>\n<p>封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。</p>\n<p><strong>（2）繼承</strong></p>\n<p>繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：</p>\n<ol>\n<li>子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），<strong>僅僅擁有</strong>。</li>\n<li>子類可以對父類進行擴展，增加新的屬性和方法。</li>\n<li>子類可以重寫父類的方法。</li>\n</ol>\n<p><strong>（3）多態</strong></p>\n<p>多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：</p>\n<ol>\n<li>對象類型和引用類型之間具有繼承/實現關係。</li>\n<li>對象類型不可變，引用類型可變。</li>\n<li>方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。</li>\n<li>父類的引用不能調用「只有子類存在但在父類不存在」的方法。</li>\n<li>如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。</li>\n</ol>\n<h3 id=\"靜態方法內爲什麼不能調用非靜態成員？\"><a href=\"#靜態方法內爲什麼不能調用非靜態成員？\" class=\"headerlink\" title=\"靜態方法內爲什麼不能調用非靜態成員？\"></a><strong>靜態方法內爲什麼不能調用非靜態成員？</strong></h3><p>因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。</p>\n<h3 id=\"接口和抽象類的區別\"><a href=\"#接口和抽象類的區別\" class=\"headerlink\" title=\"接口和抽象類的區別\"></a>接口和抽象類的區別</h3><ol>\n<li>方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。</li>\n<li>變量上：接口只能有 static、final 變量；而抽象類沒有限制。</li>\n<li>繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。</li>\n<li>設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。</li>\n</ol>\n<h2 id=\"Java-核心技術\"><a href=\"#Java-核心技術\" class=\"headerlink\" title=\"Java 核心技術\"></a>Java 核心技術</h2><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>見 <a href=\"https://tsunhua.github.io/2020/12/02/it/java/java-collection/\">Java 集合</a> </p>\n<h3 id=\"反射機制\"><a href=\"#反射機制\" class=\"headerlink\" title=\"反射機制\"></a>反射機制</h3><p><strong>（1）什麼是反射</strong></p>\n<p>Java 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。</p>\n<p><strong>（2）反射的優缺點</strong></p>\n<ol>\n<li>優點：運行時確定類型，動態加載類，提高代碼靈活度。</li>\n<li>缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。</li>\n</ol>\n<p>反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。</p>\n<p><strong>（3）反射的應用場景</strong></p>\n<p>反射是框架設計的靈魂。其應用場景有：</p>\n<ol>\n<li>模塊化開發；</li>\n<li>動態代理設計模式；</li>\n<li>Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；</li>\n<li>JDBC 連接數據庫等等。</li>\n</ol>\n<h3 id=\"異常\"><a href=\"#異常\" class=\"headerlink\" title=\"異常\"></a>異常</h3><p><strong>（1）簡介</strong></p>\n<p>Java 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。<strong>Error 通常是 JVM 錯誤，程序無法處理</strong>；<strong>而 Exception 是程序本身可以處理的異常</strong>。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。</p>\n<p><img src=\"/2021/02/06/it/java/java-basic/Untitled%201.png\" alt></p>\n<p><strong>Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）</strong>，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：</p>\n<ul>\n<li><em>IOException</em></li>\n<li><em>EOFException</em></li>\n<li><em>MalFormedURLException</em></li>\n<li><em>IntruptedException</em></li>\n</ul>\n<p><strong>Unchecked Exception 又名 Runtime Exceptions（運行時異常）</strong>，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：</p>\n<ul>\n<li><em>ArithmaticException</em></li>\n<li><em>NullPointerException</em></li>\n<li><em>IndexOutOfBoundsException</em></li>\n<li><em>ClassCastException</em></li>\n<li><em>ArrayIndexOutOfBoundsException</em></li>\n<li><em>NumberFormatException</em></li>\n</ul>\n<p><strong>（2）Throwable 類常用方法</strong></p>\n<ol>\n<li><code>getMessage</code>：返回異常的簡要描述</li>\n<li><code>toString</code>：返回異常的詳細信息</li>\n<li><code>getLocalizedMessage</code>：返回異常的本地化信息（需要子類覆蓋該方法，否則與 <code>getMessage</code> 一樣）</li>\n<li><code>printStackTrace</code>：在控制台打印 Throwable 对象封装的异常信息</li>\n</ol>\n<p><strong>（3）try-catch-finally</strong></p>\n<ol>\n<li>try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。</li>\n<li>catch 代碼塊：處理捕獲到的異常。</li>\n<li>finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value * value;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// f(2) 將返回 0 ，而不是 4.</span></span><br></pre></td></tr></table></figure>\n\n<p>以下情況，finally 代碼塊不會被執行或只部分執行：</p>\n<ol>\n<li>finally 代碼塊中有異常，代碼會中異常處中止；</li>\n<li>在 catch 代碼塊或 finally 塊中調用了 <code>System.exit</code> 函數退出程序；</li>\n<li>程序所在的線程死亡等等不可預料的系統和硬件問題。</li>\n</ol>\n<p><strong>（4）try-witch-resources</strong></p>\n<p>Java 7 中新增了 ****try-witch-resources 語法糖，適用於實現<code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try-catch-finally</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;src/main/resources/test.txt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (scanner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        scanner.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// try-witch-resources</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (Scanner scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;src/main/resources/test.txt&quot;</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多線程\"><a href=\"#多線程\" class=\"headerlink\" title=\"多線程\"></a>多線程</h3><p>見 <a href=\"https://tsunhua.github.io/2020/12/10/it/java/java-concurrent/\">Java 多線程</a> </p>\n<h3 id=\"文件與-I-O-流\"><a href=\"#文件與-I-O-流\" class=\"headerlink\" title=\"文件與 I/O 流\"></a>文件與 I/O 流</h3><p><strong>（1）Java 中 I/O 流分爲幾種？</strong></p>\n<p>按不同的分類方法有不同的分類：</p>\n<ol>\n<li>按流向分：輸入流、輸出流。</li>\n<li>按操作單元分：字節流、字符流。</li>\n<li>按角色分：節點流、處理流。</li>\n</ol>\n<p>Java 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：</p>\n<ol>\n<li>InputStream：字節輸入流</li>\n<li>Reader：字符輸入流</li>\n<li>OutputStream：字節輸出流</li>\n<li>Writer：字符輸出流</li>\n</ol>\n<p><img src=\"/2021/02/06/it/java/java-basic/Untitled%202.png\" alt></p>\n<p><img src=\"/2021/02/06/it/java/java-basic/Untitled%203.png\" alt></p>\n<p><strong>（2）爲什麼有了字節流還需要字符流？</strong></p>\n<p>不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？</p>\n<p>字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。</p>\n<p><strong>（3）BIO、NIO、AIO 有什麼區別？</strong></p>\n<ol>\n<li><strong>BIO</strong>（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（&lt; 單機 1000）的情況，結合線程池一起使用。</li>\n<li><strong>NIO</strong>（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 <code>java.nio</code> 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。</li>\n<li><strong>AIO</strong>（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。</li>\n</ol>\n<p>NIO 模型：</p>\n<p><img src=\"/2021/02/06/it/java/java-basic/Untitled%204.png\" alt></p>\n<ul>\n<li><p>NIO 服務端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiplexerNioServer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化多路复用器 绑定监听端口</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> port</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MultiplexerNioServer</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<span class=\"comment\">//获得一个serverChannel</span></span><br><span class=\"line\">            selector = Selector.open();<span class=\"comment\">////创建选择器  获得一个多路复用器</span></span><br><span class=\"line\">            serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);<span class=\"comment\">//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(port), <span class=\"number\">1024</span>);<span class=\"comment\">//绑定一个端口和等待队列长度</span></span><br><span class=\"line\">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<span class=\"comment\">//把selector注册到channel，关注链接事件</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>; <span class=\"comment\">// 优雅停机</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> client = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;1:&quot;</span> + client);</span><br><span class=\"line\">                <span class=\"comment\">// 阻塞,只有当至少一个注册的事件发生的时候才会继续.</span></span><br><span class=\"line\">                <span class=\"comment\">// int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;2:&quot;</span> + client);</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//处理事件</span></span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// selector关闭后会自动释放里面管理的资源</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//连接事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                <span class=\"comment\">// 通过ServerSocketChannel的accept创建SocketChannel实例</span></span><br><span class=\"line\">                <span class=\"comment\">// 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span></span><br><span class=\"line\">                SocketChannel sc = ssc.accept();<span class=\"comment\">//3次握手</span></span><br><span class=\"line\">                sc.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                sc.register(selector, SelectionKey.OP_READ);<span class=\"comment\">//连接建立后关注读事件</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//读事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">                ByteBuffer readbuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);<span class=\"comment\">//写 0 1024  1024</span></span><br><span class=\"line\"><span class=\"comment\">//                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存</span></span><br><span class=\"line\">                <span class=\"comment\">// 读取请求码流，返回读取到的字节数</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> readBytes = socketChannel.read(readbuffer);</span><br><span class=\"line\">                    <span class=\"comment\">// 读取到字节，对字节进行编解码</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span></span><br><span class=\"line\">                        readbuffer.flip();<span class=\"comment\">//读写模式反转</span></span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区可读字节数组复制到新建的数组中</span></span><br><span class=\"line\">                        <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readbuffer.remaining()];</span><br><span class=\"line\">                        readbuffer.get(bytes);</span><br><span class=\"line\">                        String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;input is:&quot;</span> + body);</span><br><span class=\"line\">                        res(socketChannel, body);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 链路已经关闭 释放资源</span></span><br><span class=\"line\">                        key.cancel();</span><br><span class=\"line\">                        socketChannel.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 没有读到字节忽略</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">res</span><span class=\"params\">(SocketChannel channel, String response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span> &amp;&amp; response.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = response.getBytes();</span><br><span class=\"line\">            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class=\"line\">            writeBuffer.put(bytes);</span><br><span class=\"line\">            writeBuffer.flip();</span><br><span class=\"line\">            channel.write(writeBuffer);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;res end&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NIO 客戶端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioClientHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String host;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SocketChannel socketChannel;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NioClientHandler</span><span class=\"params\">(String host, <span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.host = host;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建选择器</span></span><br><span class=\"line\">            selector = Selector.open();</span><br><span class=\"line\">            <span class=\"comment\">// 打开监听通道</span></span><br><span class=\"line\">            socketChannel = SocketChannel.open();</span><br><span class=\"line\">            <span class=\"comment\">// 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            socketChannel.configureBlocking(<span class=\"keyword\">false</span>); <span class=\"comment\">// 开启非阻塞模式</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doConnect();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> wait = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wait == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doConnect</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(host, port))) &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">            doWrite(socketChannel);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc.finishConnect()) &#123;</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    doWrite(sc);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                ByteBuffer readBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> readBytes = sc.read(readBuffer);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    readBuffer.flip();</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readBuffer.remaining()];</span><br><span class=\"line\">                    readBuffer.get(bytes);</span><br><span class=\"line\">                    String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;res&quot;</span> + body);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    key.cancel();</span><br><span class=\"line\">                    sc.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doWrite</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将消息编码为字节数组</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] request = <span class=\"string\">&quot;Hello&quot;</span>.getBytes();</span><br><span class=\"line\">        <span class=\"comment\">// 根据数组容量创建ByteBuffer</span></span><br><span class=\"line\">        ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);</span><br><span class=\"line\">        <span class=\"comment\">// 将字节数组复制到缓冲区</span></span><br><span class=\"line\">        writeBuffer.put(request);</span><br><span class=\"line\">        <span class=\"comment\">// flip读写切换操作</span></span><br><span class=\"line\">        writeBuffer.flip();</span><br><span class=\"line\">        sc.write(writeBuffer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!writeBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;写入完成&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"Java-項目管理和構建\"><a href=\"#Java-項目管理和構建\" class=\"headerlink\" title=\"Java 項目管理和構建\"></a>Java 項目管理和構建</h2><h3 id=\"Maven-项目\"><a href=\"#Maven-项目\" class=\"headerlink\" title=\"Maven 项目\"></a>Maven 项目</h3><p><strong>（1）安装</strong></p>\n<p>從 <a href=\"https://maven.apache.org/download.cgi\">Maven 官網</a>下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。</p>\n<p><strong>（2）初始化一個 Maven 項目</strong></p>\n<p>使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure>\n\n<p>或者用 IDEA 直接新建一個 Maven 項目，其結構如下：</p>\n<p><img src=\"/2021/02/06/it/java/java-basic/20201114_101407.png\" alt></p>\n<p>其中 pom.xml 的內容如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.example<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>testmaven<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--  添加以下屬性，解決編譯報錯  --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.encoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.encoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 新增依賴在下方 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.openjdk.jol<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jol-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.14<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>為什麼叫 Maven？</p>\n<p>  Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。</p>\n</li>\n<li><p>POM 又是指什麼？</p>\n<p>  POM（project object model）項目對象模型，maven 使用 <code>pom.xml</code> 定義了整個項目的構建、報告和文檔。</p>\n</li>\n</ul>\n<p><strong>（3）編譯測試打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理 target 中的文件</span></span><br><span class=\"line\">mvn clean</span><br><span class=\"line\"><span class=\"comment\"># 編譯 java 文件成 class 文件，置於 target/classes 文件夾中</span></span><br><span class=\"line\">mvn compile</span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">mvn <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># 打包成 jar 文件，置於 target 文件夾中</span></span><br><span class=\"line\">mvn package</span><br><span class=\"line\"><span class=\"comment\"># 安裝 jar 包到本地存儲庫（$&#123;user.home&#125;/.m2/repository）</span></span><br><span class=\"line\">mvn install</span><br><span class=\"line\"><span class=\"comment\"># 生成自己的 maven 站點</span></span><br><span class=\"line\">mvn site</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>SNAPSHOT 是什麼？</p>\n<p>  snapshot 簡要的意思，在版本號之後添加 <code>-SNAPSHOT</code> 是說明該版本仍處於開發階段，不是最終的發行版本。以 <code>x.y-SNAPSHOT</code> 版本為例，發行時會去除 <code>-SNAPSHOT</code>  後綴，然後將最新的開發版本升爲<code>x.(y+1)-SNAPSHOT</code> 。</p>\n</li>\n<li><p>使用 mvn compile 生成的 jar 包，其內容是怎樣的？</p>\n<p>  除了 class 文件外，還有 <code>META-INF</code> 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（<code>main/resources</code> ）的文件也會被打包到<code>META-INF</code> 文件夾中，代碼中可通過<code>getClass().getResourceAsStream( &quot;/application.properties&quot; )</code> 調用。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ jar tf target/testmaven-1.0-SNAPSHOT.jar </span><br><span class=\"line\">META-INF/</span><br><span class=\"line\">META-INF/MANIFEST.MF</span><br><span class=\"line\">B.class</span><br><span class=\"line\">MemoryLayoutTest.class</span><br><span class=\"line\">A.class</span><br><span class=\"line\">C.class</span><br><span class=\"line\">META-INF/maven/</span><br><span class=\"line\">META-INF/maven/org.example/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.xml</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.properties</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"Gradle-项目\"><a href=\"#Gradle-项目\" class=\"headerlink\" title=\"Gradle 项目\"></a>Gradle 项目</h3><p><strong>（1）安裝</strong></p>\n<p>可從 <a href=\"https://www.gradle.org/downloads\">gradle 官網</a>下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 <code>brew install gradle</code> 的方式安裝。或者直接使用 IDEA 項目中的 <code>gradle-wrapper</code> ，此時對應的 <code>gradle</code> 命令變爲 <code>gradlew</code>。</p>\n<p><strong>（2）gradle 命令能做什麼？</strong></p>\n<p>gradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gradle tasks</span><br><span class=\"line\"></span><br><span class=\"line\">:tasks</span><br><span class=\"line\"></span><br><span class=\"line\">== All tasks runnable from root project</span><br><span class=\"line\"></span><br><span class=\"line\">== Build Setup tasks</span><br><span class=\"line\">setupBuild - Initializes a new Gradle build. [incubating]</span><br><span class=\"line\"></span><br><span class=\"line\">== Help tasks</span><br><span class=\"line\">dependencies - Displays all dependencies declared <span class=\"keyword\">in</span> root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">dependencyInsight - Displays the insight into a specific dependency <span class=\"keyword\">in</span> root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\"><span class=\"built_in\">help</span> - Displays a <span class=\"built_in\">help</span> message</span><br><span class=\"line\">projects - Displays the sub-projects of root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">properties - Displays the properties of root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\">tasks - Displays the tasks runnable from root project <span class=\"string\">&#x27;gs-gradle&#x27;</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">To see all tasks and more detail, run with --all.</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL</span><br><span class=\"line\"></span><br><span class=\"line\">Total time: 3.077 secs</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）初始化一個 Gradle 項目</strong></p>\n<p>在項目文件夾中新建一個名爲 <code>build.gradle</code> 的文件，其內容如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;java&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>隨後新建一個名爲 <code>settings.gradle</code> 的文件，其內容可暫時爲空。</p>\n<p>在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 <code>gradle-wrapper</code> ，其過程等價於執行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gradle wrapper --gradle-version 6.5</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）編譯打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包</span></span><br><span class=\"line\">gradle build</span><br><span class=\"line\"><span class=\"comment\"># 或使用 gradle wrapper</span></span><br><span class=\"line\">./gradlew build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理生成的文件</span></span><br><span class=\"line\">gradle clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成 jar 文件</span></span><br><span class=\"line\">gradle jar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 運行生成的 jar 文件</span></span><br><span class=\"line\">gradle run</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">gradle <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）<code>build.gradle</code> 中可配置什麼？</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置插件，插件提供語法定義</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;application&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置入口類</span></span><br><span class=\"line\">mainClassName = <span class=\"string\">&#x27;hello.HelloWorld&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴倉庫</span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置生成的 jar 文件的入口類</span></span><br><span class=\"line\">jar &#123;</span><br><span class=\"line\">    manifest &#123;</span><br><span class=\"line\">        attributes <span class=\"string\">&#x27;Main-Class&#x27;</span>: mainClassName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置 JDK 兼容性</span></span><br><span class=\"line\">sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">targetCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile <span class=\"string\">&quot;joda-time:joda-time:2.2&quot;</span></span><br><span class=\"line\">    testCompile <span class=\"string\">&quot;junit:junit:4.12&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如需將所有依賴 jar 打進同一個 jar 包，可使用 <a href=\"https://github.com/johnrengelman/shadow\">shadow 插件</a>或使用 <a href=\"https://spring.io/quickstart\">spring boot 插件</a>。</p>"},{"title":"Java 多線程","p":"it/java/java-concurrent.md","_content":"\n首先區分進程和線程。進程是程序運行的基本單位，也是系統分配資源的最小單位；而線程是 CPU 調度的最小單位，一個進程可以有多個線程，而各個線程擁有獨立的程序計數器、虛擬機棧和本地方法棧，但共享同一個堆和方法區。爲著充分利用系統資源，減少 CPU 空等，多線程技術應運而生。系統使用時間片輪轉法分配 CPU 資源到各個線程，如果線程在分配的時間片內未能處理完任務，則會導致上下文切換。\n\nJava 中線程類爲 `Thread` ，其 `start` 方法會使線程進入 Runnable 狀態；其 `sleep` 方法會阻塞線程而不釋放鎖，跟 `Object.wait` 有別；其 `interrupt` 方法並不停止線程，而是設置一個標誌位通知線程應當關閉，線程可以根據該標誌位決定是否要停止運行。\n\n多個線程可以通過線程池進行統一管理，好處是還可以提前 Ready 好一些線程避免等待線程創建的時間損耗；還可以使用舊的線程，減少線程的頻繁創建和銷毀的資源損耗。線程池推薦直接使用 `ThreadPoolExecutor` 的構造方法去創建，以便設置合適的構造參數。調用 `ThreadPoolExecutor.execute` 可以將一個 `Runnable` 任務放入線程池處理； 調用`ThreadPoolExecutor.submit`  可以將一個 `Callable` 任務放入線程池處理，返回一個 `Future` 代表處理結果，後續通過調用 `Future.get` 獲取處理結果，其過程是阻塞的。\n\nJava 1.5 開始提供`AbstractQueuedSynchronizer`，用於創建多線程訪問共享資源的同步器，其內部使用一個名爲 CLH 的 FIFO 的雙向隊列進行資源分配。其常見實現類有：`ReentrantLock`、`ReadWriteLock` 和 `CountDownLatch` 。其中 `ReadWriteLock` 性能優於 `ReentrantLock` ，因爲兩個讀操作在 `ReadWriteLock` 中不互斥而在 `ReentrantLock` 中互斥。\n\nJava 1.8 開始提供了 `CompletableFuture` ，其實現了 `Future` 接口，並提供了基於回調的函數式異步編程方式和對`CompletableFuture` 的組合，使用者可以不關心底層的線程池，大大簡便了異步編程。\n\nJava 還提供了 ThreadLocal 類可以使得各個線程擁有變量的副本而不會相互影響，底層是使用 Thread 類的 `ThreadLocalMap`，一個類似 HashMap 的結構，其 Key 爲 ThreadLocal 對象的弱引用。\n\n多線程因會有多個線程操作共享的資源而引發了線程安全的擔憂。線程安全要求**原子性、可見性和有序性**。Java 提供了多種方式可以保證線程安全：\n\n1. synchronized 同步鎖，這是一個重量級鎖。可以使用當前類的 class 對象，當前類的對象或者任意對象對方法和代碼塊進行加鎖，方法結束或代碼塊結束則鎖自動釋放。當使用非靜態同步方法時，會使用當前對象爲鎖，因此多個非靜態同步方法共享同一鎖。Java 1.6 後引入**偏向鎖**和**輕量級鎖**的概念，使得 synchronized 不那麼「重」了。\n2. volatile 關鍵字。使用該關鍵字修飾的變量在編譯時不會有寄存器緩存而是直接使用主存、不會進行代碼重排序優化，保證了可見性和有序性；在解釋執行時使用 CPU 內存屏障技術防止指令重排序。\n3. CAS(Compare and Swap) 技術，相比於 synchronized，其假定操作是不會產生衝突的，將舊的預期值和內存中的值進行比較，若相同則更新內存中的值，否則自旋。因此被稱之爲「樂觀鎖」，而 synchronized 被稱之爲「悲觀鎖」。Java 中的 Atomic 類是典型的 CAS 實現。\n\n多線程操作共享資源還會出現死鎖。死鎖產生的條件是：**互斥、請求/等待、不可剝奪和循環等待**。解決死鎖問題的關鍵是破壞死鎖產生的條件。\n\n<!-- more -->\n\n## 多線程\n\n### **程序、進程與線程**\n\n1. 程序：程序是含有指令和數據的文件，被靜態存儲於存儲設備之中。\n2. 進程：进程是程序的一次執行過程，是**操作系統運行程序的基本單位**，是動態的。它佔用一定的系統資源（包括 CPU 時間、內存空間、文件、輸入輸出設備等等），**是資源分配的最小單位**。各進程之間相互獨立。\n3. 線程：**線程是 CPU 調度的最小單位**，擁有**程序計數器、虛擬機棧和本地方法棧**，相比進程，它佔用資源更小，產生和切換線程的負擔更小，也被稱爲**輕量級進程**。一個進程可以產生多個線程。同個進程的多個線程之間共享同一塊**堆和方法區**。\n\n- 堆是幹什麼用的？\n\n    堆是進程中最大的一塊內存，用於存放新建的對象。\n\n- 方法區是幹什麼的？\n\n    根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放程序執行代碼的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(java-concurrent/code segment)，通常只讀。具體來說，它存放了每個類的結構，例如運行時常量池，字段和方法數據，以及方法和構造函數的代碼，包括用於類和實例初始化以及接口初始化的特殊方法。\n\n    另外，UNIX 中的進程將內存劃分成三個部分：text segment,文本區，例如代碼，data segment，數據區，例如變量，stack segment，棧區域。\n\n- 程序計數器爲什麼是線程私有的？\n\n    程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。\n\n    因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。\n\n- 虛擬機棧和本地方法棧爲什麼是線程私有的？\n    - **虛擬機棧**：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態鏈接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。\n    - **本地方法棧**：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。\n\n    爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。\n\n### **線程有哪些基本狀態**\n\nJava 線程共有 6 中狀態，如下：\n\n1. New：新創建的線程，尚未執行。\n2. Runnable：運行中的線程，`run` 方法正在執行中。可細分爲 Ready 和 Running 兩個狀態。\n3. Blocked：運行中的線程，因爲某些操作被阻塞而掛起。\n4. Waiting：運行中的線程，因爲某些操作在等待。\n5. Timed Waiting：運行中的線程，因爲執行 `sleep` 等方法正在計時等待。\n6. Terminated：線程終止，因爲 `run` 方法執行完畢。\n\n![](java-concurrent/Untitled.png)\n\n### 並發和並行的區別\n\n並發（concurrent）：同一時間段，多個任務都在執行。\n\n並行（parallel）：單位時間內，多個任務同時執行。\n\n### 多線程的優勢\n\n1. 提高 CPU 和 IO 設備的綜合利用率，確保 CPU 或 IO 設備不空等。\n2. 提高 CPU 核心利用率，確保 CPU 的多個核心都能被利用到。\n3. 提高系統整體的並發能力和性能，應對高並發場景。\n\n### 上下文切換\n\n**上下文切換就是舊任務被暫停，保存自身狀態，然後新任務被執行的過程**。造成上下文切換的原因是需要同時執行的任務大於 CPU 核心數，而單個 CPU 同一時刻只能執行一個任務。CPU 採用時間片輪轉法分配 CPU 時間給多個線程，當時間片結束舊任務如果未執行完畢會被暫停，保存當前狀態，然後執行新的任務。\n\n上下文切換所需的時間很可觀，可能是操作系統中時間消耗最大的操作。操作系統中數 Linux（及其他類 Unix 系統） 上下文切換時間消耗最少。\n\n### 爲什麼調用 `Thread.start` 方法而不是 `Thread.run` 方法？\n\n調用 `start` 方法會啟動一個新線程並進入就緒狀態，當分配到時間片後會自動調用 `run` 方法。直接調用 `run` 方法只會在調用者所在的線程執行。\n\n### 比較 `Thread.sleep` 方法和 `Object.wait` 方法\n\n共同點：\n\n1. 都可以暫停線程的執行。\n2. `sleep(long)`和 `wait(long)` 都可以在指定時間段後使線程自動甦醒。\n\n不同點：\n\n1. sleep 是 Thread 類的方法，wait 是 Object 類的方法。\n2. **sleep 沒有釋放鎖，wait 釋放了**。\n3. `wait()` 被調用後線程不會自動甦醒，需要別的線程調用同一對象上的 `notify()` 或 `notifyAll()` 方法來喚醒。\n- 代碼\n\n    ```java\n    // Data.java\n    public class Data {\n        private String packet;\n\n        // 单次传输是否结束\n        // True if Receiver should wait\n        // False if Sender should wait\n        private boolean isTransfer = true;\n\n        public synchronized void send(String packet) {\n            while (!isTransfer) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            this.packet = packet;\n            isTransfer = false;\n            notifyAll();\n        }\n\n        public synchronized String receive() {\n            while (isTransfer) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            isTransfer = true;\n            notifyAll();\n            return packet;\n        }\n    }\n\n    // Sender.java\n    public class Sender implements Runnable {\n\n        private final Data data;\n\n        public Sender(Data data) {\n            this.data = data;\n        }\n\n        @Override\n        public void run() {\n            String[] packets = new String[]{\"Hello\", \"Are\", \"You\", \"Ok\", \"Over\"};\n            for (String packet : packets) {\n                data.send(packet);\n            }\n        }\n    }\n\n    // Receiver.java\n    public class Receiver implements Runnable {\n\n        private final Data data;\n\n        public Receiver(Data data) {\n            this.data = data;\n        }\n\n        @Override\n        public void run() {\n            String packet = data.receive();\n            while (!\"Over\".equals(packet)) {\n                System.out.println(packet);\n                packet = data.receive();\n            }\n        }\n    }\n\n    // Main.java\n    public class Main {\n\n        public static void main(String[] args) {\n            Data data = new Data();\n            new Thread(new Receiver(data)).start();\n            new Thread(new Sender(data)).start();\n        }\n    }\n    ```\n\n### 調用 `Thread.interrupt` 意味著什麼？\n\n調用 interrupt 方法並不會中斷一個線程，而是發出出一個中斷信號到目標線程（設置中斷標誌位的值爲 true），目標線程收到信號後可以決定是否處理。\n\n與之相關的方法有：\n\n```java\n// 測試當前線程是否已經中斷。當線程中斷時調用該方法將會清除線程的中斷狀態\npublic static boolean interrupted()\n// 測試線程是否已經中斷。不改變線程的中斷狀態。\npublic boolean isInterrupted()\n// 中斷線程\npublic void interrupt()\n```\n\n[廖雪峰的官方網站](java-concurrent//www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554)提供了以下的代碼：\n\n```java\npublic class Main {\n  public static void main(String[] args) throws InterruptedException {\n      Thread t = new MyThread();\n      t.start();\n      Thread.sleep(java-concurrent// 暫停1毫秒\n      t.interrupt(java-concurrent// 中斷t線程\n      t.join(java-concurrent// 等待t線程結束\n      System.out.println(\"end\");\n  }\n}\n\nclass MyThread extends Thread {\n  public void run() {\n      int n = 0;\n      while (! isInterrupted()) {\n          n ++;\n          System.out.println(n + \" hello!\");\n      }\n  }\n}\n```\n\n值得注意的是：\n\n1. 本線程中斷自己是被允許的；其它線程調用本線程的`interrupt`方法時，會通過`checkAccess`檢查權限。這有可能拋出`SecurityException`異常。\n2. 調用線程的`wait` 方法會讓它進入等待(阻塞)狀態，或者調用線程的`join`, `sleep` 方法也會讓它進入阻塞狀態。若線程在阻塞狀態時，調用了它的`interrupt`方法，那麼它的「中斷狀態」會被清除並且會收到一個`InterruptedException`異常。例如，線程通過`wait()`進入阻塞狀態，此時通過`interrupt()`中斷該線程；調用`interrupt()`會立即將線程的中斷標記設為「true」，但是由於線程處於阻塞狀態，所以該「中斷標記」會立即被清除為「false」，同時，會產生一個`InterruptedException`的異常。\n3. 如果線程被阻塞在一個`Selector`選擇器中，那麼通過`interrupt()`中斷它時；線程的中斷標記會被設置為true，並且它會立即從選擇操作中返回。\n4. 如果不屬於前面所說的情況，那麼通過`interrupt()`中斷線程時，它的中斷標記會被設置為「true」。\n5. 中斷一個「已終止的線程」不會產生任何操作。\n\n### 線程池技術\n\n**（1）爲什麼要使用線程池？**\n\n線程池管理了一組線程資源，並維護了一些基本的統計信息。\n\n《Java 並發編程的藝術》中講述到使用線程池的好處：\n\n1. 降低資源消耗。通過重複使用已創建的線程減少線程創建和銷毀的消耗。\n2. 提高響應速度。線程池預先創建了線程，在需要時可以直接使用不用等。\n3. 提供線程的可管理性。線程是稀缺資源，不能無限制地分配，使用線程池可以進行統一分配、調優和監控。\n\n**（2）Runnable 接口和 Callable 接口的區別**\n\n1. Runnable 始於 Java 1.0 ，Callable 接口始於 Java 1.5.\n2. Runnable 不會返回結果或拋出檢查異常，而 Callable 會。\n\n另外，工具類 `Executors` 可以實現 Runnable 對象和 Callable 對象之間的相互轉換，如下：\n\n```java\nExecutors.callable(Runnable task)\nExecutors.callable(Runnable task，Object resule)\n```\n\n**（3）`execute` 方法和 `submit` 方法有什麼區別？**\n\n1. `execute` 提交任務之後沒有返回值，無法判斷任務是否被執行成功。\n2. `submit` 提交任務之後有返回值 Future，可以知道任務是否被執行成功。調用 `Future.get()` 會阻塞線程直到任務完成；調用 `Future.get(long timeout，TimeUnit unit)`  則是阻塞指定的一段時間後立即返回，不管任務是否執行完成。當然如果提交的是 Runnable，那麼返回的 Future 中的泛型爲 Void。\n\n**（4）如何創建線程池？**\n\n《阿里巴巴 Java 開發手冊》中要求直接用 `ThreadPoolExecutor` 的構造方法去創建線程池，而非通過 Executors 去創建線程池，因爲：\n\n1. `FixedThreadPool` 和 `SingleThreadPool` 中允許請求的隊列長度爲 `Integer.MAX_VALUE`，可能會堆積大量請求，導致 OOM；\n2. `CachedThreadPool` 和 `ScheduledThreadPool` 中允許線程數爲 `Integer.MAX_VALUE`，可能會創建大量線程，導致 OOM。\n\n`ThreadPoolExecutor` 的參數分析：\n\n```java\npublic ThreadPoolExecutor(\n  // 核心線程數，規定了最小的可以同時運行的線程數量\n\tint corePoolSize,\n  // 最大線程數，當請求隊列滿時，可以同時運行的線程數量\n\tint maximumPoolSize,\n  // 當線程空閒且大於規定的核心線程數時，等待 keepAliveTime 時間後多餘的線程會被銷毀\n\tlong keepAliveTime,\n  // keepAliveTime 的時間單位\n\tTimeUnit unit,\n  // 請求隊列，當新任務進來時，當前運行的線程達到核心線程數，則新任務會被放置到請求隊列\n\tBlockingQueue<Runnable> workQueue,\n  // 線程工廠，用於創建新線程\n\tThreadFactory threadFactory,\n  // 飽和策略，當線程數量達到最大線程數且請求隊列也滿的情況下觸發飽和策略\n\tRejectedExecutionHandler handler) {\n}\n```\n\n線程池中的飽和策略有：\n\n1. `ThreadPoolExecutor.AbortPolicy`：默認策略，拋出異常，拒絕處理新任務。\n2. `ThreadPoolExecutor.CallerRunsPolicy`：直接在調用 `execute` 所在的線程執行。\n3. `ThreadPoolExecutor.DiscardPolicy`：不拋出異常，直接丟棄新任務。\n4. `ThreadPoolExecutor.DiscardOldestPolicy`：不拋出異常，丟棄最早未處理的任務。\n\n**（5）線程池對新任務的處理過程**\n\n![](java-concurrent/Untitled%201.png)\n\n### AQS（抽象隊列式同步器）\n\n**（1）概述**\n\nAQS，即 `AbstractQueuedSynchronizer` ，加入於 Java 1.5，作者爲大名鼎鼎的 Doug Lea，其定義了一套多線程訪問共享資源的同步器框架。其下有諸如 `ReentrantLock`、`ReadWriteLock`、`CountDownLatch` 等等實現。\n\nAQS 的實現思路是：如下圖所示，當請求的共享資源空閒時，請求資源的線程會被設置爲有效的工作線程，該資源會被鎖定；當請求的共享資源被佔用時，將請求資源的線程加入 CLH 隊列中。CLH 是三個人名的首字母，CLH 隊列是一個雙向隊列，FIFO。而共享資源的狀態是一個整型值，採用 CAS 方式進行值的原子更新，通常加鎖 state 會加 1，釋放則減 1。\n\n![](java-concurrent/Untitled%202.png)\n\nAQS 可以定義兩種資源共享方式，獨佔 or 共享。其採用模板方法模式編寫，實現類需要選擇性地實現以下方法（默認實現是拋出`UnsupportedOperationException`）：\n\n```java\n//該線程是否正在獨佔資源。只有用到condition才需要去實現它。\nisHeldExclusively()\n//獨佔方式。嘗試獲取資源，成功則返回true，失敗則返回false。\ntryAcquire(int)\n//獨佔方式。嘗試釋放資源，成功則返回true，失敗則返回false。\ntryRelease(int)\n//共享方式。嘗試獲取資源。負數表示失敗；0表示成功，但沒有剩餘可用資源；正數表示成功，且有剩餘資源。\ntryAcquireShared(int)\n//共享方式。嘗試釋放資源，成功則返回true，失敗則返回false。\ntryReleaseShared(int)\n```\n\n**（2）ReentrantLock**\n\nReentrantLock，可重入鎖，同一線程可以反覆加鎖，然後釋放同樣次數的鎖。synchronized 修飾的方法用的也是可重入鎖，但 ReentrantLock 提供了更爲靈活的控制，有 lock、unlock 方法還有類似於 `Object.wait` / `Object.notify` 的 `Condition.await` / `Condition.signal` 方法。\n\n- 代碼\n\n    參考：[https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/](java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/)\n\n    ```java\n    // SharedFifoQueue.java\n    public class SharedFifoQueue {\n\n      private final Object[] content;\n      // 標識當前隊列中擁有的對象數目\n      private int current = 0;\n      private int addIndex = 0;\n      private int removeIndex = 0;\n\n      private final ReentrantLock lock = new ReentrantLock();\n      private final Condition fullCondition = lock.newCondition();\n      private final Condition emptyCondition = lock.newCondition();\n\n      public SharedFifoQueue(int capacity) {\n          content = new Object[capacity];\n      }\n\n      public void add(Object item) throws InterruptedException {\n          lock.lock();\n          while (current >= content.length) {\n              fullCondition.await();\n          }\n          content[addIndex] = item;\n          addIndex = (addIndex + 1) % content.length;\n          current++;\n          emptyCondition.signal();\n          lock.unlock();\n      }\n\n      public Object remove() throws InterruptedException {\n          lock.lock();\n          while (current <= 0) {\n              emptyCondition.await();\n          }\n          Object item = content[removeIndex];\n          removeIndex = (removeIndex + 1) % content.length;\n          current--;\n          fullCondition.signal();\n          lock.unlock();\n          return item;\n      }\n    }\n\n    // Producer.java\n    public class Producer implements Runnable {\n\n      private final SharedFifoQueue queue;\n      private final Random random = new Random();\n\n      public Producer(SharedFifoQueue queue) {\n          this.queue = queue;\n      }\n\n      @Override\n      public void run() {\n          try {\n              for (int i = 0; i < 20; i++) {\n                  queue.add(\"Hello \" + i);\n                  Thread.sleep(random.nextInt(200) );\n              }\n              queue.add(null);\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n\n    // Consumer.java\n    public class Consumer implements Runnable {\n\n      private final SharedFifoQueue queue;\n\n      public Consumer(SharedFifoQueue queue) {\n          this.queue = queue;\n      }\n\n      @Override\n      public void run() {\n          try {\n              while (true) {\n                  Object item = queue.remove();\n                  if (item == null) {\n                      break;\n                  }\n                  System.out.println(item.toString());\n              }\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n\n    // Main.java\n    public static void main(String[] args) throws InterruptedException {\n        SharedFifoQueue sharedFifoQueue = new SharedFifoQueue(10);\n        Thread consumerThread = new Thread(new Consumer(sharedFifoQueue));\n        Thread producerThread = new Thread(new Producer(sharedFifoQueue));\n\n        producerThread.start();\n        consumerThread.start();\n        // join 可以讓主線程等待子線程結束\n        producerThread.join();\n        consumerThread.join();\n    }\n    ```\n\n**（3）ReadWriteLock**\n\nReadWriteLock 相比 ReentrantLock 性能更高，體現在兩個讀操作在 ReadWriteLock 裏是不互斥的，而在 ReentrantLock 裏是互斥的。\n\n- 代碼\n\n    代碼來源：[https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/](java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/)\n\n    ```java\n    public class ThreadSafeArrayList<E> {\n      private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n      private final Lock readLock = readWriteLock.readLock();\n      private final Lock writeLock = readWriteLock.writeLock();\n\n      private final List<E> list = new ArrayList<>();\n\n      public void set(E o) {\n          writeLock.lock();\n          try {\n              list.add(o);\n          } finally {\n              writeLock.unlock();\n          }\n      }\n\n      public E get(int i) {\n          readLock.lock();\n          try {\n              return list.get(i);\n          } finally {\n              readLock.unlock();\n          }\n      }\n    }\n    ```\n\n**（4）CountDownLatch**\n\nCountDownLatch 可以讓一個或多個線程等待指定的操作完成後再開始工作。初始化 CountDownLatch 時需要指定一個 count 值，需要等待的線程使用 `CountDownLatch.await()` 進行等待，當 `CountDownLatch.countDown()` 被調用 count 次時，等待的線程才得以繼續執行。\n\n- 代碼\n\n    代碼來源：[http://tutorials.jenkov.com/java-util-concurrent/countdownlatch.html](java-concurrent//tutorials.jenkov.com/java-util-concurrent/countdownlatch.html)\n\n    ```java\n    // Main.java\n    CountDownLatch latch = new CountDownLatch(3);\n\n    Waiter      waiter      = new Waiter(latch);\n    Decrementer decrementer = new Decrementer(latch);\n\n    new Thread(waiter)     .start();\n    new Thread(decrementer).start();\n\n    Thread.sleep(4000);\n    // Waiter.java\n    public class Waiter implements Runnable{\n\n      CountDownLatch latch = null;\n\n      public Waiter(CountDownLatch latch) {\n          this.latch = latch;\n      }\n\n      public void run() {\n          try {\n              latch.await();\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n\n          System.out.println(\"Waiter Released\");\n      }\n    }\n    // Decrementer.java\n    public class Decrementer implements Runnable {\n\n      CountDownLatch latch = null;\n\n      public Decrementer(CountDownLatch latch) {\n          this.latch = latch;\n      }\n\n      public void run() {\n          try {\n              Thread.sleep(1000);\n              this.latch.countDown();\n\n              Thread.sleep(1000);\n              this.latch.countDown();\n\n              Thread.sleep(1000);\n              this.latch.countDown();\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n    ```\n\n**（5）Semaphore**\n\nSemaphore 用於限制訪問資源的線程數量，以對資源進行保護。[有人將其比做是廁所的坑位數](java-concurrent//blog.csdn.net/eson_15/article/details/51577191)，譬如一個廁所有 3 個坑，則同時上廁所的人只能有 3 個，其他人要上只能等這 3 個人之一釋放坑位。\n\n使用前通過調用 `Semaphore.acquire` 獲取訪問，使用後通過  `Semaphore.release` 釋放許可。\n\n- 代碼\n\n    ```java\n    public static void main(String[] args) {\n        ExecutorService threadPool = Executors.newFixedThreadPool(10);\n        Semaphore semaphore = new Semaphore(3);\n        for (int i = 0; i < 10; i++) {\n            threadPool.execute(() -> {\n                try {\n                    semaphore.acquire();\n                    System.out.printf(\"Running Thread Id: %s, Available permit: %d, Queue length: %d\\n\", Thread.currentThread().getId(), semaphore.availablePermits(), semaphore.getQueueLength());\n                    Thread.sleep(300);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    semaphore.release();\n                }\n            });\n        }\n    }\n    ```\n\n    運行結果：\n\n    初始化總許可量爲 3，一開始被用掉一個許可，可用許可剩餘 2；隨後許可被用光，其他線程開始排隊，出現長度爲 6 的請求隊列，之後隨之許可釋放，隊列長度遞減，直到所有任務處理完成，隊列長度爲 0，許可復爲 3。\n\n    ```java\n    Running Thread Id: 13, Available permit: 2, Queue length: 0\n    Running Thread Id: 15, Available permit: 0, Queue length: 0\n    Running Thread Id: 14, Available permit: 1, Queue length: 0\n    Running Thread Id: 16, Available permit: 0, Queue length: 6\n    Running Thread Id: 17, Available permit: 1, Queue length: 5\n    Running Thread Id: 18, Available permit: 0, Queue length: 4\n    Running Thread Id: 19, Available permit: 0, Queue length: 3\n    Running Thread Id: 20, Available permit: 1, Queue length: 2\n    Running Thread Id: 21, Available permit: 0, Queue length: 1\n    Running Thread Id: 22, Available permit: 2, Queue length: 0\n    ```\n\n### CompletableFuture\n\n參考：[https://colobu.com/2016/02/29/Java-CompletableFuture/](java-concurrent//colobu.com/2016/02/29/Java-CompletableFuture/)、[https://www.jianshu.com/p/6bac52527ca4](java-concurrent//www.jianshu.com/p/6bac52527ca4)\n\nCompletableFuture 是 Java 1.8 提供的類，可以方便函數式異步編程。CompletableFuture 實現了 Future 接口。\n\nFuture 是 Java 1.5 引入的接口，它代表這異步執行的結果。可以通過 `isDone` 判斷執行是否完畢，通過 `get` 阻塞獲取結果，通過 `cancel` 取消執行。\n\nFuture 獲取結果的方式不優雅，要輪詢或一直阻塞等待結果。 CompletableFuture 提供了回調的方式處理結果（正常結果 & 異常結果），還有組合多個 CompletableFuture 的能力。\n\n有了 CompletableFuture，我們甚至可以不關心線程、線程池和同步，因爲 CompletableFuture 內部已經幫我們處理好了，我們只需要鏈式調用函數就可以了。\n\n```java\nCompletableFuture.allOf(CompletableFuture.runAsync(() -> {\n  try {\n      Thread.sleep(200);\n  } catch (InterruptedException e) {\n      e.printStackTrace();\n  }\n  System.out.println(Thread.currentThread().getId() + \" done!\");\n}), CompletableFuture.runAsync(() -> {\n  try {\n      Thread.sleep(200);\n  } catch (InterruptedException e) {\n      e.printStackTrace();\n  }\n  System.out.println(Thread.currentThread().getId() + \" done!\");\n})).handle((BiFunction<Void, Throwable, Void>) (unused, throwable) -> {\n  if (throwable != null) {\n      System.out.println(\"Exception:\" + throwable.getMessage());\n  } else {\n      System.out.println(\"All done!\");\n  }\n  return null;\n}).join();\n```\n\n### ThreadLocal\n\nThreadLocal 可以讓每個線程擁有變量的副本進行讀寫而互不影響。ThreadLocal 的原理就是 Thread 類本身的 ThreadLocalMap，當調用 `ThreadLocal.set` 方法時會去獲取當前線程的 ThreadLocalMap，然後以當前 ThreadLocal 爲 key，將值放入其中；當調用`ThreadLocal.get`時則從 ThreadLocalMap 中讀取。如此每個 Thread 都有各自的專屬變量，不受其他線程影響。\n\n![](java-concurrent/Untitled%203.png)\n\nThreadLocalMap 中的 key 採用弱引用，如果 key 即 ThreadLocal 沒有強引用的話，key 會被 GC 回收變爲 null，而 value 因爲是強引用不會被 GC 回收，於是出現了 key 爲 null 的 Entry，造成內存泄漏。ThreadLocalMap 在調用 `get`、`set` 方法時會清理 key 爲 null 的Entry，雖如此還是在使用完 ThreadLocal 後手動調用下 `remove` 方法爲好。\n\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n  /** The value associated with this ThreadLocal. */\n  Object value;\n\n  Entry(ThreadLocal<?> k, Object v) {\n      super(k);\n      value = v;\n  }\n}\n```\n\n## 線程安全\n\n### 線程安全的保證\n\n1. 原子性：多項操作要麼都執行，要麼都不執行。synchronized 可以保證代碼片段的原子性。\n2. 可見性：當一個線程對共享變量做了修改，其他線程要立即可以看到修改後的值。volatile 可以保證共享變量的可見性。\n3. 有序性：代碼編寫時的順序同編譯執行時的順序一致。volatile 可以禁止指令重排序。\n\n### **synchronized 同步鎖的用法**\n\nsynchronized 使用時需要指定一個鎖，當程序進入 synchronized 代碼塊或方法時該鎖會被鎖住，直到離開 synchronized 代碼塊或方法，鎖才會被釋放。注意：同步的範圍越小越好。\n\n**同步代碼塊**\n\n```java\npublic void f() {\n  synchronized(this){\n  }\n}\n```\n\n同步代碼塊的鎖可以選擇使用當前對象（this）、當前類 class 對象或其他任意對象。\n\n**同步方法**\n\n```java\npublic synchronized void f() {\n}\n```\n\n此時鎖爲同步方法所在類的對象。**同一個對象的多個同步方法共享同一個鎖**，多個實例對象時各個對象有各自的鎖。子類重寫父類的同步方法時可以去除同步。\n\n**同步靜態方法**\n\n```java\npublic static synchronized void f() {\n}\n```\n\n此時鎖為同步靜態方法所在類的 class 對象，即使多個實例對象也共享同一個鎖。\n\n### 使用 String 作爲鎖的注意點\n\n1. 首先 String 是一個特殊的類，JVM 使用常量池技術對其進行了緩存，通過字面量使用時會總是返回同一個 String 對象。\n2. 使用 `new String`、`StringBuilder.toString` 和 `StringBuffer.toString` 每次會返回一個新的 String 對象。\n3. 使用 `String.intern`，當常量池中有值等同的 String 對象時返回該對象，如無則將其加入常量池。\n\n### **Java 同步鎖的本質**\n\n**Java 的鎖是存在於對象頭**中的，具體就 Hotspot 虛擬機來說，是存在於對象頭中的 Mark Word（標記字段）中的鎖標誌位。Java 對象可有四種鎖狀態：\n\n1. 一開始對象無鎖，當一段同步代碼一直被一個線程訪問時，該線程自動獲得鎖，此時該鎖爲**偏向鎖**；\n2. 當鎖是偏向鎖時，另一個線程訪問同步代碼，偏向鎖會升級爲**輕量級鎖**，其他線程會通過**自旋**（指嘗試獲取鎖的線程不會立即阻塞，而是採用循環的方式獲取鎖）嘗試獲取鎖；\n3. 當鎖是輕量級鎖時，另一個線程自旋到一定次數仍然未獲得鎖，輕量級鎖會自動升級爲**重量級鎖**，其他線程進入阻塞狀態。\n\n![](java-concurrent/_2020-11-16_8.54.01.png)\n\n當處於重量級鎖時，對象頭存儲的指針指向的重量級鎖也叫 **monitor 鎖**（監視器鎖）。多個線程爭搶的就是這個 monitor 對象，誰持有誰就可以運行同步代碼。通過使用 `javap -c -s -v -l xx.class` 反彙編字節碼知道：當使用 `synchronized` 同步代碼塊時其實現時 `monitorenter` 和 `monitorexit` 指令，其中的 `monitorenter` 指令指向同步代碼塊開始的位置，`monitorexit` 則指向結束的位置；當使用 `synchronized` 修飾方法時，則是使用 `ACC_SYNCHRONIZED` 標識該方法爲同步方法。\n\n獲取鎖的過程如下圖所示：需要訪問同步代碼的多個線程首先進入 Entry Set，當線程獲取到 monitor 對象時會進入 The Owner 區域，然後將 monitor 對象中的 owner 變量設置爲當前線程，計數器 count 加 1；若線程調用 wait 方法，將釋放持有的 monitor，owner 變量設置爲 null，計數器 count 減 1，同時該線程進入 Wait Set 等待被喚醒；若線程執行完畢也將釋放 monitor 並恢復 monitor 中相關變量的值。\n\n![](java-concurrent/Untitled%204.png)\n\n### volatile 關鍵字\n\n參考：[https://monkeysayhi.github.io/2017/12/28/一文解决内存屏障/](java-concurrent//monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/)\n\nvolatile 關鍵字可以修飾變量，其作用是：\n\n標記該變量以在編譯時，取消編譯層面的緩存和重排序（編譯時的亂序優化）；在解釋執行時使用 CPU 內存屏障技術解決硬件層面的可見性和重排序。具體來說：\n\n1. **被修飾的變量在寄存器中將不會有副本，而是直接從主存進行讀寫操作**，多線程環境下，變量的值的改變**即時可見**。所謂的主存和寄存器是計算機的解決訪問 CPU 處理速度和內存讀寫速度不匹配的手段。一般認爲寄存器的讀寫速度快於主存。\n\n    ![](java-concurrent/Untitled%205.png)\n\n    未聲明 volatile 時\n\n    ![](java-concurrent/Untitled%206.png)\n\n    聲明 volatile 時\n\n2. 編譯器不對該變量進行亂序優化。\n3. JVM 在解釋執行時使用對應 CPU 架構的內存屏障指令防止指令重排序，通常有以下三種：\n    - mfence(StoreLoad Barriers、Full Barrier) 全能屏障\n    - sfence(Store Barriers) 寫屏障\n    - lfence(Load Barrirers) 讀屏障\n\n    以 x86 架構爲例子，如有一以 volatile 修飾的變量 v，JVM 對其操作如下：\n\n    1. 在寫入 v 之後插入一個 sfence，隔離了寫入 v 前後的寫入指令，防止其重排序，且 sfence 之前的修改會被寫入緩存並標記其他 CPU 核心中的緩存失效；\n    2. 在讀取 v 之前插入一個 lfence，隔離了讀取 v 前後的讀取指令，防止其重排序，且 lfence 之後會先刷新緩存，從而讀取最新的值。\n\n    sfence 和 lfence 兩相配合，保證了變量 v 的可見性。\n\n### CAS 鎖\n\nsynchronized 是悲觀鎖，假定操作是有衝突的，要加鎖然後再執行程序，完畢後再釋放鎖。而 CAS(Compare And Swap) 是樂觀鎖，假定操作是沒有衝突的，不需要加鎖，而是把舊的預期值跟內存中已有的值進行比較，如果相同再把要更新的值更新到內存，如果不同則自旋（重試，重新獲取預期值進行比較和替換），Java 中的原子類（比如 AtomicInteger）的底層實現就是 CAS。\n\nCAS 存在一個稱之爲 ABA 的問題，即對於變量 v = A，當其變爲 B 後又復原爲 A 時，無法判斷變量 v 是否被修改過。\n\n![](java-concurrent/Untitled%207.png)\n\n使用 `AtomicStampedReference` 可以防止 ABA 的問題，因爲附帶的 Stamp可以標識 Reference 的版本，Reference 變化，Stamp 隨之遞增。\n\n### Atomic 原子類\n\n`java.util.concurrent.atomic` 包中提供了一系列原子類，包括：\n\n1. 原子類型：\n    - AtomicInteger：針對整型\n    - AtomicLong：針對長整型\n    - AtomicBoolean：針對布爾類型\n2. 數組類型：\n    - AtomicIntegerArray：針對整型數組\n    - AtomicLongArray：針對長整型數組\n    - AtomicReferenceArray：針對引用類型數組\n3. 引用類型：\n    - AtomicReference：針對對象引用\n    - AtomicStampedReference：針對對象引用連同一個整型\n    - AtomicMarkableReference：針對對象引用連同一個布爾類型\n4. 對象的屬性修改類型：\n    - AtomicIntegerFieldUpdater：修改對象的一個整型屬性\n    - AtomicLongFieldUpdater：修改對象的一個長整型屬性\n    - AtomicReferenceFieldUpdater：修改對象的一個整型屬性\n\n其理論基礎就是 **CAS**(Compare and Swap) **鎖 + volatile + native 方法。**CAS 就是將舊的預期值與內存中的值進行比較，當相同時才將新的預期值設入，否則自旋。 \n\n介紹下 AtomicInteger 類的幾個原子方法：\n\n```java\npublic final int get(java-concurrent//獲取當前的值\npublic final int getAndSet(java-concurrent//獲取當前的值，並設置新的值\npublic final int getAndIncrement(java-concurrent//獲取當前的值，並自增\npublic final int getAndDecrement(java-concurrent//獲取當前的值，並自減\npublic final int getAndAdd(java-concurrent//獲取當前的值，並加上預期的值\nboolean compareAndSet(java-concurrent//如果輸入的數值等於預期值，則以原子方式將該值設置為輸入值（update）\npublic final void lazySet(java-concurrent//最終設置為newValue,使用 lazySet 設置之後可能導致其他線程在之後的一小段時間內還是可以讀到舊的值。\n```\n\n### 死鎖 (deadlock)\n\n如果一組線程中的每個線程都在等待一個事件，而這個事件只能由該組中的另一個線程觸發，這種情況會導致死鎖。\n\n死鎖需要滿足四個條件（線程維度上）：\n\n1. 互斥，該資源任意時刻只能由一個線程佔用。\n2. 請求與保持，一個線程因請求資源被阻塞，另一個線程保持該資源不放。\n3. 不剝奪/不可搶佔，一個線程不能強佔另一個線程擁有的資源，除非另一個線程釋放之。\n4. 循環等待，若干個線程形成循環等待資源的關係。\n\n那麼，防止死鎖只需要不滿足以上四個條件之一即可。具體來說：\n\n1. 破壞互斥：不可，這是資源的固有屬性，不可破壞。\n2. 破壞請求與保持：可以一次性請求所有需要的資源。\n3. 破壞不剝奪：\n    - 若有一佔有若干資源的進程請求某資源被拒絕，則它應釋放它佔有的資源。\n    - 若有一進程請求當前被另一個進程佔有的資源，則操作系統可以剝奪另一個進程的資源。\n4. 破壞循環等待：確定資源的申請順序和釋放順序。\n\n下面是一個死鎖的實例，線程A 擁有資源1 後想要獲得資源2，線程B 擁有資源2 後想要獲得資源1。\n\n![](java-concurrent/Untitled%208.png)\n\n```java\nObject res1 = new Object();\nObject res2 = new Object();\n\nnew Thread(() -> {\n  synchronized (res1) {\n      System.out.println(Thread.currentThread() + \" get res1\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res2\");\n      synchronized (res2) {\n          System.out.println(Thread.currentThread() + \" get res2\");\n      }\n  }\n}, \"Thread A\").start();\n\nnew Thread(() -> {\n  synchronized (res2) {\n      System.out.println(Thread.currentThread() + \" get res2\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res1\");\n      synchronized (res1) {\n          System.out.println(Thread.currentThread() + \" get res1\");\n      }\n  }\n}, \"Thread B\").start();\n\n// 按相同順序申請和釋放資源，破壞循環等待條件，從而避免死鎖\nnew Thread(() -> {\n  synchronized (res1) {\n      System.out.println(Thread.currentThread() + \" get res1\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res2\");\n      synchronized (res2) {\n          System.out.println(Thread.currentThread() + \" get res2\");\n      }\n  }\n}, \"Thread B\").start();\n```","source":"_posts/it/java/java-concurrent.md","raw":"---\ntitle: Java 多線程\np: it/java/java-concurrent.md\ntags:\n- Java\n---\n\n首先區分進程和線程。進程是程序運行的基本單位，也是系統分配資源的最小單位；而線程是 CPU 調度的最小單位，一個進程可以有多個線程，而各個線程擁有獨立的程序計數器、虛擬機棧和本地方法棧，但共享同一個堆和方法區。爲著充分利用系統資源，減少 CPU 空等，多線程技術應運而生。系統使用時間片輪轉法分配 CPU 資源到各個線程，如果線程在分配的時間片內未能處理完任務，則會導致上下文切換。\n\nJava 中線程類爲 `Thread` ，其 `start` 方法會使線程進入 Runnable 狀態；其 `sleep` 方法會阻塞線程而不釋放鎖，跟 `Object.wait` 有別；其 `interrupt` 方法並不停止線程，而是設置一個標誌位通知線程應當關閉，線程可以根據該標誌位決定是否要停止運行。\n\n多個線程可以通過線程池進行統一管理，好處是還可以提前 Ready 好一些線程避免等待線程創建的時間損耗；還可以使用舊的線程，減少線程的頻繁創建和銷毀的資源損耗。線程池推薦直接使用 `ThreadPoolExecutor` 的構造方法去創建，以便設置合適的構造參數。調用 `ThreadPoolExecutor.execute` 可以將一個 `Runnable` 任務放入線程池處理； 調用`ThreadPoolExecutor.submit`  可以將一個 `Callable` 任務放入線程池處理，返回一個 `Future` 代表處理結果，後續通過調用 `Future.get` 獲取處理結果，其過程是阻塞的。\n\nJava 1.5 開始提供`AbstractQueuedSynchronizer`，用於創建多線程訪問共享資源的同步器，其內部使用一個名爲 CLH 的 FIFO 的雙向隊列進行資源分配。其常見實現類有：`ReentrantLock`、`ReadWriteLock` 和 `CountDownLatch` 。其中 `ReadWriteLock` 性能優於 `ReentrantLock` ，因爲兩個讀操作在 `ReadWriteLock` 中不互斥而在 `ReentrantLock` 中互斥。\n\nJava 1.8 開始提供了 `CompletableFuture` ，其實現了 `Future` 接口，並提供了基於回調的函數式異步編程方式和對`CompletableFuture` 的組合，使用者可以不關心底層的線程池，大大簡便了異步編程。\n\nJava 還提供了 ThreadLocal 類可以使得各個線程擁有變量的副本而不會相互影響，底層是使用 Thread 類的 `ThreadLocalMap`，一個類似 HashMap 的結構，其 Key 爲 ThreadLocal 對象的弱引用。\n\n多線程因會有多個線程操作共享的資源而引發了線程安全的擔憂。線程安全要求**原子性、可見性和有序性**。Java 提供了多種方式可以保證線程安全：\n\n1. synchronized 同步鎖，這是一個重量級鎖。可以使用當前類的 class 對象，當前類的對象或者任意對象對方法和代碼塊進行加鎖，方法結束或代碼塊結束則鎖自動釋放。當使用非靜態同步方法時，會使用當前對象爲鎖，因此多個非靜態同步方法共享同一鎖。Java 1.6 後引入**偏向鎖**和**輕量級鎖**的概念，使得 synchronized 不那麼「重」了。\n2. volatile 關鍵字。使用該關鍵字修飾的變量在編譯時不會有寄存器緩存而是直接使用主存、不會進行代碼重排序優化，保證了可見性和有序性；在解釋執行時使用 CPU 內存屏障技術防止指令重排序。\n3. CAS(Compare and Swap) 技術，相比於 synchronized，其假定操作是不會產生衝突的，將舊的預期值和內存中的值進行比較，若相同則更新內存中的值，否則自旋。因此被稱之爲「樂觀鎖」，而 synchronized 被稱之爲「悲觀鎖」。Java 中的 Atomic 類是典型的 CAS 實現。\n\n多線程操作共享資源還會出現死鎖。死鎖產生的條件是：**互斥、請求/等待、不可剝奪和循環等待**。解決死鎖問題的關鍵是破壞死鎖產生的條件。\n\n<!-- more -->\n\n## 多線程\n\n### **程序、進程與線程**\n\n1. 程序：程序是含有指令和數據的文件，被靜態存儲於存儲設備之中。\n2. 進程：进程是程序的一次執行過程，是**操作系統運行程序的基本單位**，是動態的。它佔用一定的系統資源（包括 CPU 時間、內存空間、文件、輸入輸出設備等等），**是資源分配的最小單位**。各進程之間相互獨立。\n3. 線程：**線程是 CPU 調度的最小單位**，擁有**程序計數器、虛擬機棧和本地方法棧**，相比進程，它佔用資源更小，產生和切換線程的負擔更小，也被稱爲**輕量級進程**。一個進程可以產生多個線程。同個進程的多個線程之間共享同一塊**堆和方法區**。\n\n- 堆是幹什麼用的？\n\n    堆是進程中最大的一塊內存，用於存放新建的對象。\n\n- 方法區是幹什麼的？\n\n    根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放程序執行代碼的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(java-concurrent/code segment)，通常只讀。具體來說，它存放了每個類的結構，例如運行時常量池，字段和方法數據，以及方法和構造函數的代碼，包括用於類和實例初始化以及接口初始化的特殊方法。\n\n    另外，UNIX 中的進程將內存劃分成三個部分：text segment,文本區，例如代碼，data segment，數據區，例如變量，stack segment，棧區域。\n\n- 程序計數器爲什麼是線程私有的？\n\n    程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。\n\n    因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。\n\n- 虛擬機棧和本地方法棧爲什麼是線程私有的？\n    - **虛擬機棧**：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態鏈接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。\n    - **本地方法棧**：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。\n\n    爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。\n\n### **線程有哪些基本狀態**\n\nJava 線程共有 6 中狀態，如下：\n\n1. New：新創建的線程，尚未執行。\n2. Runnable：運行中的線程，`run` 方法正在執行中。可細分爲 Ready 和 Running 兩個狀態。\n3. Blocked：運行中的線程，因爲某些操作被阻塞而掛起。\n4. Waiting：運行中的線程，因爲某些操作在等待。\n5. Timed Waiting：運行中的線程，因爲執行 `sleep` 等方法正在計時等待。\n6. Terminated：線程終止，因爲 `run` 方法執行完畢。\n\n![](java-concurrent/Untitled.png)\n\n### 並發和並行的區別\n\n並發（concurrent）：同一時間段，多個任務都在執行。\n\n並行（parallel）：單位時間內，多個任務同時執行。\n\n### 多線程的優勢\n\n1. 提高 CPU 和 IO 設備的綜合利用率，確保 CPU 或 IO 設備不空等。\n2. 提高 CPU 核心利用率，確保 CPU 的多個核心都能被利用到。\n3. 提高系統整體的並發能力和性能，應對高並發場景。\n\n### 上下文切換\n\n**上下文切換就是舊任務被暫停，保存自身狀態，然後新任務被執行的過程**。造成上下文切換的原因是需要同時執行的任務大於 CPU 核心數，而單個 CPU 同一時刻只能執行一個任務。CPU 採用時間片輪轉法分配 CPU 時間給多個線程，當時間片結束舊任務如果未執行完畢會被暫停，保存當前狀態，然後執行新的任務。\n\n上下文切換所需的時間很可觀，可能是操作系統中時間消耗最大的操作。操作系統中數 Linux（及其他類 Unix 系統） 上下文切換時間消耗最少。\n\n### 爲什麼調用 `Thread.start` 方法而不是 `Thread.run` 方法？\n\n調用 `start` 方法會啟動一個新線程並進入就緒狀態，當分配到時間片後會自動調用 `run` 方法。直接調用 `run` 方法只會在調用者所在的線程執行。\n\n### 比較 `Thread.sleep` 方法和 `Object.wait` 方法\n\n共同點：\n\n1. 都可以暫停線程的執行。\n2. `sleep(long)`和 `wait(long)` 都可以在指定時間段後使線程自動甦醒。\n\n不同點：\n\n1. sleep 是 Thread 類的方法，wait 是 Object 類的方法。\n2. **sleep 沒有釋放鎖，wait 釋放了**。\n3. `wait()` 被調用後線程不會自動甦醒，需要別的線程調用同一對象上的 `notify()` 或 `notifyAll()` 方法來喚醒。\n- 代碼\n\n    ```java\n    // Data.java\n    public class Data {\n        private String packet;\n\n        // 单次传输是否结束\n        // True if Receiver should wait\n        // False if Sender should wait\n        private boolean isTransfer = true;\n\n        public synchronized void send(String packet) {\n            while (!isTransfer) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            this.packet = packet;\n            isTransfer = false;\n            notifyAll();\n        }\n\n        public synchronized String receive() {\n            while (isTransfer) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            isTransfer = true;\n            notifyAll();\n            return packet;\n        }\n    }\n\n    // Sender.java\n    public class Sender implements Runnable {\n\n        private final Data data;\n\n        public Sender(Data data) {\n            this.data = data;\n        }\n\n        @Override\n        public void run() {\n            String[] packets = new String[]{\"Hello\", \"Are\", \"You\", \"Ok\", \"Over\"};\n            for (String packet : packets) {\n                data.send(packet);\n            }\n        }\n    }\n\n    // Receiver.java\n    public class Receiver implements Runnable {\n\n        private final Data data;\n\n        public Receiver(Data data) {\n            this.data = data;\n        }\n\n        @Override\n        public void run() {\n            String packet = data.receive();\n            while (!\"Over\".equals(packet)) {\n                System.out.println(packet);\n                packet = data.receive();\n            }\n        }\n    }\n\n    // Main.java\n    public class Main {\n\n        public static void main(String[] args) {\n            Data data = new Data();\n            new Thread(new Receiver(data)).start();\n            new Thread(new Sender(data)).start();\n        }\n    }\n    ```\n\n### 調用 `Thread.interrupt` 意味著什麼？\n\n調用 interrupt 方法並不會中斷一個線程，而是發出出一個中斷信號到目標線程（設置中斷標誌位的值爲 true），目標線程收到信號後可以決定是否處理。\n\n與之相關的方法有：\n\n```java\n// 測試當前線程是否已經中斷。當線程中斷時調用該方法將會清除線程的中斷狀態\npublic static boolean interrupted()\n// 測試線程是否已經中斷。不改變線程的中斷狀態。\npublic boolean isInterrupted()\n// 中斷線程\npublic void interrupt()\n```\n\n[廖雪峰的官方網站](java-concurrent//www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554)提供了以下的代碼：\n\n```java\npublic class Main {\n  public static void main(String[] args) throws InterruptedException {\n      Thread t = new MyThread();\n      t.start();\n      Thread.sleep(java-concurrent// 暫停1毫秒\n      t.interrupt(java-concurrent// 中斷t線程\n      t.join(java-concurrent// 等待t線程結束\n      System.out.println(\"end\");\n  }\n}\n\nclass MyThread extends Thread {\n  public void run() {\n      int n = 0;\n      while (! isInterrupted()) {\n          n ++;\n          System.out.println(n + \" hello!\");\n      }\n  }\n}\n```\n\n值得注意的是：\n\n1. 本線程中斷自己是被允許的；其它線程調用本線程的`interrupt`方法時，會通過`checkAccess`檢查權限。這有可能拋出`SecurityException`異常。\n2. 調用線程的`wait` 方法會讓它進入等待(阻塞)狀態，或者調用線程的`join`, `sleep` 方法也會讓它進入阻塞狀態。若線程在阻塞狀態時，調用了它的`interrupt`方法，那麼它的「中斷狀態」會被清除並且會收到一個`InterruptedException`異常。例如，線程通過`wait()`進入阻塞狀態，此時通過`interrupt()`中斷該線程；調用`interrupt()`會立即將線程的中斷標記設為「true」，但是由於線程處於阻塞狀態，所以該「中斷標記」會立即被清除為「false」，同時，會產生一個`InterruptedException`的異常。\n3. 如果線程被阻塞在一個`Selector`選擇器中，那麼通過`interrupt()`中斷它時；線程的中斷標記會被設置為true，並且它會立即從選擇操作中返回。\n4. 如果不屬於前面所說的情況，那麼通過`interrupt()`中斷線程時，它的中斷標記會被設置為「true」。\n5. 中斷一個「已終止的線程」不會產生任何操作。\n\n### 線程池技術\n\n**（1）爲什麼要使用線程池？**\n\n線程池管理了一組線程資源，並維護了一些基本的統計信息。\n\n《Java 並發編程的藝術》中講述到使用線程池的好處：\n\n1. 降低資源消耗。通過重複使用已創建的線程減少線程創建和銷毀的消耗。\n2. 提高響應速度。線程池預先創建了線程，在需要時可以直接使用不用等。\n3. 提供線程的可管理性。線程是稀缺資源，不能無限制地分配，使用線程池可以進行統一分配、調優和監控。\n\n**（2）Runnable 接口和 Callable 接口的區別**\n\n1. Runnable 始於 Java 1.0 ，Callable 接口始於 Java 1.5.\n2. Runnable 不會返回結果或拋出檢查異常，而 Callable 會。\n\n另外，工具類 `Executors` 可以實現 Runnable 對象和 Callable 對象之間的相互轉換，如下：\n\n```java\nExecutors.callable(Runnable task)\nExecutors.callable(Runnable task，Object resule)\n```\n\n**（3）`execute` 方法和 `submit` 方法有什麼區別？**\n\n1. `execute` 提交任務之後沒有返回值，無法判斷任務是否被執行成功。\n2. `submit` 提交任務之後有返回值 Future，可以知道任務是否被執行成功。調用 `Future.get()` 會阻塞線程直到任務完成；調用 `Future.get(long timeout，TimeUnit unit)`  則是阻塞指定的一段時間後立即返回，不管任務是否執行完成。當然如果提交的是 Runnable，那麼返回的 Future 中的泛型爲 Void。\n\n**（4）如何創建線程池？**\n\n《阿里巴巴 Java 開發手冊》中要求直接用 `ThreadPoolExecutor` 的構造方法去創建線程池，而非通過 Executors 去創建線程池，因爲：\n\n1. `FixedThreadPool` 和 `SingleThreadPool` 中允許請求的隊列長度爲 `Integer.MAX_VALUE`，可能會堆積大量請求，導致 OOM；\n2. `CachedThreadPool` 和 `ScheduledThreadPool` 中允許線程數爲 `Integer.MAX_VALUE`，可能會創建大量線程，導致 OOM。\n\n`ThreadPoolExecutor` 的參數分析：\n\n```java\npublic ThreadPoolExecutor(\n  // 核心線程數，規定了最小的可以同時運行的線程數量\n\tint corePoolSize,\n  // 最大線程數，當請求隊列滿時，可以同時運行的線程數量\n\tint maximumPoolSize,\n  // 當線程空閒且大於規定的核心線程數時，等待 keepAliveTime 時間後多餘的線程會被銷毀\n\tlong keepAliveTime,\n  // keepAliveTime 的時間單位\n\tTimeUnit unit,\n  // 請求隊列，當新任務進來時，當前運行的線程達到核心線程數，則新任務會被放置到請求隊列\n\tBlockingQueue<Runnable> workQueue,\n  // 線程工廠，用於創建新線程\n\tThreadFactory threadFactory,\n  // 飽和策略，當線程數量達到最大線程數且請求隊列也滿的情況下觸發飽和策略\n\tRejectedExecutionHandler handler) {\n}\n```\n\n線程池中的飽和策略有：\n\n1. `ThreadPoolExecutor.AbortPolicy`：默認策略，拋出異常，拒絕處理新任務。\n2. `ThreadPoolExecutor.CallerRunsPolicy`：直接在調用 `execute` 所在的線程執行。\n3. `ThreadPoolExecutor.DiscardPolicy`：不拋出異常，直接丟棄新任務。\n4. `ThreadPoolExecutor.DiscardOldestPolicy`：不拋出異常，丟棄最早未處理的任務。\n\n**（5）線程池對新任務的處理過程**\n\n![](java-concurrent/Untitled%201.png)\n\n### AQS（抽象隊列式同步器）\n\n**（1）概述**\n\nAQS，即 `AbstractQueuedSynchronizer` ，加入於 Java 1.5，作者爲大名鼎鼎的 Doug Lea，其定義了一套多線程訪問共享資源的同步器框架。其下有諸如 `ReentrantLock`、`ReadWriteLock`、`CountDownLatch` 等等實現。\n\nAQS 的實現思路是：如下圖所示，當請求的共享資源空閒時，請求資源的線程會被設置爲有效的工作線程，該資源會被鎖定；當請求的共享資源被佔用時，將請求資源的線程加入 CLH 隊列中。CLH 是三個人名的首字母，CLH 隊列是一個雙向隊列，FIFO。而共享資源的狀態是一個整型值，採用 CAS 方式進行值的原子更新，通常加鎖 state 會加 1，釋放則減 1。\n\n![](java-concurrent/Untitled%202.png)\n\nAQS 可以定義兩種資源共享方式，獨佔 or 共享。其採用模板方法模式編寫，實現類需要選擇性地實現以下方法（默認實現是拋出`UnsupportedOperationException`）：\n\n```java\n//該線程是否正在獨佔資源。只有用到condition才需要去實現它。\nisHeldExclusively()\n//獨佔方式。嘗試獲取資源，成功則返回true，失敗則返回false。\ntryAcquire(int)\n//獨佔方式。嘗試釋放資源，成功則返回true，失敗則返回false。\ntryRelease(int)\n//共享方式。嘗試獲取資源。負數表示失敗；0表示成功，但沒有剩餘可用資源；正數表示成功，且有剩餘資源。\ntryAcquireShared(int)\n//共享方式。嘗試釋放資源，成功則返回true，失敗則返回false。\ntryReleaseShared(int)\n```\n\n**（2）ReentrantLock**\n\nReentrantLock，可重入鎖，同一線程可以反覆加鎖，然後釋放同樣次數的鎖。synchronized 修飾的方法用的也是可重入鎖，但 ReentrantLock 提供了更爲靈活的控制，有 lock、unlock 方法還有類似於 `Object.wait` / `Object.notify` 的 `Condition.await` / `Condition.signal` 方法。\n\n- 代碼\n\n    參考：[https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/](java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/)\n\n    ```java\n    // SharedFifoQueue.java\n    public class SharedFifoQueue {\n\n      private final Object[] content;\n      // 標識當前隊列中擁有的對象數目\n      private int current = 0;\n      private int addIndex = 0;\n      private int removeIndex = 0;\n\n      private final ReentrantLock lock = new ReentrantLock();\n      private final Condition fullCondition = lock.newCondition();\n      private final Condition emptyCondition = lock.newCondition();\n\n      public SharedFifoQueue(int capacity) {\n          content = new Object[capacity];\n      }\n\n      public void add(Object item) throws InterruptedException {\n          lock.lock();\n          while (current >= content.length) {\n              fullCondition.await();\n          }\n          content[addIndex] = item;\n          addIndex = (addIndex + 1) % content.length;\n          current++;\n          emptyCondition.signal();\n          lock.unlock();\n      }\n\n      public Object remove() throws InterruptedException {\n          lock.lock();\n          while (current <= 0) {\n              emptyCondition.await();\n          }\n          Object item = content[removeIndex];\n          removeIndex = (removeIndex + 1) % content.length;\n          current--;\n          fullCondition.signal();\n          lock.unlock();\n          return item;\n      }\n    }\n\n    // Producer.java\n    public class Producer implements Runnable {\n\n      private final SharedFifoQueue queue;\n      private final Random random = new Random();\n\n      public Producer(SharedFifoQueue queue) {\n          this.queue = queue;\n      }\n\n      @Override\n      public void run() {\n          try {\n              for (int i = 0; i < 20; i++) {\n                  queue.add(\"Hello \" + i);\n                  Thread.sleep(random.nextInt(200) );\n              }\n              queue.add(null);\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n\n    // Consumer.java\n    public class Consumer implements Runnable {\n\n      private final SharedFifoQueue queue;\n\n      public Consumer(SharedFifoQueue queue) {\n          this.queue = queue;\n      }\n\n      @Override\n      public void run() {\n          try {\n              while (true) {\n                  Object item = queue.remove();\n                  if (item == null) {\n                      break;\n                  }\n                  System.out.println(item.toString());\n              }\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n\n    // Main.java\n    public static void main(String[] args) throws InterruptedException {\n        SharedFifoQueue sharedFifoQueue = new SharedFifoQueue(10);\n        Thread consumerThread = new Thread(new Consumer(sharedFifoQueue));\n        Thread producerThread = new Thread(new Producer(sharedFifoQueue));\n\n        producerThread.start();\n        consumerThread.start();\n        // join 可以讓主線程等待子線程結束\n        producerThread.join();\n        consumerThread.join();\n    }\n    ```\n\n**（3）ReadWriteLock**\n\nReadWriteLock 相比 ReentrantLock 性能更高，體現在兩個讀操作在 ReadWriteLock 裏是不互斥的，而在 ReentrantLock 裏是互斥的。\n\n- 代碼\n\n    代碼來源：[https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/](java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/)\n\n    ```java\n    public class ThreadSafeArrayList<E> {\n      private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n      private final Lock readLock = readWriteLock.readLock();\n      private final Lock writeLock = readWriteLock.writeLock();\n\n      private final List<E> list = new ArrayList<>();\n\n      public void set(E o) {\n          writeLock.lock();\n          try {\n              list.add(o);\n          } finally {\n              writeLock.unlock();\n          }\n      }\n\n      public E get(int i) {\n          readLock.lock();\n          try {\n              return list.get(i);\n          } finally {\n              readLock.unlock();\n          }\n      }\n    }\n    ```\n\n**（4）CountDownLatch**\n\nCountDownLatch 可以讓一個或多個線程等待指定的操作完成後再開始工作。初始化 CountDownLatch 時需要指定一個 count 值，需要等待的線程使用 `CountDownLatch.await()` 進行等待，當 `CountDownLatch.countDown()` 被調用 count 次時，等待的線程才得以繼續執行。\n\n- 代碼\n\n    代碼來源：[http://tutorials.jenkov.com/java-util-concurrent/countdownlatch.html](java-concurrent//tutorials.jenkov.com/java-util-concurrent/countdownlatch.html)\n\n    ```java\n    // Main.java\n    CountDownLatch latch = new CountDownLatch(3);\n\n    Waiter      waiter      = new Waiter(latch);\n    Decrementer decrementer = new Decrementer(latch);\n\n    new Thread(waiter)     .start();\n    new Thread(decrementer).start();\n\n    Thread.sleep(4000);\n    // Waiter.java\n    public class Waiter implements Runnable{\n\n      CountDownLatch latch = null;\n\n      public Waiter(CountDownLatch latch) {\n          this.latch = latch;\n      }\n\n      public void run() {\n          try {\n              latch.await();\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n\n          System.out.println(\"Waiter Released\");\n      }\n    }\n    // Decrementer.java\n    public class Decrementer implements Runnable {\n\n      CountDownLatch latch = null;\n\n      public Decrementer(CountDownLatch latch) {\n          this.latch = latch;\n      }\n\n      public void run() {\n          try {\n              Thread.sleep(1000);\n              this.latch.countDown();\n\n              Thread.sleep(1000);\n              this.latch.countDown();\n\n              Thread.sleep(1000);\n              this.latch.countDown();\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }\n    }\n    ```\n\n**（5）Semaphore**\n\nSemaphore 用於限制訪問資源的線程數量，以對資源進行保護。[有人將其比做是廁所的坑位數](java-concurrent//blog.csdn.net/eson_15/article/details/51577191)，譬如一個廁所有 3 個坑，則同時上廁所的人只能有 3 個，其他人要上只能等這 3 個人之一釋放坑位。\n\n使用前通過調用 `Semaphore.acquire` 獲取訪問，使用後通過  `Semaphore.release` 釋放許可。\n\n- 代碼\n\n    ```java\n    public static void main(String[] args) {\n        ExecutorService threadPool = Executors.newFixedThreadPool(10);\n        Semaphore semaphore = new Semaphore(3);\n        for (int i = 0; i < 10; i++) {\n            threadPool.execute(() -> {\n                try {\n                    semaphore.acquire();\n                    System.out.printf(\"Running Thread Id: %s, Available permit: %d, Queue length: %d\\n\", Thread.currentThread().getId(), semaphore.availablePermits(), semaphore.getQueueLength());\n                    Thread.sleep(300);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    semaphore.release();\n                }\n            });\n        }\n    }\n    ```\n\n    運行結果：\n\n    初始化總許可量爲 3，一開始被用掉一個許可，可用許可剩餘 2；隨後許可被用光，其他線程開始排隊，出現長度爲 6 的請求隊列，之後隨之許可釋放，隊列長度遞減，直到所有任務處理完成，隊列長度爲 0，許可復爲 3。\n\n    ```java\n    Running Thread Id: 13, Available permit: 2, Queue length: 0\n    Running Thread Id: 15, Available permit: 0, Queue length: 0\n    Running Thread Id: 14, Available permit: 1, Queue length: 0\n    Running Thread Id: 16, Available permit: 0, Queue length: 6\n    Running Thread Id: 17, Available permit: 1, Queue length: 5\n    Running Thread Id: 18, Available permit: 0, Queue length: 4\n    Running Thread Id: 19, Available permit: 0, Queue length: 3\n    Running Thread Id: 20, Available permit: 1, Queue length: 2\n    Running Thread Id: 21, Available permit: 0, Queue length: 1\n    Running Thread Id: 22, Available permit: 2, Queue length: 0\n    ```\n\n### CompletableFuture\n\n參考：[https://colobu.com/2016/02/29/Java-CompletableFuture/](java-concurrent//colobu.com/2016/02/29/Java-CompletableFuture/)、[https://www.jianshu.com/p/6bac52527ca4](java-concurrent//www.jianshu.com/p/6bac52527ca4)\n\nCompletableFuture 是 Java 1.8 提供的類，可以方便函數式異步編程。CompletableFuture 實現了 Future 接口。\n\nFuture 是 Java 1.5 引入的接口，它代表這異步執行的結果。可以通過 `isDone` 判斷執行是否完畢，通過 `get` 阻塞獲取結果，通過 `cancel` 取消執行。\n\nFuture 獲取結果的方式不優雅，要輪詢或一直阻塞等待結果。 CompletableFuture 提供了回調的方式處理結果（正常結果 & 異常結果），還有組合多個 CompletableFuture 的能力。\n\n有了 CompletableFuture，我們甚至可以不關心線程、線程池和同步，因爲 CompletableFuture 內部已經幫我們處理好了，我們只需要鏈式調用函數就可以了。\n\n```java\nCompletableFuture.allOf(CompletableFuture.runAsync(() -> {\n  try {\n      Thread.sleep(200);\n  } catch (InterruptedException e) {\n      e.printStackTrace();\n  }\n  System.out.println(Thread.currentThread().getId() + \" done!\");\n}), CompletableFuture.runAsync(() -> {\n  try {\n      Thread.sleep(200);\n  } catch (InterruptedException e) {\n      e.printStackTrace();\n  }\n  System.out.println(Thread.currentThread().getId() + \" done!\");\n})).handle((BiFunction<Void, Throwable, Void>) (unused, throwable) -> {\n  if (throwable != null) {\n      System.out.println(\"Exception:\" + throwable.getMessage());\n  } else {\n      System.out.println(\"All done!\");\n  }\n  return null;\n}).join();\n```\n\n### ThreadLocal\n\nThreadLocal 可以讓每個線程擁有變量的副本進行讀寫而互不影響。ThreadLocal 的原理就是 Thread 類本身的 ThreadLocalMap，當調用 `ThreadLocal.set` 方法時會去獲取當前線程的 ThreadLocalMap，然後以當前 ThreadLocal 爲 key，將值放入其中；當調用`ThreadLocal.get`時則從 ThreadLocalMap 中讀取。如此每個 Thread 都有各自的專屬變量，不受其他線程影響。\n\n![](java-concurrent/Untitled%203.png)\n\nThreadLocalMap 中的 key 採用弱引用，如果 key 即 ThreadLocal 沒有強引用的話，key 會被 GC 回收變爲 null，而 value 因爲是強引用不會被 GC 回收，於是出現了 key 爲 null 的 Entry，造成內存泄漏。ThreadLocalMap 在調用 `get`、`set` 方法時會清理 key 爲 null 的Entry，雖如此還是在使用完 ThreadLocal 後手動調用下 `remove` 方法爲好。\n\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n  /** The value associated with this ThreadLocal. */\n  Object value;\n\n  Entry(ThreadLocal<?> k, Object v) {\n      super(k);\n      value = v;\n  }\n}\n```\n\n## 線程安全\n\n### 線程安全的保證\n\n1. 原子性：多項操作要麼都執行，要麼都不執行。synchronized 可以保證代碼片段的原子性。\n2. 可見性：當一個線程對共享變量做了修改，其他線程要立即可以看到修改後的值。volatile 可以保證共享變量的可見性。\n3. 有序性：代碼編寫時的順序同編譯執行時的順序一致。volatile 可以禁止指令重排序。\n\n### **synchronized 同步鎖的用法**\n\nsynchronized 使用時需要指定一個鎖，當程序進入 synchronized 代碼塊或方法時該鎖會被鎖住，直到離開 synchronized 代碼塊或方法，鎖才會被釋放。注意：同步的範圍越小越好。\n\n**同步代碼塊**\n\n```java\npublic void f() {\n  synchronized(this){\n  }\n}\n```\n\n同步代碼塊的鎖可以選擇使用當前對象（this）、當前類 class 對象或其他任意對象。\n\n**同步方法**\n\n```java\npublic synchronized void f() {\n}\n```\n\n此時鎖爲同步方法所在類的對象。**同一個對象的多個同步方法共享同一個鎖**，多個實例對象時各個對象有各自的鎖。子類重寫父類的同步方法時可以去除同步。\n\n**同步靜態方法**\n\n```java\npublic static synchronized void f() {\n}\n```\n\n此時鎖為同步靜態方法所在類的 class 對象，即使多個實例對象也共享同一個鎖。\n\n### 使用 String 作爲鎖的注意點\n\n1. 首先 String 是一個特殊的類，JVM 使用常量池技術對其進行了緩存，通過字面量使用時會總是返回同一個 String 對象。\n2. 使用 `new String`、`StringBuilder.toString` 和 `StringBuffer.toString` 每次會返回一個新的 String 對象。\n3. 使用 `String.intern`，當常量池中有值等同的 String 對象時返回該對象，如無則將其加入常量池。\n\n### **Java 同步鎖的本質**\n\n**Java 的鎖是存在於對象頭**中的，具體就 Hotspot 虛擬機來說，是存在於對象頭中的 Mark Word（標記字段）中的鎖標誌位。Java 對象可有四種鎖狀態：\n\n1. 一開始對象無鎖，當一段同步代碼一直被一個線程訪問時，該線程自動獲得鎖，此時該鎖爲**偏向鎖**；\n2. 當鎖是偏向鎖時，另一個線程訪問同步代碼，偏向鎖會升級爲**輕量級鎖**，其他線程會通過**自旋**（指嘗試獲取鎖的線程不會立即阻塞，而是採用循環的方式獲取鎖）嘗試獲取鎖；\n3. 當鎖是輕量級鎖時，另一個線程自旋到一定次數仍然未獲得鎖，輕量級鎖會自動升級爲**重量級鎖**，其他線程進入阻塞狀態。\n\n![](java-concurrent/_2020-11-16_8.54.01.png)\n\n當處於重量級鎖時，對象頭存儲的指針指向的重量級鎖也叫 **monitor 鎖**（監視器鎖）。多個線程爭搶的就是這個 monitor 對象，誰持有誰就可以運行同步代碼。通過使用 `javap -c -s -v -l xx.class` 反彙編字節碼知道：當使用 `synchronized` 同步代碼塊時其實現時 `monitorenter` 和 `monitorexit` 指令，其中的 `monitorenter` 指令指向同步代碼塊開始的位置，`monitorexit` 則指向結束的位置；當使用 `synchronized` 修飾方法時，則是使用 `ACC_SYNCHRONIZED` 標識該方法爲同步方法。\n\n獲取鎖的過程如下圖所示：需要訪問同步代碼的多個線程首先進入 Entry Set，當線程獲取到 monitor 對象時會進入 The Owner 區域，然後將 monitor 對象中的 owner 變量設置爲當前線程，計數器 count 加 1；若線程調用 wait 方法，將釋放持有的 monitor，owner 變量設置爲 null，計數器 count 減 1，同時該線程進入 Wait Set 等待被喚醒；若線程執行完畢也將釋放 monitor 並恢復 monitor 中相關變量的值。\n\n![](java-concurrent/Untitled%204.png)\n\n### volatile 關鍵字\n\n參考：[https://monkeysayhi.github.io/2017/12/28/一文解决内存屏障/](java-concurrent//monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/)\n\nvolatile 關鍵字可以修飾變量，其作用是：\n\n標記該變量以在編譯時，取消編譯層面的緩存和重排序（編譯時的亂序優化）；在解釋執行時使用 CPU 內存屏障技術解決硬件層面的可見性和重排序。具體來說：\n\n1. **被修飾的變量在寄存器中將不會有副本，而是直接從主存進行讀寫操作**，多線程環境下，變量的值的改變**即時可見**。所謂的主存和寄存器是計算機的解決訪問 CPU 處理速度和內存讀寫速度不匹配的手段。一般認爲寄存器的讀寫速度快於主存。\n\n    ![](java-concurrent/Untitled%205.png)\n\n    未聲明 volatile 時\n\n    ![](java-concurrent/Untitled%206.png)\n\n    聲明 volatile 時\n\n2. 編譯器不對該變量進行亂序優化。\n3. JVM 在解釋執行時使用對應 CPU 架構的內存屏障指令防止指令重排序，通常有以下三種：\n    - mfence(StoreLoad Barriers、Full Barrier) 全能屏障\n    - sfence(Store Barriers) 寫屏障\n    - lfence(Load Barrirers) 讀屏障\n\n    以 x86 架構爲例子，如有一以 volatile 修飾的變量 v，JVM 對其操作如下：\n\n    1. 在寫入 v 之後插入一個 sfence，隔離了寫入 v 前後的寫入指令，防止其重排序，且 sfence 之前的修改會被寫入緩存並標記其他 CPU 核心中的緩存失效；\n    2. 在讀取 v 之前插入一個 lfence，隔離了讀取 v 前後的讀取指令，防止其重排序，且 lfence 之後會先刷新緩存，從而讀取最新的值。\n\n    sfence 和 lfence 兩相配合，保證了變量 v 的可見性。\n\n### CAS 鎖\n\nsynchronized 是悲觀鎖，假定操作是有衝突的，要加鎖然後再執行程序，完畢後再釋放鎖。而 CAS(Compare And Swap) 是樂觀鎖，假定操作是沒有衝突的，不需要加鎖，而是把舊的預期值跟內存中已有的值進行比較，如果相同再把要更新的值更新到內存，如果不同則自旋（重試，重新獲取預期值進行比較和替換），Java 中的原子類（比如 AtomicInteger）的底層實現就是 CAS。\n\nCAS 存在一個稱之爲 ABA 的問題，即對於變量 v = A，當其變爲 B 後又復原爲 A 時，無法判斷變量 v 是否被修改過。\n\n![](java-concurrent/Untitled%207.png)\n\n使用 `AtomicStampedReference` 可以防止 ABA 的問題，因爲附帶的 Stamp可以標識 Reference 的版本，Reference 變化，Stamp 隨之遞增。\n\n### Atomic 原子類\n\n`java.util.concurrent.atomic` 包中提供了一系列原子類，包括：\n\n1. 原子類型：\n    - AtomicInteger：針對整型\n    - AtomicLong：針對長整型\n    - AtomicBoolean：針對布爾類型\n2. 數組類型：\n    - AtomicIntegerArray：針對整型數組\n    - AtomicLongArray：針對長整型數組\n    - AtomicReferenceArray：針對引用類型數組\n3. 引用類型：\n    - AtomicReference：針對對象引用\n    - AtomicStampedReference：針對對象引用連同一個整型\n    - AtomicMarkableReference：針對對象引用連同一個布爾類型\n4. 對象的屬性修改類型：\n    - AtomicIntegerFieldUpdater：修改對象的一個整型屬性\n    - AtomicLongFieldUpdater：修改對象的一個長整型屬性\n    - AtomicReferenceFieldUpdater：修改對象的一個整型屬性\n\n其理論基礎就是 **CAS**(Compare and Swap) **鎖 + volatile + native 方法。**CAS 就是將舊的預期值與內存中的值進行比較，當相同時才將新的預期值設入，否則自旋。 \n\n介紹下 AtomicInteger 類的幾個原子方法：\n\n```java\npublic final int get(java-concurrent//獲取當前的值\npublic final int getAndSet(java-concurrent//獲取當前的值，並設置新的值\npublic final int getAndIncrement(java-concurrent//獲取當前的值，並自增\npublic final int getAndDecrement(java-concurrent//獲取當前的值，並自減\npublic final int getAndAdd(java-concurrent//獲取當前的值，並加上預期的值\nboolean compareAndSet(java-concurrent//如果輸入的數值等於預期值，則以原子方式將該值設置為輸入值（update）\npublic final void lazySet(java-concurrent//最終設置為newValue,使用 lazySet 設置之後可能導致其他線程在之後的一小段時間內還是可以讀到舊的值。\n```\n\n### 死鎖 (deadlock)\n\n如果一組線程中的每個線程都在等待一個事件，而這個事件只能由該組中的另一個線程觸發，這種情況會導致死鎖。\n\n死鎖需要滿足四個條件（線程維度上）：\n\n1. 互斥，該資源任意時刻只能由一個線程佔用。\n2. 請求與保持，一個線程因請求資源被阻塞，另一個線程保持該資源不放。\n3. 不剝奪/不可搶佔，一個線程不能強佔另一個線程擁有的資源，除非另一個線程釋放之。\n4. 循環等待，若干個線程形成循環等待資源的關係。\n\n那麼，防止死鎖只需要不滿足以上四個條件之一即可。具體來說：\n\n1. 破壞互斥：不可，這是資源的固有屬性，不可破壞。\n2. 破壞請求與保持：可以一次性請求所有需要的資源。\n3. 破壞不剝奪：\n    - 若有一佔有若干資源的進程請求某資源被拒絕，則它應釋放它佔有的資源。\n    - 若有一進程請求當前被另一個進程佔有的資源，則操作系統可以剝奪另一個進程的資源。\n4. 破壞循環等待：確定資源的申請順序和釋放順序。\n\n下面是一個死鎖的實例，線程A 擁有資源1 後想要獲得資源2，線程B 擁有資源2 後想要獲得資源1。\n\n![](java-concurrent/Untitled%208.png)\n\n```java\nObject res1 = new Object();\nObject res2 = new Object();\n\nnew Thread(() -> {\n  synchronized (res1) {\n      System.out.println(Thread.currentThread() + \" get res1\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res2\");\n      synchronized (res2) {\n          System.out.println(Thread.currentThread() + \" get res2\");\n      }\n  }\n}, \"Thread A\").start();\n\nnew Thread(() -> {\n  synchronized (res2) {\n      System.out.println(Thread.currentThread() + \" get res2\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res1\");\n      synchronized (res1) {\n          System.out.println(Thread.currentThread() + \" get res1\");\n      }\n  }\n}, \"Thread B\").start();\n\n// 按相同順序申請和釋放資源，破壞循環等待條件，從而避免死鎖\nnew Thread(() -> {\n  synchronized (res1) {\n      System.out.println(Thread.currentThread() + \" get res1\");\n      try {\n          Thread.sleep(1000);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n      System.out.println(Thread.currentThread() + \" wait res2\");\n      synchronized (res2) {\n          System.out.println(Thread.currentThread() + \" get res2\");\n      }\n  }\n}, \"Thread B\").start();\n```","slug":"it/java/java-concurrent","published":1,"date":"2021-02-05T16:21:16.757Z","updated":"2021-02-05T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wov001i9a9kfown9dph","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>首先區分進程和線程。進程是程序運行的基本單位，也是系統分配資源的最小單位；而線程是 CPU 調度的最小單位，一個進程可以有多個線程，而各個線程擁有獨立的程序計數器、虛擬機棧和本地方法棧，但共享同一個堆和方法區。爲著充分利用系統資源，減少 CPU 空等，多線程技術應運而生。系統使用時間片輪轉法分配 CPU 資源到各個線程，如果線程在分配的時間片內未能處理完任務，則會導致上下文切換。</p>\n<p>Java 中線程類爲 <code>Thread</code> ，其 <code>start</code> 方法會使線程進入 Runnable 狀態；其 <code>sleep</code> 方法會阻塞線程而不釋放鎖，跟 <code>Object.wait</code> 有別；其 <code>interrupt</code> 方法並不停止線程，而是設置一個標誌位通知線程應當關閉，線程可以根據該標誌位決定是否要停止運行。</p>\n<p>多個線程可以通過線程池進行統一管理，好處是還可以提前 Ready 好一些線程避免等待線程創建的時間損耗；還可以使用舊的線程，減少線程的頻繁創建和銷毀的資源損耗。線程池推薦直接使用 <code>ThreadPoolExecutor</code> 的構造方法去創建，以便設置合適的構造參數。調用 <code>ThreadPoolExecutor.execute</code> 可以將一個 <code>Runnable</code> 任務放入線程池處理； 調用<code>ThreadPoolExecutor.submit</code>  可以將一個 <code>Callable</code> 任務放入線程池處理，返回一個 <code>Future</code> 代表處理結果，後續通過調用 <code>Future.get</code> 獲取處理結果，其過程是阻塞的。</p>\n<p>Java 1.5 開始提供<code>AbstractQueuedSynchronizer</code>，用於創建多線程訪問共享資源的同步器，其內部使用一個名爲 CLH 的 FIFO 的雙向隊列進行資源分配。其常見實現類有：<code>ReentrantLock</code>、<code>ReadWriteLock</code> 和 <code>CountDownLatch</code> 。其中 <code>ReadWriteLock</code> 性能優於 <code>ReentrantLock</code> ，因爲兩個讀操作在 <code>ReadWriteLock</code> 中不互斥而在 <code>ReentrantLock</code> 中互斥。</p>\n<p>Java 1.8 開始提供了 <code>CompletableFuture</code> ，其實現了 <code>Future</code> 接口，並提供了基於回調的函數式異步編程方式和對<code>CompletableFuture</code> 的組合，使用者可以不關心底層的線程池，大大簡便了異步編程。</p>\n<p>Java 還提供了 ThreadLocal 類可以使得各個線程擁有變量的副本而不會相互影響，底層是使用 Thread 類的 <code>ThreadLocalMap</code>，一個類似 HashMap 的結構，其 Key 爲 ThreadLocal 對象的弱引用。</p>\n<p>多線程因會有多個線程操作共享的資源而引發了線程安全的擔憂。線程安全要求<strong>原子性、可見性和有序性</strong>。Java 提供了多種方式可以保證線程安全：</p>\n<ol>\n<li>synchronized 同步鎖，這是一個重量級鎖。可以使用當前類的 class 對象，當前類的對象或者任意對象對方法和代碼塊進行加鎖，方法結束或代碼塊結束則鎖自動釋放。當使用非靜態同步方法時，會使用當前對象爲鎖，因此多個非靜態同步方法共享同一鎖。Java 1.6 後引入<strong>偏向鎖</strong>和<strong>輕量級鎖</strong>的概念，使得 synchronized 不那麼「重」了。</li>\n<li>volatile 關鍵字。使用該關鍵字修飾的變量在編譯時不會有寄存器緩存而是直接使用主存、不會進行代碼重排序優化，保證了可見性和有序性；在解釋執行時使用 CPU 內存屏障技術防止指令重排序。</li>\n<li>CAS(Compare and Swap) 技術，相比於 synchronized，其假定操作是不會產生衝突的，將舊的預期值和內存中的值進行比較，若相同則更新內存中的值，否則自旋。因此被稱之爲「樂觀鎖」，而 synchronized 被稱之爲「悲觀鎖」。Java 中的 Atomic 類是典型的 CAS 實現。</li>\n</ol>\n<p>多線程操作共享資源還會出現死鎖。死鎖產生的條件是：<strong>互斥、請求/等待、不可剝奪和循環等待</strong>。解決死鎖問題的關鍵是破壞死鎖產生的條件。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"多線程\"><a href=\"#多線程\" class=\"headerlink\" title=\"多線程\"></a>多線程</h2><h3 id=\"程序、進程與線程\"><a href=\"#程序、進程與線程\" class=\"headerlink\" title=\"程序、進程與線程\"></a><strong>程序、進程與線程</strong></h3><ol>\n<li>程序：程序是含有指令和數據的文件，被靜態存儲於存儲設備之中。</li>\n<li>進程：进程是程序的一次執行過程，是<strong>操作系統運行程序的基本單位</strong>，是動態的。它佔用一定的系統資源（包括 CPU 時間、內存空間、文件、輸入輸出設備等等），<strong>是資源分配的最小單位</strong>。各進程之間相互獨立。</li>\n<li>線程：<strong>線程是 CPU 調度的最小單位</strong>，擁有<strong>程序計數器、虛擬機棧和本地方法棧</strong>，相比進程，它佔用資源更小，產生和切換線程的負擔更小，也被稱爲<strong>輕量級進程</strong>。一個進程可以產生多個線程。同個進程的多個線程之間共享同一塊<strong>堆和方法區</strong>。</li>\n</ol>\n<ul>\n<li><p>堆是幹什麼用的？</p>\n<p>  堆是進程中最大的一塊內存，用於存放新建的對象。</p>\n</li>\n<li><p>方法區是幹什麼的？</p>\n<p>  根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放程序執行代碼的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(java-concurrent/code segment)，通常只讀。具體來說，它存放了每個類的結構，例如運行時常量池，字段和方法數據，以及方法和構造函數的代碼，包括用於類和實例初始化以及接口初始化的特殊方法。</p>\n<p>  另外，UNIX 中的進程將內存劃分成三個部分：text segment,文本區，例如代碼，data segment，數據區，例如變量，stack segment，棧區域。</p>\n</li>\n<li><p>程序計數器爲什麼是線程私有的？</p>\n<p>  程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。</p>\n<p>  因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。</p>\n</li>\n<li><p>虛擬機棧和本地方法棧爲什麼是線程私有的？</p>\n<ul>\n<li><p><strong>虛擬機棧</strong>：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態鏈接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。</p>\n</li>\n<li><p><strong>本地方法棧</strong>：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。</p>\n<p>爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"線程有哪些基本狀態\"><a href=\"#線程有哪些基本狀態\" class=\"headerlink\" title=\"線程有哪些基本狀態\"></a><strong>線程有哪些基本狀態</strong></h3><p>Java 線程共有 6 中狀態，如下：</p>\n<ol>\n<li>New：新創建的線程，尚未執行。</li>\n<li>Runnable：運行中的線程，<code>run</code> 方法正在執行中。可細分爲 Ready 和 Running 兩個狀態。</li>\n<li>Blocked：運行中的線程，因爲某些操作被阻塞而掛起。</li>\n<li>Waiting：運行中的線程，因爲某些操作在等待。</li>\n<li>Timed Waiting：運行中的線程，因爲執行 <code>sleep</code> 等方法正在計時等待。</li>\n<li>Terminated：線程終止，因爲 <code>run</code> 方法執行完畢。</li>\n</ol>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled.png\" alt></p>\n<h3 id=\"並發和並行的區別\"><a href=\"#並發和並行的區別\" class=\"headerlink\" title=\"並發和並行的區別\"></a>並發和並行的區別</h3><p>並發（concurrent）：同一時間段，多個任務都在執行。</p>\n<p>並行（parallel）：單位時間內，多個任務同時執行。</p>\n<h3 id=\"多線程的優勢\"><a href=\"#多線程的優勢\" class=\"headerlink\" title=\"多線程的優勢\"></a>多線程的優勢</h3><ol>\n<li>提高 CPU 和 IO 設備的綜合利用率，確保 CPU 或 IO 設備不空等。</li>\n<li>提高 CPU 核心利用率，確保 CPU 的多個核心都能被利用到。</li>\n<li>提高系統整體的並發能力和性能，應對高並發場景。</li>\n</ol>\n<h3 id=\"上下文切換\"><a href=\"#上下文切換\" class=\"headerlink\" title=\"上下文切換\"></a>上下文切換</h3><p><strong>上下文切換就是舊任務被暫停，保存自身狀態，然後新任務被執行的過程</strong>。造成上下文切換的原因是需要同時執行的任務大於 CPU 核心數，而單個 CPU 同一時刻只能執行一個任務。CPU 採用時間片輪轉法分配 CPU 時間給多個線程，當時間片結束舊任務如果未執行完畢會被暫停，保存當前狀態，然後執行新的任務。</p>\n<p>上下文切換所需的時間很可觀，可能是操作系統中時間消耗最大的操作。操作系統中數 Linux（及其他類 Unix 系統） 上下文切換時間消耗最少。</p>\n<h3 id=\"爲什麼調用-Thread-start-方法而不是-Thread-run-方法？\"><a href=\"#爲什麼調用-Thread-start-方法而不是-Thread-run-方法？\" class=\"headerlink\" title=\"爲什麼調用 Thread.start 方法而不是 Thread.run 方法？\"></a>爲什麼調用 <code>Thread.start</code> 方法而不是 <code>Thread.run</code> 方法？</h3><p>調用 <code>start</code> 方法會啟動一個新線程並進入就緒狀態，當分配到時間片後會自動調用 <code>run</code> 方法。直接調用 <code>run</code> 方法只會在調用者所在的線程執行。</p>\n<h3 id=\"比較-Thread-sleep-方法和-Object-wait-方法\"><a href=\"#比較-Thread-sleep-方法和-Object-wait-方法\" class=\"headerlink\" title=\"比較 Thread.sleep 方法和 Object.wait 方法\"></a>比較 <code>Thread.sleep</code> 方法和 <code>Object.wait</code> 方法</h3><p>共同點：</p>\n<ol>\n<li>都可以暫停線程的執行。</li>\n<li><code>sleep(long)</code>和 <code>wait(long)</code> 都可以在指定時間段後使線程自動甦醒。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li>sleep 是 Thread 類的方法，wait 是 Object 類的方法。</li>\n<li><strong>sleep 沒有釋放鎖，wait 釋放了</strong>。</li>\n<li><code>wait()</code> 被調用後線程不會自動甦醒，需要別的線程調用同一對象上的 <code>notify()</code> 或 <code>notifyAll()</code> 方法來喚醒。</li>\n</ol>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Data.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Data</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String packet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单次传输是否结束</span></span><br><span class=\"line\">    <span class=\"comment\">// True if Receiver should wait</span></span><br><span class=\"line\">    <span class=\"comment\">// False if Sender should wait</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isTransfer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(String packet)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!isTransfer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                wait();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.packet = packet;</span><br><span class=\"line\">        isTransfer = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">receive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (isTransfer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                wait();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        isTransfer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> packet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Sender.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sender</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Data data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sender</span><span class=\"params\">(Data data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String[] packets = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;Are&quot;</span>, <span class=\"string\">&quot;You&quot;</span>, <span class=\"string\">&quot;Ok&quot;</span>, <span class=\"string\">&quot;Over&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String packet : packets) &#123;</span><br><span class=\"line\">            data.send(packet);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Receiver.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Receiver</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Data data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Receiver</span><span class=\"params\">(Data data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String packet = data.receive();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!<span class=\"string\">&quot;Over&quot;</span>.equals(packet)) &#123;</span><br><span class=\"line\">            System.out.println(packet);</span><br><span class=\"line\">            packet = data.receive();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Data data = <span class=\"keyword\">new</span> Data();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Receiver(data)).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Sender(data)).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"調用-Thread-interrupt-意味著什麼？\"><a href=\"#調用-Thread-interrupt-意味著什麼？\" class=\"headerlink\" title=\"調用 Thread.interrupt 意味著什麼？\"></a>調用 <code>Thread.interrupt</code> 意味著什麼？</h3><p>調用 interrupt 方法並不會中斷一個線程，而是發出出一個中斷信號到目標線程（設置中斷標誌位的值爲 true），目標線程收到信號後可以決定是否處理。</p>\n<p>與之相關的方法有：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 測試當前線程是否已經中斷。當線程中斷時調用該方法將會清除線程的中斷狀態</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interrupted</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 測試線程是否已經中斷。不改變線程的中斷狀態。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isInterrupted</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 中斷線程</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"java-concurrent//www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554\">廖雪峰的官方網站</a>提供了以下的代碼：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">      t.start();</span><br><span class=\"line\">      Thread.sleep(java-concurrent<span class=\"comment\">// 暫停1毫秒</span></span><br><span class=\"line\">      t.interrupt(java-concurrent<span class=\"comment\">// 中斷t線程</span></span><br><span class=\"line\">      t.join(java-concurrent<span class=\"comment\">// 等待t線程結束</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (! isInterrupted()) &#123;</span><br><span class=\"line\">          n ++;</span><br><span class=\"line\">          System.out.println(n + <span class=\"string\">&quot; hello!&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是：</p>\n<ol>\n<li>本線程中斷自己是被允許的；其它線程調用本線程的<code>interrupt</code>方法時，會通過<code>checkAccess</code>檢查權限。這有可能拋出<code>SecurityException</code>異常。</li>\n<li>調用線程的<code>wait</code> 方法會讓它進入等待(阻塞)狀態，或者調用線程的<code>join</code>, <code>sleep</code> 方法也會讓它進入阻塞狀態。若線程在阻塞狀態時，調用了它的<code>interrupt</code>方法，那麼它的「中斷狀態」會被清除並且會收到一個<code>InterruptedException</code>異常。例如，線程通過<code>wait()</code>進入阻塞狀態，此時通過<code>interrupt()</code>中斷該線程；調用<code>interrupt()</code>會立即將線程的中斷標記設為「true」，但是由於線程處於阻塞狀態，所以該「中斷標記」會立即被清除為「false」，同時，會產生一個<code>InterruptedException</code>的異常。</li>\n<li>如果線程被阻塞在一個<code>Selector</code>選擇器中，那麼通過<code>interrupt()</code>中斷它時；線程的中斷標記會被設置為true，並且它會立即從選擇操作中返回。</li>\n<li>如果不屬於前面所說的情況，那麼通過<code>interrupt()</code>中斷線程時，它的中斷標記會被設置為「true」。</li>\n<li>中斷一個「已終止的線程」不會產生任何操作。</li>\n</ol>\n<h3 id=\"線程池技術\"><a href=\"#線程池技術\" class=\"headerlink\" title=\"線程池技術\"></a>線程池技術</h3><p><strong>（1）爲什麼要使用線程池？</strong></p>\n<p>線程池管理了一組線程資源，並維護了一些基本的統計信息。</p>\n<p>《Java 並發編程的藝術》中講述到使用線程池的好處：</p>\n<ol>\n<li>降低資源消耗。通過重複使用已創建的線程減少線程創建和銷毀的消耗。</li>\n<li>提高響應速度。線程池預先創建了線程，在需要時可以直接使用不用等。</li>\n<li>提供線程的可管理性。線程是稀缺資源，不能無限制地分配，使用線程池可以進行統一分配、調優和監控。</li>\n</ol>\n<p><strong>（2）Runnable 接口和 Callable 接口的區別</strong></p>\n<ol>\n<li>Runnable 始於 Java 1.0 ，Callable 接口始於 Java 1.5.</li>\n<li>Runnable 不會返回結果或拋出檢查異常，而 Callable 會。</li>\n</ol>\n<p>另外，工具類 <code>Executors</code> 可以實現 Runnable 對象和 Callable 對象之間的相互轉換，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Executors.callable(Runnable task)</span><br><span class=\"line\">Executors.callable(Runnable task，Object resule)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）<code>execute</code> 方法和 <code>submit</code> 方法有什麼區別？</strong></p>\n<ol>\n<li><code>execute</code> 提交任務之後沒有返回值，無法判斷任務是否被執行成功。</li>\n<li><code>submit</code> 提交任務之後有返回值 Future，可以知道任務是否被執行成功。調用 <code>Future.get()</code> 會阻塞線程直到任務完成；調用 <code>Future.get(long timeout，TimeUnit unit)</code>  則是阻塞指定的一段時間後立即返回，不管任務是否執行完成。當然如果提交的是 Runnable，那麼返回的 Future 中的泛型爲 Void。</li>\n</ol>\n<p><strong>（4）如何創建線程池？</strong></p>\n<p>《阿里巴巴 Java 開發手冊》中要求直接用 <code>ThreadPoolExecutor</code> 的構造方法去創建線程池，而非通過 Executors 去創建線程池，因爲：</p>\n<ol>\n<li><code>FixedThreadPool</code> 和 <code>SingleThreadPool</code> 中允許請求的隊列長度爲 <code>Integer.MAX_VALUE</code>，可能會堆積大量請求，導致 OOM；</li>\n<li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> 中允許線程數爲 <code>Integer.MAX_VALUE</code>，可能會創建大量線程，導致 OOM。</li>\n</ol>\n<p><code>ThreadPoolExecutor</code> 的參數分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 核心線程數，規定了最小的可以同時運行的線程數量</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 最大線程數，當請求隊列滿時，可以同時運行的線程數量</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 當線程空閒且大於規定的核心線程數時，等待 keepAliveTime 時間後多餘的線程會被銷毀</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // keepAliveTime 的時間單位</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tTimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 請求隊列，當新任務進來時，當前運行的線程達到核心線程數，則新任務會被放置到請求隊列</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tBlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 線程工廠，用於創建新線程</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 飽和策略，當線程數量達到最大線程數且請求隊列也滿的情況下觸發飽和策略</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tRejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>線程池中的飽和策略有：</p>\n<ol>\n<li><code>ThreadPoolExecutor.AbortPolicy</code>：默認策略，拋出異常，拒絕處理新任務。</li>\n<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：直接在調用 <code>execute</code> 所在的線程執行。</li>\n<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不拋出異常，直接丟棄新任務。</li>\n<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：不拋出異常，丟棄最早未處理的任務。</li>\n</ol>\n<p><strong>（5）線程池對新任務的處理過程</strong></p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%201.png\" alt></p>\n<h3 id=\"AQS（抽象隊列式同步器）\"><a href=\"#AQS（抽象隊列式同步器）\" class=\"headerlink\" title=\"AQS（抽象隊列式同步器）\"></a>AQS（抽象隊列式同步器）</h3><p><strong>（1）概述</strong></p>\n<p>AQS，即 <code>AbstractQueuedSynchronizer</code> ，加入於 Java 1.5，作者爲大名鼎鼎的 Doug Lea，其定義了一套多線程訪問共享資源的同步器框架。其下有諸如 <code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>CountDownLatch</code> 等等實現。</p>\n<p>AQS 的實現思路是：如下圖所示，當請求的共享資源空閒時，請求資源的線程會被設置爲有效的工作線程，該資源會被鎖定；當請求的共享資源被佔用時，將請求資源的線程加入 CLH 隊列中。CLH 是三個人名的首字母，CLH 隊列是一個雙向隊列，FIFO。而共享資源的狀態是一個整型值，採用 CAS 方式進行值的原子更新，通常加鎖 state 會加 1，釋放則減 1。</p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%202.png\" alt></p>\n<p>AQS 可以定義兩種資源共享方式，獨佔 or 共享。其採用模板方法模式編寫，實現類需要選擇性地實現以下方法（默認實現是拋出<code>UnsupportedOperationException</code>）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//該線程是否正在獨佔資源。只有用到condition才需要去實現它。</span></span><br><span class=\"line\">isHeldExclusively()</span><br><span class=\"line\"><span class=\"comment\">//獨佔方式。嘗試獲取資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryAcquire(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//獨佔方式。嘗試釋放資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryRelease(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//共享方式。嘗試獲取資源。負數表示失敗；0表示成功，但沒有剩餘可用資源；正數表示成功，且有剩餘資源。</span></span><br><span class=\"line\">tryAcquireShared(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//共享方式。嘗試釋放資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryReleaseShared(<span class=\"keyword\">int</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）ReentrantLock</strong></p>\n<p>ReentrantLock，可重入鎖，同一線程可以反覆加鎖，然後釋放同樣次數的鎖。synchronized 修飾的方法用的也是可重入鎖，但 ReentrantLock 提供了更爲靈活的控制，有 lock、unlock 方法還有類似於 <code>Object.wait</code> / <code>Object.notify</code> 的 <code>Condition.await</code> / <code>Condition.signal</code> 方法。</p>\n<ul>\n<li><p>代碼</p>\n<p>  參考：<a href=\"java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/\">https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SharedFifoQueue.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedFifoQueue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] content;</span><br><span class=\"line\">  <span class=\"comment\">// 標識當前隊列中擁有的對象數目</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> current = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> addIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> removeIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition fullCondition = lock.newCondition();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition emptyCondition = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SharedFifoQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">      content = <span class=\"keyword\">new</span> Object[capacity];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Object item)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current &gt;= content.length) &#123;</span><br><span class=\"line\">          fullCondition.await();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      content[addIndex] = item;</span><br><span class=\"line\">      addIndex = (addIndex + <span class=\"number\">1</span>) % content.length;</span><br><span class=\"line\">      current++;</span><br><span class=\"line\">      emptyCondition.signal();</span><br><span class=\"line\">      lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">remove</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          emptyCondition.await();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Object item = content[removeIndex];</span><br><span class=\"line\">      removeIndex = (removeIndex + <span class=\"number\">1</span>) % content.length;</span><br><span class=\"line\">      current--;</span><br><span class=\"line\">      fullCondition.signal();</span><br><span class=\"line\">      lock.unlock();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Producer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SharedFifoQueue queue;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Producer</span><span class=\"params\">(SharedFifoQueue queue)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">              queue.add(<span class=\"string\">&quot;Hello &quot;</span> + i);</span><br><span class=\"line\">              Thread.sleep(random.nextInt(<span class=\"number\">200</span>) );</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          queue.add(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Consumer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SharedFifoQueue queue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Consumer</span><span class=\"params\">(SharedFifoQueue queue)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">              Object item = queue.remove();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              System.out.println(item.toString());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    SharedFifoQueue sharedFifoQueue = <span class=\"keyword\">new</span> SharedFifoQueue(<span class=\"number\">10</span>);</span><br><span class=\"line\">    Thread consumerThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Consumer(sharedFifoQueue));</span><br><span class=\"line\">    Thread producerThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Producer(sharedFifoQueue));</span><br><span class=\"line\"></span><br><span class=\"line\">    producerThread.start();</span><br><span class=\"line\">    consumerThread.start();</span><br><span class=\"line\">    <span class=\"comment\">// join 可以讓主線程等待子線程結束</span></span><br><span class=\"line\">    producerThread.join();</span><br><span class=\"line\">    consumerThread.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（3）ReadWriteLock</strong></p>\n<p>ReadWriteLock 相比 ReentrantLock 性能更高，體現在兩個讀操作在 ReadWriteLock 裏是不互斥的，而在 ReentrantLock 裏是互斥的。</p>\n<ul>\n<li><p>代碼</p>\n<p>  代碼來源：<a href=\"java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/\">https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadSafeArrayList</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReadWriteLock readWriteLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock readLock = readWriteLock.readLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;E&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(E o)</span> </span>&#123;</span><br><span class=\"line\">      writeLock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          list.add(o);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          writeLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">      readLock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> list.get(i);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          readLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（4）CountDownLatch</strong></p>\n<p>CountDownLatch 可以讓一個或多個線程等待指定的操作完成後再開始工作。初始化 CountDownLatch 時需要指定一個 count 值，需要等待的線程使用 <code>CountDownLatch.await()</code> 進行等待，當 <code>CountDownLatch.countDown()</code> 被調用 count 次時，等待的線程才得以繼續執行。</p>\n<ul>\n<li><p>代碼</p>\n<p>  代碼來源：<a href=\"java-concurrent//tutorials.jenkov.com/java-util-concurrent/countdownlatch.html\">http://tutorials.jenkov.com/java-util-concurrent/countdownlatch.html</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\">CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Waiter      waiter      = <span class=\"keyword\">new</span> Waiter(latch);</span><br><span class=\"line\">Decrementer decrementer = <span class=\"keyword\">new</span> Decrementer(latch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(waiter)     .start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(decrementer).start();</span><br><span class=\"line\"></span><br><span class=\"line\">Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\"><span class=\"comment\">// Waiter.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Waiter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  CountDownLatch latch = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Waiter</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          latch.await();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Waiter Released&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Decrementer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decrementer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  CountDownLatch latch = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decrementer</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\"></span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\"></span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（5）Semaphore</strong></p>\n<p>Semaphore 用於限制訪問資源的線程數量，以對資源進行保護。<a href=\"java-concurrent//blog.csdn.net/eson_15/article/details/51577191\">有人將其比做是廁所的坑位數</a>，譬如一個廁所有 3 個坑，則同時上廁所的人只能有 3 個，其他人要上只能等這 3 個人之一釋放坑位。</p>\n<p>使用前通過調用 <code>Semaphore.acquire</code> 獲取訪問，使用後通過  <code>Semaphore.release</code> 釋放許可。</p>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\">    Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore.acquire();</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;Running Thread Id: %s, Available permit: %d, Queue length: %d\\n&quot;</span>, Thread.currentThread().getId(), semaphore.availablePermits(), semaphore.getQueueLength());</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  運行結果：</p>\n<p>  初始化總許可量爲 3，一開始被用掉一個許可，可用許可剩餘 2；隨後許可被用光，其他線程開始排隊，出現長度爲 6 的請求隊列，之後隨之許可釋放，隊列長度遞減，直到所有任務處理完成，隊列長度爲 0，許可復爲 3。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Running Thread Id: <span class=\"number\">13</span>, Available permit: <span class=\"number\">2</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">15</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">14</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">16</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">6</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">17</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">5</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">18</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">4</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">19</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">3</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">20</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">2</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">21</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">1</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">22</span>, Available permit: <span class=\"number\">2</span>, Queue length: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"CompletableFuture\"><a href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"></a>CompletableFuture</h3><p>參考：<a href=\"java-concurrent//colobu.com/2016/02/29/Java-CompletableFuture/\">https://colobu.com/2016/02/29/Java-CompletableFuture/</a>、<a href=\"java-concurrent//www.jianshu.com/p/6bac52527ca4\">https://www.jianshu.com/p/6bac52527ca4</a></p>\n<p>CompletableFuture 是 Java 1.8 提供的類，可以方便函數式異步編程。CompletableFuture 實現了 Future 接口。</p>\n<p>Future 是 Java 1.5 引入的接口，它代表這異步執行的結果。可以通過 <code>isDone</code> 判斷執行是否完畢，通過 <code>get</code> 阻塞獲取結果，通過 <code>cancel</code> 取消執行。</p>\n<p>Future 獲取結果的方式不優雅，要輪詢或一直阻塞等待結果。 CompletableFuture 提供了回調的方式處理結果（正常結果 &amp; 異常結果），還有組合多個 CompletableFuture 的能力。</p>\n<p>有了 CompletableFuture，我們甚至可以不關心線程、線程池和同步，因爲 CompletableFuture 內部已經幫我們處理好了，我們只需要鏈式調用函數就可以了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CompletableFuture.allOf(CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(Thread.currentThread().getId() + <span class=\"string\">&quot; done!&quot;</span>);</span><br><span class=\"line\">&#125;), CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(Thread.currentThread().getId() + <span class=\"string\">&quot; done!&quot;</span>);</span><br><span class=\"line\">&#125;)).handle((BiFunction&lt;Void, Throwable, Void&gt;) (unused, throwable) -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (throwable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Exception:&quot;</span> + throwable.getMessage());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;All done!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;).join();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>ThreadLocal 可以讓每個線程擁有變量的副本進行讀寫而互不影響。ThreadLocal 的原理就是 Thread 類本身的 ThreadLocalMap，當調用 <code>ThreadLocal.set</code> 方法時會去獲取當前線程的 ThreadLocalMap，然後以當前 ThreadLocal 爲 key，將值放入其中；當調用<code>ThreadLocal.get</code>時則從 ThreadLocalMap 中讀取。如此每個 Thread 都有各自的專屬變量，不受其他線程影響。</p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%203.png\" alt></p>\n<p>ThreadLocalMap 中的 key 採用弱引用，如果 key 即 ThreadLocal 沒有強引用的話，key 會被 GC 回收變爲 null，而 value 因爲是強引用不會被 GC 回收，於是出現了 key 爲 null 的 Entry，造成內存泄漏。ThreadLocalMap 在調用 <code>get</code>、<code>set</code> 方法時會清理 key 爲 null 的Entry，雖如此還是在使用完 ThreadLocal 後手動調用下 <code>remove</code> 方法爲好。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">  Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">      value = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"線程安全\"><a href=\"#線程安全\" class=\"headerlink\" title=\"線程安全\"></a>線程安全</h2><h3 id=\"線程安全的保證\"><a href=\"#線程安全的保證\" class=\"headerlink\" title=\"線程安全的保證\"></a>線程安全的保證</h3><ol>\n<li>原子性：多項操作要麼都執行，要麼都不執行。synchronized 可以保證代碼片段的原子性。</li>\n<li>可見性：當一個線程對共享變量做了修改，其他線程要立即可以看到修改後的值。volatile 可以保證共享變量的可見性。</li>\n<li>有序性：代碼編寫時的順序同編譯執行時的順序一致。volatile 可以禁止指令重排序。</li>\n</ol>\n<h3 id=\"synchronized-同步鎖的用法\"><a href=\"#synchronized-同步鎖的用法\" class=\"headerlink\" title=\"synchronized 同步鎖的用法\"></a><strong>synchronized 同步鎖的用法</strong></h3><p>synchronized 使用時需要指定一個鎖，當程序進入 synchronized 代碼塊或方法時該鎖會被鎖住，直到離開 synchronized 代碼塊或方法，鎖才會被釋放。注意：同步的範圍越小越好。</p>\n<p><strong>同步代碼塊</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同步代碼塊的鎖可以選擇使用當前對象（this）、當前類 class 對象或其他任意對象。</p>\n<p><strong>同步方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此時鎖爲同步方法所在類的對象。<strong>同一個對象的多個同步方法共享同一個鎖</strong>，多個實例對象時各個對象有各自的鎖。子類重寫父類的同步方法時可以去除同步。</p>\n<p><strong>同步靜態方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此時鎖為同步靜態方法所在類的 class 對象，即使多個實例對象也共享同一個鎖。</p>\n<h3 id=\"使用-String-作爲鎖的注意點\"><a href=\"#使用-String-作爲鎖的注意點\" class=\"headerlink\" title=\"使用 String 作爲鎖的注意點\"></a>使用 String 作爲鎖的注意點</h3><ol>\n<li>首先 String 是一個特殊的類，JVM 使用常量池技術對其進行了緩存，通過字面量使用時會總是返回同一個 String 對象。</li>\n<li>使用 <code>new String</code>、<code>StringBuilder.toString</code> 和 <code>StringBuffer.toString</code> 每次會返回一個新的 String 對象。</li>\n<li>使用 <code>String.intern</code>，當常量池中有值等同的 String 對象時返回該對象，如無則將其加入常量池。</li>\n</ol>\n<h3 id=\"Java-同步鎖的本質\"><a href=\"#Java-同步鎖的本質\" class=\"headerlink\" title=\"Java 同步鎖的本質\"></a><strong>Java 同步鎖的本質</strong></h3><p><strong>Java 的鎖是存在於對象頭</strong>中的，具體就 Hotspot 虛擬機來說，是存在於對象頭中的 Mark Word（標記字段）中的鎖標誌位。Java 對象可有四種鎖狀態：</p>\n<ol>\n<li>一開始對象無鎖，當一段同步代碼一直被一個線程訪問時，該線程自動獲得鎖，此時該鎖爲<strong>偏向鎖</strong>；</li>\n<li>當鎖是偏向鎖時，另一個線程訪問同步代碼，偏向鎖會升級爲<strong>輕量級鎖</strong>，其他線程會通過<strong>自旋</strong>（指嘗試獲取鎖的線程不會立即阻塞，而是採用循環的方式獲取鎖）嘗試獲取鎖；</li>\n<li>當鎖是輕量級鎖時，另一個線程自旋到一定次數仍然未獲得鎖，輕量級鎖會自動升級爲<strong>重量級鎖</strong>，其他線程進入阻塞狀態。</li>\n</ol>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/_2020-11-16_8.54.01.png\" alt></p>\n<p>當處於重量級鎖時，對象頭存儲的指針指向的重量級鎖也叫 <strong>monitor 鎖</strong>（監視器鎖）。多個線程爭搶的就是這個 monitor 對象，誰持有誰就可以運行同步代碼。通過使用 <code>javap -c -s -v -l xx.class</code> 反彙編字節碼知道：當使用 <code>synchronized</code> 同步代碼塊時其實現時 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中的 <code>monitorenter</code> 指令指向同步代碼塊開始的位置，<code>monitorexit</code> 則指向結束的位置；當使用 <code>synchronized</code> 修飾方法時，則是使用 <code>ACC_SYNCHRONIZED</code> 標識該方法爲同步方法。</p>\n<p>獲取鎖的過程如下圖所示：需要訪問同步代碼的多個線程首先進入 Entry Set，當線程獲取到 monitor 對象時會進入 The Owner 區域，然後將 monitor 對象中的 owner 變量設置爲當前線程，計數器 count 加 1；若線程調用 wait 方法，將釋放持有的 monitor，owner 變量設置爲 null，計數器 count 減 1，同時該線程進入 Wait Set 等待被喚醒；若線程執行完畢也將釋放 monitor 並恢復 monitor 中相關變量的值。</p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%204.png\" alt></p>\n<h3 id=\"volatile-關鍵字\"><a href=\"#volatile-關鍵字\" class=\"headerlink\" title=\"volatile 關鍵字\"></a>volatile 關鍵字</h3><p>參考：<a href=\"java-concurrent//monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/\">https://monkeysayhi.github.io/2017/12/28/一文解决内存屏障/</a></p>\n<p>volatile 關鍵字可以修飾變量，其作用是：</p>\n<p>標記該變量以在編譯時，取消編譯層面的緩存和重排序（編譯時的亂序優化）；在解釋執行時使用 CPU 內存屏障技術解決硬件層面的可見性和重排序。具體來說：</p>\n<ol>\n<li><p><strong>被修飾的變量在寄存器中將不會有副本，而是直接從主存進行讀寫操作</strong>，多線程環境下，變量的值的改變<strong>即時可見</strong>。所謂的主存和寄存器是計算機的解決訪問 CPU 處理速度和內存讀寫速度不匹配的手段。一般認爲寄存器的讀寫速度快於主存。</p>\n<p> <img src=\"/2021/02/06/it/java/java-concurrent/Untitled%205.png\" alt></p>\n<p> 未聲明 volatile 時</p>\n<p> <img src=\"/2021/02/06/it/java/java-concurrent/Untitled%206.png\" alt></p>\n<p> 聲明 volatile 時</p>\n</li>\n<li><p>編譯器不對該變量進行亂序優化。</p>\n</li>\n<li><p>JVM 在解釋執行時使用對應 CPU 架構的內存屏障指令防止指令重排序，通常有以下三種：</p>\n<ul>\n<li><p>mfence(StoreLoad Barriers、Full Barrier) 全能屏障</p>\n</li>\n<li><p>sfence(Store Barriers) 寫屏障</p>\n</li>\n<li><p>lfence(Load Barrirers) 讀屏障</p>\n<p>以 x86 架構爲例子，如有一以 volatile 修飾的變量 v，JVM 對其操作如下：</p>\n</li>\n</ul>\n<ol>\n<li><p>在寫入 v 之後插入一個 sfence，隔離了寫入 v 前後的寫入指令，防止其重排序，且 sfence 之前的修改會被寫入緩存並標記其他 CPU 核心中的緩存失效；</p>\n</li>\n<li><p>在讀取 v 之前插入一個 lfence，隔離了讀取 v 前後的讀取指令，防止其重排序，且 lfence 之後會先刷新緩存，從而讀取最新的值。</p>\n<p>sfence 和 lfence 兩相配合，保證了變量 v 的可見性。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"CAS-鎖\"><a href=\"#CAS-鎖\" class=\"headerlink\" title=\"CAS 鎖\"></a>CAS 鎖</h3><p>synchronized 是悲觀鎖，假定操作是有衝突的，要加鎖然後再執行程序，完畢後再釋放鎖。而 CAS(Compare And Swap) 是樂觀鎖，假定操作是沒有衝突的，不需要加鎖，而是把舊的預期值跟內存中已有的值進行比較，如果相同再把要更新的值更新到內存，如果不同則自旋（重試，重新獲取預期值進行比較和替換），Java 中的原子類（比如 AtomicInteger）的底層實現就是 CAS。</p>\n<p>CAS 存在一個稱之爲 ABA 的問題，即對於變量 v = A，當其變爲 B 後又復原爲 A 時，無法判斷變量 v 是否被修改過。</p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%207.png\" alt></p>\n<p>使用 <code>AtomicStampedReference</code> 可以防止 ABA 的問題，因爲附帶的 Stamp可以標識 Reference 的版本，Reference 變化，Stamp 隨之遞增。</p>\n<h3 id=\"Atomic-原子類\"><a href=\"#Atomic-原子類\" class=\"headerlink\" title=\"Atomic 原子類\"></a>Atomic 原子類</h3><p><code>java.util.concurrent.atomic</code> 包中提供了一系列原子類，包括：</p>\n<ol>\n<li>原子類型：<ul>\n<li>AtomicInteger：針對整型</li>\n<li>AtomicLong：針對長整型</li>\n<li>AtomicBoolean：針對布爾類型</li>\n</ul>\n</li>\n<li>數組類型：<ul>\n<li>AtomicIntegerArray：針對整型數組</li>\n<li>AtomicLongArray：針對長整型數組</li>\n<li>AtomicReferenceArray：針對引用類型數組</li>\n</ul>\n</li>\n<li>引用類型：<ul>\n<li>AtomicReference：針對對象引用</li>\n<li>AtomicStampedReference：針對對象引用連同一個整型</li>\n<li>AtomicMarkableReference：針對對象引用連同一個布爾類型</li>\n</ul>\n</li>\n<li>對象的屬性修改類型：<ul>\n<li>AtomicIntegerFieldUpdater：修改對象的一個整型屬性</li>\n<li>AtomicLongFieldUpdater：修改對象的一個長整型屬性</li>\n<li>AtomicReferenceFieldUpdater：修改對象的一個整型屬性</li>\n</ul>\n</li>\n</ol>\n<p>其理論基礎就是 <strong>CAS</strong>(Compare and Swap) <strong>鎖 + volatile + native 方法。</strong>CAS 就是將舊的預期值與內存中的值進行比較，當相同時才將新的預期值設入，否則自旋。 </p>\n<p>介紹下 AtomicInteger 類的幾個原子方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(java-concurrent//獲取當前的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndSet(java-concurrent//獲取當前的值，並設置新的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndIncrement(java-concurrent//獲取當前的值，並自增</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndDecrement(java-concurrent//獲取當前的值，並自減</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndAdd(java-concurrent//獲取當前的值，並加上預期的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">boolean</span> compareAndSet(java-concurrent//如果輸入的數值等於預期值，則以原子方式將該值設置為輸入值（update）</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> lazySet(java-concurrent//最終設置為newValue,使用 lazySet 設置之後可能導致其他線程在之後的一小段時間內還是可以讀到舊的值。</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"死鎖-deadlock\"><a href=\"#死鎖-deadlock\" class=\"headerlink\" title=\"死鎖 (deadlock)\"></a>死鎖 (deadlock)</h3><p>如果一組線程中的每個線程都在等待一個事件，而這個事件只能由該組中的另一個線程觸發，這種情況會導致死鎖。</p>\n<p>死鎖需要滿足四個條件（線程維度上）：</p>\n<ol>\n<li>互斥，該資源任意時刻只能由一個線程佔用。</li>\n<li>請求與保持，一個線程因請求資源被阻塞，另一個線程保持該資源不放。</li>\n<li>不剝奪/不可搶佔，一個線程不能強佔另一個線程擁有的資源，除非另一個線程釋放之。</li>\n<li>循環等待，若干個線程形成循環等待資源的關係。</li>\n</ol>\n<p>那麼，防止死鎖只需要不滿足以上四個條件之一即可。具體來說：</p>\n<ol>\n<li>破壞互斥：不可，這是資源的固有屬性，不可破壞。</li>\n<li>破壞請求與保持：可以一次性請求所有需要的資源。</li>\n<li>破壞不剝奪：<ul>\n<li>若有一佔有若干資源的進程請求某資源被拒絕，則它應釋放它佔有的資源。</li>\n<li>若有一進程請求當前被另一個進程佔有的資源，則操作系統可以剝奪另一個進程的資源。</li>\n</ul>\n</li>\n<li>破壞循環等待：確定資源的申請順序和釋放順序。</li>\n</ol>\n<p>下面是一個死鎖的實例，線程A 擁有資源1 後想要獲得資源2，線程B 擁有資源2 後想要獲得資源1。</p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%208.png\" alt></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object res1 = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">Object res2 = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread B&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按相同順序申請和釋放資源，破壞循環等待條件，從而避免死鎖</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread B&quot;</span>).start();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>首先區分進程和線程。進程是程序運行的基本單位，也是系統分配資源的最小單位；而線程是 CPU 調度的最小單位，一個進程可以有多個線程，而各個線程擁有獨立的程序計數器、虛擬機棧和本地方法棧，但共享同一個堆和方法區。爲著充分利用系統資源，減少 CPU 空等，多線程技術應運而生。系統使用時間片輪轉法分配 CPU 資源到各個線程，如果線程在分配的時間片內未能處理完任務，則會導致上下文切換。</p>\n<p>Java 中線程類爲 <code>Thread</code> ，其 <code>start</code> 方法會使線程進入 Runnable 狀態；其 <code>sleep</code> 方法會阻塞線程而不釋放鎖，跟 <code>Object.wait</code> 有別；其 <code>interrupt</code> 方法並不停止線程，而是設置一個標誌位通知線程應當關閉，線程可以根據該標誌位決定是否要停止運行。</p>\n<p>多個線程可以通過線程池進行統一管理，好處是還可以提前 Ready 好一些線程避免等待線程創建的時間損耗；還可以使用舊的線程，減少線程的頻繁創建和銷毀的資源損耗。線程池推薦直接使用 <code>ThreadPoolExecutor</code> 的構造方法去創建，以便設置合適的構造參數。調用 <code>ThreadPoolExecutor.execute</code> 可以將一個 <code>Runnable</code> 任務放入線程池處理； 調用<code>ThreadPoolExecutor.submit</code>  可以將一個 <code>Callable</code> 任務放入線程池處理，返回一個 <code>Future</code> 代表處理結果，後續通過調用 <code>Future.get</code> 獲取處理結果，其過程是阻塞的。</p>\n<p>Java 1.5 開始提供<code>AbstractQueuedSynchronizer</code>，用於創建多線程訪問共享資源的同步器，其內部使用一個名爲 CLH 的 FIFO 的雙向隊列進行資源分配。其常見實現類有：<code>ReentrantLock</code>、<code>ReadWriteLock</code> 和 <code>CountDownLatch</code> 。其中 <code>ReadWriteLock</code> 性能優於 <code>ReentrantLock</code> ，因爲兩個讀操作在 <code>ReadWriteLock</code> 中不互斥而在 <code>ReentrantLock</code> 中互斥。</p>\n<p>Java 1.8 開始提供了 <code>CompletableFuture</code> ，其實現了 <code>Future</code> 接口，並提供了基於回調的函數式異步編程方式和對<code>CompletableFuture</code> 的組合，使用者可以不關心底層的線程池，大大簡便了異步編程。</p>\n<p>Java 還提供了 ThreadLocal 類可以使得各個線程擁有變量的副本而不會相互影響，底層是使用 Thread 類的 <code>ThreadLocalMap</code>，一個類似 HashMap 的結構，其 Key 爲 ThreadLocal 對象的弱引用。</p>\n<p>多線程因會有多個線程操作共享的資源而引發了線程安全的擔憂。線程安全要求<strong>原子性、可見性和有序性</strong>。Java 提供了多種方式可以保證線程安全：</p>\n<ol>\n<li>synchronized 同步鎖，這是一個重量級鎖。可以使用當前類的 class 對象，當前類的對象或者任意對象對方法和代碼塊進行加鎖，方法結束或代碼塊結束則鎖自動釋放。當使用非靜態同步方法時，會使用當前對象爲鎖，因此多個非靜態同步方法共享同一鎖。Java 1.6 後引入<strong>偏向鎖</strong>和<strong>輕量級鎖</strong>的概念，使得 synchronized 不那麼「重」了。</li>\n<li>volatile 關鍵字。使用該關鍵字修飾的變量在編譯時不會有寄存器緩存而是直接使用主存、不會進行代碼重排序優化，保證了可見性和有序性；在解釋執行時使用 CPU 內存屏障技術防止指令重排序。</li>\n<li>CAS(Compare and Swap) 技術，相比於 synchronized，其假定操作是不會產生衝突的，將舊的預期值和內存中的值進行比較，若相同則更新內存中的值，否則自旋。因此被稱之爲「樂觀鎖」，而 synchronized 被稱之爲「悲觀鎖」。Java 中的 Atomic 類是典型的 CAS 實現。</li>\n</ol>\n<p>多線程操作共享資源還會出現死鎖。死鎖產生的條件是：<strong>互斥、請求/等待、不可剝奪和循環等待</strong>。解決死鎖問題的關鍵是破壞死鎖產生的條件。</p>","more":"<h2 id=\"多線程\"><a href=\"#多線程\" class=\"headerlink\" title=\"多線程\"></a>多線程</h2><h3 id=\"程序、進程與線程\"><a href=\"#程序、進程與線程\" class=\"headerlink\" title=\"程序、進程與線程\"></a><strong>程序、進程與線程</strong></h3><ol>\n<li>程序：程序是含有指令和數據的文件，被靜態存儲於存儲設備之中。</li>\n<li>進程：进程是程序的一次執行過程，是<strong>操作系統運行程序的基本單位</strong>，是動態的。它佔用一定的系統資源（包括 CPU 時間、內存空間、文件、輸入輸出設備等等），<strong>是資源分配的最小單位</strong>。各進程之間相互獨立。</li>\n<li>線程：<strong>線程是 CPU 調度的最小單位</strong>，擁有<strong>程序計數器、虛擬機棧和本地方法棧</strong>，相比進程，它佔用資源更小，產生和切換線程的負擔更小，也被稱爲<strong>輕量級進程</strong>。一個進程可以產生多個線程。同個進程的多個線程之間共享同一塊<strong>堆和方法區</strong>。</li>\n</ol>\n<ul>\n<li><p>堆是幹什麼用的？</p>\n<p>  堆是進程中最大的一塊內存，用於存放新建的對象。</p>\n</li>\n<li><p>方法區是幹什麼的？</p>\n<p>  根據 JVM 規範，方法區邏輯上是堆的一部分。這是一塊存放程序執行代碼的區域，類似於 UNIX 中的進程對內存的劃分的文本區/代碼段(java-concurrent/code segment)，通常只讀。具體來說，它存放了每個類的結構，例如運行時常量池，字段和方法數據，以及方法和構造函數的代碼，包括用於類和實例初始化以及接口初始化的特殊方法。</p>\n<p>  另外，UNIX 中的進程將內存劃分成三個部分：text segment,文本區，例如代碼，data segment，數據區，例如變量，stack segment，棧區域。</p>\n</li>\n<li><p>程序計數器爲什麼是線程私有的？</p>\n<p>  程序計數器（Program Counter，PC）用於存放下一條指令所在單元的地址（注意：執行native方法時該地址爲 undefined）。字節碼解釋器通過改變 PC 來依次讀取指令，實現代碼的流程控制。在多線程的環境下，可以可以當前線程執行的位置，這樣當線程被切換回來的時候就可以從上次的位置繼續。通俗的譬喻就是遊戲中存檔。</p>\n<p>  因此，PC 必須是線程私有的，否則線程切換後無法恢復到正確的位置。</p>\n</li>\n<li><p>虛擬機棧和本地方法棧爲什麼是線程私有的？</p>\n<ul>\n<li><p><strong>虛擬機棧</strong>：每個 Java 方法在執行的同時會創建一個棧幀用於存儲方法的局部變量表、操作數棧、動態鏈接和方法返回地址等信息。從方法調用直到執行完成的過程，對應著一個棧幀在虛擬機棧入棧和出棧的過程。</p>\n</li>\n<li><p><strong>本地方法棧</strong>：類似虛擬機棧，只不過是爲 native 方法服務。在 HotSpot 虛擬機中本地方法棧和虛擬機棧合而爲一。</p>\n<p>爲了保證線程中的方法執行所需的數據（包括局部變量等）不被其他線程訪問，所以虛擬機棧和本地方法棧是線程私有的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"線程有哪些基本狀態\"><a href=\"#線程有哪些基本狀態\" class=\"headerlink\" title=\"線程有哪些基本狀態\"></a><strong>線程有哪些基本狀態</strong></h3><p>Java 線程共有 6 中狀態，如下：</p>\n<ol>\n<li>New：新創建的線程，尚未執行。</li>\n<li>Runnable：運行中的線程，<code>run</code> 方法正在執行中。可細分爲 Ready 和 Running 兩個狀態。</li>\n<li>Blocked：運行中的線程，因爲某些操作被阻塞而掛起。</li>\n<li>Waiting：運行中的線程，因爲某些操作在等待。</li>\n<li>Timed Waiting：運行中的線程，因爲執行 <code>sleep</code> 等方法正在計時等待。</li>\n<li>Terminated：線程終止，因爲 <code>run</code> 方法執行完畢。</li>\n</ol>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled.png\" alt></p>\n<h3 id=\"並發和並行的區別\"><a href=\"#並發和並行的區別\" class=\"headerlink\" title=\"並發和並行的區別\"></a>並發和並行的區別</h3><p>並發（concurrent）：同一時間段，多個任務都在執行。</p>\n<p>並行（parallel）：單位時間內，多個任務同時執行。</p>\n<h3 id=\"多線程的優勢\"><a href=\"#多線程的優勢\" class=\"headerlink\" title=\"多線程的優勢\"></a>多線程的優勢</h3><ol>\n<li>提高 CPU 和 IO 設備的綜合利用率，確保 CPU 或 IO 設備不空等。</li>\n<li>提高 CPU 核心利用率，確保 CPU 的多個核心都能被利用到。</li>\n<li>提高系統整體的並發能力和性能，應對高並發場景。</li>\n</ol>\n<h3 id=\"上下文切換\"><a href=\"#上下文切換\" class=\"headerlink\" title=\"上下文切換\"></a>上下文切換</h3><p><strong>上下文切換就是舊任務被暫停，保存自身狀態，然後新任務被執行的過程</strong>。造成上下文切換的原因是需要同時執行的任務大於 CPU 核心數，而單個 CPU 同一時刻只能執行一個任務。CPU 採用時間片輪轉法分配 CPU 時間給多個線程，當時間片結束舊任務如果未執行完畢會被暫停，保存當前狀態，然後執行新的任務。</p>\n<p>上下文切換所需的時間很可觀，可能是操作系統中時間消耗最大的操作。操作系統中數 Linux（及其他類 Unix 系統） 上下文切換時間消耗最少。</p>\n<h3 id=\"爲什麼調用-Thread-start-方法而不是-Thread-run-方法？\"><a href=\"#爲什麼調用-Thread-start-方法而不是-Thread-run-方法？\" class=\"headerlink\" title=\"爲什麼調用 Thread.start 方法而不是 Thread.run 方法？\"></a>爲什麼調用 <code>Thread.start</code> 方法而不是 <code>Thread.run</code> 方法？</h3><p>調用 <code>start</code> 方法會啟動一個新線程並進入就緒狀態，當分配到時間片後會自動調用 <code>run</code> 方法。直接調用 <code>run</code> 方法只會在調用者所在的線程執行。</p>\n<h3 id=\"比較-Thread-sleep-方法和-Object-wait-方法\"><a href=\"#比較-Thread-sleep-方法和-Object-wait-方法\" class=\"headerlink\" title=\"比較 Thread.sleep 方法和 Object.wait 方法\"></a>比較 <code>Thread.sleep</code> 方法和 <code>Object.wait</code> 方法</h3><p>共同點：</p>\n<ol>\n<li>都可以暫停線程的執行。</li>\n<li><code>sleep(long)</code>和 <code>wait(long)</code> 都可以在指定時間段後使線程自動甦醒。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li>sleep 是 Thread 類的方法，wait 是 Object 類的方法。</li>\n<li><strong>sleep 沒有釋放鎖，wait 釋放了</strong>。</li>\n<li><code>wait()</code> 被調用後線程不會自動甦醒，需要別的線程調用同一對象上的 <code>notify()</code> 或 <code>notifyAll()</code> 方法來喚醒。</li>\n</ol>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Data.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Data</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String packet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单次传输是否结束</span></span><br><span class=\"line\">    <span class=\"comment\">// True if Receiver should wait</span></span><br><span class=\"line\">    <span class=\"comment\">// False if Sender should wait</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isTransfer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(String packet)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!isTransfer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                wait();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.packet = packet;</span><br><span class=\"line\">        isTransfer = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">receive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (isTransfer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                wait();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        isTransfer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> packet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Sender.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sender</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Data data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sender</span><span class=\"params\">(Data data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String[] packets = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;Are&quot;</span>, <span class=\"string\">&quot;You&quot;</span>, <span class=\"string\">&quot;Ok&quot;</span>, <span class=\"string\">&quot;Over&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String packet : packets) &#123;</span><br><span class=\"line\">            data.send(packet);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Receiver.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Receiver</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Data data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Receiver</span><span class=\"params\">(Data data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String packet = data.receive();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!<span class=\"string\">&quot;Over&quot;</span>.equals(packet)) &#123;</span><br><span class=\"line\">            System.out.println(packet);</span><br><span class=\"line\">            packet = data.receive();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Data data = <span class=\"keyword\">new</span> Data();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Receiver(data)).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Sender(data)).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"調用-Thread-interrupt-意味著什麼？\"><a href=\"#調用-Thread-interrupt-意味著什麼？\" class=\"headerlink\" title=\"調用 Thread.interrupt 意味著什麼？\"></a>調用 <code>Thread.interrupt</code> 意味著什麼？</h3><p>調用 interrupt 方法並不會中斷一個線程，而是發出出一個中斷信號到目標線程（設置中斷標誌位的值爲 true），目標線程收到信號後可以決定是否處理。</p>\n<p>與之相關的方法有：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 測試當前線程是否已經中斷。當線程中斷時調用該方法將會清除線程的中斷狀態</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interrupted</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 測試線程是否已經中斷。不改變線程的中斷狀態。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isInterrupted</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 中斷線程</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"java-concurrent//www.liaoxuefeng.com/wiki/1252599548343744/1306580767211554\">廖雪峰的官方網站</a>提供了以下的代碼：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">      t.start();</span><br><span class=\"line\">      Thread.sleep(java-concurrent<span class=\"comment\">// 暫停1毫秒</span></span><br><span class=\"line\">      t.interrupt(java-concurrent<span class=\"comment\">// 中斷t線程</span></span><br><span class=\"line\">      t.join(java-concurrent<span class=\"comment\">// 等待t線程結束</span></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (! isInterrupted()) &#123;</span><br><span class=\"line\">          n ++;</span><br><span class=\"line\">          System.out.println(n + <span class=\"string\">&quot; hello!&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是：</p>\n<ol>\n<li>本線程中斷自己是被允許的；其它線程調用本線程的<code>interrupt</code>方法時，會通過<code>checkAccess</code>檢查權限。這有可能拋出<code>SecurityException</code>異常。</li>\n<li>調用線程的<code>wait</code> 方法會讓它進入等待(阻塞)狀態，或者調用線程的<code>join</code>, <code>sleep</code> 方法也會讓它進入阻塞狀態。若線程在阻塞狀態時，調用了它的<code>interrupt</code>方法，那麼它的「中斷狀態」會被清除並且會收到一個<code>InterruptedException</code>異常。例如，線程通過<code>wait()</code>進入阻塞狀態，此時通過<code>interrupt()</code>中斷該線程；調用<code>interrupt()</code>會立即將線程的中斷標記設為「true」，但是由於線程處於阻塞狀態，所以該「中斷標記」會立即被清除為「false」，同時，會產生一個<code>InterruptedException</code>的異常。</li>\n<li>如果線程被阻塞在一個<code>Selector</code>選擇器中，那麼通過<code>interrupt()</code>中斷它時；線程的中斷標記會被設置為true，並且它會立即從選擇操作中返回。</li>\n<li>如果不屬於前面所說的情況，那麼通過<code>interrupt()</code>中斷線程時，它的中斷標記會被設置為「true」。</li>\n<li>中斷一個「已終止的線程」不會產生任何操作。</li>\n</ol>\n<h3 id=\"線程池技術\"><a href=\"#線程池技術\" class=\"headerlink\" title=\"線程池技術\"></a>線程池技術</h3><p><strong>（1）爲什麼要使用線程池？</strong></p>\n<p>線程池管理了一組線程資源，並維護了一些基本的統計信息。</p>\n<p>《Java 並發編程的藝術》中講述到使用線程池的好處：</p>\n<ol>\n<li>降低資源消耗。通過重複使用已創建的線程減少線程創建和銷毀的消耗。</li>\n<li>提高響應速度。線程池預先創建了線程，在需要時可以直接使用不用等。</li>\n<li>提供線程的可管理性。線程是稀缺資源，不能無限制地分配，使用線程池可以進行統一分配、調優和監控。</li>\n</ol>\n<p><strong>（2）Runnable 接口和 Callable 接口的區別</strong></p>\n<ol>\n<li>Runnable 始於 Java 1.0 ，Callable 接口始於 Java 1.5.</li>\n<li>Runnable 不會返回結果或拋出檢查異常，而 Callable 會。</li>\n</ol>\n<p>另外，工具類 <code>Executors</code> 可以實現 Runnable 對象和 Callable 對象之間的相互轉換，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Executors.callable(Runnable task)</span><br><span class=\"line\">Executors.callable(Runnable task，Object resule)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）<code>execute</code> 方法和 <code>submit</code> 方法有什麼區別？</strong></p>\n<ol>\n<li><code>execute</code> 提交任務之後沒有返回值，無法判斷任務是否被執行成功。</li>\n<li><code>submit</code> 提交任務之後有返回值 Future，可以知道任務是否被執行成功。調用 <code>Future.get()</code> 會阻塞線程直到任務完成；調用 <code>Future.get(long timeout，TimeUnit unit)</code>  則是阻塞指定的一段時間後立即返回，不管任務是否執行完成。當然如果提交的是 Runnable，那麼返回的 Future 中的泛型爲 Void。</li>\n</ol>\n<p><strong>（4）如何創建線程池？</strong></p>\n<p>《阿里巴巴 Java 開發手冊》中要求直接用 <code>ThreadPoolExecutor</code> 的構造方法去創建線程池，而非通過 Executors 去創建線程池，因爲：</p>\n<ol>\n<li><code>FixedThreadPool</code> 和 <code>SingleThreadPool</code> 中允許請求的隊列長度爲 <code>Integer.MAX_VALUE</code>，可能會堆積大量請求，導致 OOM；</li>\n<li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> 中允許線程數爲 <code>Integer.MAX_VALUE</code>，可能會創建大量線程，導致 OOM。</li>\n</ol>\n<p><code>ThreadPoolExecutor</code> 的參數分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 核心線程數，規定了最小的可以同時運行的線程數量</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 最大線程數，當請求隊列滿時，可以同時運行的線程數量</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 當線程空閒且大於規定的核心線程數時，等待 keepAliveTime 時間後多餘的線程會被銷毀</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // keepAliveTime 的時間單位</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tTimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 請求隊列，當新任務進來時，當前運行的線程達到核心線程數，則新任務會被放置到請求隊列</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tBlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 線程工廠，用於創建新線程</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  // 飽和策略，當線程數量達到最大線程數且請求隊列也滿的情況下觸發飽和策略</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tRejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>線程池中的飽和策略有：</p>\n<ol>\n<li><code>ThreadPoolExecutor.AbortPolicy</code>：默認策略，拋出異常，拒絕處理新任務。</li>\n<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：直接在調用 <code>execute</code> 所在的線程執行。</li>\n<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不拋出異常，直接丟棄新任務。</li>\n<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：不拋出異常，丟棄最早未處理的任務。</li>\n</ol>\n<p><strong>（5）線程池對新任務的處理過程</strong></p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%201.png\" alt></p>\n<h3 id=\"AQS（抽象隊列式同步器）\"><a href=\"#AQS（抽象隊列式同步器）\" class=\"headerlink\" title=\"AQS（抽象隊列式同步器）\"></a>AQS（抽象隊列式同步器）</h3><p><strong>（1）概述</strong></p>\n<p>AQS，即 <code>AbstractQueuedSynchronizer</code> ，加入於 Java 1.5，作者爲大名鼎鼎的 Doug Lea，其定義了一套多線程訪問共享資源的同步器框架。其下有諸如 <code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>CountDownLatch</code> 等等實現。</p>\n<p>AQS 的實現思路是：如下圖所示，當請求的共享資源空閒時，請求資源的線程會被設置爲有效的工作線程，該資源會被鎖定；當請求的共享資源被佔用時，將請求資源的線程加入 CLH 隊列中。CLH 是三個人名的首字母，CLH 隊列是一個雙向隊列，FIFO。而共享資源的狀態是一個整型值，採用 CAS 方式進行值的原子更新，通常加鎖 state 會加 1，釋放則減 1。</p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%202.png\" alt></p>\n<p>AQS 可以定義兩種資源共享方式，獨佔 or 共享。其採用模板方法模式編寫，實現類需要選擇性地實現以下方法（默認實現是拋出<code>UnsupportedOperationException</code>）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//該線程是否正在獨佔資源。只有用到condition才需要去實現它。</span></span><br><span class=\"line\">isHeldExclusively()</span><br><span class=\"line\"><span class=\"comment\">//獨佔方式。嘗試獲取資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryAcquire(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//獨佔方式。嘗試釋放資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryRelease(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//共享方式。嘗試獲取資源。負數表示失敗；0表示成功，但沒有剩餘可用資源；正數表示成功，且有剩餘資源。</span></span><br><span class=\"line\">tryAcquireShared(<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"comment\">//共享方式。嘗試釋放資源，成功則返回true，失敗則返回false。</span></span><br><span class=\"line\">tryReleaseShared(<span class=\"keyword\">int</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）ReentrantLock</strong></p>\n<p>ReentrantLock，可重入鎖，同一線程可以反覆加鎖，然後釋放同樣次數的鎖。synchronized 修飾的方法用的也是可重入鎖，但 ReentrantLock 提供了更爲靈活的控制，有 lock、unlock 方法還有類似於 <code>Object.wait</code> / <code>Object.notify</code> 的 <code>Condition.await</code> / <code>Condition.signal</code> 方法。</p>\n<ul>\n<li><p>代碼</p>\n<p>  參考：<a href=\"java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/\">https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/condition/java-util-concurrent-locks-condition-example/</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SharedFifoQueue.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedFifoQueue</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] content;</span><br><span class=\"line\">  <span class=\"comment\">// 標識當前隊列中擁有的對象數目</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> current = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> addIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> removeIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition fullCondition = lock.newCondition();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition emptyCondition = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SharedFifoQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">      content = <span class=\"keyword\">new</span> Object[capacity];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Object item)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current &gt;= content.length) &#123;</span><br><span class=\"line\">          fullCondition.await();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      content[addIndex] = item;</span><br><span class=\"line\">      addIndex = (addIndex + <span class=\"number\">1</span>) % content.length;</span><br><span class=\"line\">      current++;</span><br><span class=\"line\">      emptyCondition.signal();</span><br><span class=\"line\">      lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">remove</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      lock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (current &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          emptyCondition.await();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Object item = content[removeIndex];</span><br><span class=\"line\">      removeIndex = (removeIndex + <span class=\"number\">1</span>) % content.length;</span><br><span class=\"line\">      current--;</span><br><span class=\"line\">      fullCondition.signal();</span><br><span class=\"line\">      lock.unlock();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Producer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SharedFifoQueue queue;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Producer</span><span class=\"params\">(SharedFifoQueue queue)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">              queue.add(<span class=\"string\">&quot;Hello &quot;</span> + i);</span><br><span class=\"line\">              Thread.sleep(random.nextInt(<span class=\"number\">200</span>) );</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          queue.add(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Consumer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SharedFifoQueue queue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Consumer</span><span class=\"params\">(SharedFifoQueue queue)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">              Object item = queue.remove();</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              System.out.println(item.toString());</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    SharedFifoQueue sharedFifoQueue = <span class=\"keyword\">new</span> SharedFifoQueue(<span class=\"number\">10</span>);</span><br><span class=\"line\">    Thread consumerThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Consumer(sharedFifoQueue));</span><br><span class=\"line\">    Thread producerThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Producer(sharedFifoQueue));</span><br><span class=\"line\"></span><br><span class=\"line\">    producerThread.start();</span><br><span class=\"line\">    consumerThread.start();</span><br><span class=\"line\">    <span class=\"comment\">// join 可以讓主線程等待子線程結束</span></span><br><span class=\"line\">    producerThread.join();</span><br><span class=\"line\">    consumerThread.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（3）ReadWriteLock</strong></p>\n<p>ReadWriteLock 相比 ReentrantLock 性能更高，體現在兩個讀操作在 ReadWriteLock 裏是不互斥的，而在 ReentrantLock 裏是互斥的。</p>\n<ul>\n<li><p>代碼</p>\n<p>  代碼來源：<a href=\"java-concurrent//examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/\">https://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadSafeArrayList</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReadWriteLock readWriteLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock readLock = readWriteLock.readLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;E&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(E o)</span> </span>&#123;</span><br><span class=\"line\">      writeLock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          list.add(o);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          writeLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">      readLock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> list.get(i);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          readLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（4）CountDownLatch</strong></p>\n<p>CountDownLatch 可以讓一個或多個線程等待指定的操作完成後再開始工作。初始化 CountDownLatch 時需要指定一個 count 值，需要等待的線程使用 <code>CountDownLatch.await()</code> 進行等待，當 <code>CountDownLatch.countDown()</code> 被調用 count 次時，等待的線程才得以繼續執行。</p>\n<ul>\n<li><p>代碼</p>\n<p>  代碼來源：<a href=\"java-concurrent//tutorials.jenkov.com/java-util-concurrent/countdownlatch.html\">http://tutorials.jenkov.com/java-util-concurrent/countdownlatch.html</a></p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\">CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Waiter      waiter      = <span class=\"keyword\">new</span> Waiter(latch);</span><br><span class=\"line\">Decrementer decrementer = <span class=\"keyword\">new</span> Decrementer(latch);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(waiter)     .start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(decrementer).start();</span><br><span class=\"line\"></span><br><span class=\"line\">Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\"><span class=\"comment\">// Waiter.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Waiter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  CountDownLatch latch = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Waiter</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          latch.await();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Waiter Released&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Decrementer.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decrementer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  CountDownLatch latch = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decrementer</span><span class=\"params\">(CountDownLatch latch)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.latch = latch;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\"></span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\"></span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.latch.countDown();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>（5）Semaphore</strong></p>\n<p>Semaphore 用於限制訪問資源的線程數量，以對資源進行保護。<a href=\"java-concurrent//blog.csdn.net/eson_15/article/details/51577191\">有人將其比做是廁所的坑位數</a>，譬如一個廁所有 3 個坑，則同時上廁所的人只能有 3 個，其他人要上只能等這 3 個人之一釋放坑位。</p>\n<p>使用前通過調用 <code>Semaphore.acquire</code> 獲取訪問，使用後通過  <code>Semaphore.release</code> 釋放許可。</p>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\">    Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore.acquire();</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;Running Thread Id: %s, Available permit: %d, Queue length: %d\\n&quot;</span>, Thread.currentThread().getId(), semaphore.availablePermits(), semaphore.getQueueLength());</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  運行結果：</p>\n<p>  初始化總許可量爲 3，一開始被用掉一個許可，可用許可剩餘 2；隨後許可被用光，其他線程開始排隊，出現長度爲 6 的請求隊列，之後隨之許可釋放，隊列長度遞減，直到所有任務處理完成，隊列長度爲 0，許可復爲 3。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Running Thread Id: <span class=\"number\">13</span>, Available permit: <span class=\"number\">2</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">15</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">14</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">0</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">16</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">6</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">17</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">5</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">18</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">4</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">19</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">3</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">20</span>, Available permit: <span class=\"number\">1</span>, Queue length: <span class=\"number\">2</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">21</span>, Available permit: <span class=\"number\">0</span>, Queue length: <span class=\"number\">1</span></span><br><span class=\"line\">Running Thread Id: <span class=\"number\">22</span>, Available permit: <span class=\"number\">2</span>, Queue length: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"CompletableFuture\"><a href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"></a>CompletableFuture</h3><p>參考：<a href=\"java-concurrent//colobu.com/2016/02/29/Java-CompletableFuture/\">https://colobu.com/2016/02/29/Java-CompletableFuture/</a>、<a href=\"java-concurrent//www.jianshu.com/p/6bac52527ca4\">https://www.jianshu.com/p/6bac52527ca4</a></p>\n<p>CompletableFuture 是 Java 1.8 提供的類，可以方便函數式異步編程。CompletableFuture 實現了 Future 接口。</p>\n<p>Future 是 Java 1.5 引入的接口，它代表這異步執行的結果。可以通過 <code>isDone</code> 判斷執行是否完畢，通過 <code>get</code> 阻塞獲取結果，通過 <code>cancel</code> 取消執行。</p>\n<p>Future 獲取結果的方式不優雅，要輪詢或一直阻塞等待結果。 CompletableFuture 提供了回調的方式處理結果（正常結果 &amp; 異常結果），還有組合多個 CompletableFuture 的能力。</p>\n<p>有了 CompletableFuture，我們甚至可以不關心線程、線程池和同步，因爲 CompletableFuture 內部已經幫我們處理好了，我們只需要鏈式調用函數就可以了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CompletableFuture.allOf(CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(Thread.currentThread().getId() + <span class=\"string\">&quot; done!&quot;</span>);</span><br><span class=\"line\">&#125;), CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(Thread.currentThread().getId() + <span class=\"string\">&quot; done!&quot;</span>);</span><br><span class=\"line\">&#125;)).handle((BiFunction&lt;Void, Throwable, Void&gt;) (unused, throwable) -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (throwable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;Exception:&quot;</span> + throwable.getMessage());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;All done!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;).join();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>ThreadLocal 可以讓每個線程擁有變量的副本進行讀寫而互不影響。ThreadLocal 的原理就是 Thread 類本身的 ThreadLocalMap，當調用 <code>ThreadLocal.set</code> 方法時會去獲取當前線程的 ThreadLocalMap，然後以當前 ThreadLocal 爲 key，將值放入其中；當調用<code>ThreadLocal.get</code>時則從 ThreadLocalMap 中讀取。如此每個 Thread 都有各自的專屬變量，不受其他線程影響。</p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%203.png\" alt></p>\n<p>ThreadLocalMap 中的 key 採用弱引用，如果 key 即 ThreadLocal 沒有強引用的話，key 會被 GC 回收變爲 null，而 value 因爲是強引用不會被 GC 回收，於是出現了 key 爲 null 的 Entry，造成內存泄漏。ThreadLocalMap 在調用 <code>get</code>、<code>set</code> 方法時會清理 key 爲 null 的Entry，雖如此還是在使用完 ThreadLocal 後手動調用下 <code>remove</code> 方法爲好。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">  Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">      value = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"線程安全\"><a href=\"#線程安全\" class=\"headerlink\" title=\"線程安全\"></a>線程安全</h2><h3 id=\"線程安全的保證\"><a href=\"#線程安全的保證\" class=\"headerlink\" title=\"線程安全的保證\"></a>線程安全的保證</h3><ol>\n<li>原子性：多項操作要麼都執行，要麼都不執行。synchronized 可以保證代碼片段的原子性。</li>\n<li>可見性：當一個線程對共享變量做了修改，其他線程要立即可以看到修改後的值。volatile 可以保證共享變量的可見性。</li>\n<li>有序性：代碼編寫時的順序同編譯執行時的順序一致。volatile 可以禁止指令重排序。</li>\n</ol>\n<h3 id=\"synchronized-同步鎖的用法\"><a href=\"#synchronized-同步鎖的用法\" class=\"headerlink\" title=\"synchronized 同步鎖的用法\"></a><strong>synchronized 同步鎖的用法</strong></h3><p>synchronized 使用時需要指定一個鎖，當程序進入 synchronized 代碼塊或方法時該鎖會被鎖住，直到離開 synchronized 代碼塊或方法，鎖才會被釋放。注意：同步的範圍越小越好。</p>\n<p><strong>同步代碼塊</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同步代碼塊的鎖可以選擇使用當前對象（this）、當前類 class 對象或其他任意對象。</p>\n<p><strong>同步方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此時鎖爲同步方法所在類的對象。<strong>同一個對象的多個同步方法共享同一個鎖</strong>，多個實例對象時各個對象有各自的鎖。子類重寫父類的同步方法時可以去除同步。</p>\n<p><strong>同步靜態方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此時鎖為同步靜態方法所在類的 class 對象，即使多個實例對象也共享同一個鎖。</p>\n<h3 id=\"使用-String-作爲鎖的注意點\"><a href=\"#使用-String-作爲鎖的注意點\" class=\"headerlink\" title=\"使用 String 作爲鎖的注意點\"></a>使用 String 作爲鎖的注意點</h3><ol>\n<li>首先 String 是一個特殊的類，JVM 使用常量池技術對其進行了緩存，通過字面量使用時會總是返回同一個 String 對象。</li>\n<li>使用 <code>new String</code>、<code>StringBuilder.toString</code> 和 <code>StringBuffer.toString</code> 每次會返回一個新的 String 對象。</li>\n<li>使用 <code>String.intern</code>，當常量池中有值等同的 String 對象時返回該對象，如無則將其加入常量池。</li>\n</ol>\n<h3 id=\"Java-同步鎖的本質\"><a href=\"#Java-同步鎖的本質\" class=\"headerlink\" title=\"Java 同步鎖的本質\"></a><strong>Java 同步鎖的本質</strong></h3><p><strong>Java 的鎖是存在於對象頭</strong>中的，具體就 Hotspot 虛擬機來說，是存在於對象頭中的 Mark Word（標記字段）中的鎖標誌位。Java 對象可有四種鎖狀態：</p>\n<ol>\n<li>一開始對象無鎖，當一段同步代碼一直被一個線程訪問時，該線程自動獲得鎖，此時該鎖爲<strong>偏向鎖</strong>；</li>\n<li>當鎖是偏向鎖時，另一個線程訪問同步代碼，偏向鎖會升級爲<strong>輕量級鎖</strong>，其他線程會通過<strong>自旋</strong>（指嘗試獲取鎖的線程不會立即阻塞，而是採用循環的方式獲取鎖）嘗試獲取鎖；</li>\n<li>當鎖是輕量級鎖時，另一個線程自旋到一定次數仍然未獲得鎖，輕量級鎖會自動升級爲<strong>重量級鎖</strong>，其他線程進入阻塞狀態。</li>\n</ol>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/_2020-11-16_8.54.01.png\" alt></p>\n<p>當處於重量級鎖時，對象頭存儲的指針指向的重量級鎖也叫 <strong>monitor 鎖</strong>（監視器鎖）。多個線程爭搶的就是這個 monitor 對象，誰持有誰就可以運行同步代碼。通過使用 <code>javap -c -s -v -l xx.class</code> 反彙編字節碼知道：當使用 <code>synchronized</code> 同步代碼塊時其實現時 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中的 <code>monitorenter</code> 指令指向同步代碼塊開始的位置，<code>monitorexit</code> 則指向結束的位置；當使用 <code>synchronized</code> 修飾方法時，則是使用 <code>ACC_SYNCHRONIZED</code> 標識該方法爲同步方法。</p>\n<p>獲取鎖的過程如下圖所示：需要訪問同步代碼的多個線程首先進入 Entry Set，當線程獲取到 monitor 對象時會進入 The Owner 區域，然後將 monitor 對象中的 owner 變量設置爲當前線程，計數器 count 加 1；若線程調用 wait 方法，將釋放持有的 monitor，owner 變量設置爲 null，計數器 count 減 1，同時該線程進入 Wait Set 等待被喚醒；若線程執行完畢也將釋放 monitor 並恢復 monitor 中相關變量的值。</p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%204.png\" alt></p>\n<h3 id=\"volatile-關鍵字\"><a href=\"#volatile-關鍵字\" class=\"headerlink\" title=\"volatile 關鍵字\"></a>volatile 關鍵字</h3><p>參考：<a href=\"java-concurrent//monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/\">https://monkeysayhi.github.io/2017/12/28/一文解决内存屏障/</a></p>\n<p>volatile 關鍵字可以修飾變量，其作用是：</p>\n<p>標記該變量以在編譯時，取消編譯層面的緩存和重排序（編譯時的亂序優化）；在解釋執行時使用 CPU 內存屏障技術解決硬件層面的可見性和重排序。具體來說：</p>\n<ol>\n<li><p><strong>被修飾的變量在寄存器中將不會有副本，而是直接從主存進行讀寫操作</strong>，多線程環境下，變量的值的改變<strong>即時可見</strong>。所謂的主存和寄存器是計算機的解決訪問 CPU 處理速度和內存讀寫速度不匹配的手段。一般認爲寄存器的讀寫速度快於主存。</p>\n<p> <img src=\"/2021/02/06/it/java/java-concurrent/Untitled%205.png\" alt></p>\n<p> 未聲明 volatile 時</p>\n<p> <img src=\"/2021/02/06/it/java/java-concurrent/Untitled%206.png\" alt></p>\n<p> 聲明 volatile 時</p>\n</li>\n<li><p>編譯器不對該變量進行亂序優化。</p>\n</li>\n<li><p>JVM 在解釋執行時使用對應 CPU 架構的內存屏障指令防止指令重排序，通常有以下三種：</p>\n<ul>\n<li><p>mfence(StoreLoad Barriers、Full Barrier) 全能屏障</p>\n</li>\n<li><p>sfence(Store Barriers) 寫屏障</p>\n</li>\n<li><p>lfence(Load Barrirers) 讀屏障</p>\n<p>以 x86 架構爲例子，如有一以 volatile 修飾的變量 v，JVM 對其操作如下：</p>\n</li>\n</ul>\n<ol>\n<li><p>在寫入 v 之後插入一個 sfence，隔離了寫入 v 前後的寫入指令，防止其重排序，且 sfence 之前的修改會被寫入緩存並標記其他 CPU 核心中的緩存失效；</p>\n</li>\n<li><p>在讀取 v 之前插入一個 lfence，隔離了讀取 v 前後的讀取指令，防止其重排序，且 lfence 之後會先刷新緩存，從而讀取最新的值。</p>\n<p>sfence 和 lfence 兩相配合，保證了變量 v 的可見性。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"CAS-鎖\"><a href=\"#CAS-鎖\" class=\"headerlink\" title=\"CAS 鎖\"></a>CAS 鎖</h3><p>synchronized 是悲觀鎖，假定操作是有衝突的，要加鎖然後再執行程序，完畢後再釋放鎖。而 CAS(Compare And Swap) 是樂觀鎖，假定操作是沒有衝突的，不需要加鎖，而是把舊的預期值跟內存中已有的值進行比較，如果相同再把要更新的值更新到內存，如果不同則自旋（重試，重新獲取預期值進行比較和替換），Java 中的原子類（比如 AtomicInteger）的底層實現就是 CAS。</p>\n<p>CAS 存在一個稱之爲 ABA 的問題，即對於變量 v = A，當其變爲 B 後又復原爲 A 時，無法判斷變量 v 是否被修改過。</p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%207.png\" alt></p>\n<p>使用 <code>AtomicStampedReference</code> 可以防止 ABA 的問題，因爲附帶的 Stamp可以標識 Reference 的版本，Reference 變化，Stamp 隨之遞增。</p>\n<h3 id=\"Atomic-原子類\"><a href=\"#Atomic-原子類\" class=\"headerlink\" title=\"Atomic 原子類\"></a>Atomic 原子類</h3><p><code>java.util.concurrent.atomic</code> 包中提供了一系列原子類，包括：</p>\n<ol>\n<li>原子類型：<ul>\n<li>AtomicInteger：針對整型</li>\n<li>AtomicLong：針對長整型</li>\n<li>AtomicBoolean：針對布爾類型</li>\n</ul>\n</li>\n<li>數組類型：<ul>\n<li>AtomicIntegerArray：針對整型數組</li>\n<li>AtomicLongArray：針對長整型數組</li>\n<li>AtomicReferenceArray：針對引用類型數組</li>\n</ul>\n</li>\n<li>引用類型：<ul>\n<li>AtomicReference：針對對象引用</li>\n<li>AtomicStampedReference：針對對象引用連同一個整型</li>\n<li>AtomicMarkableReference：針對對象引用連同一個布爾類型</li>\n</ul>\n</li>\n<li>對象的屬性修改類型：<ul>\n<li>AtomicIntegerFieldUpdater：修改對象的一個整型屬性</li>\n<li>AtomicLongFieldUpdater：修改對象的一個長整型屬性</li>\n<li>AtomicReferenceFieldUpdater：修改對象的一個整型屬性</li>\n</ul>\n</li>\n</ol>\n<p>其理論基礎就是 <strong>CAS</strong>(Compare and Swap) <strong>鎖 + volatile + native 方法。</strong>CAS 就是將舊的預期值與內存中的值進行比較，當相同時才將新的預期值設入，否則自旋。 </p>\n<p>介紹下 AtomicInteger 類的幾個原子方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(java-concurrent//獲取當前的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndSet(java-concurrent//獲取當前的值，並設置新的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndIncrement(java-concurrent//獲取當前的值，並自增</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndDecrement(java-concurrent//獲取當前的值，並自減</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> getAndAdd(java-concurrent//獲取當前的值，並加上預期的值</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">boolean</span> compareAndSet(java-concurrent//如果輸入的數值等於預期值，則以原子方式將該值設置為輸入值（update）</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> lazySet(java-concurrent//最終設置為newValue,使用 lazySet 設置之後可能導致其他線程在之後的一小段時間內還是可以讀到舊的值。</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"死鎖-deadlock\"><a href=\"#死鎖-deadlock\" class=\"headerlink\" title=\"死鎖 (deadlock)\"></a>死鎖 (deadlock)</h3><p>如果一組線程中的每個線程都在等待一個事件，而這個事件只能由該組中的另一個線程觸發，這種情況會導致死鎖。</p>\n<p>死鎖需要滿足四個條件（線程維度上）：</p>\n<ol>\n<li>互斥，該資源任意時刻只能由一個線程佔用。</li>\n<li>請求與保持，一個線程因請求資源被阻塞，另一個線程保持該資源不放。</li>\n<li>不剝奪/不可搶佔，一個線程不能強佔另一個線程擁有的資源，除非另一個線程釋放之。</li>\n<li>循環等待，若干個線程形成循環等待資源的關係。</li>\n</ol>\n<p>那麼，防止死鎖只需要不滿足以上四個條件之一即可。具體來說：</p>\n<ol>\n<li>破壞互斥：不可，這是資源的固有屬性，不可破壞。</li>\n<li>破壞請求與保持：可以一次性請求所有需要的資源。</li>\n<li>破壞不剝奪：<ul>\n<li>若有一佔有若干資源的進程請求某資源被拒絕，則它應釋放它佔有的資源。</li>\n<li>若有一進程請求當前被另一個進程佔有的資源，則操作系統可以剝奪另一個進程的資源。</li>\n</ul>\n</li>\n<li>破壞循環等待：確定資源的申請順序和釋放順序。</li>\n</ol>\n<p>下面是一個死鎖的實例，線程A 擁有資源1 後想要獲得資源2，線程B 擁有資源2 後想要獲得資源1。</p>\n<p><img src=\"/2021/02/06/it/java/java-concurrent/Untitled%208.png\" alt></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object res1 = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">Object res2 = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread B&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按相同順序申請和釋放資源，破壞循環等待條件，從而避免死鎖</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (res1) &#123;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res1&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(Thread.currentThread() + <span class=\"string\">&quot; wait res2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (res2) &#123;</span><br><span class=\"line\">          System.out.println(Thread.currentThread() + <span class=\"string\">&quot; get res2&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;Thread B&quot;</span>).start();</span><br></pre></td></tr></table></figure>"},{"title":"甲子話分類辭表（2020.12）","p":"language/min/gahzi-oi-hung-lui-ci-biao","_content":"\n## 序言(su⁶ ngiang⁵)\n\n甲子鎮處在陸豐市，與惠來縣交界，語言文化上偏惠來（其實五百年前與惠來交界處同屬海豐縣）。甲子話是三甲地區（甲子、甲西、甲東三鎮）通行的語言，是甲子地方文化的重要載體之一。在學術上，甲子話被歸入粵東閩南語潮汕話片。 \n\n甲子話保留了好㩼中古乃至上古的漢語詞彙，比如：汝、諸母、新婦、箸、鼎、匏桸、雅、翹楚等等，還有極具地方特色的表達，比如：𨑨迌、走漆、理唔直、孤獨死相等等。然而無會寫甚至無會呾甲子話的人實在㩼，其中不少是受過義務教育其。 有鑑於此，本人草創此表，力求詞雅正且其音形義有所考據，權當拋磚引玉，歡迎大家儂做蜀討論改進。 \n\n另附本表主要參考資料：\n\n1. 《潮汕方言詞考釋》（林倫倫）\n2. 《海豐話分類辭表》（羅志海、鍾顯坤）\n3. [《潮典》](https://www.mogher.com/baike) \n4. 《新潮汕字典》（張曉山）\n5. [《台灣閩南語常用詞辭典》](https://twblg.dict.edu.tw/holodict%5C_new/index.html) \n6. [《小學堂閩語》](https://xiaoxue.iis.sinica.edu.tw/minyu)\n\n阿華\n2020年10月成稿，12月修訂\n\n<!--more-->\n\n## 總表(zong² biao²)\n\n### 🤵稱謂(cêng¹ ui⁶)\n\n1. 我 /ua²/\n2. 汝 /lu²/ 你\n3. 伊 /i¹/ 他/她/它\n4. 恁 /ning²/ 你們\n5. 伊人 /i¹ nang⁷/ 他們\n6. 家己 /ga¹ gi⁷/ 自己\n7. 人家 /nang⁵ gê¹/ 別人\n8. 諸夫 /za¹ bao¹/ 男人、男子\n9. 諸母 /za¹ bhao²/ 女人\n10. 諸娘 /zu¹ nion⁵/ 女子\n11. 大人 /dua⁷ nang⁷/\n12. 老人 /lao⁶ nang⁵/\n13. 後生囝 /hao⁶ sên¹ gian²/ 年輕人\n14. 孥囝 /nao⁵ gian²/、/nong⁶ gian²/ 小孩子\n15. 諸夫囝 /za¹ bao¹ gian²/ 男孩子、兒子\n16. 諸母囝 /za¹ bhao² gian²/ 女孩子、女兒\n17. 諸娘囝 /zu¹ nion⁵ gian²/ 年輕女子\n18. 阿公 /a¹ gong¹/ 爺爺\n19. 阿媽 /a¹ ma²/ 奶奶\n20. 媽人 /ma² nang⁵/ 婦女\n21. 媽祖 /ma² zao²/ 原名林默，南海保護神\n22. 爸爸 /ba¹ ba¹/ 爸爸\n23. 媽媽 /ma¹ ma¹/\n24. 父母 /bê⁶ bho²/\n25. 兄 /hian¹/ 哥哥\n26. 弟 /di⁶/ 弟弟\n27. 姐 /zê²/ 姐姐\n28. 妹 /moi⁷/ 妹妹\n29. 姊妹 /zi² moi⁷/ 姐妹\n30. 叔伯兄弟 /zêh⁴ bêh⁴ hian¹ di⁶/ 堂兄弟\n31. 同沿 /dang⁵ iang⁵/ 同輩、同儕\n32. 翁 /ang¹/ 丈夫\n33. 母 /bhao²/ 妻子\n34. 翁姐 /ang¹ zia²/ 夫妻\n35. 新婦 /sing¹ bu⁶/ 媳婦\n36. 大家 /dua⁷ gê¹/ 丈夫的母親、家婆\n37. 大家官 /dua⁷ gê¹ guan¹/ 丈夫的父親、家公\n38. 丈人 /dion⁶ nang⁵/ 岳父\n39. 丈母 /dion⁶ m²/ 岳母\n40. 妻舅 /ci¹ gu⁶/ 妻子的兄弟\n41. 妻姨 /ci¹ i⁵/ 妻子的姐妹\n42. 伯 /bêh⁴/ 伯伯\n43. 姆 /m²/ 伯父的妻子\n44. 叔 /zêh⁴/ 叔叔\n45. 嬸 /sim²/ 叔父的妻子\n46. 舅 /gu⁶/ 舅舅\n47. 妗 /gim⁶/ 舅父的妻子\n48. 姑 /gao¹/ 父親的姐妹、姑姑\n49. 姑丈 /gou¹ dion⁶/ 姑姑的丈夫\n50. 姨 /i⁵/ 母親的姐妹；母親\n51. 姨丈 /i⁵ dion⁶/ 母親的姐妹的丈夫\n52. 先生 /sing¹ sên¹/\n53. 學生 /hag⁴ sêng¹/\n54. 師父 /sai¹ bê⁶/ 工匠師傅\n55. 師父 /su¹ hu⁶/ 出家人、和尚\n56. 和尚 /hoi⁵ sion⁷/、/hua⁵ siang⁶/\n57. 腳色 /ka¹ siao³/ 人手、幫手\n58. 青暝囝 /cên¹ mên⁵ gian²/ 瞎子\n\n### 🦶身體(sing¹ ti²)\n\n1. 頭毛 /tao⁵ mo⁵/ 頭髮\n2. 頭神 /tao⁵ sing⁵/ 思維、記憶的能力\n3. 頭碗骨 /tao⁵ uan² gug⁴/ 頭蓋骨\n4. 旋 /zng⁷/ 頭髮呈漩渦狀的地方\n5. 囟 /sing³/ 嬰兒頭頂骨未合縫處\n6. 額頭 /hia² tao⁵/\n7. 面 /ming⁷/ 臉\n8. 頰溝 /gih⁴ gao¹/ 腮\n9. 痣 /gi³/\n10. 目 /mag⁸/ 眼睛\n11. 目仁 /mag⁸ ring⁵/ 眼珠子\n12. 目汁 /mag⁸ zab⁴/ 眼淚\n13. 眉 /bhai⁵/ 眉毛\n14. 耳 /hin⁶/ 耳朵\n15. 耳空、耳孔 /hin⁶ kang¹/\n16. 鼻 /pin⁷/ 鼻子\n17. 鼻空、鼻孔 /pin⁷ kang¹/\n18. 喙、嘴 /cui⁷/ 嘴巴\n19. 䶕牙 /bha³ ghê⁵/ 龅牙\n20. 涎 /nua⁶/ 唾液\n21. 痰 /tam⁵/\n22. 頷 /am⁶/ 脖子\n23. 下頦 /ê⁶ hai⁵/ 下巴\n24. 喙後肚 /cui⁷ ao⁶ dao²/ 下巴後面柔軟處\n25. 鬚 /ciu¹/ 鬍鬚\n26. 嚨喉 /na⁵ ao⁵/ 喉嚨\n27. 手 /ciu²/\n28. 正手 /zian³ ciu²/ 右手\n29. 倒手 /do³ ciu²/ 左手\n30. 胳囊跤 /goh⁴ lang⁵ ka¹/ 腋下\n31. 手後曲 /ciu² ao⁶ kiao¹/ 手肘\n32. 手模 /ciu² bhao⁵/ 手印\n33. 腡 /lê⁵/ 圓形手指紋\n34. 指頭公 /zain² tao⁵ gong¹/ 大拇指\n35. 尾指囝 /bhoi² zain² gian²/ 小指\n36. 胸 /hêng¹/\n37. 嬭、奶 /nê¹/\n38. 𩩍篱 /pian¹ li⁵/ 肋骨\n39. 肚臍 /dao² zai⁵/\n40. 背脊 /ba¹ ziah⁴/ 脊背\n41. 腰 /io¹/\n42. 跤、骹、腳 /ka¹/\n43. 跤頭趺 /ka¹ tao⁵ u⁶/ 膝蓋\n44. 大跤腿 /dua⁷ ka¹ tui²/ 大腿\n45. 跤腸肚 /ka¹ dng⁵ dao²/ 小腿後部肌肉凸出處\n46. 跤後蹬 /ka¹ ao⁶ dên¹/ 腳後跟\n47. 跤盤 /ka¹ buan⁵/ 腳板\n48. 跤目 /ka¹ mag⁸/ 腳踝\n49. 跤指公 /ka¹ zain² gong¹/ 腳大拇趾\n50. 跤液 /ka¹ sio²/ 腳汗\n51. 卵 /lang⁶/ 陰莖、屌、勢\n52. 卵鳥 /lang⁶ ziao²/ 陰莖、屌、勢\n53. 卵脬 /lang⁶ pa¹/ 精囊\n54. 卵核 /lang⁶ hug⁸/ 睪丸\n55. 膣 /zi¹/ 女陰\n56. 膣眉 /zi¹ bhai¹/ 女陰\n57. 尻川 /ka¹ cng¹/ 屁股\n58. 雞母皮 /goi¹ bho² poi⁵/ 雞皮疙瘩\n59. 汗 /guan⁷/\n60. 垢圿 /gao² goih⁴/ 體表污垢\n\n### 🍵飲食(im² ziah⁸)\n\n1. 食 /ziah⁸/ 吃、喝、抽\n2. 祭 /zi³/ 狼吞虎咽；坐享其成\n3. 咬 /ga⁶/\n4. 哺 /bao⁷/ 咀嚼\n5. 吞 /tung¹/\n6. 舐 /zi⁶/ 舔\n7. 含 /gam⁵/\n8. 啜 /coih⁴/ 喝\n9. 啉 /lim⁵/ 小口喝\n10. 灌 /guang¹/ 大口喝\n11. 吸 /kib⁴/\n12. 搵 /ung³/ 蘸\n13. 買鹹 /moi² giam⁵/ 買菜\n14. 食透早 /ziah⁸ tao⁷ za²/ 吃早飯\n15. 食眠起 /ziah⁸ mng⁵ ki²/ 吃早飯\n16. 食晝 /ziah⁸ dao³/ 吃午飯\n17. 食當晝 /ziah⁸ dêng¹ dao³/ 吃午飯\n18. 食夜昏、食暝昏 /ziah⁸ mê⁵ hng⁵/ 吃晚飯\n19. 飯 /bng⁷/\n20. 米 /bhi²/\n21. 糜 /moi⁵/ 粥\n22. 飲 /am²/ 米湯\n23. 配 /poi³/ 菜\n24. 菜式 /cai³ sêg⁴/\n25. 粿、餜 /goi²/\n26. 丸、圓 /in⁵/\n27. 油䭔 /iu⁵ zui¹/ 一種油炸食品\n28. 汰米 /tua⁷ bhi²/ 淘米\n29. 熬 /ngao⁵/ 長時間煮。～糜。\n30. 煲 /bu⁵/ 煮、熬。～藥。\n31. 潘 /png¹/ 餿水\n32. 油 /iu⁵/\n33. 鹽 /iam⁵/\n34. 醋 /cao³/\n35. 豉油 /si⁷ iu⁵/ 醬油\n36. 豆汁 /dao⁷ zab⁴/ 醬油\n37. 雞卵 /goi¹ nng⁶/ 雞蛋\n38. 豬肉 /du¹ nêg⁸/\n39. 澀肉 /siab⁴ nêg⁸/、/siab⁴ bhah⁴/ 瘦肉。澀，少油。\n40. 肉脞 /nêg⁸ co³/ 肉末\n41. 烏糖 /ao¹ tng⁵/ 紅糖、黑糖\n42. 赤砂糖 /ciah⁴ sua¹ tng⁵/\n43. 白砂糖 /bêh⁸ sua¹ tng⁵/\n44. 薰 /hung¹/ 香菸\n45. 茶 /dê⁵/\n46. 酒 /ziu²/\n47. 淖 /cioh⁴/ 粥稀\n48. 凊 /cing³/ 飯菜涼了\n49. 燒 /sio¹/ 熱呼呼\n50. 燒烘燒烘 /sio¹ hang¹ sio¹ hang¹/ 熱呼呼\n51. 芳 /pang¹/ 香\n52. 甘 /gam¹/\n53. 甜 /diam⁵/\n54. 鹹 /giam⁵/\n55. 薟 /hiam¹/ 辛辣\n56. 䭕 /zian²/ 清淡\n57. 臊 /co¹/ 腥\n58. 臭 /cao³/\n\n### 👔穿戴(cêng⁷ dua³)\n\n1. 帽 /bho⁷/\n2. 目鏡 /mah⁸ gian³/ 眼鏡\n3. 圍巾 /ui⁵ ging¹/\n4. 頷幔 /am⁶ muan¹/ 披肩\n5. 衫褲 /san¹ kao³/ 衣服\n6. 西裝 /sai¹ zuang¹/\n7. 褸 /lao¹/ 大衣\n8. 葵笠 /goi⁵ loih⁸/ 斗笠，竹編成的圓錐形大帽子。\n9. 羊毛衫 /ion⁵ mo⁵ san¹/\n10. 長䘼衫 /dng⁵ ng² san¹/ 長袖衫\n11. 短䘼衫 /dê² ng² san¹/ 短袖衫\n12. 貼身衫 /dah⁴ sing¹ san¹/ 貼身的上衣\n13. 䘥囝 /gah⁴ gian²/ 無袖內衣\n14. 底衫 /doi² san¹/ 內衣\n15. 肚綰 /dao² guan⁶/ 肚兜\n16. 長褲 /dng⁵ kao³/\n17. 短褲 /dê² kao³/\n18. 褲頭 /kao³ tao⁵/ 短褲、內褲\n19. 褲橛 /kao³ goi²/ 短褲、內褲\n20. 三角褲 /san¹ gag⁴ kao³/\n21. 裙 /gung⁵/\n22. 圍裙 /ui⁵ gung⁵/\n23. 文胸 /bhung⁵ hêng¹/ 胸罩\n24. 奶帕、嬭帕 /nê¹ pê³/ 胸罩\n25. 皮帶 /poi⁵ dua³/\n26. 手囊 /ciu² lob⁴/ 套袖\n27. 手鐲 /ciu² sio²/\n28. 鞋拖 /tua¹ oi⁵/ 拖鞋\n29. 波鞋 /bo¹ oi⁵/ 球鞋。波，英文 ball 的音譯。\n30. 釘鞋 /dêng¹ oi⁵/ 運動鞋的一種\n31. 皮鞋 /poi⁵ oi⁵/\n32. 高跟鞋 /gao¹ ging¹ oi⁵/\n33. 靴 /hia¹/\n34. 襪 /ghoih⁸/\n35. 布 /bao³/\n36. 襊 /zoi⁷/ 折痕\n37. 頷領 /am⁶ nia²/ 領子\n38. 褲袋 /kao³ dê⁷/ 位於褲子的口袋\n39. 衫袋 /san¹ dê⁷/ 位於上衣的口袋\n40. 暗袋 /am³ dê⁷/ 內側袋\n41. 內裏 /lai⁶ li²/ 衣物不露出在外的裏層\n42. 鈕 /liu²/ 鈕扣\n43. 針 /zam¹/\n44. 線 /suan³/\n45. 拉鍊 /la¹ liang³/\n46. 穿 /cêng⁷/\n47. 褪 /tng⁷/ 脱\n48. 紩 /tin⁷/ 縫\n49. 補 /bao²/\n50. 車衫褲 /cia¹ san¹ kao³/ 用縫紉機縫衣服\n\n### 🎏物件(mi² gian⁶、mian⁶)\n\n1. 眠牀 /mng⁵ cng⁵/ 牀\n2. 鋪 /pao¹/ 牀\n3. 高低牀 /gao¹ di¹ cng⁵/ 上下鋪\n4. 蓆 /cioh⁸/\n5. 簟 /diam⁶/ 竹席\n6. 毡 /ziang¹/\n7. 被 /poi⁶/\n8. 棉被 /mi⁵ poi⁶/\n9. 被單 /poi⁶ duan¹/\n10. 枕頭 /zim² tao⁵/\n11. 枕頭囊 /zim² tao⁵ lob⁴/ 枕套\n12. 蠓罩、蚊罩 /mang² da³/ 蚊帳\n13. 蠓熏、蚊熏 /mang² hung¹/ 蚊香\n14. 窗罩 /têng¹ zao⁶/\n15. 口罩 /kao² zao⁶/\n16. 壁櫥 /biah⁴ du⁵/\n17. 椅 /in²/\n18. 桌 /doh⁴/\n19. 櫃 /gui⁷/\n20. 架 /gê³/\n21. 盒 /ab⁸/\n22. 籃 /na⁵/\n23. 瓶 /bang⁵/\n24. 鎖頭 /so² tao⁵/\n25. 鎖匙 /so² si⁵/ 鑰匙\n26. 葉疊 /iab² diab⁸/ 合葉\n27. 牙簽 /ghê⁵ ciam¹/\n28. 茶盤 /dê⁵ buan⁵/\n29. 茶壺 /dê⁵ hu⁵/\n30. 沖罐 /cong¹ guang³/ 茶壺\n31. 茶杯 /dê⁵ boi¹/\n32. 茶几 /dê⁵ gi²/\n33. 熏咬 /hung¹ ga⁶/ 煙斗\n34. 熏碟 /hung¹ dih⁸/ 煙灰缸\n35. 熱壺 /riag⁸ hu⁵/ 熱水瓶\n36. 熨斗 /ug⁴ dao²/\n37. 電燈 /diang⁶ dêng¹/\n38. 電泡 /diang⁶ pa⁶/\n39. 燈籠 /dêng¹ lang⁵/\n40. 燈火 /dêng¹ hoi²/ 電燈；燈光\n41. 風箏 /hong¹ zêng¹/\n42. 米甕 /bhi² ang³/ 米缸\n43. 水䀇 /zui² gao²/ 大型儲水器\n44. 跤桶 /ka¹ tang²/ 原指洗腳桶，後泛指洗衣盆，也可用來給小孩洗澡。\n45. 面盆 /ming⁷ png⁵/ 臉盆\n46. 瓠桸 /bu⁵ hia¹/ 水瓢\n47. 口㼦 /kao² gong²/ 漱口杯\n48. 碗 /uan²/\n49. 盤 /buan⁵/\n50. 碟 /dih⁸/\n51. 甌 /ao¹/ 大碗\n52. 箸 /du⁷/ 筷子\n53. 湯匙 /tng¹ si⁵/\n54. 調羹 /tiao⁵ gên¹/ 喝粥用的小勺子；湯匙\n55. 糜匙 /moi⁵ si⁵/ 舀粥用的勺子\n56. 飯匙 /bng⁷ si⁵/ 飯勺\n57. 飯添 /bng⁷ tin¹/ 飯勺\n58. 鼎 /dian²/ 鍋\n59. 鼎㧕 /dian² liu⁶/ 鍋鏟。㧕，存疑。\n60. 鼎蓋 /dian² kain³/ 鍋蓋\n61. 菜刀 /cai³ do¹/\n62. 瓜刨 /goi¹ pao⁵/\n63. 砧 /diam¹/\n64. 篩 /tai¹/\n65. 筅 /cain²/ 刷子\n66. 菜篩 /cai³ tai¹/\n67. 鉸刀 /ga¹ do¹/ 剪刀\n68. 螺絲批 /lo⁵ si¹ poi¹/ 螺絲刀\n69. 螺絲釘 /lo⁵ si¹ dêng¹/\n70. 旋螺絲 /suag⁸ lo⁵ si¹/ 擰螺絲\n71. 鐵錘 /tih⁴ tui⁵/\n72. 鉸夾 /ga¹ giab⁸/ 鉗子\n73. 扳手 /bang² ciu²/\n74. 電筆 /diang⁶ big⁴/ 測電筆\n75. 烏膠布 /ao¹ ga¹ bao³/ 電工膠帶\n76. 黏紙 /niam⁵ zua²/ 透明膠帶\n77. 布拖 /bao³ tu¹/ 拖把\n78. 掃帚 /sao³ siu²/ 掃把\n79. 畚斗 /bng³ dao²/ 垃圾鏟\n80. 畚箕 /bng³ gi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled.png)\n\n81. 梯 /tui¹/\n82. 吸石 /hiab⁴ zioh⁸/ 磁鐵、磁石\n83. 箠 /coi⁵/ 鞭子，可用來教育孩子。\n84. 火箠 /hoi² coi⁵/ 火筷子，夾爐中煤炭或通火的用具。\n85. 角畢 /gag⁴ big⁴/ 皮箱\n86. 樹嬭 /ciu⁷ ni⁵/ 橡皮、橡膠。嬭，樹之乳膠。\n87. 嬭漱 /ni⁵ ciu³/ 橡皮擦\n88. 毛筆 /mo⁵ big⁴/\n89. 鋼筆 /gng³ big⁴/\n90. 鉛筆 /iang⁵ big⁴/\n91. 鉛筆旋 /iang⁵ big⁴ suag⁸/ 卷筆刀、筆刨\n92. 模 /bhao⁵/ 模子\n93. 㨹 /zoi⁷/ 裂縫、痕跡\n94. 離衣機 /li⁵ i¹ gi¹/ 洗衣機\n\n### 🏠建築(giang³ dog⁴)\n\n1. 茨、厝 /cu³/ 房子、家\n2. 寮 /liao⁵/ 简陋小屋\n3. 瓦茨 /hia⁶ cu³/ 瓦舍\n4. 茨手 /cu³ ciu²/ 潮汕民居天井旁兩間廂房的名稱。\n5. 兩間直 /no⁶ gain¹ dig⁸/ 傳統民居，兩房。\n6. 獨腳靴 /dog⁸ ka¹ hia¹/ 傳統民居，一聽一茨手一房。\n7. 下山虎 /hia⁶ suan¹ haon²/ 傳統民居，三合院，一廳二房二茨手。\n8. 四點金 /si³ diam² gim¹/ 傳統民居，四合院，中軸爲前廳天井後聽，兩廳兩旁各有一房。\n9. 竹竿茨 /dêg⁴ go¹ cu³/ 傳統民居，廚房客廳住房天井排列成狹長的空間，如竹竿。\n10. 駟馬拖車 /si³ mê² tua¹ cia¹/ 傳統民居，在四點金上縱加一廳，橫加兩房，三廳二天丼。\n11. 茨邊 /cu³ bin¹/ 鄰居\n12. 起茨 /ki² cu³/ 蓋房子\n13. 租茨 /zao¹ cu³/ 租房子\n14. 搬茨 /buan⁵ cu³/ 搬家\n15. 入新茨 /rib⁸ sing¹ cu³/ 搬入新家\n16. 客廳 /kêh⁴ tian¹/\n17. 客房 /kêh⁴ bang⁵/\n18. 廚房 /dao⁵ bang⁵/\n19. 浴室 /êg⁸ sig⁴/\n20. 洗浴 /soi² êg⁸/ 洗澡\n21. 廁所 /cê³ so²/\n22. 屎壑 /sai² hag⁸/ 茅廁\n23. 門窗 /mng⁵ têng¹/\n24. 門閂 /mng⁵ cuan³/\n25. 門楣 /mng⁵ bhai⁵/\n26. 門橂 /mng⁵ dain⁶/ 門檻\n27. 門扇後 /mng⁵ sin³ ao⁶/ 門後\n28. 柱 /tiao⁶/\n29. 牆壁 /cion⁵ biah⁴/\n30. 庭、埕 /dian⁵/ 寬闊平地，可曬鹽、曬穀。\n31. 临檐 /lim⁵ zin⁵/ 檐廊\n32. 塗角 /tao⁵ gag⁴/ 土磚\n33. 磚 /zng¹/\n34. 廟 /bhio⁷/\n35. 亭 /dêng⁵/\n36. 祠堂 /su⁵ dng⁵/\n37. 庵寺 /am¹ zin⁷/ 尼寺、僧寺的通稱。\n38. 學校 /hag⁸ hao⁶/\n39. 醫院 /ui¹ in⁷/\n40. 鎮府 /ding³ hu²/ 鎮政府\n41. 舖囝 /pao³ gian²/ 小賣部\n\n### 🛵交通(gao¹ tong¹)\n\n1. 腳車、跤車 /ka¹ cia¹/ 腳踏車、自行車\n2. 摩托 /mo⁵ toh⁸/ 摩托，英文 motorcycle 音譯省。\n3. 三輪車 /san¹ lung⁵ cia¹/\n4. 的士 /dêg⁴ si⁶/ 計程車、出租車。的士，英文 taxi 音譯。\n5. 小車 /sio² cia¹/ 小汽車\n6. 麵包車 /min⁷ bao¹ cia¹/\n7. 公交車 /gong¹ gao¹ cia¹/\n8. 大巴 /dua⁷ ba¹/ 巴，英文 bus 音譯。\n9. 車站 /cia¹ zam⁶/\n10. 輪船 /lung⁵ zung⁵/\n11. 龍船 /lêng⁵ zung⁵/ 龍舟\n12. 火車 /hoi² cia¹/\n13. 地鐵 /di⁷ tih⁴/\n14. 高鐵 /gao¹ tih⁴/\n15. 飛機 /boi¹ gi¹/\n16. 行路 /gian⁵ lao⁷/ 走路\n17. 踏腳車 /dah⁸ ka¹ cia¹/ 騎自行車\n18. 駛車 /sai² cia¹/ 開車\n19. 撐船 /tên¹ zung⁵/\n20. 載客 /zai³ kêh⁴/\n21. 拗䷀囝 /ao² gag⁴ gian²/ 摩托車司機。拗，載；扛。\n22. 落車 /lo² cia¹/ 下車\n23. 碼頭 /bhê² tao⁵/\n24. 涵空、涵孔 /am⁵ kang¹/ 涵洞、涵管、地下水道\n25. 橋墩 /gio⁵ dun¹/ 橋梁下面的圓柱狀基石\n\n### 🐒眾生(zêng³ sên¹)\n\n1. 眾生 /zêng³ sên¹/ 牲畜\n2. 禽兽 /kim⁵ siu⁶/\n3. 害蟲 /hai⁷ tang⁵/\n4. 豬豭 /du¹ go¹/ 配種的公豬，也比喻好色之徒。\n5. 豬槽 /du¹ zo⁵/\n6. 羊牢 /ion⁵ lo⁵/\n7. 雞翁 /goi¹ ang¹/ 雄雞\n8. 雞母 /goi¹ bho²/ 母雞\n9. 鴨囝 /ah⁴ gian²/ 小鴨子\n10. 鵝 /gho⁵/\n11. 貓牯 /ngiao¹ gao²/ 母貓\n12. 鳥 /ziao²/\n13. 燕囝 /in³ gian²/ 小燕子\n14. 鶴 /hoh⁸/\n15. 鷹 /êng¹/\n16. 白鴿 /bêh⁸ gab⁴/\n17. 白鷺鷥 /bêh⁸ lao⁷ si¹/\n18. 鸚哥 /êng¹ go¹/ 鸚鵡\n19. 麻雀 /mua⁵ ziah⁴/\n20. 蝠婆 /big⁴ bo⁵/ 蝙蝠\n21. 蛇 /zua⁵/\n22. 雨傘節 /hao⁶ suan³ zag⁴/ 一种毒蛇。\n23. 狗母蛇 /gao² bho² zua⁵/ 蛇舅母、石龍子、四腳蛇，蜥蜴的一種\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%201.png)\n\n24. 兩棲動物 /liang² ci¹ dong⁶ moih⁸/\n25. 蟾蜍 /ziong¹ zu⁵/\n26. 蛤虯 /gab⁴ giu²/ 青蛙\n27. 蛤蛙 /gab⁴ guai¹/ 蝌蚪\n28. 蚼蟻 /gao² hia⁶/ 螞蟻\n29. 白蟻 /bêh⁸ hia⁶/\n30. 蜜蜂 /bhig⁸ pang¹/\n31. 虎頭蜂 /hao² tao⁵ pang¹/ 黄蜂\n32. 龜 /gu¹/ 烏龜或像烏龜的昆蟲\n33. 金龜 /gim¹ gu¹/ 金龜子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%202.png)\n\n34. 鱉 /bih⁴/\n35. 土蚓 /dao⁶ ung²/ 蚯蚓\n36. 蜈蚣 /gê⁵ gang¹/\n37. 火金蛄 /hoi² gim¹ gao¹/ 螢火蟲\n38. 牛屎龜 /ghu⁵ sai² gu¹/ 屎殼郎、蜣螂\n39. 烏點龜 /ao¹ diam² gu¹/ 七星瓢蟲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%203.png)\n\n40. 紅新娘 /ang⁵ sing¹ nion⁵/ 紅姬緣椿象\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%204.png)\n\n41. 山蛚 /sua¹ lê⁷/ 蟬；多指[蚱蝉](http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14818)\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%205.png)\n\n42. 蝘悲蟬 /iam⁶ bi¹ sung⁵/ [蟪蛄](http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14817)\n\n    ![gahzi-oi-hung-lui-ci-biao/image.jpg](gahzi-oi-hung-lui-ci-biao/image.jpg)\n\n43. 蟋蟀 /tih⁴ sug⁴/ 又稱烏龍。\n44. ䷀ // 螽斯、莎蟲、紡織娘、蟈蟈。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%206.png)\n\n45. 草猴 // 稻蝦\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%207.png)\n\n46. ䷀ // 金盾龜金花蟲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%208.png)\n\n47. 草蜢 /cao² mên²/ 螞蚱、蚱蜢。\n48. 螳螂、螳蜋 /tang⁵ lang⁵/\n49. 神螂 /sing⁵ lang⁵/ 壁虎，蜥蜴的一種。\n50. 蛤蚧蛇 /gab⁴ gai³ zua⁵/ 大壁虎，蜥蜴的一種。\n51. 土猴 /dao⁶ gao⁵/ 螻蛄\n52. 蝶、蜨 /iah⁸/ 蝴蝶\n53. 山螟 /suan¹ mê¹/ 蜻蜓\n54. 米龜 /bhi² gu¹/ 米象，蛀食稻穀、麥粒等米糧爲生。\n55. 蛀蟲 /zu³ tang⁵/\n56. 蛓毛蟲 /ci³ mo⁵ tang⁵/ 毛毛蟲\n57. 流鼻螺 /lao⁵ pin⁷ lê⁵/ 蝸牛\n58. 戶蠅 /hao⁵ sing⁵/ 蒼蠅\n59. 枯蠅 /gao¹ sing⁵/ 介殼蟲\n60. 蠓、蚊 /mang²/\n61. 蝨母 /sag⁴ bho²/ 蝨子\n62. 曱甴、虼蚻 /ga¹ zuah⁸/ 蟑螂\n63. 蜈蜞 /ghao⁵ ki⁵/ 水蛭，喜歡吸血人畜血液。\n\n### 🐳水產(zui² suan²)\n\n1. 䭕水魚 /zian² zui² hu⁵/ 淡水魚\n2. 鹹水魚 /giam⁵ zui² hu⁵/ 海水魚\n3. 刣魚 /tai⁵ hu⁵/ 宰魚\n4. 魚春 /hu⁵ cung¹/ 魚卵。屈大均《廣東新語》：「粵方言凡禽魚卵皆為春。唐時吳君貢魚春子，即魚子也。」 \n5. 魚鱗 /hu⁵ lang⁵/\n6. 魚鰾 /hu⁵ pio⁶/\n7. 魚鰓 /hu⁵ ci¹/\n8. 魚刺 /hu⁵ ci³/\n9. 鯁 /gên²/ 魚刺在喉\n10. 馬鮫 /mê² ga¹/\n11. 鯧 /cion¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%209.png)\n\n12. 鰇魚 /riu⁵ hu⁵/ 魷魚\n13. 墨斗 /bhag⁸ dao²/、/mag⁸ dao²/ 墨魚\n14. 絲丁魚 /si¹ dêng⁶ hu⁵/ 龍頭魚、硬魚、橂魚(殿魚)、豆腐魚\n15. 狗母魚 // 蝦虎魚、狗魽仔魚、九甘魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2010.png)\n\n16. 白目噯 /ain²/\n17. 狗母囝 // 身體透明，似魩仔鱼，有淡水和海水兩種\n18. 鰻魚 /muan⁵ hu⁵/\n19. 花仙魚 /hoi¹ siang¹ hu⁵/ 鮐魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2011.png)\n\n20. 鸚哥魚 /êng¹ go¹ hu⁵/ 洛神項鰭魚、紅姑娘、紅新娘、碼頭魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2012.png)\n\n21. 癩瘑魚 /na³ go¹ hu⁵/、/lai³ go¹ hu⁵/ 多齒蛇鯔，俗稱「那哥魚」，常用於製魚丸。\n22. 娘愛魚 /nion⁵ ain¹ hu⁵/ 泥猛魚、褐篮子鱼、臭肚鱼。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2013.png)\n\n23. ䷀囝 /dêg⁸ gian²/ 又稱迪仔、綠鰭馬面魨、剝皮魚。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2014.png)\n\n24. 䱛囝 /oig⁸ gian²/ 䱛仔、䱛魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2015.png)\n\n25. 金龍䱛 /gim¹ lêng⁵ oig⁸/ 金龍魚、黃花魚，狀似䱛魚但個頭大、嘴圓、體黃。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2016.png)\n\n26. 福壽魚 /hog⁴ siu⁶ hu⁵/ 羅非魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2017.png)\n\n27. 鮭魚 /guai¹ hu⁵/ 河魨，俗稱「乖魚」，常指黃鰭東方魨。\n28. 黃牆 /ng⁵ cion⁵/ 黃鰭鯛\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2018.png)\n\n29. 軟甘 /nng² gang¹/ 杜氏鰤、油甘，體側有黃色縱帶。 \n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2019.png)\n\n30. 沙尖 /sua¹ ziam¹/ 多鱗鱚、沙鯪、北方稱沙丁魚。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2020.png)\n\n31. 龍箭 /lang⁷ zin⁷/ 鯪魚 ，淡水魚，可用於做罐頭魚。\n32. 石剎 /zio² sag⁴/ 又稱烏雞，松鯛。\n33. 淡角魚 /dam⁶ gag⁴ hu⁵/ 鯒魚、辮子魚\n34. 烏魚 /ao¹ hu⁵/ 又稱烏頭，鯔魚。\n35. 烏前魚 /ao¹ zain⁵ hu⁵/\n36. 塗虱 /tao⁵ sag⁴/ 鬍子鯰\n37. 龍舌 /lêng⁵ zi²/ 龍利魚\n38. 巴浪 /ba¹ lang¹/ 藍圓鯵\n39. 鯇魚 /uang² hu⁵/ 草魚\n40. 姑魚 /gao¹ hu⁵/ 金色小沙丁魚\n41. 鯽魚 /zig⁴ hu⁵/\n42. 秋刀魚 /ciu¹ do¹ hu⁵/\n43. 紅目鰱 /ang⁵ mag⁸ liang⁵/ 紅目大眼鯛\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2021.png)\n\n44. 田鱔 /cang⁵ cuan⁶/ 鱔魚、黃鱔\n45. 白帶魚 /bêh⁸ dua³ hu⁵/ 鞭魚、裙帶魚、海刀魚\n46. 鰐魚 /ngag⁸ hu⁵/\n47. 鯊魚 /sua¹ hu⁵/\n48. 鯨魚 /kêng⁵ hu⁵/\n49. 紅哥鯉 /ang⁵ go¹ li²/ 金線魚\n50. 蝦 /hê⁵/\n51. 蟹 /hoi⁶/\n52. 三目蠘 /san¹ mag⁸ cih⁸/ 紅星梭子蟹、三目蟹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2022.png)\n\n53. 海哲 /hai² diag⁴/\n54. 蠔、蚝、蚵 /o⁵/ 牡蠣\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2023.png)\n\n55. 紅肉 /ang⁵ nê²/ 紅肉藍蛤\n56. 蚶 /ham¹/\n57. 蜆 /hain⁶/\n58. 青匙 /cên¹ si⁵/ 綠殼菜蛤、翡翠貽貝\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2024.png)\n\n59. 花蛤 /hoi¹ gab⁴/ 菲律賓簾蛤、花甲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2025.png)\n\n60. 車白 /cia¹ bêh⁸/ 文蛤，邊緣弧度較花蛤圓。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2026.png)\n\n61. 青蛤 /cên¹ gab⁴/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2027.png)\n\n62. 毛蚶 /mo⁵ ham¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2028.png)\n\n63. 薄殼 /bo² kag⁴/ 尋氏肌蛤、海蛔、海瓜子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2029.png)\n\n64. 指甲螳 /zain² gah⁴ tang⁵/ 又稱指甲蚌hong²，蟶sêng³子。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2030.png)\n\n65. 田螺 /cang⁵ lê⁵/\n66. 尖螺 /ziang¹ lê⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2031.png)\n\n### 🌾 蔬菜(so¹ cai³)\n\n1. 五穀 /ngao⁶ gag⁴/\n2. 稻 /diu⁶/\n3. 粟 /cêg⁴/ 稻粒\n4. 麥 /mê²/\n5. 秫米 /zu² bhi²/ 糯米\n6. 薏米 /in³ bhi²/\n7. 薏仁 /in³ ring⁵/ 玉米\n8. 蕃薯 /huang¹ zu⁵/、/hang¹ zu⁵/\n9. 馬鈴薯 /mê² lêng¹ zu⁵/ 土豆\n10. 黃豆 /ng⁵ dao⁷/ 大豆、菽\n11. 綠豆 /lê² dao⁷/\n12. 烏豆 /ao¹ dao⁷/ 黑豆\n13. 赤豆 /ciah⁴ dao⁷/ 紅小豆\n14. 荷目豆 /ho⁵ mag⁸ dao⁷/ 荷蘭豆、豌豆\n15. 地豆 /di⁷ dao⁷/ 花生\n16. 豆仁 /dao⁷ ring⁵/ 花生米\n17. 油麻 /iu⁵ mua⁵/ 芝麻\n18. 菜豆 /cai³ dao⁷/ 常指四季豆\n19. 茄 /gio⁵/\n20. 苦瓜 /kao² goi¹/\n21. 角瓜 /gag⁴ goi¹/ 稜角絲瓜\n22. 秋瓜 /ciu¹ goi¹/ 絲瓜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2032.png)\n\n23. 嬭瓜、奶瓜 /nê¹ goi¹/ 木瓜\n24. 蓮藕 /nain⁵ nao⁶/\n25. 菠薐菜 /boi¹ lêng⁵ cai³/ 菠菜\n26. 蕹菜 /êng³ cai³/ 空心菜\n27. 春菜 /cung¹ cai³/ 長葉芥菜\n28. 菜花 /cai³ hoi¹/ 花椰菜\n29. 芥菜 /gua³ cai³/ 大芥菜、包心芥菜\n30. 芥藍 /gêg⁴ na⁵/\n31. 菜頭 /cai³ tao⁵/ 白蘿蔔\n32. 紅菜頭 /ang⁵ cai³ tao⁵/ 紅蘿蔔\n33. 薺蔥、錢蔥 /zin⁵ cang¹/ 荸薺\n34. 韭菜 /gu² cai³/\n35. 芫荽 /iang¹ sui¹/ 香菜\n36. 芳菜 /pang¹ cai³/\n37. 厚合 /gao⁶ hah⁸/ 厚皮菜、莙薘菜、葉用甜菜\n38. 九層塔 /gao² zang⁵ tah³/ 金不換、羅勒\n39. 萵菜 /oi¹ cai³/ 皺葉萵苣、生菜\n40. 劍菜 /giam³ cai³/ 油麥菜\n41. 上海青 /siang⁶ hai² cên¹/ 青菜的一種\n42. 芹菜 /king⁵ cai³/\n43. 津白 /gian¹ bêh⁸/ 又稱紹菜、黃芽白，天津盛產，是大白菜的一種。以下是大白菜的不同品種。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2033.png)\n\n    天津大白菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2034.png)\n\n    大白菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2035.png)\n\n    娃娃菜\n\n44. 高麗菜 /go¹ lê⁵ cai³/ 捲心菜、包菜、結球甘藍\n45. 菜花 /cai³ hoi¹/ 花椰菜\n46. 茼蒿 /dang⁵ o¹/\n47. 枸杞菜 /gao² gi² cai³/\n48. 真珠菜 /zing¹ zu¹ cai³/ 珍珠花菜、白苞蒿\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2036.png)\n\n49. 薟椒 /hiam¹ tsio¹/ 辣椒\n50. 生果 /cên¹ goi²/ 水果\n51. 荔果 /nai⁶ goi²/ 荔枝\n52. 龍眼 /nging⁵ ain²/\n53. 桑垂 /siong¹ sui⁵/ 桑葚\n54. 草莓 /cao² bhoi⁵/\n55. 刺菠 /ci³ bo¹/ 蛇莓、覆盆子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2037.png)\n\n56. 弓蕉 /gêng¹ zio¹/ 香蕉\n57. 米蕉 /bhi² zio¹/\n58. 鳥梨 /ziao² lai⁵/\n59. 檨 /suain⁷/ 芒果\n60. 菝囝 /bag⁸ gian²/ 番石榴\n61. 西瓜 /si¹ goi¹/\n62. 香櫞 /hion¹ ng⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2038.png)\n\n63. 柚 /iu⁷/\n64. 柑 /gan¹/ 柑橘\n65. 桔 /gig⁴/\n66. 橙 /cêng⁵/\n67. 菠蘿 /bo¹ lo⁵/\n68. 油甘 /iu⁵ gam¹/ 餘甘果，先苦後甜，齒留餘甘。\n69. 番茄 /huang¹ gio⁵/\n70. 青竹梅 /cên¹ dêg⁴ bhoi⁵/\n71. 李 /li²/\n72. 棗 /zo²/\n73. 蔗 /zia³/ 甘蔗\n\n### 🌿草藥 /cao² ioh⁸/\n\n1. 艾 /hia³/ 艾草 \n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2039.png)\n\n2. 草粿草 /cao² goi² cao²/ 仙草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2040.png)\n\n3. 策草 /cêg⁴ cao²/ 又稱抹(bhuah⁴)草、廣防風、防風草，甲子地區神位常年插此草。策 ，大概是指其像馬鞭。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2041.png)\n\n4. 青菭 /cên¹ ti⁵/ 青苔\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2042.png)\n\n5. 薄荷 /bo⁵ ho³/、/bon⁵ hon³/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2043.png)\n\n6. 金銀花 /gim¹ nging⁵ hoi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2044.png)\n\n7. 午時花 /ngao² si⁵ hoi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2045.png)\n\n8. 四季春 /si³ kui³ cung¹/ 四季春花\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2046.png)\n\n9. 葉下紅 /hio² ê⁶ ang⁵/ 一點紅\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2047.png)\n\n10. 臭草花 /cao³ cao² hoi¹/ 五色梅、馬纓丹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2048.png)\n\n11. 飛天蜈蚣 /boi¹ tin¹ ghê⁵ gang¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2049.png)\n\n12. 金雞脫殼 /gim¹ goi¹ tug⁴ kag⁴/\n13. 路跤菊 /lao⁷ ka¹ gêg⁴/ 路邊菊\n14. 臘裏葉 /lah⁸ li² hioh⁸/ 金邊紅桑\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2050.png)\n\n15. 芒囝筍 /mang⁵ gian² sung²/ 芒草的嫩芽\n16. 竹菜 /dêg⁴ cai³/ 竹葉草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2051.png)\n\n17. 葛菜 /guah⁴ cai³/ 野葛菜，可食。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2052.png)\n\n18. 烏規菜 /ao¹ gui¹ cai³/ 龍葵\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2053.png)\n\n19. 豬母菜 /du¹ bho² cai³/ 馬齒莧\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2054.png)\n\n20. 刺莧 /ci³ hain⁷/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2055.png)\n\n21. 苦刺 /kao² ci³/ 白簕\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2056.png)\n\n22. 苦草 /kao² cao²/ 豨薟草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2057.png)\n\n23. 兩公根 /liang² gong¹ ging¹/ 崩大碗\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2058.png)\n\n24. 鋪地錦 /pao¹ di⁷ gim²/ 滿天星\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2059.png)\n\n25. 雞屎藤 /goi¹ sai² ding⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2060.png)\n\n26. 伸筋藤 /cung¹ ging¹ ding⁵/ 蔓九節\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2061.png)\n\n27. 無頭藤 /bho⁵ tao⁵ ding⁵/ 寄生於其他植物之上\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2062.png)\n\n28. 酒甕囝 /ziu² ang³ gian²/\n29. 盐酸鸡囝 /iam⁵ sng¹ goi¹ gian²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2063.png)\n\n30. 見笑草 /giang³ siao³ cao²/ 含羞草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2064.png)\n\n31. 燈籠草 /dêng¹ lang⁵ cao²/ 其果子稱爲「姑娘果」\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2065.png)\n\n32. 車前草 /cia¹ zain⁵ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2066.png)\n\n33. 馬鞭草 /bhê² bin¹ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2067.png)\n\n34. 蟋蟀草 /tig⁴ sug⁴ cao²/ 烏龍草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2068.png)\n\n35. 蒲公英 /pu⁵ gong¹ êng¹/\n36. 鸭舌草 /ah³ zih⁸ cao²/ 苦菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2069.png)\n\n37. 魚腥草 /hu⁵ co³ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2070.png)\n\n38. 益母草 /iah⁴ bho² cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2071.png)\n\n39. 龍膽草 /lêng⁵ dan² cao²/ 苦地膽草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2072.png)\n\n40. 奶汁草 /nê¹ zab⁴ cao²/ 乳汁草，草折斷會有白色液體流出。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2073.png)\n\n41. 虎耳草 /haon² hin⁶ cao³/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2074.png)\n\n42. 大號奶汁草 /dua⁷ ho⁷ nê¹ zab⁴ cao³/ 蠔割草、飛揚草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2075.png)\n\n43. 貓毛兒 /ngiao¹ mo⁵ ri⁵/ 金絲草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2076.png)\n\n44. 貓鬚草 /ngiao¹ ciu¹ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2077.png)\n\n45. 鹅囝香 /gho⁵ gian² hiang¹/ 鹅不食草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2078.png)\n\n46. 白花蛇舌草 /bêh⁸ hoi¹ zua⁵ zih⁸ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2079.png)\n\n47. 白花蟛蜞草 /bêh⁸ hoi¹ pen⁵ ki⁵ cao²/、/bêh⁸ hoi¹ mua⁵ ki⁵ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2080.png)\n\n48. 四方枝苦楝 /si³ bang¹ gi¹ kao² nai⁷/ 鬼針草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2081.png)\n\n49. 苦楝 /kao² nai⁷/ 苦楝樹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2082.png)\n\n50. 挨礱被哺 /oi⁵ lang⁵ bi⁶ bu⁶/ 磨盤草、磨礱草、挨礱地堵，其果實似磨盤和礱。礱，磨谷農具。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2083.png)\n\n### 🏮時節(si⁵ zoih⁴)\n\n1. 今年 /gim¹ ni⁵/\n2. 舊年 /gu⁷ ni⁵/ 去年\n3. 前年 /zain³ ni⁵/、/zung³ ni⁵/\n4. 下年 /ê⁶ ni⁵/ 明年\n5. 熱天時 /ruah⁸ tin¹ si⁵/ 夏天\n6. 寒天時 /guan⁵ tin¹ si⁵/ 冬天\n7. 凝天時 /ngang⁵ tin¹ si⁵/ 冬天\n8. 春夏秋冬 /cung¹ hê⁶ ciu¹ dang¹/\n9. 老歷 /lao⁶ lê²/ 農曆\n10. 新曆 /sing¹ lê²/ 公曆\n11. 今日 /gim¹ rig⁸/\n12. 明日 /mêng⁵ rig⁸/\n13. 今旦日 /gian² rig⁸/ 今天\n14. 明旦日 /man³ rig⁸/ 明天\n15. 明眠起 /ma³ mng⁵ ki²/ 明天\n16. 昨日 /za¹ rig⁸/\n17. 前日 /zain⁵ rig⁸/、/zoh⁸ rig⁸/\n18. 後日 /ao⁶ rig⁸/\n19. 大前日 /dua⁷ zain⁵ rig⁸/、/dua⁷ zoh⁸ rig⁸/\n20. 大後日 /dua⁷ ao⁶ rig⁸/\n21. 天光 /tin¹ gng¹/ 天亮\n22. 透早 /tao³ za²/ 黎明\n23. 眠起 /mng⁵ ki²/ 早晨\n24. 日時 /rig⁸ si⁷/ 白天\n25. 早晝 /za² dao³/ 上午\n26. 中晝 /dêng¹ dao³/ 中午\n27. 中晝時 /dêng¹ dao³ si⁵/ 中午\n28. 下晝 /ê⁶ dao³/ 下午\n29. 下旰 /ê⁶ gua³/ 下午\n30. 暗頭 /am³ tao⁵/ 傍晚\n31. 暗頭時 /am³ tao⁵ si⁵/ 傍晚\n32. 下昏 /ê⁶ hng⁵/ 晚上\n33. 下昏時 /ê⁶ hng⁵ si⁵/、/êng² si⁵/ 晚上\n34. 下昏囝 /êng² gian²/ 晚上\n35. 暗時 /am³ si⁷/ 晚上\n36. 暝時、夜時 /mê⁵ si⁷/ 晚上\n37. 暝昏、夜昏 /mê⁵ hng⁵/ 晚上\n38. 暝昏時、夜昏時 /mê⁵ hng⁵ si⁵/、/mêng² si⁵/ 晚上\n39. 暝昏囝 /mêng² gian²/ 晚上\n40. 半暝、半夜 /buan³ mê⁵/\n41. 時分秒 /si⁵ hung⁵ miao²/\n42. 個字 /gai⁵ ri⁷/ 五分鐘\n43. 兩個字久 /no⁶ gai⁵ ri⁷ gu²/ 十分鐘\n44. 頭前 /tao⁵ zain⁵/ 之前\n45. 頭陣 /tao⁵ zung⁵/ 剛才\n46. 下 /ê⁶ miag⁸/、/ê⁶ mig⁸/ 剛才\n47. 一頃 /zêg⁸ kuang³/ 一會兒\n48. 一頃頭 /zêg⁸ kuang³ tao⁵/ 一下子\n49. 煞尾 /suah⁴ bhoi²/ 最後\n50. 今 /dan¹/ 現在\n51. 逐日 /dag⁸ rig⁸/ 每天\n52. 逐暝 /dag⁸ mê⁵/ 每晚\n53. 通日 /tang³ rig⁸/ 整天\n54. 半日 /buan³ rig⁸/\n55. 隔日 /gêh⁴ rig⁸/\n56. 隔暝、隔夜 /gêh⁴ mê⁵/\n57. 別日 /bag⁸ rig⁸/ 改天\n58. 即時 /ziag⁴ si⁵/ 立刻、馬上\n59. 平常時 /pêng⁵ sion⁵ si⁵/ 平時\n60. 一日通通 /zêg⁸ rig⁸ tang³ tang³/ 一整天\n61. 七早八早 /cig⁴ za² boih⁴ za²/ 一大早\n62. 七早蒙流 /cig⁴ za² mo⁵ liu⁵/ 一大早\n63. 烏暗天地 /ao¹ am³ tin¹ di¹/ 天昏地暗\n64. 立春 /lib⁸ cung¹/\n65. 雨水 /u² sui²/\n66. 驚蟄 /gêng¹ dêg8/\n67. 春分 /cung¹ hung¹/\n68. 清明 /cêng¹ mêng⁵/\n69. 谷雨 /gog⁴ u²/\n70. 立夏 /lib⁸ hê⁶/\n71. 小滿 /sio² muan²/\n72. 芒種 /mang⁵ zêng²/\n73. 夏至 /hê⁶ zi³/\n74. 小暑 /siao² su²/\n75. 大暑 /dai⁶ su²/\n76. 立秋 /lib⁸ ciu¹/\n77. 處暑 /cu³ su²/\n78. 白露 /bêh⁸ lao⁷/\n79. 秋分 /ciu¹ hung¹/\n80. 寒露 /guan⁵ lao⁷/\n81. 霜降 /sang¹ gang³/\n82. 立冬 /lib⁸ dang¹/\n83. 小雪 /siao² soh⁴/\n84. 大雪 /dai⁶ soh⁴/\n85. 冬至 /dang¹ zi³/\n86. 小寒 /siao² hang⁵/\n87. 大寒 /dai⁶ hang⁵/\n88. 時年八節 /si⁵ ni⁵ boih⁴ zoih⁴/ 一年四季八個節，最早的八節指立春、春分、立夏、夏至、立秋、秋分、立冬和冬至。而在甲子時年八節指元宵、春分、清明、五月節、七月半、秋分、八月半、冬節，過此八節要拜祖，除春分、秋分外的節還需要拜神。\n    - 四時，四季、春夏秋冬。\n    - 年，甲骨文象人負禾之形，會穀物豐收之意，古時禾穀一年一熟，於是「年」被（引申）用作周年之年。【爾雅•釋天】夏曰歲，商曰祀，周日年，唐虞曰載。古時一度流行歲星（即木星、朱比特星，公轉週期爲 398.88 天）紀年，故一年又稱一歲。\n    - 時年，一年四季。\n    - 節，中國曆法把一年分為二十四段，每段的開始即爲節。早期只有春分、秋分、夏至、冬至四節，後又加入立春、立夏、立秋、立冬，形成八節，再來後逐漸形成了二十四節。「節」早期是天文曆法上的概念，與氣候相關，後又逐漸加入了紀念或慶祝的元素。\n89. 元宵節 /nguang⁵ siao¹ zoih⁴/\n90. 公忌節 /gong¹ gi⁷ zoih⁴/ 春分和秋分，祭拜先祖，但不拜神。\n91. 清明節 /cêng¹ mêng⁵ zoih⁴/\n92. 五月節 /ngao⁶ ghoih⁸ zoih⁴/ 端午節\n93. 七月半 /cig⁴ ghoih⁸ buan³/ 中元節、鬼節\n94. 八月半 /boih⁴ ghoih⁸ buan³/ 中秋節\n95. 冬節 /dang¹ zoih⁴/ 冬至節的簡稱。\n96. 廿九暝、廿九夜 /rig⁸ gao² mê⁵/ 除夕（小月）\n97. 三十暝、三十夜 /san¹ zab⁸ mê⁵/ 除夕（大月）\n98. 春節 /cung¹ zoih⁴/\n99. 重陽 /ciang⁵ iang⁵/、/dêng⁵ iang⁵/\n100. 國慶節 /gog⁴ kêng³ zoih⁴/\n101. 勞動節 /lao⁵ dong⁶ zoih⁴/\n102. 婦女節 /hu⁶ nng² zoih⁴/\n103. 兒童節 /ri⁵ tong⁵ zoih⁴/\n104. 教師節 /ga³ su¹ zoih⁴/\n105. 做節 /zo³ zoih⁴/ 過節日\n106. 做壽 /zo³ siu⁶/ 過壽辰\n107. 做生日 /zo³ sên¹ rig⁸/ 過生日\n108. 公忌 /gong¹ gi⁷/ 先祖忌日\n109. 拜公忌 /bai³ gong¹ gi⁷/ 在忌日祭拜先祖\n110. 拜祖 // 祭拜先祖\n111. 拜老爺 // 拜神\n112. 假日 /gia² rig⁸/\n113. 放假 /bang³ gia²/、/bang³ gian²/\n114. 暑假 /su² gia²/\n115. 寒假 /hang⁵ gia²/\n\n### 🌀天時(tin¹ si⁵)\n\n1. 晴 /zên⁵/ 晴朗\n2. 出日 /cug⁴ rig⁸/ 太陽出來了\n3. 透堂白日 /tao³ dng⁵ bêh⁸ rig⁸/ 大白天\n4. 烏陰天 /ao¹ im¹ tin¹/ 陰天\n5. 透風 /tao³ hong¹/ 刮大風\n6. 風颱 /hong¹ tai¹/ 颱風\n7. 南風天 /nang¹ hong¹ tin¹/ 刮南風，濕氣加重\n8. 轉南風 /dng² nang¹ hong¹/ 南風天來了\n9. 透南風 /tao³ nang¹ hong¹/ 刮南風，伍佰有一 Live 同名。\n10. 蒙煙天 /mong⁵ iang¹ tin¹/ 霧霾天\n11. 落雨 /lo² hao⁶/ 下雨\n12. 一陣雨 /zêg⁸ zung⁵ hao⁶/\n13. 日頭雨 /rig⁸ tao⁵ hao⁶/ 一邊下雨，一邊出太陽\n14. 烏寒雨 /ao¹ guan⁵ hao⁶/ 天時烏陰落寒雨\n15. 爍焰 /sih⁴ iam⁶/ 閃電\n16. 敲雷 /ka³ lui⁵/ 打雷\n17. 冷空氣 /lêng² kong¹ ki⁷/\n18. 落雪 /lo² soh⁴/ 下雪\n19. 落雹 /lo² pag⁸/ 下冰雹\n20. 旱 /uan⁶/ 乾旱\n21. 寒 /guan⁵/ 寒冷\n22. 冷 /lêng²/ 寒冷\n23. 凝 /ngang⁵/ 寒冷\n24. 熱 /ruah⁸/\n25. 翕熱 /hib⁴ ruah⁸/ 悶熱\n26. 乾燥 /gang¹ cao³/\n27. 濕 /sib⁴/ 濕潤\n28. 涼 /liang⁵/ 涼爽\n\n### 🌛天文(tiang¹ bhung⁵)\n\n1. 天頂 /tin¹ dêng²/ 天上\n2. 日頭 /rig⁸ tao⁵/ 太陽\n3. 蝕日 /sih⁸ rig⁸/ 日食\n4. 狗齧日 /gao² na² rig⁸/ 天狗食日\n5. 西照日 /sai¹ zio³ rig⁸/ 夕陽\n6. 月娘 /ghoih⁸ nion⁵/ 月亮\n7. 月眉 /ghoih⁸ bhai⁵/ 弦月\n8. 蝕月 /sih⁸ ghoih⁸/ 月食\n9. 河溪 /ho⁵ koi¹/ 銀河、天河\n10. 落屎星 /lo² sai² cên¹/ 流星\n11. 星宿 /cên¹ siu³/\n\n### ⛰️地理(di⁷ li²)\n\n1. 中央 /diong¹ iang¹/ 中間\n2. 內底 /lai⁶ doi²/ 裏面\n3. 外口 /ghua⁷ kao²/、/la¹ kao²/ 外面\n4. 頭頂 /tao⁵ dêng²/ 上面\n5. 下跤 /ê⁶ ka¹/ 下面\n6. 下底 /ê⁶ doi²/ 下面\n7. 正手爿 /ziang³ ciu² bain⁵/ 左邊\n8. 倒手爿 /do³ ciu² bain⁵/ 右邊\n9. 頭前 /tao⁵ zain⁵/ 前面\n10. 後底 /ao⁶ doi²/ 後面\n11. 後壁 /ao⁶ biah⁴/ 後面\n12. 對面 /dui³ ming⁷/\n13. 隔壁 /gêh⁴ biah⁴/\n14. 鄰近 /lim¹ ging⁶/\n15. 塗跤 /tao⁵ ka¹/\n16. 番爿 /huang¹ bain⁵/\n17. 北爿 /bag⁴ bain⁵/\n18. 東南西北 /dang¹ nam⁵ sai¹ bag⁴/\n19. 地盤 /di⁷ buan⁵/\n20. 領域 /nia² oig⁸/\n21. 境內 /gêng² lai⁶/\n22. 世界 /si³ gai³/\n23. 宇宙 /u² diu²/\n24. 全球 /cuang¹ giu⁵/\n25. 天涯 /tiang¹ ngai⁵/\n26. 山頂 /suan¹ dêng²/\n27. 山跤 /suan¹ ka¹/\n28. 外地 /ghua⁷ dê³/\n29. 本地 /bng² di⁷/\n30. 別地 /bag⁸ dê³/ 外地\n31. 別地地 /bag⁸ di⁷ dê³/ 外地\n32. 塗 /tao⁵/ 泥\n33. 塗膏 /tao⁵ go¹/ 泥巴\n34. 石頭 /zioh⁸ tao⁵/\n35. 田園 /cang⁵ hng⁵/\n36. 溪墘 /koi¹ gin⁵/ 溪邊\n37. 草埔 /cao² bao¹/ 草坪\n38. 崎 /gia⁶/ 小山坡\n39. 坑 /kên/ 山谷、溪谷。\n40. 嶺 /nia²/ 有路可通的山頂\n41. 岑 /ngim⁵/、/cam⁵/ 小而高的山\n42. 墟 /hu¹/ 大土山\n43. 壩 /ba³/ 沙灘、沙洲。\n44. 潭 /tam⁵/ 深水池\n45. 溪 /koi¹/\n46. 江 /gang¹/\n47. 河 /ho⁵/\n48. 湖 /ao⁵/\n49. 海 /hai²/\n50. 海拔 /hai² buag⁸/\n51. 洲 /ziu¹/\n52. 港 /gang²/\n53. 灣 /uang¹/\n54. 溝 /gao¹/\n55. 渠 /ku⁵/ 水道，特指人工開的河道。\n56. 浦 /pao²/ 水邊或江河入海處\n57. 澳 /o³/ 海邊彎曲且可停泊船隻的地方\n58. 汕 /suan³/ 河流沖刷或沖刷而積成的沙灘\n59. 汕頭 /suan¹ tao⁵/\n60. 汕尾 /suan³ bhoi²/\n61. 海湧 /hai² êng²/ 海浪。湧，波浪。\n62. 東濠湧 /dang¹ hao⁵ cong¹/ 地名，在廣州越秀。濠，溝渠。湧，河流分叉處。\n63. 湧泉相報 /iong³ zuan⁵ siang¹ bo³/ 湧，水冒出。\n64. 庭、埕 /dian⁵/ 院子、宽阔处\n65. 礦物 /kuang³ moih⁸/\n66. 化石 /hoi³ zioh⁸/\n67. 原油 /nguang¹ iu⁵/\n68. 燃料 /riang⁵ liao⁷/\n69. 金屬 /gim¹ siog⁸/\n70. 金銀財寶 /gim¹ nging⁵ cai⁵ bo²/\n71. 鋼鐵 /gng³ tih⁴/\n72. 蘇打 /so³ da²/ 英文 soda 的音譯，常指小蘇打，即碳酸氫鈉。\n73. 蘇州 /sao¹ ziu¹/\n74. 蠟 /la²/\n75. 硫磺 /liu⁵ ng⁵/\n76. 砒霜 /bi¹ sng¹/\n77. 砂石 /sua¹ zioh⁸/\n78. 大理石 /dai⁶ li² zioh⁸/\n79. 碳 /tuan³/\n80. 水銀 /zui² nging⁵/\n81. 水龍水 /zui² lêng⁵ zui²/ 自來水\n82. 地牛換肩 /di⁷ ghu⁵ uang⁷ gain¹/ 地震\n83. 許婆寮 /kao² pua⁵ liao⁵/ 今可和村\n84. 北輋 /bag⁴ sia⁵/ 今博社村\n85. 四捻石 /si³ niam³ zio²/ 四片石\n86. 甲子八景：六十甲子欄、潮來人字水、雙帆跨海島、五馬渡江邊、仙人踏石積、海甲蓮花山、西峯古寺、雷廟天堂。（《陸豐縣誌》卷之二疆域四 P21）\n87. 擎天石：位於甲秀書院的側邊的一塊巨石。《陸豐縣誌》記載：在甲子所北門內峙立聳拔高出雉堞丈余，中開一痕，俗謂雷打石。胡文烜銘其上曰：「天開甲子，巨石臨門，一聲霹靂，振動乾坤 ……」。字大如鬥，余銘苔蝕莫辨。（《陸豐縣誌》卷之二古蹟十二 ）\n88. 甲秀書院：甲秀書院位於陸豐縣甲子鎮北門內。甲秀書院建於明代，歷來為粵東文人會萃講學之所。至今院內仍保存著不少歷代的石碑石刻。解放后，人民政府在此興辦中學。\n89. 福源寺：座落於甲子鎮北郊雨亭路，原名「復元寺」，又稱「蓮花山草庵」。據傳，福源寺建於宋代。因歷史久遠，原址僅遺存牆基。1990年由光茂法師主持重建。經過10多年的建造，先後建成天王殿、大雄寶殿、觀音殿、地藏殿、鐘樓、鼓樓和禪房等，重塑了諸位菩薩聖像。寺區佔地面積1.2萬多平方米，建築面積3000多平方米。\n90. 南海夫人廟：位於甲子鎮城西社區環城路東。明萬曆元年（1573），李棠中舉後爲其妻卓氏而建的紀念祠，御史鄧練題匾「南海夫人」，故稱南海夫人廟。\n91. 烈士墓\n\n### 📐計量(goi³ liang⁶)\n\n1. 〇、零 /lêng⁵/、/lang⁵/\n2. 一、壹 /zêg⁸/、/ig⁴/\n3. 二、贰 /no⁶/、/ri⁶/\n4. 三、叁 /san¹/、/sam¹/\n5. 四、肆 /si³/、/su³/\n6. 五、伍 /ngao⁶/、/u²/\n7. 六、陆 /lag⁸/\n8. 七、柒 /cig⁴/\n9. 八、捌 /boih⁴/、/bag⁴/\n10. 九、玖 /gao²/、/giu²/\n11. 十、拾 /zab⁸/\n12. 百、佰 /bêh⁴/\n13. 千、仟 /cain¹/、/ciang¹/\n14. 萬 /mang⁷/\n15. 億 /êg⁸/\n16. 一二個 /zêg⁸ no² gai⁵/\n17. 二十六 /ri⁸ ab⁸ lag⁸/、/ri⁸ zab⁸ lag⁸/\n18. 廿六號 /rig⁸ lag⁸ ho⁷/ 二十六號\n19. 五十外個 /ngao⁶ zab⁸ ghua⁷ gai⁵/\n20. 一百空八 /zêg⁸ bêh⁴ kang³ boih⁴/ 一百零八\n21. 第一 /doi⁷ ig⁴/\n22. 第二 /doi⁷ ri⁶/\n23. 第三 /doi⁷ san¹/\n24. 一個人 /zêg⁸ gai⁵ nang⁵/\n25. 一爿花 /zêg⁸ bain⁵ hoi¹/ 一片花瓣\n26. 一蕊花 /zêg⁸ lui² hoi¹/ 一朵花\n27. 一葩花 /zêg⁸ pa¹ hoi¹/ 一朵花\n28. 一枝花 /zêg⁸ gi¹ hoi¹/\n29. 一縛花 /zêg⁸ ba² hoi¹/ 一束花\n30. 一叢樹 /zêg⁸ zang⁵ hoi¹/ 一棵樹\n31. 一簇頭毛 /zêg⁸ cog⁴ tao⁵ mo⁵/ 一撮頭髮\n32. 一粒糖 /zêg⁸ liab⁸ tng⁵/\n33. 一隻車 /zêg⁸ ziah⁴ cia¹/ 一輛車\n34. 一架車 /zêg⁸ gê³ cia¹/ 一輛車\n35. 一杯茶 /zêg⁸ boi¹ dê⁵/\n36. 一碗水 /zêg⁸ uan² zui²/\n37. 一喙水、一嘴水 /zêg⁸ cui³ zui²/ 一口水\n38. 一條弓蕉 /zêg⁸ diao⁵ gêng¹ zio¹/ 一條香蕉\n39. 一本書 /zêg⁸ bng² zu¹/\n40. 一枝手機 /zêg⁸ gi¹ ciu² gi¹/ 一隻手機\n41. 一枝鎖匙 /zêg⁸ gi¹ so² si⁵/ 一把鑰匙\n42. 一個銀 /zêg⁸ gai⁵ nging⁵/ 一塊錢\n43. 一領被 /zêg⁸ nia² poi⁶/ 一席被子\n44. 一個鋪 /zêg⁸ gai⁵ pao¹/ 一張床\n45. 一個鐘頭 /zêg⁸ gai⁵ zêng¹ tao⁵/ 一個小時\n46. 一副衫褲 /zêg⁸ hu³ san¹ kao³/ 一套衣服\n47. 一腰裙 /zêg⁸ io¹ gung⁵/ 一件裙子\n48. 一尾魚 /zêg⁸ bhoi² hu⁵/ 一條魚\n49. 一墩物件 /zêg⁸ dung¹ mi² gian⁶/ 一堆東西\n50. 一橛蔗 /zêg⁸ goi² zia³/ 一截甘蔗\n51. 一葩電火 /zêg⁸ pa¹ diang⁶ hoi²/ 一盞電燈\n52. 一跤箸、一腳箸 /zêg⁸ ka¹ du⁷/ 一隻筷子\n53. 一雙箸 /zêg⁸ sang¹ du⁷/ 一雙筷子\n54. 一腹火 /zêg⁸ bag⁴ hoi²/ 一肚子火\n55. 一脬屎 /zêg⁸ bu⁵ sai²/ 一坨屎\n56. 一脬尿 /zêg⁸ bu⁵ rio⁷/ 一泡尿\n57. 一逝路 /zêg⁸ zua⁷ lao⁷/ 一趟路\n58. 一丸塗 /zêg⁸ uang⁵ tao⁵/ 一團泥土\n59. 一過 /zêg⁸ goi³/ 一次\n\n### 🧭 指代(zi² toi³)\n\n1. 只 /zi²/ 這，近指。\n2. 許 /hi²/ 那，遠指。\n3. 者、這 /zê²/、/zia²/ 這，近指。\n4. 遐 /hê²/、/hia²/ 那，遠指。\n5. 底個 /di⁷ gai⁵/ 哪個\n6. 者個 /zê² gai⁷/、/zia² gai⁷/ 這個\n7. 遐個 /hê² gai⁷/、/hia² gai⁷/ 那個\n8. 怎樣 /za³ ion⁷/、/zion²/\n9. 乜樣 /mig⁴ ion⁷/ 怎樣\n10. 底樣 /di⁷ ion⁷/ 怎樣\n11. 怎生 /za³ sên¹/、/zai¹ sên¹/怎樣\n12. 怎樣生 /zion² sên¹/ 怎樣\n13. 怎樣然 /zion² ni⁵/、/zo⁵ ni⁵/ 怎麼、幹啥\n14. 怎樣麼 /zion² mo⁷/、/ziom²/\n15. 者樣 /zê² ion⁷/、/zion¹/\n16. 遐樣 /hê² ion⁷/、/hion¹/\n17. 者樣生 /zion¹ sên¹/ 這樣\n18. 遐樣生 /hion¹ sên¹/ 那樣\n19. 底搭 /di⁷ dah⁴/ 哪裏\n20. 者搭 /zê² dah⁴/ 這裏\n21. 遐搭 /hê² dah⁴/ 那裏\n22. 底地 /di⁷ dê³/ 哪裏\n23. 者地方 /zê² ding¹/ 這裏\n24. 遐地方 /hê² ding¹/ 那裏\n25. 底囝 /di⁷ gian²/ 哪兒\n26. 者囝 /zê gian²/ 這兒\n27. 遐囝 /hê² gian²/ 那兒\n28. 底人 /di⁷ nang⁵/、/diang⁶/、/di⁷ diang⁶/ 誰\n29. 底位 /di⁷ ui⁷/ 哪位\n30. 者位 /zê² ui⁷/\n31. 遐位 /hê² ui⁷/ 那位\n32. 底時 /di⁷ si⁵/ 什麼時候\n33. 底當時 /diang⁶ si⁵/ 什麼時候\n34. 者時 /zê² si⁵/\n35. 遐時 /hê² si⁵/ 那時\n36. 乜事 /mig⁴ su⁷/ 什麼事情\n37. 若㩼 /rioh⁸ zoi⁷/、/rua⁷ zoi⁷/ 多少\n38. 幾 /gui²/\n39. 豈是 /ka³ si⁷/ 是否是\n40. 敢是 /gam² si⁷/ 是否是\n\n### 🏃‍♀️動詞(dong⁶ su⁵)\n\n**第一部分**\n\n1. 會 /oi⁶/\n2. 無會、袂、𠀾 /bhoi⁶/ 不會\n3. 未 /bhoi⁷/ 沒有（事情還沒做）\n4. 無 /bho⁵/ 沒有\n5. 有 /u⁶/\n6. 好 /ho²/\n7. 毋好、孬 /mo²/ 不好\n8. 欲 /bhêh⁴/ 要\n9. 毋、唔 /m⁶/ 不要\n10. 欲毋 /bhêh⁴ m⁶/、/bhên⁶/ 要不要\n11. 愛 /ain³/ 要\n12. 無愛 /bho⁵ ain³/ 不要\n13. 毋愛、勿、嫑 /main³/ 不要\n14. 用 /êng⁶/ 需要\n15. 免 /miang²/ 不需要\n16. 肯 /kêng²/、/kiang²/ 願意\n17. 毋肯 /m⁶ kêng²/、/m⁶ kiang²/ 不願意\n18. 架勢是 /gê³ si³ si⁷/ 看這情形是。例如：舖關了，架勢是去做節了。 \n\n**第二部分 頭、喙**\n\n1. dag⁴ 頭 // 點頭\n2. 搖頭 /io⁵ tao⁵/\n3. 攲頭 /ki¹ tao⁵/ 歪頭\n4. 呾 /dan³/ 說\n5. 參詳 // 商量\n6. 學古 /oh⁴ gao²/ 講故事\n7. 罵 /mê⁷/\n8. 詏 /a³/ 爭辯\n9. 冤家 /uang¹ gê¹/ 吵架\n10. 恬 /diam⁷/ 閉嘴、安靜\n11. 咬 /ga⁶/\n12. 哺 /bao⁷/ 咀嚼\n13. 唵 /am⁶/ 將食物放進嘴巴\n14. 喷 /pung³/ 散射\n15. 啡痰 /pui³ tam⁵/ 吐痰\n16. 歕 /bung⁵/ 吹氣\n17. 嗾？ /zag⁸/ 呛到、岔到 \n\n**第三部分 目、心**\n\n1. 睇 /toi²/ 看\n2. 看詳睇 /kang³ siang⁵ toi²/ 仔細看\n3. 經心 /gêng¹ sim¹/ 用心\n4. 經心衋事 // 操心\n5. 經破頭腦 // 想破頭 \n\n**第四部分 手、跤**\n\n1. 揨 /dian¹/ 觸、碰\n2. 拍 /pah⁴/ 打\n3. 舂 /cêng⁵/ 用力打\n4. /dng⁷/ 打\n5. 刜 /hug⁴/ 揮、打\n6. 剚、倳 /sai⁷/ 打\n7. 抶 /diag⁴/ 用鞭、杖或竹板打。～手\n8. 摔 /sug⁴/ 抽打、鞭打\n9. 拗折 /a² zi²/ 折斷\n10. 盖 /kain³/ 由上往下覆。～頭\n11. 掃 /sao³/ 迅速掠過。～面\n12. 揞 /an¹/ 掩。～面\n13. diu³ 竹囝\n14. 擎 /gia⁵/ 舉、握、拿\n15. 𢭪 /kioh⁴/ 撿、拾\n16. 挈 /kioh⁸/ 取、拿\n17. 摜 /guan⁶/ 提\n18. 厾 /doh⁴/ 戳\n19. 割 /guah⁴/\n20. 殺 /suah⁴/\n21. 斬 /zam²/\n22. 斫 /dog⁴/ 剁\n23. 宰 /zai²/ 殺\n24. 刣 /tai⁵/ 殺\n25. 拭 /cig⁴/ 擦\n26. 濡 /ru⁵/ 用濕布擦或用拖把拖\n27. 爬 /bê⁵/ 搔(癢)\n28. 掊 /boi²/ 扒開\n29. 揂 /ciu⁵/ 拉引繩子\n30. 𠡒 /dui²/ 用力拉\n31. 捏 /dên⁶/ 掐\n32. 漱牙 /ciu³ ghê⁵/ 刷牙\n33. 跋 /buah⁸/ 摔倒\n34. 踏 /dah⁴/ 踩\n35. 踢 /tag⁴/\n36. 去 /ku³/、/ka³/\n37. 轉 /dng²/ 回來\n38. 綴 /doi³/ 跟著；縫合。\n39. 修理 /siu¹ li²/、/su¹ li²/\n40. 泊車 /pag⁴ cia¹/ 停車。泊，粵語音譯英文 park 得來，停車的意思。\n\n**第五部分**\n\n1. 曳、𤆬 /cua⁷/ 帶、領\n2. 娶 /cua⁷/ 取婦\n3. 徙 /sua²/ 移動\n4. 歇 /hiah⁴/ 放置、休息\n5. 煩惱 /huang⁵ lo²/ 擔心\n6. 相信 /sion¹ siang³/、/siang¹ sing⁷/ 相信\n7. 相輔 /sion³ hu⁶/ 幫忙\n8. 排比 /bai⁵ bi²/ 安排\n9. 含包 /ham⁵ bao¹/ 包含\n10. 拚頭前 /bian³ tao⁵ zain⁵/ 爭先\n11. 輸服 /su¹ hog⁸/ 佩服\n12. ䷀䷀ /dag⁴ nng⁷/ 浪費\n13. ䷀落 /ga¹ lao⁵/ 掉落\n14. 沕 /bhih⁴/ 躲藏\n15. 支 /zin¹/ 預付\n16. 圖賴 /tu⁵ tai²/ 耍賴\n17. 放惰 /bang¹ dua⁶/ 懶得\n\n### 🧜‍♀️形容(hêng⁵ iong⁵)\n\n1. 媠 /sui²/ 好、漂亮\n2. 雅 /ngia²/ 正、漂亮\n3. 生好 /sên¹ ho²/ 漂亮、好看\n4. 䆀 /bhai²/ 差、醜陋\n5. 好 /ho²/\n6. 痞、歹 /pai²/\n7. 大細 /dua⁷ soi³/ 大小\n8. 㩼少 /zoi⁷ zio²/ 多少\n9. 加加減減 /gê¹ gê¹ giam² giam²/ 多多少少\n10. 稀罕 // 稀少，罕見。\n11. 賤 /la¹ zuan⁷/ 繁多，低賤。物以稀為貴，多則賤。\n12. 猛慢 /mê² mang⁷/ 快慢、早晚。猛，快。\n13. 肥 /bui⁵/ 胖\n14. 肥腯肥腯 /bui⁵ tuh⁸ bui⁵ tuh⁸/ 胖嘟嘟\n15. 㾪 /sang²/ 瘦\n16. 㾪猴 /sang² gao⁵/ 瘦得跟猴子一樣\n17. 㾪脯皺 /sang² bao² niao³/ 又瘦又缺水又褶皺，形容飢瘦。\n18. 懸下 /guai⁵/ 高低\n19. 早 /za²/\n20. 晏 /uang³/ 晚\n21. 粗 /cao¹/\n22. 幼 /iun³/ 細\n23. 粗殘 /cao¹ cang⁵/ 粗魯\n24. 仔細 /zu² soi⁷/ 小心\n25. 芳 /pang¹/ 香\n26. 臭 /cao³/\n27. 僫 /oh⁴/ 困難\n28. 易 /goi⁷/ 容易\n29. 闊 /kuah⁴/ 寬\n30. 狹 /oih⁸/ 窄\n31. 光 /gng¹/ 亮\n32. 暗 /am³/\n33. 恬 /diam⁷/ 安靜\n34. 吵 /cao¹/ 吵鬧\n35. 吵吵著 /cao¹ cao¹ dioh⁴/ 吵吵鬧鬧的\n36. 飽 /ba²/\n37. 枵 /iao¹/ 餓\n38. 橂 /dain⁷/ 堅實、堅硬\n39. 軟 /nam³/ 軟弱。本字不明，訓用「軟」。\n40. 韌 /rung⁷/ 堅強；不容易斷裂。\n41. 脆 /cê³/ 脆弱；容易斷裂。\n42. 聰明 /cong¹ mêng⁵/\n43. 愚蠢 /ngo⁵ cung²/\n44. 戇 /gong³/ 愚笨\n45. 賰 /cung⁵/ 剩餘\n46. 欠 /kiam³/ 缺少\n47. 清 // 清晰、乾淨\n48. 雾 /bhu⁷/ 模糊\n49. 清氣 /cêng¹ ki³/ 乾淨\n50. 清氣相 /cêng¹ ki³ sion³/ 乾淨的樣子\n51. 垃圾 /lah⁴ sab⁴/ 骯臟\n52. 垃圾相 /lah⁴ sab⁴ sion³/ 骯臟的樣子\n53. 無沙無圾 /bho⁵ sua¹ bho⁵ sab⁴/ 一塵不染\n54. 灱 /da¹/ 乾燥\n55. 㴷 /dam⁵/ 濕潤\n56. 落雨㴷渧 /lo² hao⁶ dam⁵ di³/ 下雨濕漉漉的樣子\n57. 著 /dioh⁸/ 對、正確\n58. 毋著 /m⁷ dioh⁸/ 不對\n59. 錯 /co³/\n60. 熟 /sêg⁸/\n61. 生 /cên¹/ (瓜果等)未成熟\n62. 臭生 /cao³ cên¹/ 未煮熟或瓜果未成熟\n63. 臭酸 /cao³ sng¹/ 食物變質\n64. 黐黐 /ti¹ ti¹/ 黏稠\n65. 切要 /ciag⁴ iao³/ 要緊\n66. 無要緊 /bho⁵ iao³ ging²/ 不要緊\n67. 大扮\n68. 咸澀\n69. 力相 // 努力\n70. 惰 /duan⁶/ 懶惰\n71. 鬧熱 /nao⁶ ria²/ 熱鬧\n72. 活神 // 精神好，灵活\n73. 健 /gian⁷/ 身體好\n74. 碩㦙 /sêg⁴ ngo³/ 聰明和愚蠢\n75. 夠力 /gao³ lag⁸/ 厲害\n76. 夠強 /gao³ kiang³/ 厲害\n77. 夠衰 /gao³ soi¹/ 好慘\n78. 緊要 /ging² iao³/ 要緊\n79. 切要 /ciag⁴ iao³/ 要緊\n80. 癩瘑糜烂 //\n81. 枝毛小節、枝毛細節 // 無關緊要\n82. 偪側 /bêg⁴ cêg⁴/ 心中有氣，煩躁不安。\n83. 生分 /cên¹ hung⁷/ 陌生、疏遠\n84. 無影無跡 // 沒有根據\n85. 一生跪跋 /zêg⁸ sên¹ gui⁶ buah⁸/ 一生坎坷\n\n### 🐴副詞(hu³ su⁵)\n\n1. 好 /hoh⁴/ 表示程度深。例如：好㩼人 // 好多人。\n2. 死 /si²/ 表示程度特別深。例如：死㩼人 // 超級多人。死雅 // 超漂亮的。\n3. 若 /rua⁷/ 多麼。例如：若雅 // 多麼漂亮。\n4. 者 /zia²/ 這麼。例如：者細 // 這麼小。\n5. 遐 /hia²/ 那麼。例如：遐好 // 那麼好。\n6. 上好 /siang⁶ ho²/ 最好。\n7. 上減 /siang⁶ giam²/ 最少。\n8. 上加 /siang⁶ gê¹/ 最多。\n9. 較 /ga³/ 比較地。例如：伊較厲害 // 他比較厲害。\n10. 曾 /bhah⁴/ 曾經。例如：我毋曾來過 // 我不曾來過。\n11. 攏總 /long² zong²/ 全部。例如：攏總 100 銀 // 總共 100 塊。\n12. 煞 /sua⁵/ 竟然。例如：汝煞毋知 // 你竟然不知道。\n13. 顛倒 /ding¹ do³/ 反而。例如：六月顛倒來落雪 // 六月反而下起雪。\n14. 做蜀 /zo³ zêg⁸/ 一起。例如：做蜀 ka³ // 一起去。\n\n### 😲象聲詞(siang⁶ sian¹ su⁵)\n\n1. 喏 /no⁷/ 使人注意某物\n2. 囉、咯 /lo⁷/ 表示事情完成\n3. /hoin⁷/ 呼人\n4. /oin⁷/ 應人\n5. 喂 /uê⁷/ 打招呼。\n6. 啊 /a⁷/ 加強語氣\n7. 呀 /ia⁷/ 表示贊同\n8. 喔、噢 /o⁷/ 表示醒悟、驚訝或了解\n9. 哇 /ua⁷/ 表示驚訝\n10. 嗯 /ng⁷/ 表示同意或了解\n11. 哼 /hng²/ 表示不滿\n12. 哎、噯 /ai⁷/ 嘆氣\n13. 嗐 /hai⁷/ 嘆氣，比「哎」重些。\n14. /ho⁷～/、/o⁷～/ 長吁，含有一種無力、操碎了心的感覺。\n\n### 🙃俗語(siog⁸ ngo²)\n\n1. 哇浪、我卵 /ua² lang⁶/ 哇噻\n2. 我無閒 /ua² bho⁵ ain⁵/ 我沒空\n3. 走街邊 /zao² goi¹ bin¹/ 擺地攤\n4. 汝愛去怎樣麼緊 /lu² ain³ ku³ zion² mo⁷ ging⁷/ 你趕著去幹嗎\n5. 勿者樣生 /mai³ zion¹ sên¹/ 不要這樣\n6. 知收煞 /zai¹ siu¹ suah⁴/ 適時停手\n7. 毋別世代 /m⁶ bhag⁴ si³ dê³/ 不懂事\n8. 無變 /bho⁵ biang³/ 沒有辦法\n9. 堵著無變 /du² dioh⁴ bho⁵ biang³/ 碰到沒有辦法\n10. 無理路 /bho⁵ li² lao⁷/ 無道理。路，道。\n11. 無奈何 /bho⁵ da¹ ua⁵/ 無可奈何\n12. 無奈寫作不得已 /bho⁵ nai⁶ sia² zo³ bug⁴ dêg⁴ in²/ \n13. 呾死無會變 /dan⁵ si² bhoi⁶ bin³/ 冥頑不靈\n14. 橂過石部 /dain⁷ goi³ zio² bao⁶/ 比石頭還硬\n15. 三斗油麻倒無一粒落耳 /san¹ dao² iu⁵ mua⁵ do³ bho⁵ zêg⁸ liab⁴ lo² hin⁶/ 怎麼說都聽不進去\n16. 瀉衰人 /sia³ soi¹ nang⁵/ 丟人、令人蒙羞\n17. 見笑 /giang³ siao³/ 丟人、令人蒙羞\n18. 雙目囥著褲底 /sang¹ mag⁸ kng³ dioh⁴ kao³ doi²/ 看不見\n19. 無目睇 /bho⁵ mag⁸ toin³/ 不想看\n20. 鴨囝聽雷 /ah⁴ gian² tian¹ lui⁵/ 聽不懂\n21. 戅過隻鴨 /gong⁵ goi³ ziah⁴ ah⁴/ 比鴨子還戇\n22. 一樣糜飯飼千外樣人 /zêg⁸ ion⁷ moi⁵ bng⁷ ci⁷ cain¹ ghua⁷ ion⁷ nang⁵/ 社會人各種各樣\n23. 暗過魂宫 /am³ goi³ hung⁵ gêng¹/ 比陰間還暗\n24. 三更想，半暝反 /san¹ gên¹ sion⁶, buan³ mê⁵ huang²/ 思來想去，反反覆覆。\n25. 過跤事知歇 /goi¹ ka¹ su⁷ zai¹ hiah⁴/ 過去的事情就不要計較了\n26. 無會少禮 /bhoi⁶ siao² li²/ 不害臊\n27. 刣雞教猴 /tai⁵ goi¹ ga³ gao⁵/ 殺雞儆猴\n28. 勞生拚死 /lu⁵ sên¹ bian³ si²/ 拚死拚活\n29. 食呾會，躕人強 /ziah⁸ dan³ oi⁶, du⁵ nang⁵ kiang³/ 能吃會說還很頑皮\n30. 勿踟躕我 /mai³ di¹ du⁵ ua⁷/ 別纏我，使得我不知所措。\n31. 老過伯爺 /lao⁶ goi³ bêh⁴ ia⁵/ 比土地公還年長\n32. 平樣平樣 /pên⁵ ion⁷ pên⁵ ion⁷/ 一模一樣\n33. 假力洗茶渣 /gê² lag⁸ soi² dê⁵ za¹/ 該做的不做，做了不該做的。\n34. 死無命凝 /si² bho⁵ mian⁷ ngang⁵/ 冷死了\n35. 富到流油 /bu⁷ gao³ lao⁵ iu⁵/ 很富有\n36. 人熟禮毋熟 /nang⁵ sêg⁸ li² m⁶ sêg⁸/ 雖然人很熟，但還是要講禮。\n37. 熟人免行生禮 /sêg⁸ nang⁵ miang² gian⁵ cên¹ loi²/\n38. 千人千般苦，無人苦平樣 /cain¹ nang⁵ cain¹ buan¹ kao², bho⁵ nang⁷ kao² pên⁵ ion⁷/ 各有各的煩惱\n39. 蟹有橂奅，人有碩㦙 /hoi⁶ u⁶ dain⁷ pan³, nang⁵ u⁶ sêg⁴ nga³/ 有人聰明有人愚笨。橂，堅實。奅，中空。碩，學問高、聰明。㦙，愚笨。\n40. 鳥飛會落毛，人行有跤跡 /ziao² boi¹ oi⁶ lo² mo⁵, nang⁵ gian⁵ u⁶ ka¹ ziah⁴/ 做過了的事總會留痕跡\n41. 客情好過吊頷鬼 /kêh⁴ cêng⁵ ho² goi³ diao³ am⁶ gui²/ 吊死鬼熱情地勸人上吊好代替自己，比喻虛情假意。\n42. 貓兒無葷無著茨，鴨囝無粟無會過暝 /ngiao¹ ri⁵ bho⁵ hung¹ bho⁵ dioh⁴ cu⁷, ah⁴ gian² bho⁵ cêg⁴ bhoi⁶ goi³ mê⁵/ 小貓沒有葷菜就不在家，小鴨沒有稻粒就不過夜。\n43. 衰雞無會食粟 /soi¹ goi¹ bhoi⁶ ziah⁸ cêg⁴/ 如病雞般吃不下飯\n44. 無會死大破相 /bhoi⁶ si² dua⁷ pua³ sion³/ 不死也會頭破血流\n45. 十八棚頭做到透 /zab⁸ boih⁴ bên⁵ tao⁵ zo³ gao³ tao³/ 指每種事都嘗試，貶義。十八棚頭，指十八齣溫州南戲。\n46. 無跤蟹 /bho⁵ ga¹ hoi⁶/ 孤立無援\n47. 大細目 /dua⁷ soi³ mag⁸/ 偏心\n48. 平安當大趁 /pêng⁵ ang¹ dng¹ dua⁷ tang⁷/ 平安無疾就當作是大賺一筆了\n49. 大人彎，孥囝直 /dua⁷ nang⁷ uain¹, nao⁵ gian² dig⁸/ 大人說話拐彎抹角，小孩子則是直來直去。\n50. 錢囝毋使使大錢 /zin⁵ gian² m⁶ sai² sai² dua⁷ zin⁵/ 小錢不花，久了就得要花大錢了。\n51. 未學行，先學飛 /bhoi⁷ oh⁸ gian², sain¹ oh⁸ boi¹/ 還沒學走路就要學飛了，基礎未打好。\n52. 一人主張，毋如二人參詳 /zêg⁸ nang⁷ zu² ziang¹, m⁶ ru⁵ no⁶ nang⁷ cam¹ ciang⁵/ 自作主張不如多個人一起商量\n53. 通街市獵無 /tong¹ goi¹ ci⁶ lah⁸ bho⁵/ 整條街都找不到。獵，尋找。\n54. 喙尖舌囝利 /cui³ ziamvi/ 牙尖嘴利\n55. 九月狗吶日，無用諸娘理毋直 /gao² goi² gao² nah⁴ rig⁸, bho⁵ êng⁷ zu¹ nion⁵ li² m⁶ dig⁸/ 九月份開始晝短夜長，沒用的婦女家務事搞不定了。\n56. 茶薄人情厚，茶厚有禮貌 /dê⁵ bo² nang⁵ cêng⁵ gao⁶, dê⁵ gao⁶ u⁶ li² mao⁶/\n57. 三十歲無妻是孩童 /san¹ zab⁸ hoi³ bho⁵ ci¹ si⁶ hai⁵ tong⁵/\n58. 目汁是財，愈哭愈來 /mag⁸ zab⁴ si⁶ cai⁵, ru² kao³ ru⁶ lai⁵/\n59. 呾破無酒食 /dan³ pua³ bho⁵ ziu² ziah⁸/ 師傅教徒弟，徒弟設酒宴款待，師傅酒後授予秘方。之後徒弟不再宴請師傅。\n60. 軟過豆腐 /nam³ goi³ dao⁷ hu⁷/\n61. 車大炮 /cia¹ dua⁷ pao³/ 吹牛\n62. 樹大分椏，囝大分家 /ciu⁷ dua⁷ bng¹ a¹, gian² dua⁷ bng¹ ga¹/ \n63. 閒過仙 /ain⁵ goi³ siang¹/ 比神仙還閒\n64. 雙目望無一寸長 /sang¹ mag⁸ mo⁷ bho⁵ zêg⁸ cung³ dng⁵/ 鼠目寸光\n65. 一鼠二牛三虎四兔五龍六蛇七馬八羊九猴十雞十一狗十二豬 /ig⁴ cu² ri⁶ ghu⁵ san¹ haon² si³ tao³ ngao⁶ lêng⁵ lag⁸ zua⁵ cig⁴ bhê² boih⁴ ion⁵ gao² gao⁵ zab⁸ goi¹ zab⁸ ig⁴ gao² zab⁸ ri⁶ du¹/\n66. 差豬差狗，不如家己走 /cê¹ du¹ cê¹ gao², bug⁴ ru⁵ ga¹ gi⁷ zao²/ 求人不如求己\n67. 後生擔石，老人食藥 /hao⁶ sên¹ dan¹ zioh⁸, lao⁶ nang⁵ ziah⁸ ioh⁸/ 年少積勞，年老吃藥\n68. 疑心生暗鬼 /ghi⁵ sim¹ sên¹ am³ gui²/ 因多疑而產生各種幻覺和錯誤判斷\n69. 羊尾短短，遮毋著羊尻川 /ion⁵ bhoi² dê² dê², zia¹ m⁶ dioh⁴ ion⁵ ka¹ cng¹/ 自己的缺點尷尬能自己找個遮醜的就很好了，別去取笑別人的不堪。\n70. 愛母著刻苦 /ain³ bhao² dioh⁴ kag⁴ kao²/ 要老婆就要努力了\n71. 無好家神通外鬼 /bho⁵ ho² gê¹ sing⁵ tong¹ ghua⁷ gui²/\n72. How do you do，好事來堵 /hao³ su⁷ lai³ du²/ 嗨，要搞事情我不怕你。好事，喜歡搞事情。堵，應對、抵抗。\n73. 秋瓜棚下無好人 /ciu¹ goi¹ bên⁵ ê⁶ bho⁵ ho² nang⁵/ 秋瓜，絲瓜。\n74. 三跤椅囝毋知䆀 /san¹ ka¹ in² gian² m⁶ zai¹ bhai²/ 坐著少了一腿的椅子竟然不知道壞了，比喻身處困境而不自知。\n\n### 🤣歇後語(hiah⁴ ao⁶ ngo²)\n\n1. 柴目狗耳 — 假靈 /ca⁵ mag⁸ gao² hin⁶ — gê² lêng⁵/ 目雕的眼睛看不見，狗一般耳朵卻很靈，聽風是雨。\n2. 雞跤長鴨跤短 — 有懸下 /goi¹ ka¹ dng⁵ ah⁴ ka¹ dê² — u⁶ guain⁵ gê⁶/ 雞腳長，鴨腳短，有高有矮。\n3. 爐底碳 — 塊塊通 /lao⁵ doi² tuan³ — dê⁷ dê⁷ tang³/ 百事通\n4. 孥囝食奶 — 坐亭 /nao⁶ gian² ziah⁸ nê¹ — zê⁶ dêng⁵/ 亭，直。\n5. 菜頭面刺無血 — 面皮厚 /cai³ tao⁵ ming¹ ci³ bho⁵ hoih⁴ — ming¹ poi⁵ gao⁶/\n6. 褪褲放屁 — 假工夫 /tng³ kao³ bang³ pui³ — gê² gang¹ hu¹/\n7. 竹葉包沙 — 假壯 /dêg⁴ hio² bao¹ sua¹ — gê² zang³/ 壯，與「粽」諧音。\n8. 元宵燈籠 — 一肚火 /nguang⁵ siao¹ dêng¹ lang⁵ — zêg⁸ dao² hoi²/\n9. 半天吊燈籠 —四搭无向 /buan³ tin¹ diao³ dêng¹ lang⁵ — si³ dah⁴ bho⁵ hiang³/\n10. 青暝睒鏡 — 無望 /cên¹ mên⁵ iam² gian³ — bho⁵ mo⁷/\n11. 青暝睇天 — 張樣張相 /cên¹ mên⁵ toi² tin¹ — dion¹ ion⁷ dion¹ sion⁷/\n12. 青暝點燈 — 照舊 /cên¹ mên⁵ diam² dêng¹ — zio³ gu⁷/ 對青暝人來說，點不點燈，一切照舊。\n13. 青暝掠魚 — 散摸 /cên¹ mên⁵ liah⁸ hu⁵ — suan³ mong⁵/\n14. 青暝娶母 — 稱重 /cên¹ mên⁵ cua⁷ bhao² — cing³ dang⁶/\n15. 青暝擎手電 — 各人各人善 /cên¹ mên⁵ gia⁵ ciu² diang⁶ — gag⁴ nang⁵ gag⁴ nang⁵ siang⁶/\n16. 青暝睇電影 — 聽聲 /cên¹ mên⁵ toi² diang⁶ ian² — tian¹ sian¹/\n17. 啞人食苦瓜 — 有苦難言 /ê² nang⁵ ziah⁸ kao² goi¹ — u⁶ kao² nang⁵ ngiang⁵/\n18. 啞囝食黃連 — 有苦難言 /ê² gian² ziah⁸ ng⁵ nain⁵ — u⁶ kao² nang⁵ ngiang⁵/\n19. 閻羅王嫁諸母囝 — 鬼正敢愛 /ngiam⁵ lo⁵ uang⁵ gê³ za¹ bhao² gian² — gui² zian³ gan² ain³/\n20. 閻羅王請人 — 鬼正敢食  /ngiam⁵ lo⁵ uang⁵ cian² nang⁵ — gui² zian³ gan² ziah⁸/\n21. 閻羅王賣假貨 — 騙鬼 /ngiam⁵ lo⁵ uang⁵ bhoi⁷ gê² hoi⁷ — piang³ gui²/\n22. 閻羅王出告示 — 無句人話 /ngiam⁵ lo⁵ uang⁵ cug⁴ go³ si⁷ — bho⁵ gu³ nang⁵ oi⁷/\n23. 鬼簿無名 — 免死 /gui² pao⁶ bho⁵ mian⁵ — miang² si²/\n24. 醫生開了棺材舖 — 死活都愛錢 /ui¹ sên¹ kui¹ liao² gua¹ ca⁵ pao⁷ — si² ua² do¹ ain³ zin⁵/\n25. 身長棺材短 — 屈死人 /sing¹ dng⁵ gua¹ ca⁵ dê² — kug⁴ si² nang⁵/\n26. 棺材頭畫老虎 — 驚死人 /gua¹ ca⁵ tao⁵ oi⁷ lao⁶ haon² — gian¹ si² nang⁵/\n27. 歪喙和尚 — 唸無一句正經 /uain¹ cui³ hoi⁵ sion⁷ — niam⁷ bho⁵ zêg⁸ gu³ zian³ gêng⁵/\n28. 師公和尚 — 毋同道 /sai¹ gong¹ hoi⁵ sion⁷ — m⁶ dang⁵ dao⁶/\n29. 和尚抹粉 — 白勞 /hoi⁵ sion⁷ bhuah⁴ hung² — bêh⁸ lu⁵/ 勞，與「驢」諧音。\n30. 和尚擎雨遮 — 無法無天 /hoi⁵ sion⁷ gia⁵ hao⁶ zia¹ — bho⁵ huab⁴ bho⁵ tin¹/ 法，與「髮」諧音。\n31. 橄欖尻川 — 坐毋恬 /gan¹ na² ka¹ cng¹ — zê⁶ m⁶ diam⁷/ 屁股像橄榄一般尖，坐不住。恬，静、定。\n32. 火燒豬頭 — 熟面熟面 /hoi² sio¹ du¹ tao⁵ — sêg⁸ ming⁷ sêg⁸ ming⁷/\n33. 六月芥菜 — 假有心 /lag⁸ ghoih⁸ gua³ cai³ — gê² u⁶ sim¹/\n34. 十月芥菜 — 大䀌心 /zab⁸ ghoih⁸ gua³ cai³ — dua⁷ gêg⁴ sim¹/ 䀌，與「激」諧音。\n35. 六月蕃薯 — 雙死 /lag⁸ ghoih⁸ huang¹ zu⁵ — sang¹ si²/ 雙，與「鬆」諧音。\n36. 阿媽生諸母囝 — 生菇 /a¹ ma² sên¹ za¹ bhao² gian² — sên¹ gao¹/ 生菇，發霉。菇，與「姑」諧音。\n37. 老人跤纏 — 又長又臭 /lao⁶ nang⁵ ka¹ din⁵ — ui⁶ dng⁵ ui⁶ cao³/ 講話囉嗦像老人纏足一樣\n38. 老人食豬跤 — 試味 /lao⁶ nang⁵ ziah⁸ du¹ ka¹ — ci³ bhi⁷/ 嘗試下而已\n39. 老婆跋落水 — 淒涼 /lao⁶ pua⁵ buah⁸ lo² zui² — ci¹ liang⁵/ 跋，絆倒。淒，與「妻」諧音。\n40. 老婆其阿兄 — 痴哥 /lao⁶ pua⁵ gai⁵ a¹ hian¹ — ci¹ go¹/ 痴，與「妻」諧音。\n41. 菜頭粿熱單爿 — 自作多情 /cai³ tao⁵ goi² riah⁸ duan¹ bain⁵ — zu⁶ zag⁴ do¹ cêng⁵/ 菜頭粿，蘿蔔糕。热单爿，切片下鍋油煎，但只煎單邊，上焦下嫩。一頭熱（悅），單戀。\n42. 龍眼核拭尻川 — 賽道行 /nging¹ ain² hug⁸ cih⁴ ka¹ cng¹ — sai³ dao⁶ hang⁵/ 「龍眼核拭尻川」比喻有難度的事情，看各家誰本領強了。\n43. 水仙不開花 — 裝蒜 /zui² siang¹ bug⁴ kui¹ hoi¹ — zng¹ sng³/\n44. 大炮拍麻雀 — 騙伊驚 /dua⁷ pao³ pah⁴ mua⁵ ziah⁴ — piang³ i¹ gian¹/\n45. 有錢買蠓香，無錢買蠓罩 — 會算無會除 /u⁶ zin⁵ bhoi² mang² hion¹, bho⁵ zin⁵ bhoi² mang² dan³ — oi⁶ sng³ bhoi⁶ du⁵/\n46. 天頂滴鳥屎 — 無好相覓 /tin¹ dêng² dig⁴ ziao² sai² — mo² sion¹ coi⁷/\n47. 六月薄殼 — 假大頭 /lag⁸ ghoih⁸ boh⁸ kag⁴ — gê² dua⁷ tao⁵/ 大頭，一種比薄殼略大的小貝類海鮮。假大頭，愛充大頭。\n48. 七角錢二人分 — 毋三毋四 /cig⁴ gag⁴ zin⁵ no⁶ nang⁵ bng¹ — m⁶ san¹ m⁶ si³/\n49. 十二碗圓食賰一粒 — 假客氣 /zab⁸ ri⁶ liab⁸ in⁵ ziah⁸ cung⁵ zêg⁸ liab⁸ — gê² kêh⁴ ki⁷/ 圓，丸子。賰，剩下。\n50. 狗母蛇 — 假靈 /gao² bho² zua⁵ — gê² lêng⁵/ 靈，與「龍」諧音。\n51. 兄獨目弟缺喙 — 大無好樣，細無好相 /hian¹ dog⁸ mag⁸ di⁶ koih⁴ cui³ — dua⁷ bho⁵ ho² ion⁷, soi³ bho⁵ ho² sion³/\n52. 山螟咬尾 — 食家己 /suan¹ mê¹ ga⁶ bhoi² — ziah⁸ ga¹ gi⁷/\n53. 風吹牆頭草 — 就勢倚勢 /hong¹ coi¹ ciong⁵ tao⁵ cao² — ziu⁶ si³ ua² si³/\n54. 老鼠跋落粟倉 — 倒好 /ngiao² cu² buah⁸ lo² cêg⁴ cng¹ — do³ ho²/\n55. 老鼠心肝 — 頭食頭搬 /ngiao² cu² sim¹ guan¹ — tao⁵ ziah⁸ tao⁵ buan⁵/\n56. 孥囝拍炮 — 又驚又好 /nao⁵ gian² pah⁴ pao⁷ — ui⁶ gian¹ ui⁶ hao⁷/\n57. 五行缺一 — 欠金 /ngao⁶ hêng⁵ koih⁴ ig⁴ — kiang³ gim¹/\n58. 茂生進酒 — 厚情 /mao⁶ sêng¹ zing³ ziu² — gao⁶ cêng⁵/\n59. 食人雞肉還人豬肉 — 物來物去 /ziah⁸ nang⁷ goi¹ nê² hain⁵ nang⁷ du¹ nê² — moih⁸ lai⁵ moih⁸ ko³/\n60. 刀截蕹菜 — 二頭空 /do¹ zoi² êng³ cai³ — no⁶ tao⁵ kong¹/\n61. 三個半錢 — 趕勢 /san¹ gai⁵ buan³ zin⁵ — guan² si³/ 勢，與「四」諧音。\n62. 隔暝皇帝 — 無權勢 /gêh⁴ mê⁵ huang⁵ di⁷ — bho⁵ kuang⁵ si³/\n63. 大肚水蛙 — 假鮭 /dua⁷ dao² zui² goi¹ — gê² guai¹/ 水蛙，青蛙。鮭，河魨。\n64. 五月龍船 — 相鬥 /ngao⁶ ghoih⁸ lêng⁵ zung⁵ — sion¹ dao³/\n65. 燈籠照路 — 目前光 /dêng¹ lang⁵ zio³ lao⁷ — mag⁸ zain⁵ gng¹/ 比喻目光短淺\n66. 暗室穿針 — 難過 /am³ sig⁴ cng¹ zam¹ — nang⁵ goi³/\n67. 嫁諸母囝娶新婦 — 出入平安 /gê³ za¹ bhao² gian² cua⁷ sing¹ bu⁶ — cug⁴ rib⁸ pêng⁵ ang¹/ 安，與「翁」諧音。\n68. 過關送文憑 — 做人情 /goi³ guan¹ sang³ bhung⁵ pêng⁵ — zo³ nang⁵ zian⁵/\n69. 火燒草料場 — 事出有因 /hoi² sio¹ cao² liao⁷ dion⁵ — su⁷ cu⁷ u⁶ ing¹/ 因，與「煙」諧音。\n70. 黑白電視 — 無彩 /hêg⁴ bêh⁸ dian⁶ si⁶ — bho⁵ cain²/ 無彩，可惜。\n71. 小郎遇著雨 — 積惡 /sio² nng⁵ ngo⁶ dioh⁴ hao⁶ — zêg⁴ ag⁴/ 小郎，女子稱呼丈夫的弟弟。積惡，可憐；罪惡。積，與「叔」諧音。惡，與「沃」諧音。\n\n### 🙂禮貌用語(li² mao⁶ êng³ ngo²)\n\n1. 汝食饱未 /lu² ziah⁸ ba² bhoi⁷/ 你吃飽了嗎\n2. 汝愛去底地 /lu² ain³ ku³ di⁷ dê⁷/ 你要去哪裏\n3. 汝好 /lu² ho²/ 你好\n4. 㩼謝 /zoi⁷ sia⁷/ 多謝\n5. 寬行 /kuan¹ gian⁵/ 慢走\n6. 寬駛 /kuan¹ sai²/ 慢點開車\n7. 对毋住 /dui³ m⁶ zu⁶/ 对不起\n8. 对毋起 /dui³ m⁶ ki²/ 对不起\n9. 無相干 /bho⁵ siang¹ gang¹/ 沒關係\n10. 毋知頭 /m⁶ zai¹ tao⁵/ 不是故意的\n11. 先這呾 /sain¹ zion² dan³/ 回頭再聊 \n12. 萬事應想 /mang⁷ su⁷ êng³ sion⁶/ 萬事如意\n13. 生理大趁 /sêng¹ li² dua⁷ tang⁷/ 生意興隆\n14. 新年大趁 /sing¹ ni⁵ dua⁷ tang⁷/ 新年大賺\n15. 新年合想 /sing¹ ni⁵ gah⁴ sion⁶/ 新年如意\n16. 大吉大利 /dai⁶ gig⁴ dai⁶ li⁶/\n\n### 🤐粗話(cao¹ oi⁷)\n\n1. 咒誓 /ziu³ zua⁷/ 發誓、詛咒\n2. 痟 /siao²/ 神經錯亂\n3. 神經 /sing⁵ gêng¹/\n4. 腦孬 /nao² mo³/ 腦子壞了\n5. 破脑囝 /puah⁸ nao² gian²/ 弱智\n6. 肚痛 /dao² tian³/ 「問候」別人是否肚子痛所以一直在叫。\n7. 鬼叫 /gui² gio⁷/ 「問候」別人是否聽到鬼在叫。\n8. 哭 cang¹ 哭 nain⁵ // 又哭又喊，吵死人了。\n9. 哭父死母 /kao³ bê⁶ si² bho²/ 「問候」別人是否父母過世所以一直在哭叫。\n10. 咋死人 /zag⁴ si² nang⁵/ 吵死了\n11. 鬼囝 /gui² gian²/ 小鬼\n12. 鬼卒囝 /gui² zug⁴ gian²/ 小鬼\n13. 鬼然然 /gui² riang⁵ riang⁵/ 像鬼一樣\n14. 鬼囉作禍 /gui² lo⁷ zo³ ho³/ 鬼在作祟、作怪\n15. 妖怪精 /iao¹ guai³ zian¹/\n16. 去死掉掉 /ku³ si² diao³ diao³/\n17. 散哭父 /suan⁷ kao³ bê⁶/ 散，到處。\n18. 吐屎 /tao³ sai²/ 亂說\n19. 卵屎人 /lang⁶ sai² nang⁵/ 屌絲，沒前途的人。\n20. 卵屎話 /lang⁶ sai² oi⁷/ 廢話\n21. 臭喙卵面 /cao³ cui³ lang⁶ ming⁷/ 亂說、討人厭。\n22. 關汝卵事 /guang¹ lu² lang⁶ dai⁷/ 與你何干\n23. 膣精 /zi¹ zian¹/ 多管閒事\n24. 臭膣 /cao³ zi¹/ 臭婊子\n25. 豺狗 /sai² gao²/ 狗腿子\n26. 怪卵 /guai³ lang⁶/ 古怪\n27. 無卵 /bho⁵ lang⁶/ 沒膽量\n28. 無腦 /bho⁵ nao²/ 沒腦子\n29. 𠀾好 /bhoi⁶ ho²/ 咒別人倒霉\n30. 痞囝 /pai² gian²/ 痞子、流氓。\n31. 肏母囝 /pu² bho² gian²/\n32. 早死囝 /za² si² gian²/\n33. 短命囝 /dê² mian⁷ gian²/、/dêng² mian⁷ gian²/\n34. 破家囝 /pua⁷ gê¹ gian²/ 败家子\n35. 內仙囝  /lai⁶ siang¹ gian²/ 難伺候\n36. 十惡囝 /zab⁸ ag⁴ gian²/ 十惡不赦\n37. 棺材囝 /gua¹ ca⁵ gian²/\n38. 痴哥囝 /ci¹ go¹ gian²/ 色狼\n39. 吐血死囝 /tao³ hoih⁴ si² gian²/\n40. 替人死囝 /toi⁵ nang⁵ si² gian²/\n41. 半路死囝 /buan³ lao⁷ si² gian²/\n42. 祭屎祭䷀ /zi³ sai² zi³ hê⁷/ 亂吃東西\n43. 乞鬼侵著 /koh⁴ gui² cin⁵ dioh⁴/ 鬼上身了。乞，給。侵，本讀 /cim⁵/，音變爲 /cin⁵/，附身。\n\n### 🧨娛樂(ngo⁵ log⁸)\n\n1. 耍遊戲 /sng² iu⁵ hi³/ 玩遊戲\n2. ䷀箭 /diong³ zin³/ 射箭\n3. ䷀珠 /diong³ zu¹/ 打彈珠\n4. 彈槍 /duan⁷ ciong¹/ 開槍\n5. 跳索 /tiao³ soh⁴/ 跳繩\n6. 踏孔 /dah⁸ kong²/ 捉迷藏\n7. 泅水 /siu⁵ zui²/ 游泳\n8. 釣魚 /dio³ hu⁵/\n9. 掠魚 /liah⁸ hu⁵/ 抓魚\n10. 行棋 /gian⁵ gi⁵/ 下棋\n11. 放風箏 /bang³ hong¹ zêng¹/\n12. 拍連炮 /pah⁴ liang⁵ pao³/ 放鞭炮\n13. 扣人囝 /kob⁴ nang⁵ gian²/ 人囝，也叫公仔紙、洋畫，舊時供兒童玩樂用的紙牌。\n14. 沃花 /ag⁴ hoi¹/ 澆花\n15. 做戲 /zo³ hi³/ 演戲劇\n\n### ⛩ 神明(sing⁵ mêng⁵)\n\n1. 天地父母 // 天地，原始信仰。\n2. 月娘 // 月球，原始信仰。\n3. 媽祖 // 原名林默，南海保護神，在甲子天后宮有供。\n4. 七聖娘 // 又稱七星娘娘、七聖夫人，是織女神分化出的七位仙女，是兒童保護神。\n5. 觀音娘 // 觀音菩薩\n6. 慈悲娘 // 即普悲觀音，觀音菩薩化身之一（傳說觀音菩薩有三十三化身），普遍施給眾生慈悲。\n7. 註生娘 // 全稱「大慈大悲救苦救難送子娘娘」，主管懷孕與生育。\n8. 佛祖 // 釋迦牟尼佛，姓喬達摩，名悉達多，古印度思想家、教育家、宗教改革家，佛教的創始人。\n9. 達摩祖師 // 南天竺人或波斯人，將佛教禪宗帶入中國，爲中國禪宗之開創者。\n10. 元天上帝 // 玄武大帝，象徵北極星與二十八宿中的北宮玄武，爲統理北方之道教大神。\n11. 水仙大帝 // 水仙尊王，海神之一，媽祖的從神之一。\n12. 汾陽王帝 // 郭子儀，華州鄭縣（今陝西渭南市華州區）人，唐朝名將，平定安史之亂，封汾陽郡王。此人富貴壽考，權極一時，甲子天后宮媽祖廟有供之。\n13. 王公 // 指隴尾王爺、王爺公，名鄒普勝，麻城花橋（今屬湖北）人，元末農民起義軍將領，陳友諒軍師。朱元璋建立明朝後流浪到甲子地區，爲甲子地區改造「風水」等，今甲子隴尾王爺廟有供之，大年初四在此求「落馬簽」。\n14. 關公 // 關羽，河東郡解縣（今山西省運城市鹽湖區解州鎮）人，三國時期名將，與劉備、張飛桃園三結義。又稱伽藍老爺、伽藍尊者，是寺廟、道場守護神，也有稱之爲武財神。\n15. 八仙公 // 傳說中的八位仙人，爲漢鍾離、張果老、韓湘子、鐵拐李、曹國舅、呂洞賓、藍采和、何仙姑八人。\n16. 伯公 // 福德老爺、土地公。\n17. 五穀公 // 神農大帝，相傳其發明耒耜，教民耕種五穀，並能以百草為民治病。農曆十月十五拜之。\n18. 城隍公 // 古代城鎮保護神。\n19. 皇帝公 // 南宋小皇帝趙昰，曾流亡到甲子待渡山。\n20. 灶公 // 灶君，主掌廚房和飲食的神。\n21. 百姓公 // 無主死者，集中掩埋於百姓公墓，稱爲百姓公(媽)，其中多喪於 1943 年的大飢荒，其時僅甲子一鎮亡者就近 2 萬人，慘絕。\n22. 地主爺 // 住宅的守護靈。\n23. 財神爺 // 常指陝西終南山的玄壇真君趙公明，也指關聖帝君關羽。\n24. 三山國王 // 指現揭西縣河婆鎮北面的三座山——巾山、明山、獨山的三位山神。\n\n## 風俗(hong¹ sioh⁸)\n\n1. 大年初一：食齋菜（菠薐菜、粉絲、菜頭丸、豆腐乾）。\n2. 人日(正月初七)：食七樣菜（厚合、蒜仔、芥藍、高麗菜、真珠菜、香菜、大菜芯）。\n3. 元宵(正月十五)：食蔗。\n4. 三月初三：食青草飯（雞屎藤、伸筋藤、苦刺心、臭草心、蠟裏葉、四方枝苦楝葉）。\n5. 清明：食硬殼餅，掃墓掛紙。\n6. 佛誕(四月初八)：食飯茶。\n7. 端午：食梔粽、梔粿，洗午時水。\n8. 七月初七：出花園。\n9. 中秋：食月餅、芋頭、蔗。\n10. 重陽(九月初九)：食雞湯。\n11. 冬節：食冬節丸、羊肉。\n12. 三十夜、廿九夜：食團圓飯、送壓腰錢（dêh⁴ io¹ zin⁵, 壓歲錢）。\n\n## 歷史(lêg⁸ su²)\n\n1. 甲子的名號是因爲港後有六十塊大石頭，應了干支紀年法一甲子的數目，故名。\n2. 漢文帝時曾派遣大臣陸賈（約公元前240年～公元前170年）到南越國，期間命令將士調查海岸線，到過甲子門。\n3. 三國時，吳侯孫權派遣將軍衛溫（？～231年）攻打福建、琉球和台灣（夷州），被風雨刮到甲子門。\n4. 南宋乾道五年(1169)，承奉郎致仕范有仁建順濟橋，橋從大膽山腳(今東宮社轄區)跨越瀛江到後庭（今甲東鎮雨亭村轄區）。\n\n    ![順濟橋（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）](gahzi-oi-hung-lui-ci-biao/Untitled%2084.png)\n\n5. 宋嘉定甲申年(1224)，南宋承奉郎范良臣（范有仁之孫）登腹石山，因山對面可見甲子門奇石十八，屹立如人，遂刻「登瀛」二字於石，取十八學士登瀛洲之義。\n6. 1276 年，元兵攻陷南宋京城臨安，南宋擁立幼帝趙昰，從福州乘船經福建沿海入廣東，於冬十二月抵甲子門腹石山（後人爲紀念此事，更山名爲待渡山），范良臣給軍食三日，留帝像登瀛石上。\n7. 1277 年正月，漁民鄭復組織義兵509人乘船護送宋帝昺及隨臣去崖門。途中在現珠海橫琴島和澳門與元兵相遇，十六日宋室全軍覆滅，陸秀夫背幼帝昺投海自盡，鄭復等在激戰中全部士兵犧牲。\n8. 明永樂六年(1408)，順濟橋被拆。因「指揮花茂奉旨建甲子所，慮倭寇泊海易渡，拆之以為城基。」\n9. 明嘉靖三十九年(1560)，八萬洞資首黃啓薦扎寨惠來冰山頭（今邦山村）攻陷甲子所城，城中居民移至龍溪都（今惠來隆江以南）為逃避倭禍而暫居，該城之難民，慘遭殺害者甚眾，婦女被擄掠，有的全家罹難。\n10. 明隆慶二年(1568)，倭寇入侵甲子，千戶馬壽麻痹輕敵，城被攻陷，甲子和龍溪都一帶受害慘重。馬壽因失職罪下獄，死於獄中。\n11. 明隆慶四年(1570)，大旱，入春至初夏，天無滴雨，時又常遭賊寇蹂躪，田園拋荒，赤地千里，人民苦不堪言。\n12. 明隆慶四年(1570)九月，曾作倭寇嚮導之海寇楊老復，率賊眾攻陷甲子所城，擄掠男女上船，千戶董（佚名）戰死。次日，船遇颱風，賊與被擄者均溺死。\n13. 隆慶五年(1571)七月，海盜林道乾（又名林鳳，惠來人），於龍溪都一帶擄民劫捨，後聞朝廷將派兵進剿，遂遠循至甲子一帶搶劫，攻破新寨，劫擄李棠，其妻卓氏攜二子上船換夫歸，遂投海殉節。後朝廷封為「南海夫人」。\n14. 明萬曆二十六年(1598)，湯顯祖作《牡丹亭》，其第六齣中有詞句「榕樹梢頭訪古台，下看甲子海門開。越王歌舞今何在？時有鷓鴣飛去來。」\n15. 明萬曆二十八年(1600)八月二十三日，惠來及甲子一帶地震。\n16. 明萬曆三十三年(1605)三月，惠來及甲子一帶地震，七月初三至初七颱風暴雨，沿海田舍淹沒。\n17. 明萬曆三十五年(1607)，參將張萬紀、守備胡文烜在待渡山下建宋帝亭，即進食亭。\n18. 明萬曆四十二年(1620)春正月，海盜袁八老余黨林新老入甲子沃，把總金允武出戰死之。\n19. 明天啓七年(1627)三月，海寇入甲子門，守備葉台死亡。\n20. 明崇禎八年(1635)，海寇劉香攻陷甲子，擄去守道洪雲蒸。閩粵大兵突至，洪遇害，後劉香被擄伏誅。\n21. 明崇禎十四年(1641)十二月十四日夜，惠來地震，波及甲子。\n22. 民國32年(1943，癸未年)，甲子乃至整個海陸豐地區、潮汕地區遭遇大飢荒，時兵災、旱災、蝗災和瘟疫，餓殍遍野，僅甲子一鎮亡者就近 2 萬，佔當時鎮人口逾 45%。\n23. 1966年，中國大陸爆發文化大革命，「破四舊」。次年，有360年歷史的進食亭被炸毀！\n24. 2004年夏～2005年秋，甲子諸賢達捐資重建了進食亭。\n25. 2013年12月29日凌晨，廣東警方出動3000多人的警力對有「毒品村」之稱的甲西鎮博社村開展清繳行動，當天繳獲近3噸冰毒，抓捕180多名涉毒犯罪嫌疑人，原村委書記蔡東家名列其中。\n\n## 建置(giang³ di³)\n\n1. 秦以前：屬南越國\n2. 秦：屬南海郡之博羅縣\n3. 漢：屬博羅縣\n4. 三國：屬博羅縣\n5. 晉：咸和六年（326）析博羅，置海豐縣，屬东官郡\n6. 宋：屬海豐縣\n7. 齊：屬海豐縣\n8. 梁：屬海豐縣\n9. 陳：屬海豐縣\n10. 隋：海豐縣屬循州\n11. 唐：海豐縣屬循州。武德五年（622）析置安陸縣；貞觀元年（627）復歸海豐縣。\n12. 五代：大寶元年（958）海豐縣属祯州。\n13. 宋：海豐縣屬祯州。天禧五年（1021）屬惠州。\n14. 元：海豐縣屬惠州路。\n15. 明：海豐縣屬惠州府。洪武二十七年(1394)，置甲子守禦千戸所，隸屬碣石衛。嘉靖三年（1524）海豐划出龍溪都、潮州府析出潮陽縣合置惠來縣。\n\n    ![甲子所城範圍（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）](gahzi-oi-hung-lui-ci-biao/Untitled%2085.png)\n    \n16. 清：海豐縣屬惠州府。雍正九年（1731）海豐划出石帆（甲子屬石帆都）、吉康、坊廓3都置陸豐縣，並裁甲子所設立甲子巡檢司。\n17. 中華民國：陸豐縣屬潮循道。\n18. 中華人民共和國：1957年甲子鎮劃出甲東鎮、甲西鎮（取甲子之東、甲子之西義）；1958年鎮改爲人民公社，陸豐縣屬汕頭地區；1983年陸豐屬惠陽地區；1980年成立甲子鎮人民政府；1988年陸豐縣改屬汕尾市；1995年陸豐撤縣建市。\n\n## 拼音方案(pêng³ im¹ huang¹ uan³)\n\n### 聲母表(sian¹ bho² biao²)\n\n格式：`聲母 [國際音標] 例字`\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png)\n\n### 韻母表(ung¹ bho² biao²)\n\n格式：`韻母 [國際音標] 例字 / 入聲韻 [國際音標] 例字`\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png)\n\n### 聲調(sian¹ diao⁶)\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png)\n\n### 變調(biang³ diao⁶)\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png)\n\n## 地圖(di⁷ dao⁵)\n\n![三甲地區（來源：騰訊地圖）](gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg)\n\n","source":"_posts/language/min/gahzi-oi-hung-lui-ci-biao.md","raw":"---\ntitle: 甲子話分類辭表（2020.12）\np: language/min/gahzi-oi-hung-lui-ci-biao\ntags:\n- 甲子話\n- 閩南語\n---\n\n## 序言(su⁶ ngiang⁵)\n\n甲子鎮處在陸豐市，與惠來縣交界，語言文化上偏惠來（其實五百年前與惠來交界處同屬海豐縣）。甲子話是三甲地區（甲子、甲西、甲東三鎮）通行的語言，是甲子地方文化的重要載體之一。在學術上，甲子話被歸入粵東閩南語潮汕話片。 \n\n甲子話保留了好㩼中古乃至上古的漢語詞彙，比如：汝、諸母、新婦、箸、鼎、匏桸、雅、翹楚等等，還有極具地方特色的表達，比如：𨑨迌、走漆、理唔直、孤獨死相等等。然而無會寫甚至無會呾甲子話的人實在㩼，其中不少是受過義務教育其。 有鑑於此，本人草創此表，力求詞雅正且其音形義有所考據，權當拋磚引玉，歡迎大家儂做蜀討論改進。 \n\n另附本表主要參考資料：\n\n1. 《潮汕方言詞考釋》（林倫倫）\n2. 《海豐話分類辭表》（羅志海、鍾顯坤）\n3. [《潮典》](https://www.mogher.com/baike) \n4. 《新潮汕字典》（張曉山）\n5. [《台灣閩南語常用詞辭典》](https://twblg.dict.edu.tw/holodict%5C_new/index.html) \n6. [《小學堂閩語》](https://xiaoxue.iis.sinica.edu.tw/minyu)\n\n阿華\n2020年10月成稿，12月修訂\n\n<!--more-->\n\n## 總表(zong² biao²)\n\n### 🤵稱謂(cêng¹ ui⁶)\n\n1. 我 /ua²/\n2. 汝 /lu²/ 你\n3. 伊 /i¹/ 他/她/它\n4. 恁 /ning²/ 你們\n5. 伊人 /i¹ nang⁷/ 他們\n6. 家己 /ga¹ gi⁷/ 自己\n7. 人家 /nang⁵ gê¹/ 別人\n8. 諸夫 /za¹ bao¹/ 男人、男子\n9. 諸母 /za¹ bhao²/ 女人\n10. 諸娘 /zu¹ nion⁵/ 女子\n11. 大人 /dua⁷ nang⁷/\n12. 老人 /lao⁶ nang⁵/\n13. 後生囝 /hao⁶ sên¹ gian²/ 年輕人\n14. 孥囝 /nao⁵ gian²/、/nong⁶ gian²/ 小孩子\n15. 諸夫囝 /za¹ bao¹ gian²/ 男孩子、兒子\n16. 諸母囝 /za¹ bhao² gian²/ 女孩子、女兒\n17. 諸娘囝 /zu¹ nion⁵ gian²/ 年輕女子\n18. 阿公 /a¹ gong¹/ 爺爺\n19. 阿媽 /a¹ ma²/ 奶奶\n20. 媽人 /ma² nang⁵/ 婦女\n21. 媽祖 /ma² zao²/ 原名林默，南海保護神\n22. 爸爸 /ba¹ ba¹/ 爸爸\n23. 媽媽 /ma¹ ma¹/\n24. 父母 /bê⁶ bho²/\n25. 兄 /hian¹/ 哥哥\n26. 弟 /di⁶/ 弟弟\n27. 姐 /zê²/ 姐姐\n28. 妹 /moi⁷/ 妹妹\n29. 姊妹 /zi² moi⁷/ 姐妹\n30. 叔伯兄弟 /zêh⁴ bêh⁴ hian¹ di⁶/ 堂兄弟\n31. 同沿 /dang⁵ iang⁵/ 同輩、同儕\n32. 翁 /ang¹/ 丈夫\n33. 母 /bhao²/ 妻子\n34. 翁姐 /ang¹ zia²/ 夫妻\n35. 新婦 /sing¹ bu⁶/ 媳婦\n36. 大家 /dua⁷ gê¹/ 丈夫的母親、家婆\n37. 大家官 /dua⁷ gê¹ guan¹/ 丈夫的父親、家公\n38. 丈人 /dion⁶ nang⁵/ 岳父\n39. 丈母 /dion⁶ m²/ 岳母\n40. 妻舅 /ci¹ gu⁶/ 妻子的兄弟\n41. 妻姨 /ci¹ i⁵/ 妻子的姐妹\n42. 伯 /bêh⁴/ 伯伯\n43. 姆 /m²/ 伯父的妻子\n44. 叔 /zêh⁴/ 叔叔\n45. 嬸 /sim²/ 叔父的妻子\n46. 舅 /gu⁶/ 舅舅\n47. 妗 /gim⁶/ 舅父的妻子\n48. 姑 /gao¹/ 父親的姐妹、姑姑\n49. 姑丈 /gou¹ dion⁶/ 姑姑的丈夫\n50. 姨 /i⁵/ 母親的姐妹；母親\n51. 姨丈 /i⁵ dion⁶/ 母親的姐妹的丈夫\n52. 先生 /sing¹ sên¹/\n53. 學生 /hag⁴ sêng¹/\n54. 師父 /sai¹ bê⁶/ 工匠師傅\n55. 師父 /su¹ hu⁶/ 出家人、和尚\n56. 和尚 /hoi⁵ sion⁷/、/hua⁵ siang⁶/\n57. 腳色 /ka¹ siao³/ 人手、幫手\n58. 青暝囝 /cên¹ mên⁵ gian²/ 瞎子\n\n### 🦶身體(sing¹ ti²)\n\n1. 頭毛 /tao⁵ mo⁵/ 頭髮\n2. 頭神 /tao⁵ sing⁵/ 思維、記憶的能力\n3. 頭碗骨 /tao⁵ uan² gug⁴/ 頭蓋骨\n4. 旋 /zng⁷/ 頭髮呈漩渦狀的地方\n5. 囟 /sing³/ 嬰兒頭頂骨未合縫處\n6. 額頭 /hia² tao⁵/\n7. 面 /ming⁷/ 臉\n8. 頰溝 /gih⁴ gao¹/ 腮\n9. 痣 /gi³/\n10. 目 /mag⁸/ 眼睛\n11. 目仁 /mag⁸ ring⁵/ 眼珠子\n12. 目汁 /mag⁸ zab⁴/ 眼淚\n13. 眉 /bhai⁵/ 眉毛\n14. 耳 /hin⁶/ 耳朵\n15. 耳空、耳孔 /hin⁶ kang¹/\n16. 鼻 /pin⁷/ 鼻子\n17. 鼻空、鼻孔 /pin⁷ kang¹/\n18. 喙、嘴 /cui⁷/ 嘴巴\n19. 䶕牙 /bha³ ghê⁵/ 龅牙\n20. 涎 /nua⁶/ 唾液\n21. 痰 /tam⁵/\n22. 頷 /am⁶/ 脖子\n23. 下頦 /ê⁶ hai⁵/ 下巴\n24. 喙後肚 /cui⁷ ao⁶ dao²/ 下巴後面柔軟處\n25. 鬚 /ciu¹/ 鬍鬚\n26. 嚨喉 /na⁵ ao⁵/ 喉嚨\n27. 手 /ciu²/\n28. 正手 /zian³ ciu²/ 右手\n29. 倒手 /do³ ciu²/ 左手\n30. 胳囊跤 /goh⁴ lang⁵ ka¹/ 腋下\n31. 手後曲 /ciu² ao⁶ kiao¹/ 手肘\n32. 手模 /ciu² bhao⁵/ 手印\n33. 腡 /lê⁵/ 圓形手指紋\n34. 指頭公 /zain² tao⁵ gong¹/ 大拇指\n35. 尾指囝 /bhoi² zain² gian²/ 小指\n36. 胸 /hêng¹/\n37. 嬭、奶 /nê¹/\n38. 𩩍篱 /pian¹ li⁵/ 肋骨\n39. 肚臍 /dao² zai⁵/\n40. 背脊 /ba¹ ziah⁴/ 脊背\n41. 腰 /io¹/\n42. 跤、骹、腳 /ka¹/\n43. 跤頭趺 /ka¹ tao⁵ u⁶/ 膝蓋\n44. 大跤腿 /dua⁷ ka¹ tui²/ 大腿\n45. 跤腸肚 /ka¹ dng⁵ dao²/ 小腿後部肌肉凸出處\n46. 跤後蹬 /ka¹ ao⁶ dên¹/ 腳後跟\n47. 跤盤 /ka¹ buan⁵/ 腳板\n48. 跤目 /ka¹ mag⁸/ 腳踝\n49. 跤指公 /ka¹ zain² gong¹/ 腳大拇趾\n50. 跤液 /ka¹ sio²/ 腳汗\n51. 卵 /lang⁶/ 陰莖、屌、勢\n52. 卵鳥 /lang⁶ ziao²/ 陰莖、屌、勢\n53. 卵脬 /lang⁶ pa¹/ 精囊\n54. 卵核 /lang⁶ hug⁸/ 睪丸\n55. 膣 /zi¹/ 女陰\n56. 膣眉 /zi¹ bhai¹/ 女陰\n57. 尻川 /ka¹ cng¹/ 屁股\n58. 雞母皮 /goi¹ bho² poi⁵/ 雞皮疙瘩\n59. 汗 /guan⁷/\n60. 垢圿 /gao² goih⁴/ 體表污垢\n\n### 🍵飲食(im² ziah⁸)\n\n1. 食 /ziah⁸/ 吃、喝、抽\n2. 祭 /zi³/ 狼吞虎咽；坐享其成\n3. 咬 /ga⁶/\n4. 哺 /bao⁷/ 咀嚼\n5. 吞 /tung¹/\n6. 舐 /zi⁶/ 舔\n7. 含 /gam⁵/\n8. 啜 /coih⁴/ 喝\n9. 啉 /lim⁵/ 小口喝\n10. 灌 /guang¹/ 大口喝\n11. 吸 /kib⁴/\n12. 搵 /ung³/ 蘸\n13. 買鹹 /moi² giam⁵/ 買菜\n14. 食透早 /ziah⁸ tao⁷ za²/ 吃早飯\n15. 食眠起 /ziah⁸ mng⁵ ki²/ 吃早飯\n16. 食晝 /ziah⁸ dao³/ 吃午飯\n17. 食當晝 /ziah⁸ dêng¹ dao³/ 吃午飯\n18. 食夜昏、食暝昏 /ziah⁸ mê⁵ hng⁵/ 吃晚飯\n19. 飯 /bng⁷/\n20. 米 /bhi²/\n21. 糜 /moi⁵/ 粥\n22. 飲 /am²/ 米湯\n23. 配 /poi³/ 菜\n24. 菜式 /cai³ sêg⁴/\n25. 粿、餜 /goi²/\n26. 丸、圓 /in⁵/\n27. 油䭔 /iu⁵ zui¹/ 一種油炸食品\n28. 汰米 /tua⁷ bhi²/ 淘米\n29. 熬 /ngao⁵/ 長時間煮。～糜。\n30. 煲 /bu⁵/ 煮、熬。～藥。\n31. 潘 /png¹/ 餿水\n32. 油 /iu⁵/\n33. 鹽 /iam⁵/\n34. 醋 /cao³/\n35. 豉油 /si⁷ iu⁵/ 醬油\n36. 豆汁 /dao⁷ zab⁴/ 醬油\n37. 雞卵 /goi¹ nng⁶/ 雞蛋\n38. 豬肉 /du¹ nêg⁸/\n39. 澀肉 /siab⁴ nêg⁸/、/siab⁴ bhah⁴/ 瘦肉。澀，少油。\n40. 肉脞 /nêg⁸ co³/ 肉末\n41. 烏糖 /ao¹ tng⁵/ 紅糖、黑糖\n42. 赤砂糖 /ciah⁴ sua¹ tng⁵/\n43. 白砂糖 /bêh⁸ sua¹ tng⁵/\n44. 薰 /hung¹/ 香菸\n45. 茶 /dê⁵/\n46. 酒 /ziu²/\n47. 淖 /cioh⁴/ 粥稀\n48. 凊 /cing³/ 飯菜涼了\n49. 燒 /sio¹/ 熱呼呼\n50. 燒烘燒烘 /sio¹ hang¹ sio¹ hang¹/ 熱呼呼\n51. 芳 /pang¹/ 香\n52. 甘 /gam¹/\n53. 甜 /diam⁵/\n54. 鹹 /giam⁵/\n55. 薟 /hiam¹/ 辛辣\n56. 䭕 /zian²/ 清淡\n57. 臊 /co¹/ 腥\n58. 臭 /cao³/\n\n### 👔穿戴(cêng⁷ dua³)\n\n1. 帽 /bho⁷/\n2. 目鏡 /mah⁸ gian³/ 眼鏡\n3. 圍巾 /ui⁵ ging¹/\n4. 頷幔 /am⁶ muan¹/ 披肩\n5. 衫褲 /san¹ kao³/ 衣服\n6. 西裝 /sai¹ zuang¹/\n7. 褸 /lao¹/ 大衣\n8. 葵笠 /goi⁵ loih⁸/ 斗笠，竹編成的圓錐形大帽子。\n9. 羊毛衫 /ion⁵ mo⁵ san¹/\n10. 長䘼衫 /dng⁵ ng² san¹/ 長袖衫\n11. 短䘼衫 /dê² ng² san¹/ 短袖衫\n12. 貼身衫 /dah⁴ sing¹ san¹/ 貼身的上衣\n13. 䘥囝 /gah⁴ gian²/ 無袖內衣\n14. 底衫 /doi² san¹/ 內衣\n15. 肚綰 /dao² guan⁶/ 肚兜\n16. 長褲 /dng⁵ kao³/\n17. 短褲 /dê² kao³/\n18. 褲頭 /kao³ tao⁵/ 短褲、內褲\n19. 褲橛 /kao³ goi²/ 短褲、內褲\n20. 三角褲 /san¹ gag⁴ kao³/\n21. 裙 /gung⁵/\n22. 圍裙 /ui⁵ gung⁵/\n23. 文胸 /bhung⁵ hêng¹/ 胸罩\n24. 奶帕、嬭帕 /nê¹ pê³/ 胸罩\n25. 皮帶 /poi⁵ dua³/\n26. 手囊 /ciu² lob⁴/ 套袖\n27. 手鐲 /ciu² sio²/\n28. 鞋拖 /tua¹ oi⁵/ 拖鞋\n29. 波鞋 /bo¹ oi⁵/ 球鞋。波，英文 ball 的音譯。\n30. 釘鞋 /dêng¹ oi⁵/ 運動鞋的一種\n31. 皮鞋 /poi⁵ oi⁵/\n32. 高跟鞋 /gao¹ ging¹ oi⁵/\n33. 靴 /hia¹/\n34. 襪 /ghoih⁸/\n35. 布 /bao³/\n36. 襊 /zoi⁷/ 折痕\n37. 頷領 /am⁶ nia²/ 領子\n38. 褲袋 /kao³ dê⁷/ 位於褲子的口袋\n39. 衫袋 /san¹ dê⁷/ 位於上衣的口袋\n40. 暗袋 /am³ dê⁷/ 內側袋\n41. 內裏 /lai⁶ li²/ 衣物不露出在外的裏層\n42. 鈕 /liu²/ 鈕扣\n43. 針 /zam¹/\n44. 線 /suan³/\n45. 拉鍊 /la¹ liang³/\n46. 穿 /cêng⁷/\n47. 褪 /tng⁷/ 脱\n48. 紩 /tin⁷/ 縫\n49. 補 /bao²/\n50. 車衫褲 /cia¹ san¹ kao³/ 用縫紉機縫衣服\n\n### 🎏物件(mi² gian⁶、mian⁶)\n\n1. 眠牀 /mng⁵ cng⁵/ 牀\n2. 鋪 /pao¹/ 牀\n3. 高低牀 /gao¹ di¹ cng⁵/ 上下鋪\n4. 蓆 /cioh⁸/\n5. 簟 /diam⁶/ 竹席\n6. 毡 /ziang¹/\n7. 被 /poi⁶/\n8. 棉被 /mi⁵ poi⁶/\n9. 被單 /poi⁶ duan¹/\n10. 枕頭 /zim² tao⁵/\n11. 枕頭囊 /zim² tao⁵ lob⁴/ 枕套\n12. 蠓罩、蚊罩 /mang² da³/ 蚊帳\n13. 蠓熏、蚊熏 /mang² hung¹/ 蚊香\n14. 窗罩 /têng¹ zao⁶/\n15. 口罩 /kao² zao⁶/\n16. 壁櫥 /biah⁴ du⁵/\n17. 椅 /in²/\n18. 桌 /doh⁴/\n19. 櫃 /gui⁷/\n20. 架 /gê³/\n21. 盒 /ab⁸/\n22. 籃 /na⁵/\n23. 瓶 /bang⁵/\n24. 鎖頭 /so² tao⁵/\n25. 鎖匙 /so² si⁵/ 鑰匙\n26. 葉疊 /iab² diab⁸/ 合葉\n27. 牙簽 /ghê⁵ ciam¹/\n28. 茶盤 /dê⁵ buan⁵/\n29. 茶壺 /dê⁵ hu⁵/\n30. 沖罐 /cong¹ guang³/ 茶壺\n31. 茶杯 /dê⁵ boi¹/\n32. 茶几 /dê⁵ gi²/\n33. 熏咬 /hung¹ ga⁶/ 煙斗\n34. 熏碟 /hung¹ dih⁸/ 煙灰缸\n35. 熱壺 /riag⁸ hu⁵/ 熱水瓶\n36. 熨斗 /ug⁴ dao²/\n37. 電燈 /diang⁶ dêng¹/\n38. 電泡 /diang⁶ pa⁶/\n39. 燈籠 /dêng¹ lang⁵/\n40. 燈火 /dêng¹ hoi²/ 電燈；燈光\n41. 風箏 /hong¹ zêng¹/\n42. 米甕 /bhi² ang³/ 米缸\n43. 水䀇 /zui² gao²/ 大型儲水器\n44. 跤桶 /ka¹ tang²/ 原指洗腳桶，後泛指洗衣盆，也可用來給小孩洗澡。\n45. 面盆 /ming⁷ png⁵/ 臉盆\n46. 瓠桸 /bu⁵ hia¹/ 水瓢\n47. 口㼦 /kao² gong²/ 漱口杯\n48. 碗 /uan²/\n49. 盤 /buan⁵/\n50. 碟 /dih⁸/\n51. 甌 /ao¹/ 大碗\n52. 箸 /du⁷/ 筷子\n53. 湯匙 /tng¹ si⁵/\n54. 調羹 /tiao⁵ gên¹/ 喝粥用的小勺子；湯匙\n55. 糜匙 /moi⁵ si⁵/ 舀粥用的勺子\n56. 飯匙 /bng⁷ si⁵/ 飯勺\n57. 飯添 /bng⁷ tin¹/ 飯勺\n58. 鼎 /dian²/ 鍋\n59. 鼎㧕 /dian² liu⁶/ 鍋鏟。㧕，存疑。\n60. 鼎蓋 /dian² kain³/ 鍋蓋\n61. 菜刀 /cai³ do¹/\n62. 瓜刨 /goi¹ pao⁵/\n63. 砧 /diam¹/\n64. 篩 /tai¹/\n65. 筅 /cain²/ 刷子\n66. 菜篩 /cai³ tai¹/\n67. 鉸刀 /ga¹ do¹/ 剪刀\n68. 螺絲批 /lo⁵ si¹ poi¹/ 螺絲刀\n69. 螺絲釘 /lo⁵ si¹ dêng¹/\n70. 旋螺絲 /suag⁸ lo⁵ si¹/ 擰螺絲\n71. 鐵錘 /tih⁴ tui⁵/\n72. 鉸夾 /ga¹ giab⁸/ 鉗子\n73. 扳手 /bang² ciu²/\n74. 電筆 /diang⁶ big⁴/ 測電筆\n75. 烏膠布 /ao¹ ga¹ bao³/ 電工膠帶\n76. 黏紙 /niam⁵ zua²/ 透明膠帶\n77. 布拖 /bao³ tu¹/ 拖把\n78. 掃帚 /sao³ siu²/ 掃把\n79. 畚斗 /bng³ dao²/ 垃圾鏟\n80. 畚箕 /bng³ gi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled.png)\n\n81. 梯 /tui¹/\n82. 吸石 /hiab⁴ zioh⁸/ 磁鐵、磁石\n83. 箠 /coi⁵/ 鞭子，可用來教育孩子。\n84. 火箠 /hoi² coi⁵/ 火筷子，夾爐中煤炭或通火的用具。\n85. 角畢 /gag⁴ big⁴/ 皮箱\n86. 樹嬭 /ciu⁷ ni⁵/ 橡皮、橡膠。嬭，樹之乳膠。\n87. 嬭漱 /ni⁵ ciu³/ 橡皮擦\n88. 毛筆 /mo⁵ big⁴/\n89. 鋼筆 /gng³ big⁴/\n90. 鉛筆 /iang⁵ big⁴/\n91. 鉛筆旋 /iang⁵ big⁴ suag⁸/ 卷筆刀、筆刨\n92. 模 /bhao⁵/ 模子\n93. 㨹 /zoi⁷/ 裂縫、痕跡\n94. 離衣機 /li⁵ i¹ gi¹/ 洗衣機\n\n### 🏠建築(giang³ dog⁴)\n\n1. 茨、厝 /cu³/ 房子、家\n2. 寮 /liao⁵/ 简陋小屋\n3. 瓦茨 /hia⁶ cu³/ 瓦舍\n4. 茨手 /cu³ ciu²/ 潮汕民居天井旁兩間廂房的名稱。\n5. 兩間直 /no⁶ gain¹ dig⁸/ 傳統民居，兩房。\n6. 獨腳靴 /dog⁸ ka¹ hia¹/ 傳統民居，一聽一茨手一房。\n7. 下山虎 /hia⁶ suan¹ haon²/ 傳統民居，三合院，一廳二房二茨手。\n8. 四點金 /si³ diam² gim¹/ 傳統民居，四合院，中軸爲前廳天井後聽，兩廳兩旁各有一房。\n9. 竹竿茨 /dêg⁴ go¹ cu³/ 傳統民居，廚房客廳住房天井排列成狹長的空間，如竹竿。\n10. 駟馬拖車 /si³ mê² tua¹ cia¹/ 傳統民居，在四點金上縱加一廳，橫加兩房，三廳二天丼。\n11. 茨邊 /cu³ bin¹/ 鄰居\n12. 起茨 /ki² cu³/ 蓋房子\n13. 租茨 /zao¹ cu³/ 租房子\n14. 搬茨 /buan⁵ cu³/ 搬家\n15. 入新茨 /rib⁸ sing¹ cu³/ 搬入新家\n16. 客廳 /kêh⁴ tian¹/\n17. 客房 /kêh⁴ bang⁵/\n18. 廚房 /dao⁵ bang⁵/\n19. 浴室 /êg⁸ sig⁴/\n20. 洗浴 /soi² êg⁸/ 洗澡\n21. 廁所 /cê³ so²/\n22. 屎壑 /sai² hag⁸/ 茅廁\n23. 門窗 /mng⁵ têng¹/\n24. 門閂 /mng⁵ cuan³/\n25. 門楣 /mng⁵ bhai⁵/\n26. 門橂 /mng⁵ dain⁶/ 門檻\n27. 門扇後 /mng⁵ sin³ ao⁶/ 門後\n28. 柱 /tiao⁶/\n29. 牆壁 /cion⁵ biah⁴/\n30. 庭、埕 /dian⁵/ 寬闊平地，可曬鹽、曬穀。\n31. 临檐 /lim⁵ zin⁵/ 檐廊\n32. 塗角 /tao⁵ gag⁴/ 土磚\n33. 磚 /zng¹/\n34. 廟 /bhio⁷/\n35. 亭 /dêng⁵/\n36. 祠堂 /su⁵ dng⁵/\n37. 庵寺 /am¹ zin⁷/ 尼寺、僧寺的通稱。\n38. 學校 /hag⁸ hao⁶/\n39. 醫院 /ui¹ in⁷/\n40. 鎮府 /ding³ hu²/ 鎮政府\n41. 舖囝 /pao³ gian²/ 小賣部\n\n### 🛵交通(gao¹ tong¹)\n\n1. 腳車、跤車 /ka¹ cia¹/ 腳踏車、自行車\n2. 摩托 /mo⁵ toh⁸/ 摩托，英文 motorcycle 音譯省。\n3. 三輪車 /san¹ lung⁵ cia¹/\n4. 的士 /dêg⁴ si⁶/ 計程車、出租車。的士，英文 taxi 音譯。\n5. 小車 /sio² cia¹/ 小汽車\n6. 麵包車 /min⁷ bao¹ cia¹/\n7. 公交車 /gong¹ gao¹ cia¹/\n8. 大巴 /dua⁷ ba¹/ 巴，英文 bus 音譯。\n9. 車站 /cia¹ zam⁶/\n10. 輪船 /lung⁵ zung⁵/\n11. 龍船 /lêng⁵ zung⁵/ 龍舟\n12. 火車 /hoi² cia¹/\n13. 地鐵 /di⁷ tih⁴/\n14. 高鐵 /gao¹ tih⁴/\n15. 飛機 /boi¹ gi¹/\n16. 行路 /gian⁵ lao⁷/ 走路\n17. 踏腳車 /dah⁸ ka¹ cia¹/ 騎自行車\n18. 駛車 /sai² cia¹/ 開車\n19. 撐船 /tên¹ zung⁵/\n20. 載客 /zai³ kêh⁴/\n21. 拗䷀囝 /ao² gag⁴ gian²/ 摩托車司機。拗，載；扛。\n22. 落車 /lo² cia¹/ 下車\n23. 碼頭 /bhê² tao⁵/\n24. 涵空、涵孔 /am⁵ kang¹/ 涵洞、涵管、地下水道\n25. 橋墩 /gio⁵ dun¹/ 橋梁下面的圓柱狀基石\n\n### 🐒眾生(zêng³ sên¹)\n\n1. 眾生 /zêng³ sên¹/ 牲畜\n2. 禽兽 /kim⁵ siu⁶/\n3. 害蟲 /hai⁷ tang⁵/\n4. 豬豭 /du¹ go¹/ 配種的公豬，也比喻好色之徒。\n5. 豬槽 /du¹ zo⁵/\n6. 羊牢 /ion⁵ lo⁵/\n7. 雞翁 /goi¹ ang¹/ 雄雞\n8. 雞母 /goi¹ bho²/ 母雞\n9. 鴨囝 /ah⁴ gian²/ 小鴨子\n10. 鵝 /gho⁵/\n11. 貓牯 /ngiao¹ gao²/ 母貓\n12. 鳥 /ziao²/\n13. 燕囝 /in³ gian²/ 小燕子\n14. 鶴 /hoh⁸/\n15. 鷹 /êng¹/\n16. 白鴿 /bêh⁸ gab⁴/\n17. 白鷺鷥 /bêh⁸ lao⁷ si¹/\n18. 鸚哥 /êng¹ go¹/ 鸚鵡\n19. 麻雀 /mua⁵ ziah⁴/\n20. 蝠婆 /big⁴ bo⁵/ 蝙蝠\n21. 蛇 /zua⁵/\n22. 雨傘節 /hao⁶ suan³ zag⁴/ 一种毒蛇。\n23. 狗母蛇 /gao² bho² zua⁵/ 蛇舅母、石龍子、四腳蛇，蜥蜴的一種\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%201.png)\n\n24. 兩棲動物 /liang² ci¹ dong⁶ moih⁸/\n25. 蟾蜍 /ziong¹ zu⁵/\n26. 蛤虯 /gab⁴ giu²/ 青蛙\n27. 蛤蛙 /gab⁴ guai¹/ 蝌蚪\n28. 蚼蟻 /gao² hia⁶/ 螞蟻\n29. 白蟻 /bêh⁸ hia⁶/\n30. 蜜蜂 /bhig⁸ pang¹/\n31. 虎頭蜂 /hao² tao⁵ pang¹/ 黄蜂\n32. 龜 /gu¹/ 烏龜或像烏龜的昆蟲\n33. 金龜 /gim¹ gu¹/ 金龜子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%202.png)\n\n34. 鱉 /bih⁴/\n35. 土蚓 /dao⁶ ung²/ 蚯蚓\n36. 蜈蚣 /gê⁵ gang¹/\n37. 火金蛄 /hoi² gim¹ gao¹/ 螢火蟲\n38. 牛屎龜 /ghu⁵ sai² gu¹/ 屎殼郎、蜣螂\n39. 烏點龜 /ao¹ diam² gu¹/ 七星瓢蟲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%203.png)\n\n40. 紅新娘 /ang⁵ sing¹ nion⁵/ 紅姬緣椿象\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%204.png)\n\n41. 山蛚 /sua¹ lê⁷/ 蟬；多指[蚱蝉](http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14818)\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%205.png)\n\n42. 蝘悲蟬 /iam⁶ bi¹ sung⁵/ [蟪蛄](http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14817)\n\n    ![gahzi-oi-hung-lui-ci-biao/image.jpg](gahzi-oi-hung-lui-ci-biao/image.jpg)\n\n43. 蟋蟀 /tih⁴ sug⁴/ 又稱烏龍。\n44. ䷀ // 螽斯、莎蟲、紡織娘、蟈蟈。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%206.png)\n\n45. 草猴 // 稻蝦\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%207.png)\n\n46. ䷀ // 金盾龜金花蟲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%208.png)\n\n47. 草蜢 /cao² mên²/ 螞蚱、蚱蜢。\n48. 螳螂、螳蜋 /tang⁵ lang⁵/\n49. 神螂 /sing⁵ lang⁵/ 壁虎，蜥蜴的一種。\n50. 蛤蚧蛇 /gab⁴ gai³ zua⁵/ 大壁虎，蜥蜴的一種。\n51. 土猴 /dao⁶ gao⁵/ 螻蛄\n52. 蝶、蜨 /iah⁸/ 蝴蝶\n53. 山螟 /suan¹ mê¹/ 蜻蜓\n54. 米龜 /bhi² gu¹/ 米象，蛀食稻穀、麥粒等米糧爲生。\n55. 蛀蟲 /zu³ tang⁵/\n56. 蛓毛蟲 /ci³ mo⁵ tang⁵/ 毛毛蟲\n57. 流鼻螺 /lao⁵ pin⁷ lê⁵/ 蝸牛\n58. 戶蠅 /hao⁵ sing⁵/ 蒼蠅\n59. 枯蠅 /gao¹ sing⁵/ 介殼蟲\n60. 蠓、蚊 /mang²/\n61. 蝨母 /sag⁴ bho²/ 蝨子\n62. 曱甴、虼蚻 /ga¹ zuah⁸/ 蟑螂\n63. 蜈蜞 /ghao⁵ ki⁵/ 水蛭，喜歡吸血人畜血液。\n\n### 🐳水產(zui² suan²)\n\n1. 䭕水魚 /zian² zui² hu⁵/ 淡水魚\n2. 鹹水魚 /giam⁵ zui² hu⁵/ 海水魚\n3. 刣魚 /tai⁵ hu⁵/ 宰魚\n4. 魚春 /hu⁵ cung¹/ 魚卵。屈大均《廣東新語》：「粵方言凡禽魚卵皆為春。唐時吳君貢魚春子，即魚子也。」 \n5. 魚鱗 /hu⁵ lang⁵/\n6. 魚鰾 /hu⁵ pio⁶/\n7. 魚鰓 /hu⁵ ci¹/\n8. 魚刺 /hu⁵ ci³/\n9. 鯁 /gên²/ 魚刺在喉\n10. 馬鮫 /mê² ga¹/\n11. 鯧 /cion¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%209.png)\n\n12. 鰇魚 /riu⁵ hu⁵/ 魷魚\n13. 墨斗 /bhag⁸ dao²/、/mag⁸ dao²/ 墨魚\n14. 絲丁魚 /si¹ dêng⁶ hu⁵/ 龍頭魚、硬魚、橂魚(殿魚)、豆腐魚\n15. 狗母魚 // 蝦虎魚、狗魽仔魚、九甘魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2010.png)\n\n16. 白目噯 /ain²/\n17. 狗母囝 // 身體透明，似魩仔鱼，有淡水和海水兩種\n18. 鰻魚 /muan⁵ hu⁵/\n19. 花仙魚 /hoi¹ siang¹ hu⁵/ 鮐魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2011.png)\n\n20. 鸚哥魚 /êng¹ go¹ hu⁵/ 洛神項鰭魚、紅姑娘、紅新娘、碼頭魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2012.png)\n\n21. 癩瘑魚 /na³ go¹ hu⁵/、/lai³ go¹ hu⁵/ 多齒蛇鯔，俗稱「那哥魚」，常用於製魚丸。\n22. 娘愛魚 /nion⁵ ain¹ hu⁵/ 泥猛魚、褐篮子鱼、臭肚鱼。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2013.png)\n\n23. ䷀囝 /dêg⁸ gian²/ 又稱迪仔、綠鰭馬面魨、剝皮魚。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2014.png)\n\n24. 䱛囝 /oig⁸ gian²/ 䱛仔、䱛魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2015.png)\n\n25. 金龍䱛 /gim¹ lêng⁵ oig⁸/ 金龍魚、黃花魚，狀似䱛魚但個頭大、嘴圓、體黃。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2016.png)\n\n26. 福壽魚 /hog⁴ siu⁶ hu⁵/ 羅非魚\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2017.png)\n\n27. 鮭魚 /guai¹ hu⁵/ 河魨，俗稱「乖魚」，常指黃鰭東方魨。\n28. 黃牆 /ng⁵ cion⁵/ 黃鰭鯛\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2018.png)\n\n29. 軟甘 /nng² gang¹/ 杜氏鰤、油甘，體側有黃色縱帶。 \n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2019.png)\n\n30. 沙尖 /sua¹ ziam¹/ 多鱗鱚、沙鯪、北方稱沙丁魚。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2020.png)\n\n31. 龍箭 /lang⁷ zin⁷/ 鯪魚 ，淡水魚，可用於做罐頭魚。\n32. 石剎 /zio² sag⁴/ 又稱烏雞，松鯛。\n33. 淡角魚 /dam⁶ gag⁴ hu⁵/ 鯒魚、辮子魚\n34. 烏魚 /ao¹ hu⁵/ 又稱烏頭，鯔魚。\n35. 烏前魚 /ao¹ zain⁵ hu⁵/\n36. 塗虱 /tao⁵ sag⁴/ 鬍子鯰\n37. 龍舌 /lêng⁵ zi²/ 龍利魚\n38. 巴浪 /ba¹ lang¹/ 藍圓鯵\n39. 鯇魚 /uang² hu⁵/ 草魚\n40. 姑魚 /gao¹ hu⁵/ 金色小沙丁魚\n41. 鯽魚 /zig⁴ hu⁵/\n42. 秋刀魚 /ciu¹ do¹ hu⁵/\n43. 紅目鰱 /ang⁵ mag⁸ liang⁵/ 紅目大眼鯛\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2021.png)\n\n44. 田鱔 /cang⁵ cuan⁶/ 鱔魚、黃鱔\n45. 白帶魚 /bêh⁸ dua³ hu⁵/ 鞭魚、裙帶魚、海刀魚\n46. 鰐魚 /ngag⁸ hu⁵/\n47. 鯊魚 /sua¹ hu⁵/\n48. 鯨魚 /kêng⁵ hu⁵/\n49. 紅哥鯉 /ang⁵ go¹ li²/ 金線魚\n50. 蝦 /hê⁵/\n51. 蟹 /hoi⁶/\n52. 三目蠘 /san¹ mag⁸ cih⁸/ 紅星梭子蟹、三目蟹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2022.png)\n\n53. 海哲 /hai² diag⁴/\n54. 蠔、蚝、蚵 /o⁵/ 牡蠣\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2023.png)\n\n55. 紅肉 /ang⁵ nê²/ 紅肉藍蛤\n56. 蚶 /ham¹/\n57. 蜆 /hain⁶/\n58. 青匙 /cên¹ si⁵/ 綠殼菜蛤、翡翠貽貝\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2024.png)\n\n59. 花蛤 /hoi¹ gab⁴/ 菲律賓簾蛤、花甲\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2025.png)\n\n60. 車白 /cia¹ bêh⁸/ 文蛤，邊緣弧度較花蛤圓。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2026.png)\n\n61. 青蛤 /cên¹ gab⁴/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2027.png)\n\n62. 毛蚶 /mo⁵ ham¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2028.png)\n\n63. 薄殼 /bo² kag⁴/ 尋氏肌蛤、海蛔、海瓜子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2029.png)\n\n64. 指甲螳 /zain² gah⁴ tang⁵/ 又稱指甲蚌hong²，蟶sêng³子。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2030.png)\n\n65. 田螺 /cang⁵ lê⁵/\n66. 尖螺 /ziang¹ lê⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2031.png)\n\n### 🌾 蔬菜(so¹ cai³)\n\n1. 五穀 /ngao⁶ gag⁴/\n2. 稻 /diu⁶/\n3. 粟 /cêg⁴/ 稻粒\n4. 麥 /mê²/\n5. 秫米 /zu² bhi²/ 糯米\n6. 薏米 /in³ bhi²/\n7. 薏仁 /in³ ring⁵/ 玉米\n8. 蕃薯 /huang¹ zu⁵/、/hang¹ zu⁵/\n9. 馬鈴薯 /mê² lêng¹ zu⁵/ 土豆\n10. 黃豆 /ng⁵ dao⁷/ 大豆、菽\n11. 綠豆 /lê² dao⁷/\n12. 烏豆 /ao¹ dao⁷/ 黑豆\n13. 赤豆 /ciah⁴ dao⁷/ 紅小豆\n14. 荷目豆 /ho⁵ mag⁸ dao⁷/ 荷蘭豆、豌豆\n15. 地豆 /di⁷ dao⁷/ 花生\n16. 豆仁 /dao⁷ ring⁵/ 花生米\n17. 油麻 /iu⁵ mua⁵/ 芝麻\n18. 菜豆 /cai³ dao⁷/ 常指四季豆\n19. 茄 /gio⁵/\n20. 苦瓜 /kao² goi¹/\n21. 角瓜 /gag⁴ goi¹/ 稜角絲瓜\n22. 秋瓜 /ciu¹ goi¹/ 絲瓜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2032.png)\n\n23. 嬭瓜、奶瓜 /nê¹ goi¹/ 木瓜\n24. 蓮藕 /nain⁵ nao⁶/\n25. 菠薐菜 /boi¹ lêng⁵ cai³/ 菠菜\n26. 蕹菜 /êng³ cai³/ 空心菜\n27. 春菜 /cung¹ cai³/ 長葉芥菜\n28. 菜花 /cai³ hoi¹/ 花椰菜\n29. 芥菜 /gua³ cai³/ 大芥菜、包心芥菜\n30. 芥藍 /gêg⁴ na⁵/\n31. 菜頭 /cai³ tao⁵/ 白蘿蔔\n32. 紅菜頭 /ang⁵ cai³ tao⁵/ 紅蘿蔔\n33. 薺蔥、錢蔥 /zin⁵ cang¹/ 荸薺\n34. 韭菜 /gu² cai³/\n35. 芫荽 /iang¹ sui¹/ 香菜\n36. 芳菜 /pang¹ cai³/\n37. 厚合 /gao⁶ hah⁸/ 厚皮菜、莙薘菜、葉用甜菜\n38. 九層塔 /gao² zang⁵ tah³/ 金不換、羅勒\n39. 萵菜 /oi¹ cai³/ 皺葉萵苣、生菜\n40. 劍菜 /giam³ cai³/ 油麥菜\n41. 上海青 /siang⁶ hai² cên¹/ 青菜的一種\n42. 芹菜 /king⁵ cai³/\n43. 津白 /gian¹ bêh⁸/ 又稱紹菜、黃芽白，天津盛產，是大白菜的一種。以下是大白菜的不同品種。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2033.png)\n\n    天津大白菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2034.png)\n\n    大白菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2035.png)\n\n    娃娃菜\n\n44. 高麗菜 /go¹ lê⁵ cai³/ 捲心菜、包菜、結球甘藍\n45. 菜花 /cai³ hoi¹/ 花椰菜\n46. 茼蒿 /dang⁵ o¹/\n47. 枸杞菜 /gao² gi² cai³/\n48. 真珠菜 /zing¹ zu¹ cai³/ 珍珠花菜、白苞蒿\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2036.png)\n\n49. 薟椒 /hiam¹ tsio¹/ 辣椒\n50. 生果 /cên¹ goi²/ 水果\n51. 荔果 /nai⁶ goi²/ 荔枝\n52. 龍眼 /nging⁵ ain²/\n53. 桑垂 /siong¹ sui⁵/ 桑葚\n54. 草莓 /cao² bhoi⁵/\n55. 刺菠 /ci³ bo¹/ 蛇莓、覆盆子\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2037.png)\n\n56. 弓蕉 /gêng¹ zio¹/ 香蕉\n57. 米蕉 /bhi² zio¹/\n58. 鳥梨 /ziao² lai⁵/\n59. 檨 /suain⁷/ 芒果\n60. 菝囝 /bag⁸ gian²/ 番石榴\n61. 西瓜 /si¹ goi¹/\n62. 香櫞 /hion¹ ng⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2038.png)\n\n63. 柚 /iu⁷/\n64. 柑 /gan¹/ 柑橘\n65. 桔 /gig⁴/\n66. 橙 /cêng⁵/\n67. 菠蘿 /bo¹ lo⁵/\n68. 油甘 /iu⁵ gam¹/ 餘甘果，先苦後甜，齒留餘甘。\n69. 番茄 /huang¹ gio⁵/\n70. 青竹梅 /cên¹ dêg⁴ bhoi⁵/\n71. 李 /li²/\n72. 棗 /zo²/\n73. 蔗 /zia³/ 甘蔗\n\n### 🌿草藥 /cao² ioh⁸/\n\n1. 艾 /hia³/ 艾草 \n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2039.png)\n\n2. 草粿草 /cao² goi² cao²/ 仙草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2040.png)\n\n3. 策草 /cêg⁴ cao²/ 又稱抹(bhuah⁴)草、廣防風、防風草，甲子地區神位常年插此草。策 ，大概是指其像馬鞭。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2041.png)\n\n4. 青菭 /cên¹ ti⁵/ 青苔\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2042.png)\n\n5. 薄荷 /bo⁵ ho³/、/bon⁵ hon³/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2043.png)\n\n6. 金銀花 /gim¹ nging⁵ hoi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2044.png)\n\n7. 午時花 /ngao² si⁵ hoi¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2045.png)\n\n8. 四季春 /si³ kui³ cung¹/ 四季春花\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2046.png)\n\n9. 葉下紅 /hio² ê⁶ ang⁵/ 一點紅\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2047.png)\n\n10. 臭草花 /cao³ cao² hoi¹/ 五色梅、馬纓丹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2048.png)\n\n11. 飛天蜈蚣 /boi¹ tin¹ ghê⁵ gang¹/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2049.png)\n\n12. 金雞脫殼 /gim¹ goi¹ tug⁴ kag⁴/\n13. 路跤菊 /lao⁷ ka¹ gêg⁴/ 路邊菊\n14. 臘裏葉 /lah⁸ li² hioh⁸/ 金邊紅桑\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2050.png)\n\n15. 芒囝筍 /mang⁵ gian² sung²/ 芒草的嫩芽\n16. 竹菜 /dêg⁴ cai³/ 竹葉草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2051.png)\n\n17. 葛菜 /guah⁴ cai³/ 野葛菜，可食。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2052.png)\n\n18. 烏規菜 /ao¹ gui¹ cai³/ 龍葵\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2053.png)\n\n19. 豬母菜 /du¹ bho² cai³/ 馬齒莧\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2054.png)\n\n20. 刺莧 /ci³ hain⁷/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2055.png)\n\n21. 苦刺 /kao² ci³/ 白簕\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2056.png)\n\n22. 苦草 /kao² cao²/ 豨薟草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2057.png)\n\n23. 兩公根 /liang² gong¹ ging¹/ 崩大碗\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2058.png)\n\n24. 鋪地錦 /pao¹ di⁷ gim²/ 滿天星\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2059.png)\n\n25. 雞屎藤 /goi¹ sai² ding⁵/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2060.png)\n\n26. 伸筋藤 /cung¹ ging¹ ding⁵/ 蔓九節\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2061.png)\n\n27. 無頭藤 /bho⁵ tao⁵ ding⁵/ 寄生於其他植物之上\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2062.png)\n\n28. 酒甕囝 /ziu² ang³ gian²/\n29. 盐酸鸡囝 /iam⁵ sng¹ goi¹ gian²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2063.png)\n\n30. 見笑草 /giang³ siao³ cao²/ 含羞草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2064.png)\n\n31. 燈籠草 /dêng¹ lang⁵ cao²/ 其果子稱爲「姑娘果」\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2065.png)\n\n32. 車前草 /cia¹ zain⁵ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2066.png)\n\n33. 馬鞭草 /bhê² bin¹ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2067.png)\n\n34. 蟋蟀草 /tig⁴ sug⁴ cao²/ 烏龍草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2068.png)\n\n35. 蒲公英 /pu⁵ gong¹ êng¹/\n36. 鸭舌草 /ah³ zih⁸ cao²/ 苦菜\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2069.png)\n\n37. 魚腥草 /hu⁵ co³ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2070.png)\n\n38. 益母草 /iah⁴ bho² cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2071.png)\n\n39. 龍膽草 /lêng⁵ dan² cao²/ 苦地膽草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2072.png)\n\n40. 奶汁草 /nê¹ zab⁴ cao²/ 乳汁草，草折斷會有白色液體流出。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2073.png)\n\n41. 虎耳草 /haon² hin⁶ cao³/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2074.png)\n\n42. 大號奶汁草 /dua⁷ ho⁷ nê¹ zab⁴ cao³/ 蠔割草、飛揚草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2075.png)\n\n43. 貓毛兒 /ngiao¹ mo⁵ ri⁵/ 金絲草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2076.png)\n\n44. 貓鬚草 /ngiao¹ ciu¹ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2077.png)\n\n45. 鹅囝香 /gho⁵ gian² hiang¹/ 鹅不食草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2078.png)\n\n46. 白花蛇舌草 /bêh⁸ hoi¹ zua⁵ zih⁸ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2079.png)\n\n47. 白花蟛蜞草 /bêh⁸ hoi¹ pen⁵ ki⁵ cao²/、/bêh⁸ hoi¹ mua⁵ ki⁵ cao²/\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2080.png)\n\n48. 四方枝苦楝 /si³ bang¹ gi¹ kao² nai⁷/ 鬼針草\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2081.png)\n\n49. 苦楝 /kao² nai⁷/ 苦楝樹\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2082.png)\n\n50. 挨礱被哺 /oi⁵ lang⁵ bi⁶ bu⁶/ 磨盤草、磨礱草、挨礱地堵，其果實似磨盤和礱。礱，磨谷農具。\n\n    ![](gahzi-oi-hung-lui-ci-biao/Untitled%2083.png)\n\n### 🏮時節(si⁵ zoih⁴)\n\n1. 今年 /gim¹ ni⁵/\n2. 舊年 /gu⁷ ni⁵/ 去年\n3. 前年 /zain³ ni⁵/、/zung³ ni⁵/\n4. 下年 /ê⁶ ni⁵/ 明年\n5. 熱天時 /ruah⁸ tin¹ si⁵/ 夏天\n6. 寒天時 /guan⁵ tin¹ si⁵/ 冬天\n7. 凝天時 /ngang⁵ tin¹ si⁵/ 冬天\n8. 春夏秋冬 /cung¹ hê⁶ ciu¹ dang¹/\n9. 老歷 /lao⁶ lê²/ 農曆\n10. 新曆 /sing¹ lê²/ 公曆\n11. 今日 /gim¹ rig⁸/\n12. 明日 /mêng⁵ rig⁸/\n13. 今旦日 /gian² rig⁸/ 今天\n14. 明旦日 /man³ rig⁸/ 明天\n15. 明眠起 /ma³ mng⁵ ki²/ 明天\n16. 昨日 /za¹ rig⁸/\n17. 前日 /zain⁵ rig⁸/、/zoh⁸ rig⁸/\n18. 後日 /ao⁶ rig⁸/\n19. 大前日 /dua⁷ zain⁵ rig⁸/、/dua⁷ zoh⁸ rig⁸/\n20. 大後日 /dua⁷ ao⁶ rig⁸/\n21. 天光 /tin¹ gng¹/ 天亮\n22. 透早 /tao³ za²/ 黎明\n23. 眠起 /mng⁵ ki²/ 早晨\n24. 日時 /rig⁸ si⁷/ 白天\n25. 早晝 /za² dao³/ 上午\n26. 中晝 /dêng¹ dao³/ 中午\n27. 中晝時 /dêng¹ dao³ si⁵/ 中午\n28. 下晝 /ê⁶ dao³/ 下午\n29. 下旰 /ê⁶ gua³/ 下午\n30. 暗頭 /am³ tao⁵/ 傍晚\n31. 暗頭時 /am³ tao⁵ si⁵/ 傍晚\n32. 下昏 /ê⁶ hng⁵/ 晚上\n33. 下昏時 /ê⁶ hng⁵ si⁵/、/êng² si⁵/ 晚上\n34. 下昏囝 /êng² gian²/ 晚上\n35. 暗時 /am³ si⁷/ 晚上\n36. 暝時、夜時 /mê⁵ si⁷/ 晚上\n37. 暝昏、夜昏 /mê⁵ hng⁵/ 晚上\n38. 暝昏時、夜昏時 /mê⁵ hng⁵ si⁵/、/mêng² si⁵/ 晚上\n39. 暝昏囝 /mêng² gian²/ 晚上\n40. 半暝、半夜 /buan³ mê⁵/\n41. 時分秒 /si⁵ hung⁵ miao²/\n42. 個字 /gai⁵ ri⁷/ 五分鐘\n43. 兩個字久 /no⁶ gai⁵ ri⁷ gu²/ 十分鐘\n44. 頭前 /tao⁵ zain⁵/ 之前\n45. 頭陣 /tao⁵ zung⁵/ 剛才\n46. 下 /ê⁶ miag⁸/、/ê⁶ mig⁸/ 剛才\n47. 一頃 /zêg⁸ kuang³/ 一會兒\n48. 一頃頭 /zêg⁸ kuang³ tao⁵/ 一下子\n49. 煞尾 /suah⁴ bhoi²/ 最後\n50. 今 /dan¹/ 現在\n51. 逐日 /dag⁸ rig⁸/ 每天\n52. 逐暝 /dag⁸ mê⁵/ 每晚\n53. 通日 /tang³ rig⁸/ 整天\n54. 半日 /buan³ rig⁸/\n55. 隔日 /gêh⁴ rig⁸/\n56. 隔暝、隔夜 /gêh⁴ mê⁵/\n57. 別日 /bag⁸ rig⁸/ 改天\n58. 即時 /ziag⁴ si⁵/ 立刻、馬上\n59. 平常時 /pêng⁵ sion⁵ si⁵/ 平時\n60. 一日通通 /zêg⁸ rig⁸ tang³ tang³/ 一整天\n61. 七早八早 /cig⁴ za² boih⁴ za²/ 一大早\n62. 七早蒙流 /cig⁴ za² mo⁵ liu⁵/ 一大早\n63. 烏暗天地 /ao¹ am³ tin¹ di¹/ 天昏地暗\n64. 立春 /lib⁸ cung¹/\n65. 雨水 /u² sui²/\n66. 驚蟄 /gêng¹ dêg8/\n67. 春分 /cung¹ hung¹/\n68. 清明 /cêng¹ mêng⁵/\n69. 谷雨 /gog⁴ u²/\n70. 立夏 /lib⁸ hê⁶/\n71. 小滿 /sio² muan²/\n72. 芒種 /mang⁵ zêng²/\n73. 夏至 /hê⁶ zi³/\n74. 小暑 /siao² su²/\n75. 大暑 /dai⁶ su²/\n76. 立秋 /lib⁸ ciu¹/\n77. 處暑 /cu³ su²/\n78. 白露 /bêh⁸ lao⁷/\n79. 秋分 /ciu¹ hung¹/\n80. 寒露 /guan⁵ lao⁷/\n81. 霜降 /sang¹ gang³/\n82. 立冬 /lib⁸ dang¹/\n83. 小雪 /siao² soh⁴/\n84. 大雪 /dai⁶ soh⁴/\n85. 冬至 /dang¹ zi³/\n86. 小寒 /siao² hang⁵/\n87. 大寒 /dai⁶ hang⁵/\n88. 時年八節 /si⁵ ni⁵ boih⁴ zoih⁴/ 一年四季八個節，最早的八節指立春、春分、立夏、夏至、立秋、秋分、立冬和冬至。而在甲子時年八節指元宵、春分、清明、五月節、七月半、秋分、八月半、冬節，過此八節要拜祖，除春分、秋分外的節還需要拜神。\n    - 四時，四季、春夏秋冬。\n    - 年，甲骨文象人負禾之形，會穀物豐收之意，古時禾穀一年一熟，於是「年」被（引申）用作周年之年。【爾雅•釋天】夏曰歲，商曰祀，周日年，唐虞曰載。古時一度流行歲星（即木星、朱比特星，公轉週期爲 398.88 天）紀年，故一年又稱一歲。\n    - 時年，一年四季。\n    - 節，中國曆法把一年分為二十四段，每段的開始即爲節。早期只有春分、秋分、夏至、冬至四節，後又加入立春、立夏、立秋、立冬，形成八節，再來後逐漸形成了二十四節。「節」早期是天文曆法上的概念，與氣候相關，後又逐漸加入了紀念或慶祝的元素。\n89. 元宵節 /nguang⁵ siao¹ zoih⁴/\n90. 公忌節 /gong¹ gi⁷ zoih⁴/ 春分和秋分，祭拜先祖，但不拜神。\n91. 清明節 /cêng¹ mêng⁵ zoih⁴/\n92. 五月節 /ngao⁶ ghoih⁸ zoih⁴/ 端午節\n93. 七月半 /cig⁴ ghoih⁸ buan³/ 中元節、鬼節\n94. 八月半 /boih⁴ ghoih⁸ buan³/ 中秋節\n95. 冬節 /dang¹ zoih⁴/ 冬至節的簡稱。\n96. 廿九暝、廿九夜 /rig⁸ gao² mê⁵/ 除夕（小月）\n97. 三十暝、三十夜 /san¹ zab⁸ mê⁵/ 除夕（大月）\n98. 春節 /cung¹ zoih⁴/\n99. 重陽 /ciang⁵ iang⁵/、/dêng⁵ iang⁵/\n100. 國慶節 /gog⁴ kêng³ zoih⁴/\n101. 勞動節 /lao⁵ dong⁶ zoih⁴/\n102. 婦女節 /hu⁶ nng² zoih⁴/\n103. 兒童節 /ri⁵ tong⁵ zoih⁴/\n104. 教師節 /ga³ su¹ zoih⁴/\n105. 做節 /zo³ zoih⁴/ 過節日\n106. 做壽 /zo³ siu⁶/ 過壽辰\n107. 做生日 /zo³ sên¹ rig⁸/ 過生日\n108. 公忌 /gong¹ gi⁷/ 先祖忌日\n109. 拜公忌 /bai³ gong¹ gi⁷/ 在忌日祭拜先祖\n110. 拜祖 // 祭拜先祖\n111. 拜老爺 // 拜神\n112. 假日 /gia² rig⁸/\n113. 放假 /bang³ gia²/、/bang³ gian²/\n114. 暑假 /su² gia²/\n115. 寒假 /hang⁵ gia²/\n\n### 🌀天時(tin¹ si⁵)\n\n1. 晴 /zên⁵/ 晴朗\n2. 出日 /cug⁴ rig⁸/ 太陽出來了\n3. 透堂白日 /tao³ dng⁵ bêh⁸ rig⁸/ 大白天\n4. 烏陰天 /ao¹ im¹ tin¹/ 陰天\n5. 透風 /tao³ hong¹/ 刮大風\n6. 風颱 /hong¹ tai¹/ 颱風\n7. 南風天 /nang¹ hong¹ tin¹/ 刮南風，濕氣加重\n8. 轉南風 /dng² nang¹ hong¹/ 南風天來了\n9. 透南風 /tao³ nang¹ hong¹/ 刮南風，伍佰有一 Live 同名。\n10. 蒙煙天 /mong⁵ iang¹ tin¹/ 霧霾天\n11. 落雨 /lo² hao⁶/ 下雨\n12. 一陣雨 /zêg⁸ zung⁵ hao⁶/\n13. 日頭雨 /rig⁸ tao⁵ hao⁶/ 一邊下雨，一邊出太陽\n14. 烏寒雨 /ao¹ guan⁵ hao⁶/ 天時烏陰落寒雨\n15. 爍焰 /sih⁴ iam⁶/ 閃電\n16. 敲雷 /ka³ lui⁵/ 打雷\n17. 冷空氣 /lêng² kong¹ ki⁷/\n18. 落雪 /lo² soh⁴/ 下雪\n19. 落雹 /lo² pag⁸/ 下冰雹\n20. 旱 /uan⁶/ 乾旱\n21. 寒 /guan⁵/ 寒冷\n22. 冷 /lêng²/ 寒冷\n23. 凝 /ngang⁵/ 寒冷\n24. 熱 /ruah⁸/\n25. 翕熱 /hib⁴ ruah⁸/ 悶熱\n26. 乾燥 /gang¹ cao³/\n27. 濕 /sib⁴/ 濕潤\n28. 涼 /liang⁵/ 涼爽\n\n### 🌛天文(tiang¹ bhung⁵)\n\n1. 天頂 /tin¹ dêng²/ 天上\n2. 日頭 /rig⁸ tao⁵/ 太陽\n3. 蝕日 /sih⁸ rig⁸/ 日食\n4. 狗齧日 /gao² na² rig⁸/ 天狗食日\n5. 西照日 /sai¹ zio³ rig⁸/ 夕陽\n6. 月娘 /ghoih⁸ nion⁵/ 月亮\n7. 月眉 /ghoih⁸ bhai⁵/ 弦月\n8. 蝕月 /sih⁸ ghoih⁸/ 月食\n9. 河溪 /ho⁵ koi¹/ 銀河、天河\n10. 落屎星 /lo² sai² cên¹/ 流星\n11. 星宿 /cên¹ siu³/\n\n### ⛰️地理(di⁷ li²)\n\n1. 中央 /diong¹ iang¹/ 中間\n2. 內底 /lai⁶ doi²/ 裏面\n3. 外口 /ghua⁷ kao²/、/la¹ kao²/ 外面\n4. 頭頂 /tao⁵ dêng²/ 上面\n5. 下跤 /ê⁶ ka¹/ 下面\n6. 下底 /ê⁶ doi²/ 下面\n7. 正手爿 /ziang³ ciu² bain⁵/ 左邊\n8. 倒手爿 /do³ ciu² bain⁵/ 右邊\n9. 頭前 /tao⁵ zain⁵/ 前面\n10. 後底 /ao⁶ doi²/ 後面\n11. 後壁 /ao⁶ biah⁴/ 後面\n12. 對面 /dui³ ming⁷/\n13. 隔壁 /gêh⁴ biah⁴/\n14. 鄰近 /lim¹ ging⁶/\n15. 塗跤 /tao⁵ ka¹/\n16. 番爿 /huang¹ bain⁵/\n17. 北爿 /bag⁴ bain⁵/\n18. 東南西北 /dang¹ nam⁵ sai¹ bag⁴/\n19. 地盤 /di⁷ buan⁵/\n20. 領域 /nia² oig⁸/\n21. 境內 /gêng² lai⁶/\n22. 世界 /si³ gai³/\n23. 宇宙 /u² diu²/\n24. 全球 /cuang¹ giu⁵/\n25. 天涯 /tiang¹ ngai⁵/\n26. 山頂 /suan¹ dêng²/\n27. 山跤 /suan¹ ka¹/\n28. 外地 /ghua⁷ dê³/\n29. 本地 /bng² di⁷/\n30. 別地 /bag⁸ dê³/ 外地\n31. 別地地 /bag⁸ di⁷ dê³/ 外地\n32. 塗 /tao⁵/ 泥\n33. 塗膏 /tao⁵ go¹/ 泥巴\n34. 石頭 /zioh⁸ tao⁵/\n35. 田園 /cang⁵ hng⁵/\n36. 溪墘 /koi¹ gin⁵/ 溪邊\n37. 草埔 /cao² bao¹/ 草坪\n38. 崎 /gia⁶/ 小山坡\n39. 坑 /kên/ 山谷、溪谷。\n40. 嶺 /nia²/ 有路可通的山頂\n41. 岑 /ngim⁵/、/cam⁵/ 小而高的山\n42. 墟 /hu¹/ 大土山\n43. 壩 /ba³/ 沙灘、沙洲。\n44. 潭 /tam⁵/ 深水池\n45. 溪 /koi¹/\n46. 江 /gang¹/\n47. 河 /ho⁵/\n48. 湖 /ao⁵/\n49. 海 /hai²/\n50. 海拔 /hai² buag⁸/\n51. 洲 /ziu¹/\n52. 港 /gang²/\n53. 灣 /uang¹/\n54. 溝 /gao¹/\n55. 渠 /ku⁵/ 水道，特指人工開的河道。\n56. 浦 /pao²/ 水邊或江河入海處\n57. 澳 /o³/ 海邊彎曲且可停泊船隻的地方\n58. 汕 /suan³/ 河流沖刷或沖刷而積成的沙灘\n59. 汕頭 /suan¹ tao⁵/\n60. 汕尾 /suan³ bhoi²/\n61. 海湧 /hai² êng²/ 海浪。湧，波浪。\n62. 東濠湧 /dang¹ hao⁵ cong¹/ 地名，在廣州越秀。濠，溝渠。湧，河流分叉處。\n63. 湧泉相報 /iong³ zuan⁵ siang¹ bo³/ 湧，水冒出。\n64. 庭、埕 /dian⁵/ 院子、宽阔处\n65. 礦物 /kuang³ moih⁸/\n66. 化石 /hoi³ zioh⁸/\n67. 原油 /nguang¹ iu⁵/\n68. 燃料 /riang⁵ liao⁷/\n69. 金屬 /gim¹ siog⁸/\n70. 金銀財寶 /gim¹ nging⁵ cai⁵ bo²/\n71. 鋼鐵 /gng³ tih⁴/\n72. 蘇打 /so³ da²/ 英文 soda 的音譯，常指小蘇打，即碳酸氫鈉。\n73. 蘇州 /sao¹ ziu¹/\n74. 蠟 /la²/\n75. 硫磺 /liu⁵ ng⁵/\n76. 砒霜 /bi¹ sng¹/\n77. 砂石 /sua¹ zioh⁸/\n78. 大理石 /dai⁶ li² zioh⁸/\n79. 碳 /tuan³/\n80. 水銀 /zui² nging⁵/\n81. 水龍水 /zui² lêng⁵ zui²/ 自來水\n82. 地牛換肩 /di⁷ ghu⁵ uang⁷ gain¹/ 地震\n83. 許婆寮 /kao² pua⁵ liao⁵/ 今可和村\n84. 北輋 /bag⁴ sia⁵/ 今博社村\n85. 四捻石 /si³ niam³ zio²/ 四片石\n86. 甲子八景：六十甲子欄、潮來人字水、雙帆跨海島、五馬渡江邊、仙人踏石積、海甲蓮花山、西峯古寺、雷廟天堂。（《陸豐縣誌》卷之二疆域四 P21）\n87. 擎天石：位於甲秀書院的側邊的一塊巨石。《陸豐縣誌》記載：在甲子所北門內峙立聳拔高出雉堞丈余，中開一痕，俗謂雷打石。胡文烜銘其上曰：「天開甲子，巨石臨門，一聲霹靂，振動乾坤 ……」。字大如鬥，余銘苔蝕莫辨。（《陸豐縣誌》卷之二古蹟十二 ）\n88. 甲秀書院：甲秀書院位於陸豐縣甲子鎮北門內。甲秀書院建於明代，歷來為粵東文人會萃講學之所。至今院內仍保存著不少歷代的石碑石刻。解放后，人民政府在此興辦中學。\n89. 福源寺：座落於甲子鎮北郊雨亭路，原名「復元寺」，又稱「蓮花山草庵」。據傳，福源寺建於宋代。因歷史久遠，原址僅遺存牆基。1990年由光茂法師主持重建。經過10多年的建造，先後建成天王殿、大雄寶殿、觀音殿、地藏殿、鐘樓、鼓樓和禪房等，重塑了諸位菩薩聖像。寺區佔地面積1.2萬多平方米，建築面積3000多平方米。\n90. 南海夫人廟：位於甲子鎮城西社區環城路東。明萬曆元年（1573），李棠中舉後爲其妻卓氏而建的紀念祠，御史鄧練題匾「南海夫人」，故稱南海夫人廟。\n91. 烈士墓\n\n### 📐計量(goi³ liang⁶)\n\n1. 〇、零 /lêng⁵/、/lang⁵/\n2. 一、壹 /zêg⁸/、/ig⁴/\n3. 二、贰 /no⁶/、/ri⁶/\n4. 三、叁 /san¹/、/sam¹/\n5. 四、肆 /si³/、/su³/\n6. 五、伍 /ngao⁶/、/u²/\n7. 六、陆 /lag⁸/\n8. 七、柒 /cig⁴/\n9. 八、捌 /boih⁴/、/bag⁴/\n10. 九、玖 /gao²/、/giu²/\n11. 十、拾 /zab⁸/\n12. 百、佰 /bêh⁴/\n13. 千、仟 /cain¹/、/ciang¹/\n14. 萬 /mang⁷/\n15. 億 /êg⁸/\n16. 一二個 /zêg⁸ no² gai⁵/\n17. 二十六 /ri⁸ ab⁸ lag⁸/、/ri⁸ zab⁸ lag⁸/\n18. 廿六號 /rig⁸ lag⁸ ho⁷/ 二十六號\n19. 五十外個 /ngao⁶ zab⁸ ghua⁷ gai⁵/\n20. 一百空八 /zêg⁸ bêh⁴ kang³ boih⁴/ 一百零八\n21. 第一 /doi⁷ ig⁴/\n22. 第二 /doi⁷ ri⁶/\n23. 第三 /doi⁷ san¹/\n24. 一個人 /zêg⁸ gai⁵ nang⁵/\n25. 一爿花 /zêg⁸ bain⁵ hoi¹/ 一片花瓣\n26. 一蕊花 /zêg⁸ lui² hoi¹/ 一朵花\n27. 一葩花 /zêg⁸ pa¹ hoi¹/ 一朵花\n28. 一枝花 /zêg⁸ gi¹ hoi¹/\n29. 一縛花 /zêg⁸ ba² hoi¹/ 一束花\n30. 一叢樹 /zêg⁸ zang⁵ hoi¹/ 一棵樹\n31. 一簇頭毛 /zêg⁸ cog⁴ tao⁵ mo⁵/ 一撮頭髮\n32. 一粒糖 /zêg⁸ liab⁸ tng⁵/\n33. 一隻車 /zêg⁸ ziah⁴ cia¹/ 一輛車\n34. 一架車 /zêg⁸ gê³ cia¹/ 一輛車\n35. 一杯茶 /zêg⁸ boi¹ dê⁵/\n36. 一碗水 /zêg⁸ uan² zui²/\n37. 一喙水、一嘴水 /zêg⁸ cui³ zui²/ 一口水\n38. 一條弓蕉 /zêg⁸ diao⁵ gêng¹ zio¹/ 一條香蕉\n39. 一本書 /zêg⁸ bng² zu¹/\n40. 一枝手機 /zêg⁸ gi¹ ciu² gi¹/ 一隻手機\n41. 一枝鎖匙 /zêg⁸ gi¹ so² si⁵/ 一把鑰匙\n42. 一個銀 /zêg⁸ gai⁵ nging⁵/ 一塊錢\n43. 一領被 /zêg⁸ nia² poi⁶/ 一席被子\n44. 一個鋪 /zêg⁸ gai⁵ pao¹/ 一張床\n45. 一個鐘頭 /zêg⁸ gai⁵ zêng¹ tao⁵/ 一個小時\n46. 一副衫褲 /zêg⁸ hu³ san¹ kao³/ 一套衣服\n47. 一腰裙 /zêg⁸ io¹ gung⁵/ 一件裙子\n48. 一尾魚 /zêg⁸ bhoi² hu⁵/ 一條魚\n49. 一墩物件 /zêg⁸ dung¹ mi² gian⁶/ 一堆東西\n50. 一橛蔗 /zêg⁸ goi² zia³/ 一截甘蔗\n51. 一葩電火 /zêg⁸ pa¹ diang⁶ hoi²/ 一盞電燈\n52. 一跤箸、一腳箸 /zêg⁸ ka¹ du⁷/ 一隻筷子\n53. 一雙箸 /zêg⁸ sang¹ du⁷/ 一雙筷子\n54. 一腹火 /zêg⁸ bag⁴ hoi²/ 一肚子火\n55. 一脬屎 /zêg⁸ bu⁵ sai²/ 一坨屎\n56. 一脬尿 /zêg⁸ bu⁵ rio⁷/ 一泡尿\n57. 一逝路 /zêg⁸ zua⁷ lao⁷/ 一趟路\n58. 一丸塗 /zêg⁸ uang⁵ tao⁵/ 一團泥土\n59. 一過 /zêg⁸ goi³/ 一次\n\n### 🧭 指代(zi² toi³)\n\n1. 只 /zi²/ 這，近指。\n2. 許 /hi²/ 那，遠指。\n3. 者、這 /zê²/、/zia²/ 這，近指。\n4. 遐 /hê²/、/hia²/ 那，遠指。\n5. 底個 /di⁷ gai⁵/ 哪個\n6. 者個 /zê² gai⁷/、/zia² gai⁷/ 這個\n7. 遐個 /hê² gai⁷/、/hia² gai⁷/ 那個\n8. 怎樣 /za³ ion⁷/、/zion²/\n9. 乜樣 /mig⁴ ion⁷/ 怎樣\n10. 底樣 /di⁷ ion⁷/ 怎樣\n11. 怎生 /za³ sên¹/、/zai¹ sên¹/怎樣\n12. 怎樣生 /zion² sên¹/ 怎樣\n13. 怎樣然 /zion² ni⁵/、/zo⁵ ni⁵/ 怎麼、幹啥\n14. 怎樣麼 /zion² mo⁷/、/ziom²/\n15. 者樣 /zê² ion⁷/、/zion¹/\n16. 遐樣 /hê² ion⁷/、/hion¹/\n17. 者樣生 /zion¹ sên¹/ 這樣\n18. 遐樣生 /hion¹ sên¹/ 那樣\n19. 底搭 /di⁷ dah⁴/ 哪裏\n20. 者搭 /zê² dah⁴/ 這裏\n21. 遐搭 /hê² dah⁴/ 那裏\n22. 底地 /di⁷ dê³/ 哪裏\n23. 者地方 /zê² ding¹/ 這裏\n24. 遐地方 /hê² ding¹/ 那裏\n25. 底囝 /di⁷ gian²/ 哪兒\n26. 者囝 /zê gian²/ 這兒\n27. 遐囝 /hê² gian²/ 那兒\n28. 底人 /di⁷ nang⁵/、/diang⁶/、/di⁷ diang⁶/ 誰\n29. 底位 /di⁷ ui⁷/ 哪位\n30. 者位 /zê² ui⁷/\n31. 遐位 /hê² ui⁷/ 那位\n32. 底時 /di⁷ si⁵/ 什麼時候\n33. 底當時 /diang⁶ si⁵/ 什麼時候\n34. 者時 /zê² si⁵/\n35. 遐時 /hê² si⁵/ 那時\n36. 乜事 /mig⁴ su⁷/ 什麼事情\n37. 若㩼 /rioh⁸ zoi⁷/、/rua⁷ zoi⁷/ 多少\n38. 幾 /gui²/\n39. 豈是 /ka³ si⁷/ 是否是\n40. 敢是 /gam² si⁷/ 是否是\n\n### 🏃‍♀️動詞(dong⁶ su⁵)\n\n**第一部分**\n\n1. 會 /oi⁶/\n2. 無會、袂、𠀾 /bhoi⁶/ 不會\n3. 未 /bhoi⁷/ 沒有（事情還沒做）\n4. 無 /bho⁵/ 沒有\n5. 有 /u⁶/\n6. 好 /ho²/\n7. 毋好、孬 /mo²/ 不好\n8. 欲 /bhêh⁴/ 要\n9. 毋、唔 /m⁶/ 不要\n10. 欲毋 /bhêh⁴ m⁶/、/bhên⁶/ 要不要\n11. 愛 /ain³/ 要\n12. 無愛 /bho⁵ ain³/ 不要\n13. 毋愛、勿、嫑 /main³/ 不要\n14. 用 /êng⁶/ 需要\n15. 免 /miang²/ 不需要\n16. 肯 /kêng²/、/kiang²/ 願意\n17. 毋肯 /m⁶ kêng²/、/m⁶ kiang²/ 不願意\n18. 架勢是 /gê³ si³ si⁷/ 看這情形是。例如：舖關了，架勢是去做節了。 \n\n**第二部分 頭、喙**\n\n1. dag⁴ 頭 // 點頭\n2. 搖頭 /io⁵ tao⁵/\n3. 攲頭 /ki¹ tao⁵/ 歪頭\n4. 呾 /dan³/ 說\n5. 參詳 // 商量\n6. 學古 /oh⁴ gao²/ 講故事\n7. 罵 /mê⁷/\n8. 詏 /a³/ 爭辯\n9. 冤家 /uang¹ gê¹/ 吵架\n10. 恬 /diam⁷/ 閉嘴、安靜\n11. 咬 /ga⁶/\n12. 哺 /bao⁷/ 咀嚼\n13. 唵 /am⁶/ 將食物放進嘴巴\n14. 喷 /pung³/ 散射\n15. 啡痰 /pui³ tam⁵/ 吐痰\n16. 歕 /bung⁵/ 吹氣\n17. 嗾？ /zag⁸/ 呛到、岔到 \n\n**第三部分 目、心**\n\n1. 睇 /toi²/ 看\n2. 看詳睇 /kang³ siang⁵ toi²/ 仔細看\n3. 經心 /gêng¹ sim¹/ 用心\n4. 經心衋事 // 操心\n5. 經破頭腦 // 想破頭 \n\n**第四部分 手、跤**\n\n1. 揨 /dian¹/ 觸、碰\n2. 拍 /pah⁴/ 打\n3. 舂 /cêng⁵/ 用力打\n4. /dng⁷/ 打\n5. 刜 /hug⁴/ 揮、打\n6. 剚、倳 /sai⁷/ 打\n7. 抶 /diag⁴/ 用鞭、杖或竹板打。～手\n8. 摔 /sug⁴/ 抽打、鞭打\n9. 拗折 /a² zi²/ 折斷\n10. 盖 /kain³/ 由上往下覆。～頭\n11. 掃 /sao³/ 迅速掠過。～面\n12. 揞 /an¹/ 掩。～面\n13. diu³ 竹囝\n14. 擎 /gia⁵/ 舉、握、拿\n15. 𢭪 /kioh⁴/ 撿、拾\n16. 挈 /kioh⁸/ 取、拿\n17. 摜 /guan⁶/ 提\n18. 厾 /doh⁴/ 戳\n19. 割 /guah⁴/\n20. 殺 /suah⁴/\n21. 斬 /zam²/\n22. 斫 /dog⁴/ 剁\n23. 宰 /zai²/ 殺\n24. 刣 /tai⁵/ 殺\n25. 拭 /cig⁴/ 擦\n26. 濡 /ru⁵/ 用濕布擦或用拖把拖\n27. 爬 /bê⁵/ 搔(癢)\n28. 掊 /boi²/ 扒開\n29. 揂 /ciu⁵/ 拉引繩子\n30. 𠡒 /dui²/ 用力拉\n31. 捏 /dên⁶/ 掐\n32. 漱牙 /ciu³ ghê⁵/ 刷牙\n33. 跋 /buah⁸/ 摔倒\n34. 踏 /dah⁴/ 踩\n35. 踢 /tag⁴/\n36. 去 /ku³/、/ka³/\n37. 轉 /dng²/ 回來\n38. 綴 /doi³/ 跟著；縫合。\n39. 修理 /siu¹ li²/、/su¹ li²/\n40. 泊車 /pag⁴ cia¹/ 停車。泊，粵語音譯英文 park 得來，停車的意思。\n\n**第五部分**\n\n1. 曳、𤆬 /cua⁷/ 帶、領\n2. 娶 /cua⁷/ 取婦\n3. 徙 /sua²/ 移動\n4. 歇 /hiah⁴/ 放置、休息\n5. 煩惱 /huang⁵ lo²/ 擔心\n6. 相信 /sion¹ siang³/、/siang¹ sing⁷/ 相信\n7. 相輔 /sion³ hu⁶/ 幫忙\n8. 排比 /bai⁵ bi²/ 安排\n9. 含包 /ham⁵ bao¹/ 包含\n10. 拚頭前 /bian³ tao⁵ zain⁵/ 爭先\n11. 輸服 /su¹ hog⁸/ 佩服\n12. ䷀䷀ /dag⁴ nng⁷/ 浪費\n13. ䷀落 /ga¹ lao⁵/ 掉落\n14. 沕 /bhih⁴/ 躲藏\n15. 支 /zin¹/ 預付\n16. 圖賴 /tu⁵ tai²/ 耍賴\n17. 放惰 /bang¹ dua⁶/ 懶得\n\n### 🧜‍♀️形容(hêng⁵ iong⁵)\n\n1. 媠 /sui²/ 好、漂亮\n2. 雅 /ngia²/ 正、漂亮\n3. 生好 /sên¹ ho²/ 漂亮、好看\n4. 䆀 /bhai²/ 差、醜陋\n5. 好 /ho²/\n6. 痞、歹 /pai²/\n7. 大細 /dua⁷ soi³/ 大小\n8. 㩼少 /zoi⁷ zio²/ 多少\n9. 加加減減 /gê¹ gê¹ giam² giam²/ 多多少少\n10. 稀罕 // 稀少，罕見。\n11. 賤 /la¹ zuan⁷/ 繁多，低賤。物以稀為貴，多則賤。\n12. 猛慢 /mê² mang⁷/ 快慢、早晚。猛，快。\n13. 肥 /bui⁵/ 胖\n14. 肥腯肥腯 /bui⁵ tuh⁸ bui⁵ tuh⁸/ 胖嘟嘟\n15. 㾪 /sang²/ 瘦\n16. 㾪猴 /sang² gao⁵/ 瘦得跟猴子一樣\n17. 㾪脯皺 /sang² bao² niao³/ 又瘦又缺水又褶皺，形容飢瘦。\n18. 懸下 /guai⁵/ 高低\n19. 早 /za²/\n20. 晏 /uang³/ 晚\n21. 粗 /cao¹/\n22. 幼 /iun³/ 細\n23. 粗殘 /cao¹ cang⁵/ 粗魯\n24. 仔細 /zu² soi⁷/ 小心\n25. 芳 /pang¹/ 香\n26. 臭 /cao³/\n27. 僫 /oh⁴/ 困難\n28. 易 /goi⁷/ 容易\n29. 闊 /kuah⁴/ 寬\n30. 狹 /oih⁸/ 窄\n31. 光 /gng¹/ 亮\n32. 暗 /am³/\n33. 恬 /diam⁷/ 安靜\n34. 吵 /cao¹/ 吵鬧\n35. 吵吵著 /cao¹ cao¹ dioh⁴/ 吵吵鬧鬧的\n36. 飽 /ba²/\n37. 枵 /iao¹/ 餓\n38. 橂 /dain⁷/ 堅實、堅硬\n39. 軟 /nam³/ 軟弱。本字不明，訓用「軟」。\n40. 韌 /rung⁷/ 堅強；不容易斷裂。\n41. 脆 /cê³/ 脆弱；容易斷裂。\n42. 聰明 /cong¹ mêng⁵/\n43. 愚蠢 /ngo⁵ cung²/\n44. 戇 /gong³/ 愚笨\n45. 賰 /cung⁵/ 剩餘\n46. 欠 /kiam³/ 缺少\n47. 清 // 清晰、乾淨\n48. 雾 /bhu⁷/ 模糊\n49. 清氣 /cêng¹ ki³/ 乾淨\n50. 清氣相 /cêng¹ ki³ sion³/ 乾淨的樣子\n51. 垃圾 /lah⁴ sab⁴/ 骯臟\n52. 垃圾相 /lah⁴ sab⁴ sion³/ 骯臟的樣子\n53. 無沙無圾 /bho⁵ sua¹ bho⁵ sab⁴/ 一塵不染\n54. 灱 /da¹/ 乾燥\n55. 㴷 /dam⁵/ 濕潤\n56. 落雨㴷渧 /lo² hao⁶ dam⁵ di³/ 下雨濕漉漉的樣子\n57. 著 /dioh⁸/ 對、正確\n58. 毋著 /m⁷ dioh⁸/ 不對\n59. 錯 /co³/\n60. 熟 /sêg⁸/\n61. 生 /cên¹/ (瓜果等)未成熟\n62. 臭生 /cao³ cên¹/ 未煮熟或瓜果未成熟\n63. 臭酸 /cao³ sng¹/ 食物變質\n64. 黐黐 /ti¹ ti¹/ 黏稠\n65. 切要 /ciag⁴ iao³/ 要緊\n66. 無要緊 /bho⁵ iao³ ging²/ 不要緊\n67. 大扮\n68. 咸澀\n69. 力相 // 努力\n70. 惰 /duan⁶/ 懶惰\n71. 鬧熱 /nao⁶ ria²/ 熱鬧\n72. 活神 // 精神好，灵活\n73. 健 /gian⁷/ 身體好\n74. 碩㦙 /sêg⁴ ngo³/ 聰明和愚蠢\n75. 夠力 /gao³ lag⁸/ 厲害\n76. 夠強 /gao³ kiang³/ 厲害\n77. 夠衰 /gao³ soi¹/ 好慘\n78. 緊要 /ging² iao³/ 要緊\n79. 切要 /ciag⁴ iao³/ 要緊\n80. 癩瘑糜烂 //\n81. 枝毛小節、枝毛細節 // 無關緊要\n82. 偪側 /bêg⁴ cêg⁴/ 心中有氣，煩躁不安。\n83. 生分 /cên¹ hung⁷/ 陌生、疏遠\n84. 無影無跡 // 沒有根據\n85. 一生跪跋 /zêg⁸ sên¹ gui⁶ buah⁸/ 一生坎坷\n\n### 🐴副詞(hu³ su⁵)\n\n1. 好 /hoh⁴/ 表示程度深。例如：好㩼人 // 好多人。\n2. 死 /si²/ 表示程度特別深。例如：死㩼人 // 超級多人。死雅 // 超漂亮的。\n3. 若 /rua⁷/ 多麼。例如：若雅 // 多麼漂亮。\n4. 者 /zia²/ 這麼。例如：者細 // 這麼小。\n5. 遐 /hia²/ 那麼。例如：遐好 // 那麼好。\n6. 上好 /siang⁶ ho²/ 最好。\n7. 上減 /siang⁶ giam²/ 最少。\n8. 上加 /siang⁶ gê¹/ 最多。\n9. 較 /ga³/ 比較地。例如：伊較厲害 // 他比較厲害。\n10. 曾 /bhah⁴/ 曾經。例如：我毋曾來過 // 我不曾來過。\n11. 攏總 /long² zong²/ 全部。例如：攏總 100 銀 // 總共 100 塊。\n12. 煞 /sua⁵/ 竟然。例如：汝煞毋知 // 你竟然不知道。\n13. 顛倒 /ding¹ do³/ 反而。例如：六月顛倒來落雪 // 六月反而下起雪。\n14. 做蜀 /zo³ zêg⁸/ 一起。例如：做蜀 ka³ // 一起去。\n\n### 😲象聲詞(siang⁶ sian¹ su⁵)\n\n1. 喏 /no⁷/ 使人注意某物\n2. 囉、咯 /lo⁷/ 表示事情完成\n3. /hoin⁷/ 呼人\n4. /oin⁷/ 應人\n5. 喂 /uê⁷/ 打招呼。\n6. 啊 /a⁷/ 加強語氣\n7. 呀 /ia⁷/ 表示贊同\n8. 喔、噢 /o⁷/ 表示醒悟、驚訝或了解\n9. 哇 /ua⁷/ 表示驚訝\n10. 嗯 /ng⁷/ 表示同意或了解\n11. 哼 /hng²/ 表示不滿\n12. 哎、噯 /ai⁷/ 嘆氣\n13. 嗐 /hai⁷/ 嘆氣，比「哎」重些。\n14. /ho⁷～/、/o⁷～/ 長吁，含有一種無力、操碎了心的感覺。\n\n### 🙃俗語(siog⁸ ngo²)\n\n1. 哇浪、我卵 /ua² lang⁶/ 哇噻\n2. 我無閒 /ua² bho⁵ ain⁵/ 我沒空\n3. 走街邊 /zao² goi¹ bin¹/ 擺地攤\n4. 汝愛去怎樣麼緊 /lu² ain³ ku³ zion² mo⁷ ging⁷/ 你趕著去幹嗎\n5. 勿者樣生 /mai³ zion¹ sên¹/ 不要這樣\n6. 知收煞 /zai¹ siu¹ suah⁴/ 適時停手\n7. 毋別世代 /m⁶ bhag⁴ si³ dê³/ 不懂事\n8. 無變 /bho⁵ biang³/ 沒有辦法\n9. 堵著無變 /du² dioh⁴ bho⁵ biang³/ 碰到沒有辦法\n10. 無理路 /bho⁵ li² lao⁷/ 無道理。路，道。\n11. 無奈何 /bho⁵ da¹ ua⁵/ 無可奈何\n12. 無奈寫作不得已 /bho⁵ nai⁶ sia² zo³ bug⁴ dêg⁴ in²/ \n13. 呾死無會變 /dan⁵ si² bhoi⁶ bin³/ 冥頑不靈\n14. 橂過石部 /dain⁷ goi³ zio² bao⁶/ 比石頭還硬\n15. 三斗油麻倒無一粒落耳 /san¹ dao² iu⁵ mua⁵ do³ bho⁵ zêg⁸ liab⁴ lo² hin⁶/ 怎麼說都聽不進去\n16. 瀉衰人 /sia³ soi¹ nang⁵/ 丟人、令人蒙羞\n17. 見笑 /giang³ siao³/ 丟人、令人蒙羞\n18. 雙目囥著褲底 /sang¹ mag⁸ kng³ dioh⁴ kao³ doi²/ 看不見\n19. 無目睇 /bho⁵ mag⁸ toin³/ 不想看\n20. 鴨囝聽雷 /ah⁴ gian² tian¹ lui⁵/ 聽不懂\n21. 戅過隻鴨 /gong⁵ goi³ ziah⁴ ah⁴/ 比鴨子還戇\n22. 一樣糜飯飼千外樣人 /zêg⁸ ion⁷ moi⁵ bng⁷ ci⁷ cain¹ ghua⁷ ion⁷ nang⁵/ 社會人各種各樣\n23. 暗過魂宫 /am³ goi³ hung⁵ gêng¹/ 比陰間還暗\n24. 三更想，半暝反 /san¹ gên¹ sion⁶, buan³ mê⁵ huang²/ 思來想去，反反覆覆。\n25. 過跤事知歇 /goi¹ ka¹ su⁷ zai¹ hiah⁴/ 過去的事情就不要計較了\n26. 無會少禮 /bhoi⁶ siao² li²/ 不害臊\n27. 刣雞教猴 /tai⁵ goi¹ ga³ gao⁵/ 殺雞儆猴\n28. 勞生拚死 /lu⁵ sên¹ bian³ si²/ 拚死拚活\n29. 食呾會，躕人強 /ziah⁸ dan³ oi⁶, du⁵ nang⁵ kiang³/ 能吃會說還很頑皮\n30. 勿踟躕我 /mai³ di¹ du⁵ ua⁷/ 別纏我，使得我不知所措。\n31. 老過伯爺 /lao⁶ goi³ bêh⁴ ia⁵/ 比土地公還年長\n32. 平樣平樣 /pên⁵ ion⁷ pên⁵ ion⁷/ 一模一樣\n33. 假力洗茶渣 /gê² lag⁸ soi² dê⁵ za¹/ 該做的不做，做了不該做的。\n34. 死無命凝 /si² bho⁵ mian⁷ ngang⁵/ 冷死了\n35. 富到流油 /bu⁷ gao³ lao⁵ iu⁵/ 很富有\n36. 人熟禮毋熟 /nang⁵ sêg⁸ li² m⁶ sêg⁸/ 雖然人很熟，但還是要講禮。\n37. 熟人免行生禮 /sêg⁸ nang⁵ miang² gian⁵ cên¹ loi²/\n38. 千人千般苦，無人苦平樣 /cain¹ nang⁵ cain¹ buan¹ kao², bho⁵ nang⁷ kao² pên⁵ ion⁷/ 各有各的煩惱\n39. 蟹有橂奅，人有碩㦙 /hoi⁶ u⁶ dain⁷ pan³, nang⁵ u⁶ sêg⁴ nga³/ 有人聰明有人愚笨。橂，堅實。奅，中空。碩，學問高、聰明。㦙，愚笨。\n40. 鳥飛會落毛，人行有跤跡 /ziao² boi¹ oi⁶ lo² mo⁵, nang⁵ gian⁵ u⁶ ka¹ ziah⁴/ 做過了的事總會留痕跡\n41. 客情好過吊頷鬼 /kêh⁴ cêng⁵ ho² goi³ diao³ am⁶ gui²/ 吊死鬼熱情地勸人上吊好代替自己，比喻虛情假意。\n42. 貓兒無葷無著茨，鴨囝無粟無會過暝 /ngiao¹ ri⁵ bho⁵ hung¹ bho⁵ dioh⁴ cu⁷, ah⁴ gian² bho⁵ cêg⁴ bhoi⁶ goi³ mê⁵/ 小貓沒有葷菜就不在家，小鴨沒有稻粒就不過夜。\n43. 衰雞無會食粟 /soi¹ goi¹ bhoi⁶ ziah⁸ cêg⁴/ 如病雞般吃不下飯\n44. 無會死大破相 /bhoi⁶ si² dua⁷ pua³ sion³/ 不死也會頭破血流\n45. 十八棚頭做到透 /zab⁸ boih⁴ bên⁵ tao⁵ zo³ gao³ tao³/ 指每種事都嘗試，貶義。十八棚頭，指十八齣溫州南戲。\n46. 無跤蟹 /bho⁵ ga¹ hoi⁶/ 孤立無援\n47. 大細目 /dua⁷ soi³ mag⁸/ 偏心\n48. 平安當大趁 /pêng⁵ ang¹ dng¹ dua⁷ tang⁷/ 平安無疾就當作是大賺一筆了\n49. 大人彎，孥囝直 /dua⁷ nang⁷ uain¹, nao⁵ gian² dig⁸/ 大人說話拐彎抹角，小孩子則是直來直去。\n50. 錢囝毋使使大錢 /zin⁵ gian² m⁶ sai² sai² dua⁷ zin⁵/ 小錢不花，久了就得要花大錢了。\n51. 未學行，先學飛 /bhoi⁷ oh⁸ gian², sain¹ oh⁸ boi¹/ 還沒學走路就要學飛了，基礎未打好。\n52. 一人主張，毋如二人參詳 /zêg⁸ nang⁷ zu² ziang¹, m⁶ ru⁵ no⁶ nang⁷ cam¹ ciang⁵/ 自作主張不如多個人一起商量\n53. 通街市獵無 /tong¹ goi¹ ci⁶ lah⁸ bho⁵/ 整條街都找不到。獵，尋找。\n54. 喙尖舌囝利 /cui³ ziamvi/ 牙尖嘴利\n55. 九月狗吶日，無用諸娘理毋直 /gao² goi² gao² nah⁴ rig⁸, bho⁵ êng⁷ zu¹ nion⁵ li² m⁶ dig⁸/ 九月份開始晝短夜長，沒用的婦女家務事搞不定了。\n56. 茶薄人情厚，茶厚有禮貌 /dê⁵ bo² nang⁵ cêng⁵ gao⁶, dê⁵ gao⁶ u⁶ li² mao⁶/\n57. 三十歲無妻是孩童 /san¹ zab⁸ hoi³ bho⁵ ci¹ si⁶ hai⁵ tong⁵/\n58. 目汁是財，愈哭愈來 /mag⁸ zab⁴ si⁶ cai⁵, ru² kao³ ru⁶ lai⁵/\n59. 呾破無酒食 /dan³ pua³ bho⁵ ziu² ziah⁸/ 師傅教徒弟，徒弟設酒宴款待，師傅酒後授予秘方。之後徒弟不再宴請師傅。\n60. 軟過豆腐 /nam³ goi³ dao⁷ hu⁷/\n61. 車大炮 /cia¹ dua⁷ pao³/ 吹牛\n62. 樹大分椏，囝大分家 /ciu⁷ dua⁷ bng¹ a¹, gian² dua⁷ bng¹ ga¹/ \n63. 閒過仙 /ain⁵ goi³ siang¹/ 比神仙還閒\n64. 雙目望無一寸長 /sang¹ mag⁸ mo⁷ bho⁵ zêg⁸ cung³ dng⁵/ 鼠目寸光\n65. 一鼠二牛三虎四兔五龍六蛇七馬八羊九猴十雞十一狗十二豬 /ig⁴ cu² ri⁶ ghu⁵ san¹ haon² si³ tao³ ngao⁶ lêng⁵ lag⁸ zua⁵ cig⁴ bhê² boih⁴ ion⁵ gao² gao⁵ zab⁸ goi¹ zab⁸ ig⁴ gao² zab⁸ ri⁶ du¹/\n66. 差豬差狗，不如家己走 /cê¹ du¹ cê¹ gao², bug⁴ ru⁵ ga¹ gi⁷ zao²/ 求人不如求己\n67. 後生擔石，老人食藥 /hao⁶ sên¹ dan¹ zioh⁸, lao⁶ nang⁵ ziah⁸ ioh⁸/ 年少積勞，年老吃藥\n68. 疑心生暗鬼 /ghi⁵ sim¹ sên¹ am³ gui²/ 因多疑而產生各種幻覺和錯誤判斷\n69. 羊尾短短，遮毋著羊尻川 /ion⁵ bhoi² dê² dê², zia¹ m⁶ dioh⁴ ion⁵ ka¹ cng¹/ 自己的缺點尷尬能自己找個遮醜的就很好了，別去取笑別人的不堪。\n70. 愛母著刻苦 /ain³ bhao² dioh⁴ kag⁴ kao²/ 要老婆就要努力了\n71. 無好家神通外鬼 /bho⁵ ho² gê¹ sing⁵ tong¹ ghua⁷ gui²/\n72. How do you do，好事來堵 /hao³ su⁷ lai³ du²/ 嗨，要搞事情我不怕你。好事，喜歡搞事情。堵，應對、抵抗。\n73. 秋瓜棚下無好人 /ciu¹ goi¹ bên⁵ ê⁶ bho⁵ ho² nang⁵/ 秋瓜，絲瓜。\n74. 三跤椅囝毋知䆀 /san¹ ka¹ in² gian² m⁶ zai¹ bhai²/ 坐著少了一腿的椅子竟然不知道壞了，比喻身處困境而不自知。\n\n### 🤣歇後語(hiah⁴ ao⁶ ngo²)\n\n1. 柴目狗耳 — 假靈 /ca⁵ mag⁸ gao² hin⁶ — gê² lêng⁵/ 目雕的眼睛看不見，狗一般耳朵卻很靈，聽風是雨。\n2. 雞跤長鴨跤短 — 有懸下 /goi¹ ka¹ dng⁵ ah⁴ ka¹ dê² — u⁶ guain⁵ gê⁶/ 雞腳長，鴨腳短，有高有矮。\n3. 爐底碳 — 塊塊通 /lao⁵ doi² tuan³ — dê⁷ dê⁷ tang³/ 百事通\n4. 孥囝食奶 — 坐亭 /nao⁶ gian² ziah⁸ nê¹ — zê⁶ dêng⁵/ 亭，直。\n5. 菜頭面刺無血 — 面皮厚 /cai³ tao⁵ ming¹ ci³ bho⁵ hoih⁴ — ming¹ poi⁵ gao⁶/\n6. 褪褲放屁 — 假工夫 /tng³ kao³ bang³ pui³ — gê² gang¹ hu¹/\n7. 竹葉包沙 — 假壯 /dêg⁴ hio² bao¹ sua¹ — gê² zang³/ 壯，與「粽」諧音。\n8. 元宵燈籠 — 一肚火 /nguang⁵ siao¹ dêng¹ lang⁵ — zêg⁸ dao² hoi²/\n9. 半天吊燈籠 —四搭无向 /buan³ tin¹ diao³ dêng¹ lang⁵ — si³ dah⁴ bho⁵ hiang³/\n10. 青暝睒鏡 — 無望 /cên¹ mên⁵ iam² gian³ — bho⁵ mo⁷/\n11. 青暝睇天 — 張樣張相 /cên¹ mên⁵ toi² tin¹ — dion¹ ion⁷ dion¹ sion⁷/\n12. 青暝點燈 — 照舊 /cên¹ mên⁵ diam² dêng¹ — zio³ gu⁷/ 對青暝人來說，點不點燈，一切照舊。\n13. 青暝掠魚 — 散摸 /cên¹ mên⁵ liah⁸ hu⁵ — suan³ mong⁵/\n14. 青暝娶母 — 稱重 /cên¹ mên⁵ cua⁷ bhao² — cing³ dang⁶/\n15. 青暝擎手電 — 各人各人善 /cên¹ mên⁵ gia⁵ ciu² diang⁶ — gag⁴ nang⁵ gag⁴ nang⁵ siang⁶/\n16. 青暝睇電影 — 聽聲 /cên¹ mên⁵ toi² diang⁶ ian² — tian¹ sian¹/\n17. 啞人食苦瓜 — 有苦難言 /ê² nang⁵ ziah⁸ kao² goi¹ — u⁶ kao² nang⁵ ngiang⁵/\n18. 啞囝食黃連 — 有苦難言 /ê² gian² ziah⁸ ng⁵ nain⁵ — u⁶ kao² nang⁵ ngiang⁵/\n19. 閻羅王嫁諸母囝 — 鬼正敢愛 /ngiam⁵ lo⁵ uang⁵ gê³ za¹ bhao² gian² — gui² zian³ gan² ain³/\n20. 閻羅王請人 — 鬼正敢食  /ngiam⁵ lo⁵ uang⁵ cian² nang⁵ — gui² zian³ gan² ziah⁸/\n21. 閻羅王賣假貨 — 騙鬼 /ngiam⁵ lo⁵ uang⁵ bhoi⁷ gê² hoi⁷ — piang³ gui²/\n22. 閻羅王出告示 — 無句人話 /ngiam⁵ lo⁵ uang⁵ cug⁴ go³ si⁷ — bho⁵ gu³ nang⁵ oi⁷/\n23. 鬼簿無名 — 免死 /gui² pao⁶ bho⁵ mian⁵ — miang² si²/\n24. 醫生開了棺材舖 — 死活都愛錢 /ui¹ sên¹ kui¹ liao² gua¹ ca⁵ pao⁷ — si² ua² do¹ ain³ zin⁵/\n25. 身長棺材短 — 屈死人 /sing¹ dng⁵ gua¹ ca⁵ dê² — kug⁴ si² nang⁵/\n26. 棺材頭畫老虎 — 驚死人 /gua¹ ca⁵ tao⁵ oi⁷ lao⁶ haon² — gian¹ si² nang⁵/\n27. 歪喙和尚 — 唸無一句正經 /uain¹ cui³ hoi⁵ sion⁷ — niam⁷ bho⁵ zêg⁸ gu³ zian³ gêng⁵/\n28. 師公和尚 — 毋同道 /sai¹ gong¹ hoi⁵ sion⁷ — m⁶ dang⁵ dao⁶/\n29. 和尚抹粉 — 白勞 /hoi⁵ sion⁷ bhuah⁴ hung² — bêh⁸ lu⁵/ 勞，與「驢」諧音。\n30. 和尚擎雨遮 — 無法無天 /hoi⁵ sion⁷ gia⁵ hao⁶ zia¹ — bho⁵ huab⁴ bho⁵ tin¹/ 法，與「髮」諧音。\n31. 橄欖尻川 — 坐毋恬 /gan¹ na² ka¹ cng¹ — zê⁶ m⁶ diam⁷/ 屁股像橄榄一般尖，坐不住。恬，静、定。\n32. 火燒豬頭 — 熟面熟面 /hoi² sio¹ du¹ tao⁵ — sêg⁸ ming⁷ sêg⁸ ming⁷/\n33. 六月芥菜 — 假有心 /lag⁸ ghoih⁸ gua³ cai³ — gê² u⁶ sim¹/\n34. 十月芥菜 — 大䀌心 /zab⁸ ghoih⁸ gua³ cai³ — dua⁷ gêg⁴ sim¹/ 䀌，與「激」諧音。\n35. 六月蕃薯 — 雙死 /lag⁸ ghoih⁸ huang¹ zu⁵ — sang¹ si²/ 雙，與「鬆」諧音。\n36. 阿媽生諸母囝 — 生菇 /a¹ ma² sên¹ za¹ bhao² gian² — sên¹ gao¹/ 生菇，發霉。菇，與「姑」諧音。\n37. 老人跤纏 — 又長又臭 /lao⁶ nang⁵ ka¹ din⁵ — ui⁶ dng⁵ ui⁶ cao³/ 講話囉嗦像老人纏足一樣\n38. 老人食豬跤 — 試味 /lao⁶ nang⁵ ziah⁸ du¹ ka¹ — ci³ bhi⁷/ 嘗試下而已\n39. 老婆跋落水 — 淒涼 /lao⁶ pua⁵ buah⁸ lo² zui² — ci¹ liang⁵/ 跋，絆倒。淒，與「妻」諧音。\n40. 老婆其阿兄 — 痴哥 /lao⁶ pua⁵ gai⁵ a¹ hian¹ — ci¹ go¹/ 痴，與「妻」諧音。\n41. 菜頭粿熱單爿 — 自作多情 /cai³ tao⁵ goi² riah⁸ duan¹ bain⁵ — zu⁶ zag⁴ do¹ cêng⁵/ 菜頭粿，蘿蔔糕。热单爿，切片下鍋油煎，但只煎單邊，上焦下嫩。一頭熱（悅），單戀。\n42. 龍眼核拭尻川 — 賽道行 /nging¹ ain² hug⁸ cih⁴ ka¹ cng¹ — sai³ dao⁶ hang⁵/ 「龍眼核拭尻川」比喻有難度的事情，看各家誰本領強了。\n43. 水仙不開花 — 裝蒜 /zui² siang¹ bug⁴ kui¹ hoi¹ — zng¹ sng³/\n44. 大炮拍麻雀 — 騙伊驚 /dua⁷ pao³ pah⁴ mua⁵ ziah⁴ — piang³ i¹ gian¹/\n45. 有錢買蠓香，無錢買蠓罩 — 會算無會除 /u⁶ zin⁵ bhoi² mang² hion¹, bho⁵ zin⁵ bhoi² mang² dan³ — oi⁶ sng³ bhoi⁶ du⁵/\n46. 天頂滴鳥屎 — 無好相覓 /tin¹ dêng² dig⁴ ziao² sai² — mo² sion¹ coi⁷/\n47. 六月薄殼 — 假大頭 /lag⁸ ghoih⁸ boh⁸ kag⁴ — gê² dua⁷ tao⁵/ 大頭，一種比薄殼略大的小貝類海鮮。假大頭，愛充大頭。\n48. 七角錢二人分 — 毋三毋四 /cig⁴ gag⁴ zin⁵ no⁶ nang⁵ bng¹ — m⁶ san¹ m⁶ si³/\n49. 十二碗圓食賰一粒 — 假客氣 /zab⁸ ri⁶ liab⁸ in⁵ ziah⁸ cung⁵ zêg⁸ liab⁸ — gê² kêh⁴ ki⁷/ 圓，丸子。賰，剩下。\n50. 狗母蛇 — 假靈 /gao² bho² zua⁵ — gê² lêng⁵/ 靈，與「龍」諧音。\n51. 兄獨目弟缺喙 — 大無好樣，細無好相 /hian¹ dog⁸ mag⁸ di⁶ koih⁴ cui³ — dua⁷ bho⁵ ho² ion⁷, soi³ bho⁵ ho² sion³/\n52. 山螟咬尾 — 食家己 /suan¹ mê¹ ga⁶ bhoi² — ziah⁸ ga¹ gi⁷/\n53. 風吹牆頭草 — 就勢倚勢 /hong¹ coi¹ ciong⁵ tao⁵ cao² — ziu⁶ si³ ua² si³/\n54. 老鼠跋落粟倉 — 倒好 /ngiao² cu² buah⁸ lo² cêg⁴ cng¹ — do³ ho²/\n55. 老鼠心肝 — 頭食頭搬 /ngiao² cu² sim¹ guan¹ — tao⁵ ziah⁸ tao⁵ buan⁵/\n56. 孥囝拍炮 — 又驚又好 /nao⁵ gian² pah⁴ pao⁷ — ui⁶ gian¹ ui⁶ hao⁷/\n57. 五行缺一 — 欠金 /ngao⁶ hêng⁵ koih⁴ ig⁴ — kiang³ gim¹/\n58. 茂生進酒 — 厚情 /mao⁶ sêng¹ zing³ ziu² — gao⁶ cêng⁵/\n59. 食人雞肉還人豬肉 — 物來物去 /ziah⁸ nang⁷ goi¹ nê² hain⁵ nang⁷ du¹ nê² — moih⁸ lai⁵ moih⁸ ko³/\n60. 刀截蕹菜 — 二頭空 /do¹ zoi² êng³ cai³ — no⁶ tao⁵ kong¹/\n61. 三個半錢 — 趕勢 /san¹ gai⁵ buan³ zin⁵ — guan² si³/ 勢，與「四」諧音。\n62. 隔暝皇帝 — 無權勢 /gêh⁴ mê⁵ huang⁵ di⁷ — bho⁵ kuang⁵ si³/\n63. 大肚水蛙 — 假鮭 /dua⁷ dao² zui² goi¹ — gê² guai¹/ 水蛙，青蛙。鮭，河魨。\n64. 五月龍船 — 相鬥 /ngao⁶ ghoih⁸ lêng⁵ zung⁵ — sion¹ dao³/\n65. 燈籠照路 — 目前光 /dêng¹ lang⁵ zio³ lao⁷ — mag⁸ zain⁵ gng¹/ 比喻目光短淺\n66. 暗室穿針 — 難過 /am³ sig⁴ cng¹ zam¹ — nang⁵ goi³/\n67. 嫁諸母囝娶新婦 — 出入平安 /gê³ za¹ bhao² gian² cua⁷ sing¹ bu⁶ — cug⁴ rib⁸ pêng⁵ ang¹/ 安，與「翁」諧音。\n68. 過關送文憑 — 做人情 /goi³ guan¹ sang³ bhung⁵ pêng⁵ — zo³ nang⁵ zian⁵/\n69. 火燒草料場 — 事出有因 /hoi² sio¹ cao² liao⁷ dion⁵ — su⁷ cu⁷ u⁶ ing¹/ 因，與「煙」諧音。\n70. 黑白電視 — 無彩 /hêg⁴ bêh⁸ dian⁶ si⁶ — bho⁵ cain²/ 無彩，可惜。\n71. 小郎遇著雨 — 積惡 /sio² nng⁵ ngo⁶ dioh⁴ hao⁶ — zêg⁴ ag⁴/ 小郎，女子稱呼丈夫的弟弟。積惡，可憐；罪惡。積，與「叔」諧音。惡，與「沃」諧音。\n\n### 🙂禮貌用語(li² mao⁶ êng³ ngo²)\n\n1. 汝食饱未 /lu² ziah⁸ ba² bhoi⁷/ 你吃飽了嗎\n2. 汝愛去底地 /lu² ain³ ku³ di⁷ dê⁷/ 你要去哪裏\n3. 汝好 /lu² ho²/ 你好\n4. 㩼謝 /zoi⁷ sia⁷/ 多謝\n5. 寬行 /kuan¹ gian⁵/ 慢走\n6. 寬駛 /kuan¹ sai²/ 慢點開車\n7. 对毋住 /dui³ m⁶ zu⁶/ 对不起\n8. 对毋起 /dui³ m⁶ ki²/ 对不起\n9. 無相干 /bho⁵ siang¹ gang¹/ 沒關係\n10. 毋知頭 /m⁶ zai¹ tao⁵/ 不是故意的\n11. 先這呾 /sain¹ zion² dan³/ 回頭再聊 \n12. 萬事應想 /mang⁷ su⁷ êng³ sion⁶/ 萬事如意\n13. 生理大趁 /sêng¹ li² dua⁷ tang⁷/ 生意興隆\n14. 新年大趁 /sing¹ ni⁵ dua⁷ tang⁷/ 新年大賺\n15. 新年合想 /sing¹ ni⁵ gah⁴ sion⁶/ 新年如意\n16. 大吉大利 /dai⁶ gig⁴ dai⁶ li⁶/\n\n### 🤐粗話(cao¹ oi⁷)\n\n1. 咒誓 /ziu³ zua⁷/ 發誓、詛咒\n2. 痟 /siao²/ 神經錯亂\n3. 神經 /sing⁵ gêng¹/\n4. 腦孬 /nao² mo³/ 腦子壞了\n5. 破脑囝 /puah⁸ nao² gian²/ 弱智\n6. 肚痛 /dao² tian³/ 「問候」別人是否肚子痛所以一直在叫。\n7. 鬼叫 /gui² gio⁷/ 「問候」別人是否聽到鬼在叫。\n8. 哭 cang¹ 哭 nain⁵ // 又哭又喊，吵死人了。\n9. 哭父死母 /kao³ bê⁶ si² bho²/ 「問候」別人是否父母過世所以一直在哭叫。\n10. 咋死人 /zag⁴ si² nang⁵/ 吵死了\n11. 鬼囝 /gui² gian²/ 小鬼\n12. 鬼卒囝 /gui² zug⁴ gian²/ 小鬼\n13. 鬼然然 /gui² riang⁵ riang⁵/ 像鬼一樣\n14. 鬼囉作禍 /gui² lo⁷ zo³ ho³/ 鬼在作祟、作怪\n15. 妖怪精 /iao¹ guai³ zian¹/\n16. 去死掉掉 /ku³ si² diao³ diao³/\n17. 散哭父 /suan⁷ kao³ bê⁶/ 散，到處。\n18. 吐屎 /tao³ sai²/ 亂說\n19. 卵屎人 /lang⁶ sai² nang⁵/ 屌絲，沒前途的人。\n20. 卵屎話 /lang⁶ sai² oi⁷/ 廢話\n21. 臭喙卵面 /cao³ cui³ lang⁶ ming⁷/ 亂說、討人厭。\n22. 關汝卵事 /guang¹ lu² lang⁶ dai⁷/ 與你何干\n23. 膣精 /zi¹ zian¹/ 多管閒事\n24. 臭膣 /cao³ zi¹/ 臭婊子\n25. 豺狗 /sai² gao²/ 狗腿子\n26. 怪卵 /guai³ lang⁶/ 古怪\n27. 無卵 /bho⁵ lang⁶/ 沒膽量\n28. 無腦 /bho⁵ nao²/ 沒腦子\n29. 𠀾好 /bhoi⁶ ho²/ 咒別人倒霉\n30. 痞囝 /pai² gian²/ 痞子、流氓。\n31. 肏母囝 /pu² bho² gian²/\n32. 早死囝 /za² si² gian²/\n33. 短命囝 /dê² mian⁷ gian²/、/dêng² mian⁷ gian²/\n34. 破家囝 /pua⁷ gê¹ gian²/ 败家子\n35. 內仙囝  /lai⁶ siang¹ gian²/ 難伺候\n36. 十惡囝 /zab⁸ ag⁴ gian²/ 十惡不赦\n37. 棺材囝 /gua¹ ca⁵ gian²/\n38. 痴哥囝 /ci¹ go¹ gian²/ 色狼\n39. 吐血死囝 /tao³ hoih⁴ si² gian²/\n40. 替人死囝 /toi⁵ nang⁵ si² gian²/\n41. 半路死囝 /buan³ lao⁷ si² gian²/\n42. 祭屎祭䷀ /zi³ sai² zi³ hê⁷/ 亂吃東西\n43. 乞鬼侵著 /koh⁴ gui² cin⁵ dioh⁴/ 鬼上身了。乞，給。侵，本讀 /cim⁵/，音變爲 /cin⁵/，附身。\n\n### 🧨娛樂(ngo⁵ log⁸)\n\n1. 耍遊戲 /sng² iu⁵ hi³/ 玩遊戲\n2. ䷀箭 /diong³ zin³/ 射箭\n3. ䷀珠 /diong³ zu¹/ 打彈珠\n4. 彈槍 /duan⁷ ciong¹/ 開槍\n5. 跳索 /tiao³ soh⁴/ 跳繩\n6. 踏孔 /dah⁸ kong²/ 捉迷藏\n7. 泅水 /siu⁵ zui²/ 游泳\n8. 釣魚 /dio³ hu⁵/\n9. 掠魚 /liah⁸ hu⁵/ 抓魚\n10. 行棋 /gian⁵ gi⁵/ 下棋\n11. 放風箏 /bang³ hong¹ zêng¹/\n12. 拍連炮 /pah⁴ liang⁵ pao³/ 放鞭炮\n13. 扣人囝 /kob⁴ nang⁵ gian²/ 人囝，也叫公仔紙、洋畫，舊時供兒童玩樂用的紙牌。\n14. 沃花 /ag⁴ hoi¹/ 澆花\n15. 做戲 /zo³ hi³/ 演戲劇\n\n### ⛩ 神明(sing⁵ mêng⁵)\n\n1. 天地父母 // 天地，原始信仰。\n2. 月娘 // 月球，原始信仰。\n3. 媽祖 // 原名林默，南海保護神，在甲子天后宮有供。\n4. 七聖娘 // 又稱七星娘娘、七聖夫人，是織女神分化出的七位仙女，是兒童保護神。\n5. 觀音娘 // 觀音菩薩\n6. 慈悲娘 // 即普悲觀音，觀音菩薩化身之一（傳說觀音菩薩有三十三化身），普遍施給眾生慈悲。\n7. 註生娘 // 全稱「大慈大悲救苦救難送子娘娘」，主管懷孕與生育。\n8. 佛祖 // 釋迦牟尼佛，姓喬達摩，名悉達多，古印度思想家、教育家、宗教改革家，佛教的創始人。\n9. 達摩祖師 // 南天竺人或波斯人，將佛教禪宗帶入中國，爲中國禪宗之開創者。\n10. 元天上帝 // 玄武大帝，象徵北極星與二十八宿中的北宮玄武，爲統理北方之道教大神。\n11. 水仙大帝 // 水仙尊王，海神之一，媽祖的從神之一。\n12. 汾陽王帝 // 郭子儀，華州鄭縣（今陝西渭南市華州區）人，唐朝名將，平定安史之亂，封汾陽郡王。此人富貴壽考，權極一時，甲子天后宮媽祖廟有供之。\n13. 王公 // 指隴尾王爺、王爺公，名鄒普勝，麻城花橋（今屬湖北）人，元末農民起義軍將領，陳友諒軍師。朱元璋建立明朝後流浪到甲子地區，爲甲子地區改造「風水」等，今甲子隴尾王爺廟有供之，大年初四在此求「落馬簽」。\n14. 關公 // 關羽，河東郡解縣（今山西省運城市鹽湖區解州鎮）人，三國時期名將，與劉備、張飛桃園三結義。又稱伽藍老爺、伽藍尊者，是寺廟、道場守護神，也有稱之爲武財神。\n15. 八仙公 // 傳說中的八位仙人，爲漢鍾離、張果老、韓湘子、鐵拐李、曹國舅、呂洞賓、藍采和、何仙姑八人。\n16. 伯公 // 福德老爺、土地公。\n17. 五穀公 // 神農大帝，相傳其發明耒耜，教民耕種五穀，並能以百草為民治病。農曆十月十五拜之。\n18. 城隍公 // 古代城鎮保護神。\n19. 皇帝公 // 南宋小皇帝趙昰，曾流亡到甲子待渡山。\n20. 灶公 // 灶君，主掌廚房和飲食的神。\n21. 百姓公 // 無主死者，集中掩埋於百姓公墓，稱爲百姓公(媽)，其中多喪於 1943 年的大飢荒，其時僅甲子一鎮亡者就近 2 萬人，慘絕。\n22. 地主爺 // 住宅的守護靈。\n23. 財神爺 // 常指陝西終南山的玄壇真君趙公明，也指關聖帝君關羽。\n24. 三山國王 // 指現揭西縣河婆鎮北面的三座山——巾山、明山、獨山的三位山神。\n\n## 風俗(hong¹ sioh⁸)\n\n1. 大年初一：食齋菜（菠薐菜、粉絲、菜頭丸、豆腐乾）。\n2. 人日(正月初七)：食七樣菜（厚合、蒜仔、芥藍、高麗菜、真珠菜、香菜、大菜芯）。\n3. 元宵(正月十五)：食蔗。\n4. 三月初三：食青草飯（雞屎藤、伸筋藤、苦刺心、臭草心、蠟裏葉、四方枝苦楝葉）。\n5. 清明：食硬殼餅，掃墓掛紙。\n6. 佛誕(四月初八)：食飯茶。\n7. 端午：食梔粽、梔粿，洗午時水。\n8. 七月初七：出花園。\n9. 中秋：食月餅、芋頭、蔗。\n10. 重陽(九月初九)：食雞湯。\n11. 冬節：食冬節丸、羊肉。\n12. 三十夜、廿九夜：食團圓飯、送壓腰錢（dêh⁴ io¹ zin⁵, 壓歲錢）。\n\n## 歷史(lêg⁸ su²)\n\n1. 甲子的名號是因爲港後有六十塊大石頭，應了干支紀年法一甲子的數目，故名。\n2. 漢文帝時曾派遣大臣陸賈（約公元前240年～公元前170年）到南越國，期間命令將士調查海岸線，到過甲子門。\n3. 三國時，吳侯孫權派遣將軍衛溫（？～231年）攻打福建、琉球和台灣（夷州），被風雨刮到甲子門。\n4. 南宋乾道五年(1169)，承奉郎致仕范有仁建順濟橋，橋從大膽山腳(今東宮社轄區)跨越瀛江到後庭（今甲東鎮雨亭村轄區）。\n\n    ![順濟橋（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）](gahzi-oi-hung-lui-ci-biao/Untitled%2084.png)\n\n5. 宋嘉定甲申年(1224)，南宋承奉郎范良臣（范有仁之孫）登腹石山，因山對面可見甲子門奇石十八，屹立如人，遂刻「登瀛」二字於石，取十八學士登瀛洲之義。\n6. 1276 年，元兵攻陷南宋京城臨安，南宋擁立幼帝趙昰，從福州乘船經福建沿海入廣東，於冬十二月抵甲子門腹石山（後人爲紀念此事，更山名爲待渡山），范良臣給軍食三日，留帝像登瀛石上。\n7. 1277 年正月，漁民鄭復組織義兵509人乘船護送宋帝昺及隨臣去崖門。途中在現珠海橫琴島和澳門與元兵相遇，十六日宋室全軍覆滅，陸秀夫背幼帝昺投海自盡，鄭復等在激戰中全部士兵犧牲。\n8. 明永樂六年(1408)，順濟橋被拆。因「指揮花茂奉旨建甲子所，慮倭寇泊海易渡，拆之以為城基。」\n9. 明嘉靖三十九年(1560)，八萬洞資首黃啓薦扎寨惠來冰山頭（今邦山村）攻陷甲子所城，城中居民移至龍溪都（今惠來隆江以南）為逃避倭禍而暫居，該城之難民，慘遭殺害者甚眾，婦女被擄掠，有的全家罹難。\n10. 明隆慶二年(1568)，倭寇入侵甲子，千戶馬壽麻痹輕敵，城被攻陷，甲子和龍溪都一帶受害慘重。馬壽因失職罪下獄，死於獄中。\n11. 明隆慶四年(1570)，大旱，入春至初夏，天無滴雨，時又常遭賊寇蹂躪，田園拋荒，赤地千里，人民苦不堪言。\n12. 明隆慶四年(1570)九月，曾作倭寇嚮導之海寇楊老復，率賊眾攻陷甲子所城，擄掠男女上船，千戶董（佚名）戰死。次日，船遇颱風，賊與被擄者均溺死。\n13. 隆慶五年(1571)七月，海盜林道乾（又名林鳳，惠來人），於龍溪都一帶擄民劫捨，後聞朝廷將派兵進剿，遂遠循至甲子一帶搶劫，攻破新寨，劫擄李棠，其妻卓氏攜二子上船換夫歸，遂投海殉節。後朝廷封為「南海夫人」。\n14. 明萬曆二十六年(1598)，湯顯祖作《牡丹亭》，其第六齣中有詞句「榕樹梢頭訪古台，下看甲子海門開。越王歌舞今何在？時有鷓鴣飛去來。」\n15. 明萬曆二十八年(1600)八月二十三日，惠來及甲子一帶地震。\n16. 明萬曆三十三年(1605)三月，惠來及甲子一帶地震，七月初三至初七颱風暴雨，沿海田舍淹沒。\n17. 明萬曆三十五年(1607)，參將張萬紀、守備胡文烜在待渡山下建宋帝亭，即進食亭。\n18. 明萬曆四十二年(1620)春正月，海盜袁八老余黨林新老入甲子沃，把總金允武出戰死之。\n19. 明天啓七年(1627)三月，海寇入甲子門，守備葉台死亡。\n20. 明崇禎八年(1635)，海寇劉香攻陷甲子，擄去守道洪雲蒸。閩粵大兵突至，洪遇害，後劉香被擄伏誅。\n21. 明崇禎十四年(1641)十二月十四日夜，惠來地震，波及甲子。\n22. 民國32年(1943，癸未年)，甲子乃至整個海陸豐地區、潮汕地區遭遇大飢荒，時兵災、旱災、蝗災和瘟疫，餓殍遍野，僅甲子一鎮亡者就近 2 萬，佔當時鎮人口逾 45%。\n23. 1966年，中國大陸爆發文化大革命，「破四舊」。次年，有360年歷史的進食亭被炸毀！\n24. 2004年夏～2005年秋，甲子諸賢達捐資重建了進食亭。\n25. 2013年12月29日凌晨，廣東警方出動3000多人的警力對有「毒品村」之稱的甲西鎮博社村開展清繳行動，當天繳獲近3噸冰毒，抓捕180多名涉毒犯罪嫌疑人，原村委書記蔡東家名列其中。\n\n## 建置(giang³ di³)\n\n1. 秦以前：屬南越國\n2. 秦：屬南海郡之博羅縣\n3. 漢：屬博羅縣\n4. 三國：屬博羅縣\n5. 晉：咸和六年（326）析博羅，置海豐縣，屬东官郡\n6. 宋：屬海豐縣\n7. 齊：屬海豐縣\n8. 梁：屬海豐縣\n9. 陳：屬海豐縣\n10. 隋：海豐縣屬循州\n11. 唐：海豐縣屬循州。武德五年（622）析置安陸縣；貞觀元年（627）復歸海豐縣。\n12. 五代：大寶元年（958）海豐縣属祯州。\n13. 宋：海豐縣屬祯州。天禧五年（1021）屬惠州。\n14. 元：海豐縣屬惠州路。\n15. 明：海豐縣屬惠州府。洪武二十七年(1394)，置甲子守禦千戸所，隸屬碣石衛。嘉靖三年（1524）海豐划出龍溪都、潮州府析出潮陽縣合置惠來縣。\n\n    ![甲子所城範圍（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）](gahzi-oi-hung-lui-ci-biao/Untitled%2085.png)\n    \n16. 清：海豐縣屬惠州府。雍正九年（1731）海豐划出石帆（甲子屬石帆都）、吉康、坊廓3都置陸豐縣，並裁甲子所設立甲子巡檢司。\n17. 中華民國：陸豐縣屬潮循道。\n18. 中華人民共和國：1957年甲子鎮劃出甲東鎮、甲西鎮（取甲子之東、甲子之西義）；1958年鎮改爲人民公社，陸豐縣屬汕頭地區；1983年陸豐屬惠陽地區；1980年成立甲子鎮人民政府；1988年陸豐縣改屬汕尾市；1995年陸豐撤縣建市。\n\n## 拼音方案(pêng³ im¹ huang¹ uan³)\n\n### 聲母表(sian¹ bho² biao²)\n\n格式：`聲母 [國際音標] 例字`\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png)\n\n### 韻母表(ung¹ bho² biao²)\n\n格式：`韻母 [國際音標] 例字 / 入聲韻 [國際音標] 例字`\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png)\n\n### 聲調(sian¹ diao⁶)\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png)\n\n### 變調(biang³ diao⁶)\n\n![](gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png)\n\n## 地圖(di⁷ dao⁵)\n\n![三甲地區（來源：騰訊地圖）](gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg)\n\n","slug":"language/min/gahzi-oi-hung-lui-ci-biao","published":1,"date":"2021-02-05T16:21:16.892Z","updated":"2021-02-05T16:21:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt7c7wp2001l9a9k6w61gy4s","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><h2 id=\"序言-su⁶-ngiang⁵\"><a href=\"#序言-su⁶-ngiang⁵\" class=\"headerlink\" title=\"序言(su⁶ ngiang⁵)\"></a>序言(su⁶ ngiang⁵)</h2><p>甲子鎮處在陸豐市，與惠來縣交界，語言文化上偏惠來（其實五百年前與惠來交界處同屬海豐縣）。甲子話是三甲地區（甲子、甲西、甲東三鎮）通行的語言，是甲子地方文化的重要載體之一。在學術上，甲子話被歸入粵東閩南語潮汕話片。 </p>\n<p>甲子話保留了好㩼中古乃至上古的漢語詞彙，比如：汝、諸母、新婦、箸、鼎、匏桸、雅、翹楚等等，還有極具地方特色的表達，比如：𨑨迌、走漆、理唔直、孤獨死相等等。然而無會寫甚至無會呾甲子話的人實在㩼，其中不少是受過義務教育其。 有鑑於此，本人草創此表，力求詞雅正且其音形義有所考據，權當拋磚引玉，歡迎大家儂做蜀討論改進。 </p>\n<p>另附本表主要參考資料：</p>\n<ol>\n<li>《潮汕方言詞考釋》（林倫倫）</li>\n<li>《海豐話分類辭表》（羅志海、鍾顯坤）</li>\n<li><a href=\"https://www.mogher.com/baike\">《潮典》</a> </li>\n<li>《新潮汕字典》（張曉山）</li>\n<li><a href=\"https://twblg.dict.edu.tw/holodict%5C_new/index.html\">《台灣閩南語常用詞辭典》</a> </li>\n<li><a href=\"https://xiaoxue.iis.sinica.edu.tw/minyu\">《小學堂閩語》</a></li>\n</ol>\n<p>阿華<br>2020年10月成稿，12月修訂</p>\n<span id=\"more\"></span>\n\n<h2 id=\"總表-zong²-biao²\"><a href=\"#總表-zong²-biao²\" class=\"headerlink\" title=\"總表(zong² biao²)\"></a>總表(zong² biao²)</h2><h3 id=\"🤵稱謂-ceng¹-ui⁶\"><a href=\"#🤵稱謂-ceng¹-ui⁶\" class=\"headerlink\" title=\"🤵稱謂(cêng¹ ui⁶)\"></a>🤵稱謂(cêng¹ ui⁶)</h3><ol>\n<li>我 /ua²/</li>\n<li>汝 /lu²/ 你</li>\n<li>伊 /i¹/ 他/她/它</li>\n<li>恁 /ning²/ 你們</li>\n<li>伊人 /i¹ nang⁷/ 他們</li>\n<li>家己 /ga¹ gi⁷/ 自己</li>\n<li>人家 /nang⁵ gê¹/ 別人</li>\n<li>諸夫 /za¹ bao¹/ 男人、男子</li>\n<li>諸母 /za¹ bhao²/ 女人</li>\n<li>諸娘 /zu¹ nion⁵/ 女子</li>\n<li>大人 /dua⁷ nang⁷/</li>\n<li>老人 /lao⁶ nang⁵/</li>\n<li>後生囝 /hao⁶ sên¹ gian²/ 年輕人</li>\n<li>孥囝 /nao⁵ gian²/、/nong⁶ gian²/ 小孩子</li>\n<li>諸夫囝 /za¹ bao¹ gian²/ 男孩子、兒子</li>\n<li>諸母囝 /za¹ bhao² gian²/ 女孩子、女兒</li>\n<li>諸娘囝 /zu¹ nion⁵ gian²/ 年輕女子</li>\n<li>阿公 /a¹ gong¹/ 爺爺</li>\n<li>阿媽 /a¹ ma²/ 奶奶</li>\n<li>媽人 /ma² nang⁵/ 婦女</li>\n<li>媽祖 /ma² zao²/ 原名林默，南海保護神</li>\n<li>爸爸 /ba¹ ba¹/ 爸爸</li>\n<li>媽媽 /ma¹ ma¹/</li>\n<li>父母 /bê⁶ bho²/</li>\n<li>兄 /hian¹/ 哥哥</li>\n<li>弟 /di⁶/ 弟弟</li>\n<li>姐 /zê²/ 姐姐</li>\n<li>妹 /moi⁷/ 妹妹</li>\n<li>姊妹 /zi² moi⁷/ 姐妹</li>\n<li>叔伯兄弟 /zêh⁴ bêh⁴ hian¹ di⁶/ 堂兄弟</li>\n<li>同沿 /dang⁵ iang⁵/ 同輩、同儕</li>\n<li>翁 /ang¹/ 丈夫</li>\n<li>母 /bhao²/ 妻子</li>\n<li>翁姐 /ang¹ zia²/ 夫妻</li>\n<li>新婦 /sing¹ bu⁶/ 媳婦</li>\n<li>大家 /dua⁷ gê¹/ 丈夫的母親、家婆</li>\n<li>大家官 /dua⁷ gê¹ guan¹/ 丈夫的父親、家公</li>\n<li>丈人 /dion⁶ nang⁵/ 岳父</li>\n<li>丈母 /dion⁶ m²/ 岳母</li>\n<li>妻舅 /ci¹ gu⁶/ 妻子的兄弟</li>\n<li>妻姨 /ci¹ i⁵/ 妻子的姐妹</li>\n<li>伯 /bêh⁴/ 伯伯</li>\n<li>姆 /m²/ 伯父的妻子</li>\n<li>叔 /zêh⁴/ 叔叔</li>\n<li>嬸 /sim²/ 叔父的妻子</li>\n<li>舅 /gu⁶/ 舅舅</li>\n<li>妗 /gim⁶/ 舅父的妻子</li>\n<li>姑 /gao¹/ 父親的姐妹、姑姑</li>\n<li>姑丈 /gou¹ dion⁶/ 姑姑的丈夫</li>\n<li>姨 /i⁵/ 母親的姐妹；母親</li>\n<li>姨丈 /i⁵ dion⁶/ 母親的姐妹的丈夫</li>\n<li>先生 /sing¹ sên¹/</li>\n<li>學生 /hag⁴ sêng¹/</li>\n<li>師父 /sai¹ bê⁶/ 工匠師傅</li>\n<li>師父 /su¹ hu⁶/ 出家人、和尚</li>\n<li>和尚 /hoi⁵ sion⁷/、/hua⁵ siang⁶/</li>\n<li>腳色 /ka¹ siao³/ 人手、幫手</li>\n<li>青暝囝 /cên¹ mên⁵ gian²/ 瞎子</li>\n</ol>\n<h3 id=\"🦶身體-sing¹-ti²\"><a href=\"#🦶身體-sing¹-ti²\" class=\"headerlink\" title=\"🦶身體(sing¹ ti²)\"></a>🦶身體(sing¹ ti²)</h3><ol>\n<li>頭毛 /tao⁵ mo⁵/ 頭髮</li>\n<li>頭神 /tao⁵ sing⁵/ 思維、記憶的能力</li>\n<li>頭碗骨 /tao⁵ uan² gug⁴/ 頭蓋骨</li>\n<li>旋 /zng⁷/ 頭髮呈漩渦狀的地方</li>\n<li>囟 /sing³/ 嬰兒頭頂骨未合縫處</li>\n<li>額頭 /hia² tao⁵/</li>\n<li>面 /ming⁷/ 臉</li>\n<li>頰溝 /gih⁴ gao¹/ 腮</li>\n<li>痣 /gi³/</li>\n<li>目 /mag⁸/ 眼睛</li>\n<li>目仁 /mag⁸ ring⁵/ 眼珠子</li>\n<li>目汁 /mag⁸ zab⁴/ 眼淚</li>\n<li>眉 /bhai⁵/ 眉毛</li>\n<li>耳 /hin⁶/ 耳朵</li>\n<li>耳空、耳孔 /hin⁶ kang¹/</li>\n<li>鼻 /pin⁷/ 鼻子</li>\n<li>鼻空、鼻孔 /pin⁷ kang¹/</li>\n<li>喙、嘴 /cui⁷/ 嘴巴</li>\n<li>䶕牙 /bha³ ghê⁵/ 龅牙</li>\n<li>涎 /nua⁶/ 唾液</li>\n<li>痰 /tam⁵/</li>\n<li>頷 /am⁶/ 脖子</li>\n<li>下頦 /ê⁶ hai⁵/ 下巴</li>\n<li>喙後肚 /cui⁷ ao⁶ dao²/ 下巴後面柔軟處</li>\n<li>鬚 /ciu¹/ 鬍鬚</li>\n<li>嚨喉 /na⁵ ao⁵/ 喉嚨</li>\n<li>手 /ciu²/</li>\n<li>正手 /zian³ ciu²/ 右手</li>\n<li>倒手 /do³ ciu²/ 左手</li>\n<li>胳囊跤 /goh⁴ lang⁵ ka¹/ 腋下</li>\n<li>手後曲 /ciu² ao⁶ kiao¹/ 手肘</li>\n<li>手模 /ciu² bhao⁵/ 手印</li>\n<li>腡 /lê⁵/ 圓形手指紋</li>\n<li>指頭公 /zain² tao⁵ gong¹/ 大拇指</li>\n<li>尾指囝 /bhoi² zain² gian²/ 小指</li>\n<li>胸 /hêng¹/</li>\n<li>嬭、奶 /nê¹/</li>\n<li>𩩍篱 /pian¹ li⁵/ 肋骨</li>\n<li>肚臍 /dao² zai⁵/</li>\n<li>背脊 /ba¹ ziah⁴/ 脊背</li>\n<li>腰 /io¹/</li>\n<li>跤、骹、腳 /ka¹/</li>\n<li>跤頭趺 /ka¹ tao⁵ u⁶/ 膝蓋</li>\n<li>大跤腿 /dua⁷ ka¹ tui²/ 大腿</li>\n<li>跤腸肚 /ka¹ dng⁵ dao²/ 小腿後部肌肉凸出處</li>\n<li>跤後蹬 /ka¹ ao⁶ dên¹/ 腳後跟</li>\n<li>跤盤 /ka¹ buan⁵/ 腳板</li>\n<li>跤目 /ka¹ mag⁸/ 腳踝</li>\n<li>跤指公 /ka¹ zain² gong¹/ 腳大拇趾</li>\n<li>跤液 /ka¹ sio²/ 腳汗</li>\n<li>卵 /lang⁶/ 陰莖、屌、勢</li>\n<li>卵鳥 /lang⁶ ziao²/ 陰莖、屌、勢</li>\n<li>卵脬 /lang⁶ pa¹/ 精囊</li>\n<li>卵核 /lang⁶ hug⁸/ 睪丸</li>\n<li>膣 /zi¹/ 女陰</li>\n<li>膣眉 /zi¹ bhai¹/ 女陰</li>\n<li>尻川 /ka¹ cng¹/ 屁股</li>\n<li>雞母皮 /goi¹ bho² poi⁵/ 雞皮疙瘩</li>\n<li>汗 /guan⁷/</li>\n<li>垢圿 /gao² goih⁴/ 體表污垢</li>\n</ol>\n<h3 id=\"🍵飲食-im²-ziah⁸\"><a href=\"#🍵飲食-im²-ziah⁸\" class=\"headerlink\" title=\"🍵飲食(im² ziah⁸)\"></a>🍵飲食(im² ziah⁸)</h3><ol>\n<li>食 /ziah⁸/ 吃、喝、抽</li>\n<li>祭 /zi³/ 狼吞虎咽；坐享其成</li>\n<li>咬 /ga⁶/</li>\n<li>哺 /bao⁷/ 咀嚼</li>\n<li>吞 /tung¹/</li>\n<li>舐 /zi⁶/ 舔</li>\n<li>含 /gam⁵/</li>\n<li>啜 /coih⁴/ 喝</li>\n<li>啉 /lim⁵/ 小口喝</li>\n<li>灌 /guang¹/ 大口喝</li>\n<li>吸 /kib⁴/</li>\n<li>搵 /ung³/ 蘸</li>\n<li>買鹹 /moi² giam⁵/ 買菜</li>\n<li>食透早 /ziah⁸ tao⁷ za²/ 吃早飯</li>\n<li>食眠起 /ziah⁸ mng⁵ ki²/ 吃早飯</li>\n<li>食晝 /ziah⁸ dao³/ 吃午飯</li>\n<li>食當晝 /ziah⁸ dêng¹ dao³/ 吃午飯</li>\n<li>食夜昏、食暝昏 /ziah⁸ mê⁵ hng⁵/ 吃晚飯</li>\n<li>飯 /bng⁷/</li>\n<li>米 /bhi²/</li>\n<li>糜 /moi⁵/ 粥</li>\n<li>飲 /am²/ 米湯</li>\n<li>配 /poi³/ 菜</li>\n<li>菜式 /cai³ sêg⁴/</li>\n<li>粿、餜 /goi²/</li>\n<li>丸、圓 /in⁵/</li>\n<li>油䭔 /iu⁵ zui¹/ 一種油炸食品</li>\n<li>汰米 /tua⁷ bhi²/ 淘米</li>\n<li>熬 /ngao⁵/ 長時間煮。～糜。</li>\n<li>煲 /bu⁵/ 煮、熬。～藥。</li>\n<li>潘 /png¹/ 餿水</li>\n<li>油 /iu⁵/</li>\n<li>鹽 /iam⁵/</li>\n<li>醋 /cao³/</li>\n<li>豉油 /si⁷ iu⁵/ 醬油</li>\n<li>豆汁 /dao⁷ zab⁴/ 醬油</li>\n<li>雞卵 /goi¹ nng⁶/ 雞蛋</li>\n<li>豬肉 /du¹ nêg⁸/</li>\n<li>澀肉 /siab⁴ nêg⁸/、/siab⁴ bhah⁴/ 瘦肉。澀，少油。</li>\n<li>肉脞 /nêg⁸ co³/ 肉末</li>\n<li>烏糖 /ao¹ tng⁵/ 紅糖、黑糖</li>\n<li>赤砂糖 /ciah⁴ sua¹ tng⁵/</li>\n<li>白砂糖 /bêh⁸ sua¹ tng⁵/</li>\n<li>薰 /hung¹/ 香菸</li>\n<li>茶 /dê⁵/</li>\n<li>酒 /ziu²/</li>\n<li>淖 /cioh⁴/ 粥稀</li>\n<li>凊 /cing³/ 飯菜涼了</li>\n<li>燒 /sio¹/ 熱呼呼</li>\n<li>燒烘燒烘 /sio¹ hang¹ sio¹ hang¹/ 熱呼呼</li>\n<li>芳 /pang¹/ 香</li>\n<li>甘 /gam¹/</li>\n<li>甜 /diam⁵/</li>\n<li>鹹 /giam⁵/</li>\n<li>薟 /hiam¹/ 辛辣</li>\n<li>䭕 /zian²/ 清淡</li>\n<li>臊 /co¹/ 腥</li>\n<li>臭 /cao³/</li>\n</ol>\n<h3 id=\"👔穿戴-ceng⁷-dua³\"><a href=\"#👔穿戴-ceng⁷-dua³\" class=\"headerlink\" title=\"👔穿戴(cêng⁷ dua³)\"></a>👔穿戴(cêng⁷ dua³)</h3><ol>\n<li>帽 /bho⁷/</li>\n<li>目鏡 /mah⁸ gian³/ 眼鏡</li>\n<li>圍巾 /ui⁵ ging¹/</li>\n<li>頷幔 /am⁶ muan¹/ 披肩</li>\n<li>衫褲 /san¹ kao³/ 衣服</li>\n<li>西裝 /sai¹ zuang¹/</li>\n<li>褸 /lao¹/ 大衣</li>\n<li>葵笠 /goi⁵ loih⁸/ 斗笠，竹編成的圓錐形大帽子。</li>\n<li>羊毛衫 /ion⁵ mo⁵ san¹/</li>\n<li>長䘼衫 /dng⁵ ng² san¹/ 長袖衫</li>\n<li>短䘼衫 /dê² ng² san¹/ 短袖衫</li>\n<li>貼身衫 /dah⁴ sing¹ san¹/ 貼身的上衣</li>\n<li>䘥囝 /gah⁴ gian²/ 無袖內衣</li>\n<li>底衫 /doi² san¹/ 內衣</li>\n<li>肚綰 /dao² guan⁶/ 肚兜</li>\n<li>長褲 /dng⁵ kao³/</li>\n<li>短褲 /dê² kao³/</li>\n<li>褲頭 /kao³ tao⁵/ 短褲、內褲</li>\n<li>褲橛 /kao³ goi²/ 短褲、內褲</li>\n<li>三角褲 /san¹ gag⁴ kao³/</li>\n<li>裙 /gung⁵/</li>\n<li>圍裙 /ui⁵ gung⁵/</li>\n<li>文胸 /bhung⁵ hêng¹/ 胸罩</li>\n<li>奶帕、嬭帕 /nê¹ pê³/ 胸罩</li>\n<li>皮帶 /poi⁵ dua³/</li>\n<li>手囊 /ciu² lob⁴/ 套袖</li>\n<li>手鐲 /ciu² sio²/</li>\n<li>鞋拖 /tua¹ oi⁵/ 拖鞋</li>\n<li>波鞋 /bo¹ oi⁵/ 球鞋。波，英文 ball 的音譯。</li>\n<li>釘鞋 /dêng¹ oi⁵/ 運動鞋的一種</li>\n<li>皮鞋 /poi⁵ oi⁵/</li>\n<li>高跟鞋 /gao¹ ging¹ oi⁵/</li>\n<li>靴 /hia¹/</li>\n<li>襪 /ghoih⁸/</li>\n<li>布 /bao³/</li>\n<li>襊 /zoi⁷/ 折痕</li>\n<li>頷領 /am⁶ nia²/ 領子</li>\n<li>褲袋 /kao³ dê⁷/ 位於褲子的口袋</li>\n<li>衫袋 /san¹ dê⁷/ 位於上衣的口袋</li>\n<li>暗袋 /am³ dê⁷/ 內側袋</li>\n<li>內裏 /lai⁶ li²/ 衣物不露出在外的裏層</li>\n<li>鈕 /liu²/ 鈕扣</li>\n<li>針 /zam¹/</li>\n<li>線 /suan³/</li>\n<li>拉鍊 /la¹ liang³/</li>\n<li>穿 /cêng⁷/</li>\n<li>褪 /tng⁷/ 脱</li>\n<li>紩 /tin⁷/ 縫</li>\n<li>補 /bao²/</li>\n<li>車衫褲 /cia¹ san¹ kao³/ 用縫紉機縫衣服</li>\n</ol>\n<h3 id=\"🎏物件-mi²-gian⁶、mian⁶\"><a href=\"#🎏物件-mi²-gian⁶、mian⁶\" class=\"headerlink\" title=\"🎏物件(mi² gian⁶、mian⁶)\"></a>🎏物件(mi² gian⁶、mian⁶)</h3><ol>\n<li><p>眠牀 /mng⁵ cng⁵/ 牀</p>\n</li>\n<li><p>鋪 /pao¹/ 牀</p>\n</li>\n<li><p>高低牀 /gao¹ di¹ cng⁵/ 上下鋪</p>\n</li>\n<li><p>蓆 /cioh⁸/</p>\n</li>\n<li><p>簟 /diam⁶/ 竹席</p>\n</li>\n<li><p>毡 /ziang¹/</p>\n</li>\n<li><p>被 /poi⁶/</p>\n</li>\n<li><p>棉被 /mi⁵ poi⁶/</p>\n</li>\n<li><p>被單 /poi⁶ duan¹/</p>\n</li>\n<li><p>枕頭 /zim² tao⁵/</p>\n</li>\n<li><p>枕頭囊 /zim² tao⁵ lob⁴/ 枕套</p>\n</li>\n<li><p>蠓罩、蚊罩 /mang² da³/ 蚊帳</p>\n</li>\n<li><p>蠓熏、蚊熏 /mang² hung¹/ 蚊香</p>\n</li>\n<li><p>窗罩 /têng¹ zao⁶/</p>\n</li>\n<li><p>口罩 /kao² zao⁶/</p>\n</li>\n<li><p>壁櫥 /biah⁴ du⁵/</p>\n</li>\n<li><p>椅 /in²/</p>\n</li>\n<li><p>桌 /doh⁴/</p>\n</li>\n<li><p>櫃 /gui⁷/</p>\n</li>\n<li><p>架 /gê³/</p>\n</li>\n<li><p>盒 /ab⁸/</p>\n</li>\n<li><p>籃 /na⁵/</p>\n</li>\n<li><p>瓶 /bang⁵/</p>\n</li>\n<li><p>鎖頭 /so² tao⁵/</p>\n</li>\n<li><p>鎖匙 /so² si⁵/ 鑰匙</p>\n</li>\n<li><p>葉疊 /iab² diab⁸/ 合葉</p>\n</li>\n<li><p>牙簽 /ghê⁵ ciam¹/</p>\n</li>\n<li><p>茶盤 /dê⁵ buan⁵/</p>\n</li>\n<li><p>茶壺 /dê⁵ hu⁵/</p>\n</li>\n<li><p>沖罐 /cong¹ guang³/ 茶壺</p>\n</li>\n<li><p>茶杯 /dê⁵ boi¹/</p>\n</li>\n<li><p>茶几 /dê⁵ gi²/</p>\n</li>\n<li><p>熏咬 /hung¹ ga⁶/ 煙斗</p>\n</li>\n<li><p>熏碟 /hung¹ dih⁸/ 煙灰缸</p>\n</li>\n<li><p>熱壺 /riag⁸ hu⁵/ 熱水瓶</p>\n</li>\n<li><p>熨斗 /ug⁴ dao²/</p>\n</li>\n<li><p>電燈 /diang⁶ dêng¹/</p>\n</li>\n<li><p>電泡 /diang⁶ pa⁶/</p>\n</li>\n<li><p>燈籠 /dêng¹ lang⁵/</p>\n</li>\n<li><p>燈火 /dêng¹ hoi²/ 電燈；燈光</p>\n</li>\n<li><p>風箏 /hong¹ zêng¹/</p>\n</li>\n<li><p>米甕 /bhi² ang³/ 米缸</p>\n</li>\n<li><p>水䀇 /zui² gao²/ 大型儲水器</p>\n</li>\n<li><p>跤桶 /ka¹ tang²/ 原指洗腳桶，後泛指洗衣盆，也可用來給小孩洗澡。</p>\n</li>\n<li><p>面盆 /ming⁷ png⁵/ 臉盆</p>\n</li>\n<li><p>瓠桸 /bu⁵ hia¹/ 水瓢</p>\n</li>\n<li><p>口㼦 /kao² gong²/ 漱口杯</p>\n</li>\n<li><p>碗 /uan²/</p>\n</li>\n<li><p>盤 /buan⁵/</p>\n</li>\n<li><p>碟 /dih⁸/</p>\n</li>\n<li><p>甌 /ao¹/ 大碗</p>\n</li>\n<li><p>箸 /du⁷/ 筷子</p>\n</li>\n<li><p>湯匙 /tng¹ si⁵/</p>\n</li>\n<li><p>調羹 /tiao⁵ gên¹/ 喝粥用的小勺子；湯匙</p>\n</li>\n<li><p>糜匙 /moi⁵ si⁵/ 舀粥用的勺子</p>\n</li>\n<li><p>飯匙 /bng⁷ si⁵/ 飯勺</p>\n</li>\n<li><p>飯添 /bng⁷ tin¹/ 飯勺</p>\n</li>\n<li><p>鼎 /dian²/ 鍋</p>\n</li>\n<li><p>鼎㧕 /dian² liu⁶/ 鍋鏟。㧕，存疑。</p>\n</li>\n<li><p>鼎蓋 /dian² kain³/ 鍋蓋</p>\n</li>\n<li><p>菜刀 /cai³ do¹/</p>\n</li>\n<li><p>瓜刨 /goi¹ pao⁵/</p>\n</li>\n<li><p>砧 /diam¹/</p>\n</li>\n<li><p>篩 /tai¹/</p>\n</li>\n<li><p>筅 /cain²/ 刷子</p>\n</li>\n<li><p>菜篩 /cai³ tai¹/</p>\n</li>\n<li><p>鉸刀 /ga¹ do¹/ 剪刀</p>\n</li>\n<li><p>螺絲批 /lo⁵ si¹ poi¹/ 螺絲刀</p>\n</li>\n<li><p>螺絲釘 /lo⁵ si¹ dêng¹/</p>\n</li>\n<li><p>旋螺絲 /suag⁸ lo⁵ si¹/ 擰螺絲</p>\n</li>\n<li><p>鐵錘 /tih⁴ tui⁵/</p>\n</li>\n<li><p>鉸夾 /ga¹ giab⁸/ 鉗子</p>\n</li>\n<li><p>扳手 /bang² ciu²/</p>\n</li>\n<li><p>電筆 /diang⁶ big⁴/ 測電筆</p>\n</li>\n<li><p>烏膠布 /ao¹ ga¹ bao³/ 電工膠帶</p>\n</li>\n<li><p>黏紙 /niam⁵ zua²/ 透明膠帶</p>\n</li>\n<li><p>布拖 /bao³ tu¹/ 拖把</p>\n</li>\n<li><p>掃帚 /sao³ siu²/ 掃把</p>\n</li>\n<li><p>畚斗 /bng³ dao²/ 垃圾鏟</p>\n</li>\n<li><p>畚箕 /bng³ gi¹/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled.png\" alt></p>\n</li>\n<li><p>梯 /tui¹/</p>\n</li>\n<li><p>吸石 /hiab⁴ zioh⁸/ 磁鐵、磁石</p>\n</li>\n<li><p>箠 /coi⁵/ 鞭子，可用來教育孩子。</p>\n</li>\n<li><p>火箠 /hoi² coi⁵/ 火筷子，夾爐中煤炭或通火的用具。</p>\n</li>\n<li><p>角畢 /gag⁴ big⁴/ 皮箱</p>\n</li>\n<li><p>樹嬭 /ciu⁷ ni⁵/ 橡皮、橡膠。嬭，樹之乳膠。</p>\n</li>\n<li><p>嬭漱 /ni⁵ ciu³/ 橡皮擦</p>\n</li>\n<li><p>毛筆 /mo⁵ big⁴/</p>\n</li>\n<li><p>鋼筆 /gng³ big⁴/</p>\n</li>\n<li><p>鉛筆 /iang⁵ big⁴/</p>\n</li>\n<li><p>鉛筆旋 /iang⁵ big⁴ suag⁸/ 卷筆刀、筆刨</p>\n</li>\n<li><p>模 /bhao⁵/ 模子</p>\n</li>\n<li><p>㨹 /zoi⁷/ 裂縫、痕跡</p>\n</li>\n<li><p>離衣機 /li⁵ i¹ gi¹/ 洗衣機</p>\n</li>\n</ol>\n<h3 id=\"🏠建築-giang³-dog⁴\"><a href=\"#🏠建築-giang³-dog⁴\" class=\"headerlink\" title=\"🏠建築(giang³ dog⁴)\"></a>🏠建築(giang³ dog⁴)</h3><ol>\n<li>茨、厝 /cu³/ 房子、家</li>\n<li>寮 /liao⁵/ 简陋小屋</li>\n<li>瓦茨 /hia⁶ cu³/ 瓦舍</li>\n<li>茨手 /cu³ ciu²/ 潮汕民居天井旁兩間廂房的名稱。</li>\n<li>兩間直 /no⁶ gain¹ dig⁸/ 傳統民居，兩房。</li>\n<li>獨腳靴 /dog⁸ ka¹ hia¹/ 傳統民居，一聽一茨手一房。</li>\n<li>下山虎 /hia⁶ suan¹ haon²/ 傳統民居，三合院，一廳二房二茨手。</li>\n<li>四點金 /si³ diam² gim¹/ 傳統民居，四合院，中軸爲前廳天井後聽，兩廳兩旁各有一房。</li>\n<li>竹竿茨 /dêg⁴ go¹ cu³/ 傳統民居，廚房客廳住房天井排列成狹長的空間，如竹竿。</li>\n<li>駟馬拖車 /si³ mê² tua¹ cia¹/ 傳統民居，在四點金上縱加一廳，橫加兩房，三廳二天丼。</li>\n<li>茨邊 /cu³ bin¹/ 鄰居</li>\n<li>起茨 /ki² cu³/ 蓋房子</li>\n<li>租茨 /zao¹ cu³/ 租房子</li>\n<li>搬茨 /buan⁵ cu³/ 搬家</li>\n<li>入新茨 /rib⁸ sing¹ cu³/ 搬入新家</li>\n<li>客廳 /kêh⁴ tian¹/</li>\n<li>客房 /kêh⁴ bang⁵/</li>\n<li>廚房 /dao⁵ bang⁵/</li>\n<li>浴室 /êg⁸ sig⁴/</li>\n<li>洗浴 /soi² êg⁸/ 洗澡</li>\n<li>廁所 /cê³ so²/</li>\n<li>屎壑 /sai² hag⁸/ 茅廁</li>\n<li>門窗 /mng⁵ têng¹/</li>\n<li>門閂 /mng⁵ cuan³/</li>\n<li>門楣 /mng⁵ bhai⁵/</li>\n<li>門橂 /mng⁵ dain⁶/ 門檻</li>\n<li>門扇後 /mng⁵ sin³ ao⁶/ 門後</li>\n<li>柱 /tiao⁶/</li>\n<li>牆壁 /cion⁵ biah⁴/</li>\n<li>庭、埕 /dian⁵/ 寬闊平地，可曬鹽、曬穀。</li>\n<li>临檐 /lim⁵ zin⁵/ 檐廊</li>\n<li>塗角 /tao⁵ gag⁴/ 土磚</li>\n<li>磚 /zng¹/</li>\n<li>廟 /bhio⁷/</li>\n<li>亭 /dêng⁵/</li>\n<li>祠堂 /su⁵ dng⁵/</li>\n<li>庵寺 /am¹ zin⁷/ 尼寺、僧寺的通稱。</li>\n<li>學校 /hag⁸ hao⁶/</li>\n<li>醫院 /ui¹ in⁷/</li>\n<li>鎮府 /ding³ hu²/ 鎮政府</li>\n<li>舖囝 /pao³ gian²/ 小賣部</li>\n</ol>\n<h3 id=\"🛵交通-gao¹-tong¹\"><a href=\"#🛵交通-gao¹-tong¹\" class=\"headerlink\" title=\"🛵交通(gao¹ tong¹)\"></a>🛵交通(gao¹ tong¹)</h3><ol>\n<li>腳車、跤車 /ka¹ cia¹/ 腳踏車、自行車</li>\n<li>摩托 /mo⁵ toh⁸/ 摩托，英文 motorcycle 音譯省。</li>\n<li>三輪車 /san¹ lung⁵ cia¹/</li>\n<li>的士 /dêg⁴ si⁶/ 計程車、出租車。的士，英文 taxi 音譯。</li>\n<li>小車 /sio² cia¹/ 小汽車</li>\n<li>麵包車 /min⁷ bao¹ cia¹/</li>\n<li>公交車 /gong¹ gao¹ cia¹/</li>\n<li>大巴 /dua⁷ ba¹/ 巴，英文 bus 音譯。</li>\n<li>車站 /cia¹ zam⁶/</li>\n<li>輪船 /lung⁵ zung⁵/</li>\n<li>龍船 /lêng⁵ zung⁵/ 龍舟</li>\n<li>火車 /hoi² cia¹/</li>\n<li>地鐵 /di⁷ tih⁴/</li>\n<li>高鐵 /gao¹ tih⁴/</li>\n<li>飛機 /boi¹ gi¹/</li>\n<li>行路 /gian⁵ lao⁷/ 走路</li>\n<li>踏腳車 /dah⁸ ka¹ cia¹/ 騎自行車</li>\n<li>駛車 /sai² cia¹/ 開車</li>\n<li>撐船 /tên¹ zung⁵/</li>\n<li>載客 /zai³ kêh⁴/</li>\n<li>拗䷀囝 /ao² gag⁴ gian²/ 摩托車司機。拗，載；扛。</li>\n<li>落車 /lo² cia¹/ 下車</li>\n<li>碼頭 /bhê² tao⁵/</li>\n<li>涵空、涵孔 /am⁵ kang¹/ 涵洞、涵管、地下水道</li>\n<li>橋墩 /gio⁵ dun¹/ 橋梁下面的圓柱狀基石</li>\n</ol>\n<h3 id=\"🐒眾生-zeng³-sen¹\"><a href=\"#🐒眾生-zeng³-sen¹\" class=\"headerlink\" title=\"🐒眾生(zêng³ sên¹)\"></a>🐒眾生(zêng³ sên¹)</h3><ol>\n<li><p>眾生 /zêng³ sên¹/ 牲畜</p>\n</li>\n<li><p>禽兽 /kim⁵ siu⁶/</p>\n</li>\n<li><p>害蟲 /hai⁷ tang⁵/</p>\n</li>\n<li><p>豬豭 /du¹ go¹/ 配種的公豬，也比喻好色之徒。</p>\n</li>\n<li><p>豬槽 /du¹ zo⁵/</p>\n</li>\n<li><p>羊牢 /ion⁵ lo⁵/</p>\n</li>\n<li><p>雞翁 /goi¹ ang¹/ 雄雞</p>\n</li>\n<li><p>雞母 /goi¹ bho²/ 母雞</p>\n</li>\n<li><p>鴨囝 /ah⁴ gian²/ 小鴨子</p>\n</li>\n<li><p>鵝 /gho⁵/</p>\n</li>\n<li><p>貓牯 /ngiao¹ gao²/ 母貓</p>\n</li>\n<li><p>鳥 /ziao²/</p>\n</li>\n<li><p>燕囝 /in³ gian²/ 小燕子</p>\n</li>\n<li><p>鶴 /hoh⁸/</p>\n</li>\n<li><p>鷹 /êng¹/</p>\n</li>\n<li><p>白鴿 /bêh⁸ gab⁴/</p>\n</li>\n<li><p>白鷺鷥 /bêh⁸ lao⁷ si¹/</p>\n</li>\n<li><p>鸚哥 /êng¹ go¹/ 鸚鵡</p>\n</li>\n<li><p>麻雀 /mua⁵ ziah⁴/</p>\n</li>\n<li><p>蝠婆 /big⁴ bo⁵/ 蝙蝠</p>\n</li>\n<li><p>蛇 /zua⁵/</p>\n</li>\n<li><p>雨傘節 /hao⁶ suan³ zag⁴/ 一种毒蛇。</p>\n</li>\n<li><p>狗母蛇 /gao² bho² zua⁵/ 蛇舅母、石龍子、四腳蛇，蜥蜴的一種</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%201.png\" alt></p>\n</li>\n<li><p>兩棲動物 /liang² ci¹ dong⁶ moih⁸/</p>\n</li>\n<li><p>蟾蜍 /ziong¹ zu⁵/</p>\n</li>\n<li><p>蛤虯 /gab⁴ giu²/ 青蛙</p>\n</li>\n<li><p>蛤蛙 /gab⁴ guai¹/ 蝌蚪</p>\n</li>\n<li><p>蚼蟻 /gao² hia⁶/ 螞蟻</p>\n</li>\n<li><p>白蟻 /bêh⁸ hia⁶/</p>\n</li>\n<li><p>蜜蜂 /bhig⁸ pang¹/</p>\n</li>\n<li><p>虎頭蜂 /hao² tao⁵ pang¹/ 黄蜂</p>\n</li>\n<li><p>龜 /gu¹/ 烏龜或像烏龜的昆蟲</p>\n</li>\n<li><p>金龜 /gim¹ gu¹/ 金龜子</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%202.png\" alt></p>\n</li>\n<li><p>鱉 /bih⁴/</p>\n</li>\n<li><p>土蚓 /dao⁶ ung²/ 蚯蚓</p>\n</li>\n<li><p>蜈蚣 /gê⁵ gang¹/</p>\n</li>\n<li><p>火金蛄 /hoi² gim¹ gao¹/ 螢火蟲</p>\n</li>\n<li><p>牛屎龜 /ghu⁵ sai² gu¹/ 屎殼郎、蜣螂</p>\n</li>\n<li><p>烏點龜 /ao¹ diam² gu¹/ 七星瓢蟲</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%203.png\" alt></p>\n</li>\n<li><p>紅新娘 /ang⁵ sing¹ nion⁵/ 紅姬緣椿象</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%204.png\" alt></p>\n</li>\n<li><p>山蛚 /sua¹ lê⁷/ 蟬；多指<a href=\"http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14818\">蚱蝉</a></p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%205.png\" alt></p>\n</li>\n<li><p>蝘悲蟬 /iam⁶ bi¹ sung⁵/ <a href=\"http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14817\">蟪蛄</a></p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/image.jpg\" alt=\"gahzi-oi-hung-lui-ci-biao/image.jpg\"></p>\n</li>\n<li><p>蟋蟀 /tih⁴ sug⁴/ 又稱烏龍。</p>\n</li>\n<li><p>䷀ // 螽斯、莎蟲、紡織娘、蟈蟈。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%206.png\" alt></p>\n</li>\n<li><p>草猴 // 稻蝦</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%207.png\" alt></p>\n</li>\n<li><p>䷀ // 金盾龜金花蟲</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%208.png\" alt></p>\n</li>\n<li><p>草蜢 /cao² mên²/ 螞蚱、蚱蜢。</p>\n</li>\n<li><p>螳螂、螳蜋 /tang⁵ lang⁵/</p>\n</li>\n<li><p>神螂 /sing⁵ lang⁵/ 壁虎，蜥蜴的一種。</p>\n</li>\n<li><p>蛤蚧蛇 /gab⁴ gai³ zua⁵/ 大壁虎，蜥蜴的一種。</p>\n</li>\n<li><p>土猴 /dao⁶ gao⁵/ 螻蛄</p>\n</li>\n<li><p>蝶、蜨 /iah⁸/ 蝴蝶</p>\n</li>\n<li><p>山螟 /suan¹ mê¹/ 蜻蜓</p>\n</li>\n<li><p>米龜 /bhi² gu¹/ 米象，蛀食稻穀、麥粒等米糧爲生。</p>\n</li>\n<li><p>蛀蟲 /zu³ tang⁵/</p>\n</li>\n<li><p>蛓毛蟲 /ci³ mo⁵ tang⁵/ 毛毛蟲</p>\n</li>\n<li><p>流鼻螺 /lao⁵ pin⁷ lê⁵/ 蝸牛</p>\n</li>\n<li><p>戶蠅 /hao⁵ sing⁵/ 蒼蠅</p>\n</li>\n<li><p>枯蠅 /gao¹ sing⁵/ 介殼蟲</p>\n</li>\n<li><p>蠓、蚊 /mang²/</p>\n</li>\n<li><p>蝨母 /sag⁴ bho²/ 蝨子</p>\n</li>\n<li><p>曱甴、虼蚻 /ga¹ zuah⁸/ 蟑螂</p>\n</li>\n<li><p>蜈蜞 /ghao⁵ ki⁵/ 水蛭，喜歡吸血人畜血液。</p>\n</li>\n</ol>\n<h3 id=\"🐳水產-zui²-suan²\"><a href=\"#🐳水產-zui²-suan²\" class=\"headerlink\" title=\"🐳水產(zui² suan²)\"></a>🐳水產(zui² suan²)</h3><ol>\n<li><p>䭕水魚 /zian² zui² hu⁵/ 淡水魚</p>\n</li>\n<li><p>鹹水魚 /giam⁵ zui² hu⁵/ 海水魚</p>\n</li>\n<li><p>刣魚 /tai⁵ hu⁵/ 宰魚</p>\n</li>\n<li><p>魚春 /hu⁵ cung¹/ 魚卵。屈大均《廣東新語》：「粵方言凡禽魚卵皆為春。唐時吳君貢魚春子，即魚子也。」 </p>\n</li>\n<li><p>魚鱗 /hu⁵ lang⁵/</p>\n</li>\n<li><p>魚鰾 /hu⁵ pio⁶/</p>\n</li>\n<li><p>魚鰓 /hu⁵ ci¹/</p>\n</li>\n<li><p>魚刺 /hu⁵ ci³/</p>\n</li>\n<li><p>鯁 /gên²/ 魚刺在喉</p>\n</li>\n<li><p>馬鮫 /mê² ga¹/</p>\n</li>\n<li><p>鯧 /cion¹/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%209.png\" alt></p>\n</li>\n<li><p>鰇魚 /riu⁵ hu⁵/ 魷魚</p>\n</li>\n<li><p>墨斗 /bhag⁸ dao²/、/mag⁸ dao²/ 墨魚</p>\n</li>\n<li><p>絲丁魚 /si¹ dêng⁶ hu⁵/ 龍頭魚、硬魚、橂魚(殿魚)、豆腐魚</p>\n</li>\n<li><p>狗母魚 // 蝦虎魚、狗魽仔魚、九甘魚</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2010.png\" alt></p>\n</li>\n<li><p>白目噯 /ain²/</p>\n</li>\n<li><p>狗母囝 // 身體透明，似魩仔鱼，有淡水和海水兩種</p>\n</li>\n<li><p>鰻魚 /muan⁵ hu⁵/</p>\n</li>\n<li><p>花仙魚 /hoi¹ siang¹ hu⁵/ 鮐魚</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2011.png\" alt></p>\n</li>\n<li><p>鸚哥魚 /êng¹ go¹ hu⁵/ 洛神項鰭魚、紅姑娘、紅新娘、碼頭魚</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2012.png\" alt></p>\n</li>\n<li><p>癩瘑魚 /na³ go¹ hu⁵/、/lai³ go¹ hu⁵/ 多齒蛇鯔，俗稱「那哥魚」，常用於製魚丸。</p>\n</li>\n<li><p>娘愛魚 /nion⁵ ain¹ hu⁵/ 泥猛魚、褐篮子鱼、臭肚鱼。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2013.png\" alt></p>\n</li>\n<li><p>䷀囝 /dêg⁸ gian²/ 又稱迪仔、綠鰭馬面魨、剝皮魚。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2014.png\" alt></p>\n</li>\n<li><p>䱛囝 /oig⁸ gian²/ 䱛仔、䱛魚</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2015.png\" alt></p>\n</li>\n<li><p>金龍䱛 /gim¹ lêng⁵ oig⁸/ 金龍魚、黃花魚，狀似䱛魚但個頭大、嘴圓、體黃。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2016.png\" alt></p>\n</li>\n<li><p>福壽魚 /hog⁴ siu⁶ hu⁵/ 羅非魚</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2017.png\" alt></p>\n</li>\n<li><p>鮭魚 /guai¹ hu⁵/ 河魨，俗稱「乖魚」，常指黃鰭東方魨。</p>\n</li>\n<li><p>黃牆 /ng⁵ cion⁵/ 黃鰭鯛</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2018.png\" alt></p>\n</li>\n<li><p>軟甘 /nng² gang¹/ 杜氏鰤、油甘，體側有黃色縱帶。 </p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2019.png\" alt></p>\n</li>\n<li><p>沙尖 /sua¹ ziam¹/ 多鱗鱚、沙鯪、北方稱沙丁魚。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2020.png\" alt></p>\n</li>\n<li><p>龍箭 /lang⁷ zin⁷/ 鯪魚 ，淡水魚，可用於做罐頭魚。</p>\n</li>\n<li><p>石剎 /zio² sag⁴/ 又稱烏雞，松鯛。</p>\n</li>\n<li><p>淡角魚 /dam⁶ gag⁴ hu⁵/ 鯒魚、辮子魚</p>\n</li>\n<li><p>烏魚 /ao¹ hu⁵/ 又稱烏頭，鯔魚。</p>\n</li>\n<li><p>烏前魚 /ao¹ zain⁵ hu⁵/</p>\n</li>\n<li><p>塗虱 /tao⁵ sag⁴/ 鬍子鯰</p>\n</li>\n<li><p>龍舌 /lêng⁵ zi²/ 龍利魚</p>\n</li>\n<li><p>巴浪 /ba¹ lang¹/ 藍圓鯵</p>\n</li>\n<li><p>鯇魚 /uang² hu⁵/ 草魚</p>\n</li>\n<li><p>姑魚 /gao¹ hu⁵/ 金色小沙丁魚</p>\n</li>\n<li><p>鯽魚 /zig⁴ hu⁵/</p>\n</li>\n<li><p>秋刀魚 /ciu¹ do¹ hu⁵/</p>\n</li>\n<li><p>紅目鰱 /ang⁵ mag⁸ liang⁵/ 紅目大眼鯛</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2021.png\" alt></p>\n</li>\n<li><p>田鱔 /cang⁵ cuan⁶/ 鱔魚、黃鱔</p>\n</li>\n<li><p>白帶魚 /bêh⁸ dua³ hu⁵/ 鞭魚、裙帶魚、海刀魚</p>\n</li>\n<li><p>鰐魚 /ngag⁸ hu⁵/</p>\n</li>\n<li><p>鯊魚 /sua¹ hu⁵/</p>\n</li>\n<li><p>鯨魚 /kêng⁵ hu⁵/</p>\n</li>\n<li><p>紅哥鯉 /ang⁵ go¹ li²/ 金線魚</p>\n</li>\n<li><p>蝦 /hê⁵/</p>\n</li>\n<li><p>蟹 /hoi⁶/</p>\n</li>\n<li><p>三目蠘 /san¹ mag⁸ cih⁸/ 紅星梭子蟹、三目蟹</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2022.png\" alt></p>\n</li>\n<li><p>海哲 /hai² diag⁴/</p>\n</li>\n<li><p>蠔、蚝、蚵 /o⁵/ 牡蠣</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2023.png\" alt></p>\n</li>\n<li><p>紅肉 /ang⁵ nê²/ 紅肉藍蛤</p>\n</li>\n<li><p>蚶 /ham¹/</p>\n</li>\n<li><p>蜆 /hain⁶/</p>\n</li>\n<li><p>青匙 /cên¹ si⁵/ 綠殼菜蛤、翡翠貽貝</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2024.png\" alt></p>\n</li>\n<li><p>花蛤 /hoi¹ gab⁴/ 菲律賓簾蛤、花甲</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2025.png\" alt></p>\n</li>\n<li><p>車白 /cia¹ bêh⁸/ 文蛤，邊緣弧度較花蛤圓。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2026.png\" alt></p>\n</li>\n<li><p>青蛤 /cên¹ gab⁴/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2027.png\" alt></p>\n</li>\n<li><p>毛蚶 /mo⁵ ham¹/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2028.png\" alt></p>\n</li>\n<li><p>薄殼 /bo² kag⁴/ 尋氏肌蛤、海蛔、海瓜子</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2029.png\" alt></p>\n</li>\n<li><p>指甲螳 /zain² gah⁴ tang⁵/ 又稱指甲蚌hong²，蟶sêng³子。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2030.png\" alt></p>\n</li>\n<li><p>田螺 /cang⁵ lê⁵/</p>\n</li>\n<li><p>尖螺 /ziang¹ lê⁵/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2031.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"🌾-蔬菜-so¹-cai³\"><a href=\"#🌾-蔬菜-so¹-cai³\" class=\"headerlink\" title=\"🌾 蔬菜(so¹ cai³)\"></a>🌾 蔬菜(so¹ cai³)</h3><ol>\n<li><p>五穀 /ngao⁶ gag⁴/</p>\n</li>\n<li><p>稻 /diu⁶/</p>\n</li>\n<li><p>粟 /cêg⁴/ 稻粒</p>\n</li>\n<li><p>麥 /mê²/</p>\n</li>\n<li><p>秫米 /zu² bhi²/ 糯米</p>\n</li>\n<li><p>薏米 /in³ bhi²/</p>\n</li>\n<li><p>薏仁 /in³ ring⁵/ 玉米</p>\n</li>\n<li><p>蕃薯 /huang¹ zu⁵/、/hang¹ zu⁵/</p>\n</li>\n<li><p>馬鈴薯 /mê² lêng¹ zu⁵/ 土豆</p>\n</li>\n<li><p>黃豆 /ng⁵ dao⁷/ 大豆、菽</p>\n</li>\n<li><p>綠豆 /lê² dao⁷/</p>\n</li>\n<li><p>烏豆 /ao¹ dao⁷/ 黑豆</p>\n</li>\n<li><p>赤豆 /ciah⁴ dao⁷/ 紅小豆</p>\n</li>\n<li><p>荷目豆 /ho⁵ mag⁸ dao⁷/ 荷蘭豆、豌豆</p>\n</li>\n<li><p>地豆 /di⁷ dao⁷/ 花生</p>\n</li>\n<li><p>豆仁 /dao⁷ ring⁵/ 花生米</p>\n</li>\n<li><p>油麻 /iu⁵ mua⁵/ 芝麻</p>\n</li>\n<li><p>菜豆 /cai³ dao⁷/ 常指四季豆</p>\n</li>\n<li><p>茄 /gio⁵/</p>\n</li>\n<li><p>苦瓜 /kao² goi¹/</p>\n</li>\n<li><p>角瓜 /gag⁴ goi¹/ 稜角絲瓜</p>\n</li>\n<li><p>秋瓜 /ciu¹ goi¹/ 絲瓜</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2032.png\" alt></p>\n</li>\n<li><p>嬭瓜、奶瓜 /nê¹ goi¹/ 木瓜</p>\n</li>\n<li><p>蓮藕 /nain⁵ nao⁶/</p>\n</li>\n<li><p>菠薐菜 /boi¹ lêng⁵ cai³/ 菠菜</p>\n</li>\n<li><p>蕹菜 /êng³ cai³/ 空心菜</p>\n</li>\n<li><p>春菜 /cung¹ cai³/ 長葉芥菜</p>\n</li>\n<li><p>菜花 /cai³ hoi¹/ 花椰菜</p>\n</li>\n<li><p>芥菜 /gua³ cai³/ 大芥菜、包心芥菜</p>\n</li>\n<li><p>芥藍 /gêg⁴ na⁵/</p>\n</li>\n<li><p>菜頭 /cai³ tao⁵/ 白蘿蔔</p>\n</li>\n<li><p>紅菜頭 /ang⁵ cai³ tao⁵/ 紅蘿蔔</p>\n</li>\n<li><p>薺蔥、錢蔥 /zin⁵ cang¹/ 荸薺</p>\n</li>\n<li><p>韭菜 /gu² cai³/</p>\n</li>\n<li><p>芫荽 /iang¹ sui¹/ 香菜</p>\n</li>\n<li><p>芳菜 /pang¹ cai³/</p>\n</li>\n<li><p>厚合 /gao⁶ hah⁸/ 厚皮菜、莙薘菜、葉用甜菜</p>\n</li>\n<li><p>九層塔 /gao² zang⁵ tah³/ 金不換、羅勒</p>\n</li>\n<li><p>萵菜 /oi¹ cai³/ 皺葉萵苣、生菜</p>\n</li>\n<li><p>劍菜 /giam³ cai³/ 油麥菜</p>\n</li>\n<li><p>上海青 /siang⁶ hai² cên¹/ 青菜的一種</p>\n</li>\n<li><p>芹菜 /king⁵ cai³/</p>\n</li>\n<li><p>津白 /gian¹ bêh⁸/ 又稱紹菜、黃芽白，天津盛產，是大白菜的一種。以下是大白菜的不同品種。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2033.png\" alt></p>\n<p>天津大白菜</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2034.png\" alt></p>\n<p>大白菜</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2035.png\" alt></p>\n<p>娃娃菜</p>\n</li>\n<li><p>高麗菜 /go¹ lê⁵ cai³/ 捲心菜、包菜、結球甘藍</p>\n</li>\n<li><p>菜花 /cai³ hoi¹/ 花椰菜</p>\n</li>\n<li><p>茼蒿 /dang⁵ o¹/</p>\n</li>\n<li><p>枸杞菜 /gao² gi² cai³/</p>\n</li>\n<li><p>真珠菜 /zing¹ zu¹ cai³/ 珍珠花菜、白苞蒿</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2036.png\" alt></p>\n</li>\n<li><p>薟椒 /hiam¹ tsio¹/ 辣椒</p>\n</li>\n<li><p>生果 /cên¹ goi²/ 水果</p>\n</li>\n<li><p>荔果 /nai⁶ goi²/ 荔枝</p>\n</li>\n<li><p>龍眼 /nging⁵ ain²/</p>\n</li>\n<li><p>桑垂 /siong¹ sui⁵/ 桑葚</p>\n</li>\n<li><p>草莓 /cao² bhoi⁵/</p>\n</li>\n<li><p>刺菠 /ci³ bo¹/ 蛇莓、覆盆子</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2037.png\" alt></p>\n</li>\n<li><p>弓蕉 /gêng¹ zio¹/ 香蕉</p>\n</li>\n<li><p>米蕉 /bhi² zio¹/</p>\n</li>\n<li><p>鳥梨 /ziao² lai⁵/</p>\n</li>\n<li><p>檨 /suain⁷/ 芒果</p>\n</li>\n<li><p>菝囝 /bag⁸ gian²/ 番石榴</p>\n</li>\n<li><p>西瓜 /si¹ goi¹/</p>\n</li>\n<li><p>香櫞 /hion¹ ng⁵/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2038.png\" alt></p>\n</li>\n<li><p>柚 /iu⁷/</p>\n</li>\n<li><p>柑 /gan¹/ 柑橘</p>\n</li>\n<li><p>桔 /gig⁴/</p>\n</li>\n<li><p>橙 /cêng⁵/</p>\n</li>\n<li><p>菠蘿 /bo¹ lo⁵/</p>\n</li>\n<li><p>油甘 /iu⁵ gam¹/ 餘甘果，先苦後甜，齒留餘甘。</p>\n</li>\n<li><p>番茄 /huang¹ gio⁵/</p>\n</li>\n<li><p>青竹梅 /cên¹ dêg⁴ bhoi⁵/</p>\n</li>\n<li><p>李 /li²/</p>\n</li>\n<li><p>棗 /zo²/</p>\n</li>\n<li><p>蔗 /zia³/ 甘蔗</p>\n</li>\n</ol>\n<h3 id=\"🌿草藥-cao²-ioh⁸\"><a href=\"#🌿草藥-cao²-ioh⁸\" class=\"headerlink\" title=\"🌿草藥 /cao² ioh⁸/\"></a>🌿草藥 /cao² ioh⁸/</h3><ol>\n<li><p>艾 /hia³/ 艾草 </p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2039.png\" alt></p>\n</li>\n<li><p>草粿草 /cao² goi² cao²/ 仙草</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2040.png\" alt></p>\n</li>\n<li><p>策草 /cêg⁴ cao²/ 又稱抹(bhuah⁴)草、廣防風、防風草，甲子地區神位常年插此草。策 ，大概是指其像馬鞭。</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2041.png\" alt></p>\n</li>\n<li><p>青菭 /cên¹ ti⁵/ 青苔</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2042.png\" alt></p>\n</li>\n<li><p>薄荷 /bo⁵ ho³/、/bon⁵ hon³/</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2043.png\" alt></p>\n</li>\n<li><p>金銀花 /gim¹ nging⁵ hoi¹/</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2044.png\" alt></p>\n</li>\n<li><p>午時花 /ngao² si⁵ hoi¹/</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2045.png\" alt></p>\n</li>\n<li><p>四季春 /si³ kui³ cung¹/ 四季春花</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2046.png\" alt></p>\n</li>\n<li><p>葉下紅 /hio² ê⁶ ang⁵/ 一點紅</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2047.png\" alt></p>\n</li>\n<li><p>臭草花 /cao³ cao² hoi¹/ 五色梅、馬纓丹</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2048.png\" alt></p>\n</li>\n<li><p>飛天蜈蚣 /boi¹ tin¹ ghê⁵ gang¹/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2049.png\" alt></p>\n</li>\n<li><p>金雞脫殼 /gim¹ goi¹ tug⁴ kag⁴/</p>\n</li>\n<li><p>路跤菊 /lao⁷ ka¹ gêg⁴/ 路邊菊</p>\n</li>\n<li><p>臘裏葉 /lah⁸ li² hioh⁸/ 金邊紅桑</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2050.png\" alt></p>\n</li>\n<li><p>芒囝筍 /mang⁵ gian² sung²/ 芒草的嫩芽</p>\n</li>\n<li><p>竹菜 /dêg⁴ cai³/ 竹葉草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2051.png\" alt></p>\n</li>\n<li><p>葛菜 /guah⁴ cai³/ 野葛菜，可食。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2052.png\" alt></p>\n</li>\n<li><p>烏規菜 /ao¹ gui¹ cai³/ 龍葵</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2053.png\" alt></p>\n</li>\n<li><p>豬母菜 /du¹ bho² cai³/ 馬齒莧</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2054.png\" alt></p>\n</li>\n<li><p>刺莧 /ci³ hain⁷/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2055.png\" alt></p>\n</li>\n<li><p>苦刺 /kao² ci³/ 白簕</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2056.png\" alt></p>\n</li>\n<li><p>苦草 /kao² cao²/ 豨薟草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2057.png\" alt></p>\n</li>\n<li><p>兩公根 /liang² gong¹ ging¹/ 崩大碗</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2058.png\" alt></p>\n</li>\n<li><p>鋪地錦 /pao¹ di⁷ gim²/ 滿天星</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2059.png\" alt></p>\n</li>\n<li><p>雞屎藤 /goi¹ sai² ding⁵/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2060.png\" alt></p>\n</li>\n<li><p>伸筋藤 /cung¹ ging¹ ding⁵/ 蔓九節</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2061.png\" alt></p>\n</li>\n<li><p>無頭藤 /bho⁵ tao⁵ ding⁵/ 寄生於其他植物之上</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2062.png\" alt></p>\n</li>\n<li><p>酒甕囝 /ziu² ang³ gian²/</p>\n</li>\n<li><p>盐酸鸡囝 /iam⁵ sng¹ goi¹ gian²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2063.png\" alt></p>\n</li>\n<li><p>見笑草 /giang³ siao³ cao²/ 含羞草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2064.png\" alt></p>\n</li>\n<li><p>燈籠草 /dêng¹ lang⁵ cao²/ 其果子稱爲「姑娘果」</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2065.png\" alt></p>\n</li>\n<li><p>車前草 /cia¹ zain⁵ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2066.png\" alt></p>\n</li>\n<li><p>馬鞭草 /bhê² bin¹ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2067.png\" alt></p>\n</li>\n<li><p>蟋蟀草 /tig⁴ sug⁴ cao²/ 烏龍草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2068.png\" alt></p>\n</li>\n<li><p>蒲公英 /pu⁵ gong¹ êng¹/</p>\n</li>\n<li><p>鸭舌草 /ah³ zih⁸ cao²/ 苦菜</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2069.png\" alt></p>\n</li>\n<li><p>魚腥草 /hu⁵ co³ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2070.png\" alt></p>\n</li>\n<li><p>益母草 /iah⁴ bho² cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2071.png\" alt></p>\n</li>\n<li><p>龍膽草 /lêng⁵ dan² cao²/ 苦地膽草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2072.png\" alt></p>\n</li>\n<li><p>奶汁草 /nê¹ zab⁴ cao²/ 乳汁草，草折斷會有白色液體流出。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2073.png\" alt></p>\n</li>\n<li><p>虎耳草 /haon² hin⁶ cao³/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2074.png\" alt></p>\n</li>\n<li><p>大號奶汁草 /dua⁷ ho⁷ nê¹ zab⁴ cao³/ 蠔割草、飛揚草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2075.png\" alt></p>\n</li>\n<li><p>貓毛兒 /ngiao¹ mo⁵ ri⁵/ 金絲草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2076.png\" alt></p>\n</li>\n<li><p>貓鬚草 /ngiao¹ ciu¹ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2077.png\" alt></p>\n</li>\n<li><p>鹅囝香 /gho⁵ gian² hiang¹/ 鹅不食草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2078.png\" alt></p>\n</li>\n<li><p>白花蛇舌草 /bêh⁸ hoi¹ zua⁵ zih⁸ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2079.png\" alt></p>\n</li>\n<li><p>白花蟛蜞草 /bêh⁸ hoi¹ pen⁵ ki⁵ cao²/、/bêh⁸ hoi¹ mua⁵ ki⁵ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2080.png\" alt></p>\n</li>\n<li><p>四方枝苦楝 /si³ bang¹ gi¹ kao² nai⁷/ 鬼針草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2081.png\" alt></p>\n</li>\n<li><p>苦楝 /kao² nai⁷/ 苦楝樹</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2082.png\" alt></p>\n</li>\n<li><p>挨礱被哺 /oi⁵ lang⁵ bi⁶ bu⁶/ 磨盤草、磨礱草、挨礱地堵，其果實似磨盤和礱。礱，磨谷農具。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2083.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"🏮時節-si⁵-zoih⁴\"><a href=\"#🏮時節-si⁵-zoih⁴\" class=\"headerlink\" title=\"🏮時節(si⁵ zoih⁴)\"></a>🏮時節(si⁵ zoih⁴)</h3><ol>\n<li>今年 /gim¹ ni⁵/</li>\n<li>舊年 /gu⁷ ni⁵/ 去年</li>\n<li>前年 /zain³ ni⁵/、/zung³ ni⁵/</li>\n<li>下年 /ê⁶ ni⁵/ 明年</li>\n<li>熱天時 /ruah⁸ tin¹ si⁵/ 夏天</li>\n<li>寒天時 /guan⁵ tin¹ si⁵/ 冬天</li>\n<li>凝天時 /ngang⁵ tin¹ si⁵/ 冬天</li>\n<li>春夏秋冬 /cung¹ hê⁶ ciu¹ dang¹/</li>\n<li>老歷 /lao⁶ lê²/ 農曆</li>\n<li>新曆 /sing¹ lê²/ 公曆</li>\n<li>今日 /gim¹ rig⁸/</li>\n<li>明日 /mêng⁵ rig⁸/</li>\n<li>今旦日 /gian² rig⁸/ 今天</li>\n<li>明旦日 /man³ rig⁸/ 明天</li>\n<li>明眠起 /ma³ mng⁵ ki²/ 明天</li>\n<li>昨日 /za¹ rig⁸/</li>\n<li>前日 /zain⁵ rig⁸/、/zoh⁸ rig⁸/</li>\n<li>後日 /ao⁶ rig⁸/</li>\n<li>大前日 /dua⁷ zain⁵ rig⁸/、/dua⁷ zoh⁸ rig⁸/</li>\n<li>大後日 /dua⁷ ao⁶ rig⁸/</li>\n<li>天光 /tin¹ gng¹/ 天亮</li>\n<li>透早 /tao³ za²/ 黎明</li>\n<li>眠起 /mng⁵ ki²/ 早晨</li>\n<li>日時 /rig⁸ si⁷/ 白天</li>\n<li>早晝 /za² dao³/ 上午</li>\n<li>中晝 /dêng¹ dao³/ 中午</li>\n<li>中晝時 /dêng¹ dao³ si⁵/ 中午</li>\n<li>下晝 /ê⁶ dao³/ 下午</li>\n<li>下旰 /ê⁶ gua³/ 下午</li>\n<li>暗頭 /am³ tao⁵/ 傍晚</li>\n<li>暗頭時 /am³ tao⁵ si⁵/ 傍晚</li>\n<li>下昏 /ê⁶ hng⁵/ 晚上</li>\n<li>下昏時 /ê⁶ hng⁵ si⁵/、/êng² si⁵/ 晚上</li>\n<li>下昏囝 /êng² gian²/ 晚上</li>\n<li>暗時 /am³ si⁷/ 晚上</li>\n<li>暝時、夜時 /mê⁵ si⁷/ 晚上</li>\n<li>暝昏、夜昏 /mê⁵ hng⁵/ 晚上</li>\n<li>暝昏時、夜昏時 /mê⁵ hng⁵ si⁵/、/mêng² si⁵/ 晚上</li>\n<li>暝昏囝 /mêng² gian²/ 晚上</li>\n<li>半暝、半夜 /buan³ mê⁵/</li>\n<li>時分秒 /si⁵ hung⁵ miao²/</li>\n<li>個字 /gai⁵ ri⁷/ 五分鐘</li>\n<li>兩個字久 /no⁶ gai⁵ ri⁷ gu²/ 十分鐘</li>\n<li>頭前 /tao⁵ zain⁵/ 之前</li>\n<li>頭陣 /tao⁵ zung⁵/ 剛才</li>\n<li>下 /ê⁶ miag⁸/、/ê⁶ mig⁸/ 剛才</li>\n<li>一頃 /zêg⁸ kuang³/ 一會兒</li>\n<li>一頃頭 /zêg⁸ kuang³ tao⁵/ 一下子</li>\n<li>煞尾 /suah⁴ bhoi²/ 最後</li>\n<li>今 /dan¹/ 現在</li>\n<li>逐日 /dag⁸ rig⁸/ 每天</li>\n<li>逐暝 /dag⁸ mê⁵/ 每晚</li>\n<li>通日 /tang³ rig⁸/ 整天</li>\n<li>半日 /buan³ rig⁸/</li>\n<li>隔日 /gêh⁴ rig⁸/</li>\n<li>隔暝、隔夜 /gêh⁴ mê⁵/</li>\n<li>別日 /bag⁸ rig⁸/ 改天</li>\n<li>即時 /ziag⁴ si⁵/ 立刻、馬上</li>\n<li>平常時 /pêng⁵ sion⁵ si⁵/ 平時</li>\n<li>一日通通 /zêg⁸ rig⁸ tang³ tang³/ 一整天</li>\n<li>七早八早 /cig⁴ za² boih⁴ za²/ 一大早</li>\n<li>七早蒙流 /cig⁴ za² mo⁵ liu⁵/ 一大早</li>\n<li>烏暗天地 /ao¹ am³ tin¹ di¹/ 天昏地暗</li>\n<li>立春 /lib⁸ cung¹/</li>\n<li>雨水 /u² sui²/</li>\n<li>驚蟄 /gêng¹ dêg8/</li>\n<li>春分 /cung¹ hung¹/</li>\n<li>清明 /cêng¹ mêng⁵/</li>\n<li>谷雨 /gog⁴ u²/</li>\n<li>立夏 /lib⁸ hê⁶/</li>\n<li>小滿 /sio² muan²/</li>\n<li>芒種 /mang⁵ zêng²/</li>\n<li>夏至 /hê⁶ zi³/</li>\n<li>小暑 /siao² su²/</li>\n<li>大暑 /dai⁶ su²/</li>\n<li>立秋 /lib⁸ ciu¹/</li>\n<li>處暑 /cu³ su²/</li>\n<li>白露 /bêh⁸ lao⁷/</li>\n<li>秋分 /ciu¹ hung¹/</li>\n<li>寒露 /guan⁵ lao⁷/</li>\n<li>霜降 /sang¹ gang³/</li>\n<li>立冬 /lib⁸ dang¹/</li>\n<li>小雪 /siao² soh⁴/</li>\n<li>大雪 /dai⁶ soh⁴/</li>\n<li>冬至 /dang¹ zi³/</li>\n<li>小寒 /siao² hang⁵/</li>\n<li>大寒 /dai⁶ hang⁵/</li>\n<li>時年八節 /si⁵ ni⁵ boih⁴ zoih⁴/ 一年四季八個節，最早的八節指立春、春分、立夏、夏至、立秋、秋分、立冬和冬至。而在甲子時年八節指元宵、春分、清明、五月節、七月半、秋分、八月半、冬節，過此八節要拜祖，除春分、秋分外的節還需要拜神。<ul>\n<li>四時，四季、春夏秋冬。</li>\n<li>年，甲骨文象人負禾之形，會穀物豐收之意，古時禾穀一年一熟，於是「年」被（引申）用作周年之年。【爾雅•釋天】夏曰歲，商曰祀，周日年，唐虞曰載。古時一度流行歲星（即木星、朱比特星，公轉週期爲 398.88 天）紀年，故一年又稱一歲。</li>\n<li>時年，一年四季。</li>\n<li>節，中國曆法把一年分為二十四段，每段的開始即爲節。早期只有春分、秋分、夏至、冬至四節，後又加入立春、立夏、立秋、立冬，形成八節，再來後逐漸形成了二十四節。「節」早期是天文曆法上的概念，與氣候相關，後又逐漸加入了紀念或慶祝的元素。</li>\n</ul>\n</li>\n<li>元宵節 /nguang⁵ siao¹ zoih⁴/</li>\n<li>公忌節 /gong¹ gi⁷ zoih⁴/ 春分和秋分，祭拜先祖，但不拜神。</li>\n<li>清明節 /cêng¹ mêng⁵ zoih⁴/</li>\n<li>五月節 /ngao⁶ ghoih⁸ zoih⁴/ 端午節</li>\n<li>七月半 /cig⁴ ghoih⁸ buan³/ 中元節、鬼節</li>\n<li>八月半 /boih⁴ ghoih⁸ buan³/ 中秋節</li>\n<li>冬節 /dang¹ zoih⁴/ 冬至節的簡稱。</li>\n<li>廿九暝、廿九夜 /rig⁸ gao² mê⁵/ 除夕（小月）</li>\n<li>三十暝、三十夜 /san¹ zab⁸ mê⁵/ 除夕（大月）</li>\n<li>春節 /cung¹ zoih⁴/</li>\n<li>重陽 /ciang⁵ iang⁵/、/dêng⁵ iang⁵/</li>\n<li>國慶節 /gog⁴ kêng³ zoih⁴/</li>\n<li>勞動節 /lao⁵ dong⁶ zoih⁴/</li>\n<li>婦女節 /hu⁶ nng² zoih⁴/</li>\n<li>兒童節 /ri⁵ tong⁵ zoih⁴/</li>\n<li>教師節 /ga³ su¹ zoih⁴/</li>\n<li>做節 /zo³ zoih⁴/ 過節日</li>\n<li>做壽 /zo³ siu⁶/ 過壽辰</li>\n<li>做生日 /zo³ sên¹ rig⁸/ 過生日</li>\n<li>公忌 /gong¹ gi⁷/ 先祖忌日</li>\n<li>拜公忌 /bai³ gong¹ gi⁷/ 在忌日祭拜先祖</li>\n<li>拜祖 // 祭拜先祖</li>\n<li>拜老爺 // 拜神</li>\n<li>假日 /gia² rig⁸/</li>\n<li>放假 /bang³ gia²/、/bang³ gian²/</li>\n<li>暑假 /su² gia²/</li>\n<li>寒假 /hang⁵ gia²/</li>\n</ol>\n<h3 id=\"🌀天時-tin¹-si⁵\"><a href=\"#🌀天時-tin¹-si⁵\" class=\"headerlink\" title=\"🌀天時(tin¹ si⁵)\"></a>🌀天時(tin¹ si⁵)</h3><ol>\n<li>晴 /zên⁵/ 晴朗</li>\n<li>出日 /cug⁴ rig⁸/ 太陽出來了</li>\n<li>透堂白日 /tao³ dng⁵ bêh⁸ rig⁸/ 大白天</li>\n<li>烏陰天 /ao¹ im¹ tin¹/ 陰天</li>\n<li>透風 /tao³ hong¹/ 刮大風</li>\n<li>風颱 /hong¹ tai¹/ 颱風</li>\n<li>南風天 /nang¹ hong¹ tin¹/ 刮南風，濕氣加重</li>\n<li>轉南風 /dng² nang¹ hong¹/ 南風天來了</li>\n<li>透南風 /tao³ nang¹ hong¹/ 刮南風，伍佰有一 Live 同名。</li>\n<li>蒙煙天 /mong⁵ iang¹ tin¹/ 霧霾天</li>\n<li>落雨 /lo² hao⁶/ 下雨</li>\n<li>一陣雨 /zêg⁸ zung⁵ hao⁶/</li>\n<li>日頭雨 /rig⁸ tao⁵ hao⁶/ 一邊下雨，一邊出太陽</li>\n<li>烏寒雨 /ao¹ guan⁵ hao⁶/ 天時烏陰落寒雨</li>\n<li>爍焰 /sih⁴ iam⁶/ 閃電</li>\n<li>敲雷 /ka³ lui⁵/ 打雷</li>\n<li>冷空氣 /lêng² kong¹ ki⁷/</li>\n<li>落雪 /lo² soh⁴/ 下雪</li>\n<li>落雹 /lo² pag⁸/ 下冰雹</li>\n<li>旱 /uan⁶/ 乾旱</li>\n<li>寒 /guan⁵/ 寒冷</li>\n<li>冷 /lêng²/ 寒冷</li>\n<li>凝 /ngang⁵/ 寒冷</li>\n<li>熱 /ruah⁸/</li>\n<li>翕熱 /hib⁴ ruah⁸/ 悶熱</li>\n<li>乾燥 /gang¹ cao³/</li>\n<li>濕 /sib⁴/ 濕潤</li>\n<li>涼 /liang⁵/ 涼爽</li>\n</ol>\n<h3 id=\"🌛天文-tiang¹-bhung⁵\"><a href=\"#🌛天文-tiang¹-bhung⁵\" class=\"headerlink\" title=\"🌛天文(tiang¹ bhung⁵)\"></a>🌛天文(tiang¹ bhung⁵)</h3><ol>\n<li>天頂 /tin¹ dêng²/ 天上</li>\n<li>日頭 /rig⁸ tao⁵/ 太陽</li>\n<li>蝕日 /sih⁸ rig⁸/ 日食</li>\n<li>狗齧日 /gao² na² rig⁸/ 天狗食日</li>\n<li>西照日 /sai¹ zio³ rig⁸/ 夕陽</li>\n<li>月娘 /ghoih⁸ nion⁵/ 月亮</li>\n<li>月眉 /ghoih⁸ bhai⁵/ 弦月</li>\n<li>蝕月 /sih⁸ ghoih⁸/ 月食</li>\n<li>河溪 /ho⁵ koi¹/ 銀河、天河</li>\n<li>落屎星 /lo² sai² cên¹/ 流星</li>\n<li>星宿 /cên¹ siu³/</li>\n</ol>\n<h3 id=\"⛰️地理-di⁷-li²\"><a href=\"#⛰️地理-di⁷-li²\" class=\"headerlink\" title=\"⛰️地理(di⁷ li²)\"></a>⛰️地理(di⁷ li²)</h3><ol>\n<li>中央 /diong¹ iang¹/ 中間</li>\n<li>內底 /lai⁶ doi²/ 裏面</li>\n<li>外口 /ghua⁷ kao²/、/la¹ kao²/ 外面</li>\n<li>頭頂 /tao⁵ dêng²/ 上面</li>\n<li>下跤 /ê⁶ ka¹/ 下面</li>\n<li>下底 /ê⁶ doi²/ 下面</li>\n<li>正手爿 /ziang³ ciu² bain⁵/ 左邊</li>\n<li>倒手爿 /do³ ciu² bain⁵/ 右邊</li>\n<li>頭前 /tao⁵ zain⁵/ 前面</li>\n<li>後底 /ao⁶ doi²/ 後面</li>\n<li>後壁 /ao⁶ biah⁴/ 後面</li>\n<li>對面 /dui³ ming⁷/</li>\n<li>隔壁 /gêh⁴ biah⁴/</li>\n<li>鄰近 /lim¹ ging⁶/</li>\n<li>塗跤 /tao⁵ ka¹/</li>\n<li>番爿 /huang¹ bain⁵/</li>\n<li>北爿 /bag⁴ bain⁵/</li>\n<li>東南西北 /dang¹ nam⁵ sai¹ bag⁴/</li>\n<li>地盤 /di⁷ buan⁵/</li>\n<li>領域 /nia² oig⁸/</li>\n<li>境內 /gêng² lai⁶/</li>\n<li>世界 /si³ gai³/</li>\n<li>宇宙 /u² diu²/</li>\n<li>全球 /cuang¹ giu⁵/</li>\n<li>天涯 /tiang¹ ngai⁵/</li>\n<li>山頂 /suan¹ dêng²/</li>\n<li>山跤 /suan¹ ka¹/</li>\n<li>外地 /ghua⁷ dê³/</li>\n<li>本地 /bng² di⁷/</li>\n<li>別地 /bag⁸ dê³/ 外地</li>\n<li>別地地 /bag⁸ di⁷ dê³/ 外地</li>\n<li>塗 /tao⁵/ 泥</li>\n<li>塗膏 /tao⁵ go¹/ 泥巴</li>\n<li>石頭 /zioh⁸ tao⁵/</li>\n<li>田園 /cang⁵ hng⁵/</li>\n<li>溪墘 /koi¹ gin⁵/ 溪邊</li>\n<li>草埔 /cao² bao¹/ 草坪</li>\n<li>崎 /gia⁶/ 小山坡</li>\n<li>坑 /kên/ 山谷、溪谷。</li>\n<li>嶺 /nia²/ 有路可通的山頂</li>\n<li>岑 /ngim⁵/、/cam⁵/ 小而高的山</li>\n<li>墟 /hu¹/ 大土山</li>\n<li>壩 /ba³/ 沙灘、沙洲。</li>\n<li>潭 /tam⁵/ 深水池</li>\n<li>溪 /koi¹/</li>\n<li>江 /gang¹/</li>\n<li>河 /ho⁵/</li>\n<li>湖 /ao⁵/</li>\n<li>海 /hai²/</li>\n<li>海拔 /hai² buag⁸/</li>\n<li>洲 /ziu¹/</li>\n<li>港 /gang²/</li>\n<li>灣 /uang¹/</li>\n<li>溝 /gao¹/</li>\n<li>渠 /ku⁵/ 水道，特指人工開的河道。</li>\n<li>浦 /pao²/ 水邊或江河入海處</li>\n<li>澳 /o³/ 海邊彎曲且可停泊船隻的地方</li>\n<li>汕 /suan³/ 河流沖刷或沖刷而積成的沙灘</li>\n<li>汕頭 /suan¹ tao⁵/</li>\n<li>汕尾 /suan³ bhoi²/</li>\n<li>海湧 /hai² êng²/ 海浪。湧，波浪。</li>\n<li>東濠湧 /dang¹ hao⁵ cong¹/ 地名，在廣州越秀。濠，溝渠。湧，河流分叉處。</li>\n<li>湧泉相報 /iong³ zuan⁵ siang¹ bo³/ 湧，水冒出。</li>\n<li>庭、埕 /dian⁵/ 院子、宽阔处</li>\n<li>礦物 /kuang³ moih⁸/</li>\n<li>化石 /hoi³ zioh⁸/</li>\n<li>原油 /nguang¹ iu⁵/</li>\n<li>燃料 /riang⁵ liao⁷/</li>\n<li>金屬 /gim¹ siog⁸/</li>\n<li>金銀財寶 /gim¹ nging⁵ cai⁵ bo²/</li>\n<li>鋼鐵 /gng³ tih⁴/</li>\n<li>蘇打 /so³ da²/ 英文 soda 的音譯，常指小蘇打，即碳酸氫鈉。</li>\n<li>蘇州 /sao¹ ziu¹/</li>\n<li>蠟 /la²/</li>\n<li>硫磺 /liu⁵ ng⁵/</li>\n<li>砒霜 /bi¹ sng¹/</li>\n<li>砂石 /sua¹ zioh⁸/</li>\n<li>大理石 /dai⁶ li² zioh⁸/</li>\n<li>碳 /tuan³/</li>\n<li>水銀 /zui² nging⁵/</li>\n<li>水龍水 /zui² lêng⁵ zui²/ 自來水</li>\n<li>地牛換肩 /di⁷ ghu⁵ uang⁷ gain¹/ 地震</li>\n<li>許婆寮 /kao² pua⁵ liao⁵/ 今可和村</li>\n<li>北輋 /bag⁴ sia⁵/ 今博社村</li>\n<li>四捻石 /si³ niam³ zio²/ 四片石</li>\n<li>甲子八景：六十甲子欄、潮來人字水、雙帆跨海島、五馬渡江邊、仙人踏石積、海甲蓮花山、西峯古寺、雷廟天堂。（《陸豐縣誌》卷之二疆域四 P21）</li>\n<li>擎天石：位於甲秀書院的側邊的一塊巨石。《陸豐縣誌》記載：在甲子所北門內峙立聳拔高出雉堞丈余，中開一痕，俗謂雷打石。胡文烜銘其上曰：「天開甲子，巨石臨門，一聲霹靂，振動乾坤 ……」。字大如鬥，余銘苔蝕莫辨。（《陸豐縣誌》卷之二古蹟十二 ）</li>\n<li>甲秀書院：甲秀書院位於陸豐縣甲子鎮北門內。甲秀書院建於明代，歷來為粵東文人會萃講學之所。至今院內仍保存著不少歷代的石碑石刻。解放后，人民政府在此興辦中學。</li>\n<li>福源寺：座落於甲子鎮北郊雨亭路，原名「復元寺」，又稱「蓮花山草庵」。據傳，福源寺建於宋代。因歷史久遠，原址僅遺存牆基。1990年由光茂法師主持重建。經過10多年的建造，先後建成天王殿、大雄寶殿、觀音殿、地藏殿、鐘樓、鼓樓和禪房等，重塑了諸位菩薩聖像。寺區佔地面積1.2萬多平方米，建築面積3000多平方米。</li>\n<li>南海夫人廟：位於甲子鎮城西社區環城路東。明萬曆元年（1573），李棠中舉後爲其妻卓氏而建的紀念祠，御史鄧練題匾「南海夫人」，故稱南海夫人廟。</li>\n<li>烈士墓</li>\n</ol>\n<h3 id=\"📐計量-goi³-liang⁶\"><a href=\"#📐計量-goi³-liang⁶\" class=\"headerlink\" title=\"📐計量(goi³ liang⁶)\"></a>📐計量(goi³ liang⁶)</h3><ol>\n<li>〇、零 /lêng⁵/、/lang⁵/</li>\n<li>一、壹 /zêg⁸/、/ig⁴/</li>\n<li>二、贰 /no⁶/、/ri⁶/</li>\n<li>三、叁 /san¹/、/sam¹/</li>\n<li>四、肆 /si³/、/su³/</li>\n<li>五、伍 /ngao⁶/、/u²/</li>\n<li>六、陆 /lag⁸/</li>\n<li>七、柒 /cig⁴/</li>\n<li>八、捌 /boih⁴/、/bag⁴/</li>\n<li>九、玖 /gao²/、/giu²/</li>\n<li>十、拾 /zab⁸/</li>\n<li>百、佰 /bêh⁴/</li>\n<li>千、仟 /cain¹/、/ciang¹/</li>\n<li>萬 /mang⁷/</li>\n<li>億 /êg⁸/</li>\n<li>一二個 /zêg⁸ no² gai⁵/</li>\n<li>二十六 /ri⁸ ab⁸ lag⁸/、/ri⁸ zab⁸ lag⁸/</li>\n<li>廿六號 /rig⁸ lag⁸ ho⁷/ 二十六號</li>\n<li>五十外個 /ngao⁶ zab⁸ ghua⁷ gai⁵/</li>\n<li>一百空八 /zêg⁸ bêh⁴ kang³ boih⁴/ 一百零八</li>\n<li>第一 /doi⁷ ig⁴/</li>\n<li>第二 /doi⁷ ri⁶/</li>\n<li>第三 /doi⁷ san¹/</li>\n<li>一個人 /zêg⁸ gai⁵ nang⁵/</li>\n<li>一爿花 /zêg⁸ bain⁵ hoi¹/ 一片花瓣</li>\n<li>一蕊花 /zêg⁸ lui² hoi¹/ 一朵花</li>\n<li>一葩花 /zêg⁸ pa¹ hoi¹/ 一朵花</li>\n<li>一枝花 /zêg⁸ gi¹ hoi¹/</li>\n<li>一縛花 /zêg⁸ ba² hoi¹/ 一束花</li>\n<li>一叢樹 /zêg⁸ zang⁵ hoi¹/ 一棵樹</li>\n<li>一簇頭毛 /zêg⁸ cog⁴ tao⁵ mo⁵/ 一撮頭髮</li>\n<li>一粒糖 /zêg⁸ liab⁸ tng⁵/</li>\n<li>一隻車 /zêg⁸ ziah⁴ cia¹/ 一輛車</li>\n<li>一架車 /zêg⁸ gê³ cia¹/ 一輛車</li>\n<li>一杯茶 /zêg⁸ boi¹ dê⁵/</li>\n<li>一碗水 /zêg⁸ uan² zui²/</li>\n<li>一喙水、一嘴水 /zêg⁸ cui³ zui²/ 一口水</li>\n<li>一條弓蕉 /zêg⁸ diao⁵ gêng¹ zio¹/ 一條香蕉</li>\n<li>一本書 /zêg⁸ bng² zu¹/</li>\n<li>一枝手機 /zêg⁸ gi¹ ciu² gi¹/ 一隻手機</li>\n<li>一枝鎖匙 /zêg⁸ gi¹ so² si⁵/ 一把鑰匙</li>\n<li>一個銀 /zêg⁸ gai⁵ nging⁵/ 一塊錢</li>\n<li>一領被 /zêg⁸ nia² poi⁶/ 一席被子</li>\n<li>一個鋪 /zêg⁸ gai⁵ pao¹/ 一張床</li>\n<li>一個鐘頭 /zêg⁸ gai⁵ zêng¹ tao⁵/ 一個小時</li>\n<li>一副衫褲 /zêg⁸ hu³ san¹ kao³/ 一套衣服</li>\n<li>一腰裙 /zêg⁸ io¹ gung⁵/ 一件裙子</li>\n<li>一尾魚 /zêg⁸ bhoi² hu⁵/ 一條魚</li>\n<li>一墩物件 /zêg⁸ dung¹ mi² gian⁶/ 一堆東西</li>\n<li>一橛蔗 /zêg⁸ goi² zia³/ 一截甘蔗</li>\n<li>一葩電火 /zêg⁸ pa¹ diang⁶ hoi²/ 一盞電燈</li>\n<li>一跤箸、一腳箸 /zêg⁸ ka¹ du⁷/ 一隻筷子</li>\n<li>一雙箸 /zêg⁸ sang¹ du⁷/ 一雙筷子</li>\n<li>一腹火 /zêg⁸ bag⁴ hoi²/ 一肚子火</li>\n<li>一脬屎 /zêg⁸ bu⁵ sai²/ 一坨屎</li>\n<li>一脬尿 /zêg⁸ bu⁵ rio⁷/ 一泡尿</li>\n<li>一逝路 /zêg⁸ zua⁷ lao⁷/ 一趟路</li>\n<li>一丸塗 /zêg⁸ uang⁵ tao⁵/ 一團泥土</li>\n<li>一過 /zêg⁸ goi³/ 一次</li>\n</ol>\n<h3 id=\"🧭-指代-zi²-toi³\"><a href=\"#🧭-指代-zi²-toi³\" class=\"headerlink\" title=\"🧭 指代(zi² toi³)\"></a>🧭 指代(zi² toi³)</h3><ol>\n<li>只 /zi²/ 這，近指。</li>\n<li>許 /hi²/ 那，遠指。</li>\n<li>者、這 /zê²/、/zia²/ 這，近指。</li>\n<li>遐 /hê²/、/hia²/ 那，遠指。</li>\n<li>底個 /di⁷ gai⁵/ 哪個</li>\n<li>者個 /zê² gai⁷/、/zia² gai⁷/ 這個</li>\n<li>遐個 /hê² gai⁷/、/hia² gai⁷/ 那個</li>\n<li>怎樣 /za³ ion⁷/、/zion²/</li>\n<li>乜樣 /mig⁴ ion⁷/ 怎樣</li>\n<li>底樣 /di⁷ ion⁷/ 怎樣</li>\n<li>怎生 /za³ sên¹/、/zai¹ sên¹/怎樣</li>\n<li>怎樣生 /zion² sên¹/ 怎樣</li>\n<li>怎樣然 /zion² ni⁵/、/zo⁵ ni⁵/ 怎麼、幹啥</li>\n<li>怎樣麼 /zion² mo⁷/、/ziom²/</li>\n<li>者樣 /zê² ion⁷/、/zion¹/</li>\n<li>遐樣 /hê² ion⁷/、/hion¹/</li>\n<li>者樣生 /zion¹ sên¹/ 這樣</li>\n<li>遐樣生 /hion¹ sên¹/ 那樣</li>\n<li>底搭 /di⁷ dah⁴/ 哪裏</li>\n<li>者搭 /zê² dah⁴/ 這裏</li>\n<li>遐搭 /hê² dah⁴/ 那裏</li>\n<li>底地 /di⁷ dê³/ 哪裏</li>\n<li>者地方 /zê² ding¹/ 這裏</li>\n<li>遐地方 /hê² ding¹/ 那裏</li>\n<li>底囝 /di⁷ gian²/ 哪兒</li>\n<li>者囝 /zê gian²/ 這兒</li>\n<li>遐囝 /hê² gian²/ 那兒</li>\n<li>底人 /di⁷ nang⁵/、/diang⁶/、/di⁷ diang⁶/ 誰</li>\n<li>底位 /di⁷ ui⁷/ 哪位</li>\n<li>者位 /zê² ui⁷/</li>\n<li>遐位 /hê² ui⁷/ 那位</li>\n<li>底時 /di⁷ si⁵/ 什麼時候</li>\n<li>底當時 /diang⁶ si⁵/ 什麼時候</li>\n<li>者時 /zê² si⁵/</li>\n<li>遐時 /hê² si⁵/ 那時</li>\n<li>乜事 /mig⁴ su⁷/ 什麼事情</li>\n<li>若㩼 /rioh⁸ zoi⁷/、/rua⁷ zoi⁷/ 多少</li>\n<li>幾 /gui²/</li>\n<li>豈是 /ka³ si⁷/ 是否是</li>\n<li>敢是 /gam² si⁷/ 是否是</li>\n</ol>\n<h3 id=\"🏃‍♀️動詞-dong⁶-su⁵\"><a href=\"#🏃‍♀️動詞-dong⁶-su⁵\" class=\"headerlink\" title=\"🏃‍♀️動詞(dong⁶ su⁵)\"></a>🏃‍♀️動詞(dong⁶ su⁵)</h3><p><strong>第一部分</strong></p>\n<ol>\n<li>會 /oi⁶/</li>\n<li>無會、袂、𠀾 /bhoi⁶/ 不會</li>\n<li>未 /bhoi⁷/ 沒有（事情還沒做）</li>\n<li>無 /bho⁵/ 沒有</li>\n<li>有 /u⁶/</li>\n<li>好 /ho²/</li>\n<li>毋好、孬 /mo²/ 不好</li>\n<li>欲 /bhêh⁴/ 要</li>\n<li>毋、唔 /m⁶/ 不要</li>\n<li>欲毋 /bhêh⁴ m⁶/、/bhên⁶/ 要不要</li>\n<li>愛 /ain³/ 要</li>\n<li>無愛 /bho⁵ ain³/ 不要</li>\n<li>毋愛、勿、嫑 /main³/ 不要</li>\n<li>用 /êng⁶/ 需要</li>\n<li>免 /miang²/ 不需要</li>\n<li>肯 /kêng²/、/kiang²/ 願意</li>\n<li>毋肯 /m⁶ kêng²/、/m⁶ kiang²/ 不願意</li>\n<li>架勢是 /gê³ si³ si⁷/ 看這情形是。例如：舖關了，架勢是去做節了。 </li>\n</ol>\n<p><strong>第二部分 頭、喙</strong></p>\n<ol>\n<li>dag⁴ 頭 // 點頭</li>\n<li>搖頭 /io⁵ tao⁵/</li>\n<li>攲頭 /ki¹ tao⁵/ 歪頭</li>\n<li>呾 /dan³/ 說</li>\n<li>參詳 // 商量</li>\n<li>學古 /oh⁴ gao²/ 講故事</li>\n<li>罵 /mê⁷/</li>\n<li>詏 /a³/ 爭辯</li>\n<li>冤家 /uang¹ gê¹/ 吵架</li>\n<li>恬 /diam⁷/ 閉嘴、安靜</li>\n<li>咬 /ga⁶/</li>\n<li>哺 /bao⁷/ 咀嚼</li>\n<li>唵 /am⁶/ 將食物放進嘴巴</li>\n<li>喷 /pung³/ 散射</li>\n<li>啡痰 /pui³ tam⁵/ 吐痰</li>\n<li>歕 /bung⁵/ 吹氣</li>\n<li>嗾？ /zag⁸/ 呛到、岔到 </li>\n</ol>\n<p><strong>第三部分 目、心</strong></p>\n<ol>\n<li>睇 /toi²/ 看</li>\n<li>看詳睇 /kang³ siang⁵ toi²/ 仔細看</li>\n<li>經心 /gêng¹ sim¹/ 用心</li>\n<li>經心衋事 // 操心</li>\n<li>經破頭腦 // 想破頭 </li>\n</ol>\n<p><strong>第四部分 手、跤</strong></p>\n<ol>\n<li>揨 /dian¹/ 觸、碰</li>\n<li>拍 /pah⁴/ 打</li>\n<li>舂 /cêng⁵/ 用力打</li>\n<li>/dng⁷/ 打</li>\n<li>刜 /hug⁴/ 揮、打</li>\n<li>剚、倳 /sai⁷/ 打</li>\n<li>抶 /diag⁴/ 用鞭、杖或竹板打。～手</li>\n<li>摔 /sug⁴/ 抽打、鞭打</li>\n<li>拗折 /a² zi²/ 折斷</li>\n<li>盖 /kain³/ 由上往下覆。～頭</li>\n<li>掃 /sao³/ 迅速掠過。～面</li>\n<li>揞 /an¹/ 掩。～面</li>\n<li>diu³ 竹囝</li>\n<li>擎 /gia⁵/ 舉、握、拿</li>\n<li>𢭪 /kioh⁴/ 撿、拾</li>\n<li>挈 /kioh⁸/ 取、拿</li>\n<li>摜 /guan⁶/ 提</li>\n<li>厾 /doh⁴/ 戳</li>\n<li>割 /guah⁴/</li>\n<li>殺 /suah⁴/</li>\n<li>斬 /zam²/</li>\n<li>斫 /dog⁴/ 剁</li>\n<li>宰 /zai²/ 殺</li>\n<li>刣 /tai⁵/ 殺</li>\n<li>拭 /cig⁴/ 擦</li>\n<li>濡 /ru⁵/ 用濕布擦或用拖把拖</li>\n<li>爬 /bê⁵/ 搔(癢)</li>\n<li>掊 /boi²/ 扒開</li>\n<li>揂 /ciu⁵/ 拉引繩子</li>\n<li>𠡒 /dui²/ 用力拉</li>\n<li>捏 /dên⁶/ 掐</li>\n<li>漱牙 /ciu³ ghê⁵/ 刷牙</li>\n<li>跋 /buah⁸/ 摔倒</li>\n<li>踏 /dah⁴/ 踩</li>\n<li>踢 /tag⁴/</li>\n<li>去 /ku³/、/ka³/</li>\n<li>轉 /dng²/ 回來</li>\n<li>綴 /doi³/ 跟著；縫合。</li>\n<li>修理 /siu¹ li²/、/su¹ li²/</li>\n<li>泊車 /pag⁴ cia¹/ 停車。泊，粵語音譯英文 park 得來，停車的意思。</li>\n</ol>\n<p><strong>第五部分</strong></p>\n<ol>\n<li>曳、𤆬 /cua⁷/ 帶、領</li>\n<li>娶 /cua⁷/ 取婦</li>\n<li>徙 /sua²/ 移動</li>\n<li>歇 /hiah⁴/ 放置、休息</li>\n<li>煩惱 /huang⁵ lo²/ 擔心</li>\n<li>相信 /sion¹ siang³/、/siang¹ sing⁷/ 相信</li>\n<li>相輔 /sion³ hu⁶/ 幫忙</li>\n<li>排比 /bai⁵ bi²/ 安排</li>\n<li>含包 /ham⁵ bao¹/ 包含</li>\n<li>拚頭前 /bian³ tao⁵ zain⁵/ 爭先</li>\n<li>輸服 /su¹ hog⁸/ 佩服</li>\n<li>䷀䷀ /dag⁴ nng⁷/ 浪費</li>\n<li>䷀落 /ga¹ lao⁵/ 掉落</li>\n<li>沕 /bhih⁴/ 躲藏</li>\n<li>支 /zin¹/ 預付</li>\n<li>圖賴 /tu⁵ tai²/ 耍賴</li>\n<li>放惰 /bang¹ dua⁶/ 懶得</li>\n</ol>\n<h3 id=\"🧜‍♀️形容-heng⁵-iong⁵\"><a href=\"#🧜‍♀️形容-heng⁵-iong⁵\" class=\"headerlink\" title=\"🧜‍♀️形容(hêng⁵ iong⁵)\"></a>🧜‍♀️形容(hêng⁵ iong⁵)</h3><ol>\n<li>媠 /sui²/ 好、漂亮</li>\n<li>雅 /ngia²/ 正、漂亮</li>\n<li>生好 /sên¹ ho²/ 漂亮、好看</li>\n<li>䆀 /bhai²/ 差、醜陋</li>\n<li>好 /ho²/</li>\n<li>痞、歹 /pai²/</li>\n<li>大細 /dua⁷ soi³/ 大小</li>\n<li>㩼少 /zoi⁷ zio²/ 多少</li>\n<li>加加減減 /gê¹ gê¹ giam² giam²/ 多多少少</li>\n<li>稀罕 // 稀少，罕見。</li>\n<li>賤 /la¹ zuan⁷/ 繁多，低賤。物以稀為貴，多則賤。</li>\n<li>猛慢 /mê² mang⁷/ 快慢、早晚。猛，快。</li>\n<li>肥 /bui⁵/ 胖</li>\n<li>肥腯肥腯 /bui⁵ tuh⁸ bui⁵ tuh⁸/ 胖嘟嘟</li>\n<li>㾪 /sang²/ 瘦</li>\n<li>㾪猴 /sang² gao⁵/ 瘦得跟猴子一樣</li>\n<li>㾪脯皺 /sang² bao² niao³/ 又瘦又缺水又褶皺，形容飢瘦。</li>\n<li>懸下 /guai⁵/ 高低</li>\n<li>早 /za²/</li>\n<li>晏 /uang³/ 晚</li>\n<li>粗 /cao¹/</li>\n<li>幼 /iun³/ 細</li>\n<li>粗殘 /cao¹ cang⁵/ 粗魯</li>\n<li>仔細 /zu² soi⁷/ 小心</li>\n<li>芳 /pang¹/ 香</li>\n<li>臭 /cao³/</li>\n<li>僫 /oh⁴/ 困難</li>\n<li>易 /goi⁷/ 容易</li>\n<li>闊 /kuah⁴/ 寬</li>\n<li>狹 /oih⁸/ 窄</li>\n<li>光 /gng¹/ 亮</li>\n<li>暗 /am³/</li>\n<li>恬 /diam⁷/ 安靜</li>\n<li>吵 /cao¹/ 吵鬧</li>\n<li>吵吵著 /cao¹ cao¹ dioh⁴/ 吵吵鬧鬧的</li>\n<li>飽 /ba²/</li>\n<li>枵 /iao¹/ 餓</li>\n<li>橂 /dain⁷/ 堅實、堅硬</li>\n<li>軟 /nam³/ 軟弱。本字不明，訓用「軟」。</li>\n<li>韌 /rung⁷/ 堅強；不容易斷裂。</li>\n<li>脆 /cê³/ 脆弱；容易斷裂。</li>\n<li>聰明 /cong¹ mêng⁵/</li>\n<li>愚蠢 /ngo⁵ cung²/</li>\n<li>戇 /gong³/ 愚笨</li>\n<li>賰 /cung⁵/ 剩餘</li>\n<li>欠 /kiam³/ 缺少</li>\n<li>清 // 清晰、乾淨</li>\n<li>雾 /bhu⁷/ 模糊</li>\n<li>清氣 /cêng¹ ki³/ 乾淨</li>\n<li>清氣相 /cêng¹ ki³ sion³/ 乾淨的樣子</li>\n<li>垃圾 /lah⁴ sab⁴/ 骯臟</li>\n<li>垃圾相 /lah⁴ sab⁴ sion³/ 骯臟的樣子</li>\n<li>無沙無圾 /bho⁵ sua¹ bho⁵ sab⁴/ 一塵不染</li>\n<li>灱 /da¹/ 乾燥</li>\n<li>㴷 /dam⁵/ 濕潤</li>\n<li>落雨㴷渧 /lo² hao⁶ dam⁵ di³/ 下雨濕漉漉的樣子</li>\n<li>著 /dioh⁸/ 對、正確</li>\n<li>毋著 /m⁷ dioh⁸/ 不對</li>\n<li>錯 /co³/</li>\n<li>熟 /sêg⁸/</li>\n<li>生 /cên¹/ (瓜果等)未成熟</li>\n<li>臭生 /cao³ cên¹/ 未煮熟或瓜果未成熟</li>\n<li>臭酸 /cao³ sng¹/ 食物變質</li>\n<li>黐黐 /ti¹ ti¹/ 黏稠</li>\n<li>切要 /ciag⁴ iao³/ 要緊</li>\n<li>無要緊 /bho⁵ iao³ ging²/ 不要緊</li>\n<li>大扮</li>\n<li>咸澀</li>\n<li>力相 // 努力</li>\n<li>惰 /duan⁶/ 懶惰</li>\n<li>鬧熱 /nao⁶ ria²/ 熱鬧</li>\n<li>活神 // 精神好，灵活</li>\n<li>健 /gian⁷/ 身體好</li>\n<li>碩㦙 /sêg⁴ ngo³/ 聰明和愚蠢</li>\n<li>夠力 /gao³ lag⁸/ 厲害</li>\n<li>夠強 /gao³ kiang³/ 厲害</li>\n<li>夠衰 /gao³ soi¹/ 好慘</li>\n<li>緊要 /ging² iao³/ 要緊</li>\n<li>切要 /ciag⁴ iao³/ 要緊</li>\n<li>癩瘑糜烂 //</li>\n<li>枝毛小節、枝毛細節 // 無關緊要</li>\n<li>偪側 /bêg⁴ cêg⁴/ 心中有氣，煩躁不安。</li>\n<li>生分 /cên¹ hung⁷/ 陌生、疏遠</li>\n<li>無影無跡 // 沒有根據</li>\n<li>一生跪跋 /zêg⁸ sên¹ gui⁶ buah⁸/ 一生坎坷</li>\n</ol>\n<h3 id=\"🐴副詞-hu³-su⁵\"><a href=\"#🐴副詞-hu³-su⁵\" class=\"headerlink\" title=\"🐴副詞(hu³ su⁵)\"></a>🐴副詞(hu³ su⁵)</h3><ol>\n<li>好 /hoh⁴/ 表示程度深。例如：好㩼人 // 好多人。</li>\n<li>死 /si²/ 表示程度特別深。例如：死㩼人 // 超級多人。死雅 // 超漂亮的。</li>\n<li>若 /rua⁷/ 多麼。例如：若雅 // 多麼漂亮。</li>\n<li>者 /zia²/ 這麼。例如：者細 // 這麼小。</li>\n<li>遐 /hia²/ 那麼。例如：遐好 // 那麼好。</li>\n<li>上好 /siang⁶ ho²/ 最好。</li>\n<li>上減 /siang⁶ giam²/ 最少。</li>\n<li>上加 /siang⁶ gê¹/ 最多。</li>\n<li>較 /ga³/ 比較地。例如：伊較厲害 // 他比較厲害。</li>\n<li>曾 /bhah⁴/ 曾經。例如：我毋曾來過 // 我不曾來過。</li>\n<li>攏總 /long² zong²/ 全部。例如：攏總 100 銀 // 總共 100 塊。</li>\n<li>煞 /sua⁵/ 竟然。例如：汝煞毋知 // 你竟然不知道。</li>\n<li>顛倒 /ding¹ do³/ 反而。例如：六月顛倒來落雪 // 六月反而下起雪。</li>\n<li>做蜀 /zo³ zêg⁸/ 一起。例如：做蜀 ka³ // 一起去。</li>\n</ol>\n<h3 id=\"😲象聲詞-siang⁶-sian¹-su⁵\"><a href=\"#😲象聲詞-siang⁶-sian¹-su⁵\" class=\"headerlink\" title=\"😲象聲詞(siang⁶ sian¹ su⁵)\"></a>😲象聲詞(siang⁶ sian¹ su⁵)</h3><ol>\n<li>喏 /no⁷/ 使人注意某物</li>\n<li>囉、咯 /lo⁷/ 表示事情完成</li>\n<li>/hoin⁷/ 呼人</li>\n<li>/oin⁷/ 應人</li>\n<li>喂 /uê⁷/ 打招呼。</li>\n<li>啊 /a⁷/ 加強語氣</li>\n<li>呀 /ia⁷/ 表示贊同</li>\n<li>喔、噢 /o⁷/ 表示醒悟、驚訝或了解</li>\n<li>哇 /ua⁷/ 表示驚訝</li>\n<li>嗯 /ng⁷/ 表示同意或了解</li>\n<li>哼 /hng²/ 表示不滿</li>\n<li>哎、噯 /ai⁷/ 嘆氣</li>\n<li>嗐 /hai⁷/ 嘆氣，比「哎」重些。</li>\n<li>/ho⁷～/、/o⁷～/ 長吁，含有一種無力、操碎了心的感覺。</li>\n</ol>\n<h3 id=\"🙃俗語-siog⁸-ngo²\"><a href=\"#🙃俗語-siog⁸-ngo²\" class=\"headerlink\" title=\"🙃俗語(siog⁸ ngo²)\"></a>🙃俗語(siog⁸ ngo²)</h3><ol>\n<li>哇浪、我卵 /ua² lang⁶/ 哇噻</li>\n<li>我無閒 /ua² bho⁵ ain⁵/ 我沒空</li>\n<li>走街邊 /zao² goi¹ bin¹/ 擺地攤</li>\n<li>汝愛去怎樣麼緊 /lu² ain³ ku³ zion² mo⁷ ging⁷/ 你趕著去幹嗎</li>\n<li>勿者樣生 /mai³ zion¹ sên¹/ 不要這樣</li>\n<li>知收煞 /zai¹ siu¹ suah⁴/ 適時停手</li>\n<li>毋別世代 /m⁶ bhag⁴ si³ dê³/ 不懂事</li>\n<li>無變 /bho⁵ biang³/ 沒有辦法</li>\n<li>堵著無變 /du² dioh⁴ bho⁵ biang³/ 碰到沒有辦法</li>\n<li>無理路 /bho⁵ li² lao⁷/ 無道理。路，道。</li>\n<li>無奈何 /bho⁵ da¹ ua⁵/ 無可奈何</li>\n<li>無奈寫作不得已 /bho⁵ nai⁶ sia² zo³ bug⁴ dêg⁴ in²/ </li>\n<li>呾死無會變 /dan⁵ si² bhoi⁶ bin³/ 冥頑不靈</li>\n<li>橂過石部 /dain⁷ goi³ zio² bao⁶/ 比石頭還硬</li>\n<li>三斗油麻倒無一粒落耳 /san¹ dao² iu⁵ mua⁵ do³ bho⁵ zêg⁸ liab⁴ lo² hin⁶/ 怎麼說都聽不進去</li>\n<li>瀉衰人 /sia³ soi¹ nang⁵/ 丟人、令人蒙羞</li>\n<li>見笑 /giang³ siao³/ 丟人、令人蒙羞</li>\n<li>雙目囥著褲底 /sang¹ mag⁸ kng³ dioh⁴ kao³ doi²/ 看不見</li>\n<li>無目睇 /bho⁵ mag⁸ toin³/ 不想看</li>\n<li>鴨囝聽雷 /ah⁴ gian² tian¹ lui⁵/ 聽不懂</li>\n<li>戅過隻鴨 /gong⁵ goi³ ziah⁴ ah⁴/ 比鴨子還戇</li>\n<li>一樣糜飯飼千外樣人 /zêg⁸ ion⁷ moi⁵ bng⁷ ci⁷ cain¹ ghua⁷ ion⁷ nang⁵/ 社會人各種各樣</li>\n<li>暗過魂宫 /am³ goi³ hung⁵ gêng¹/ 比陰間還暗</li>\n<li>三更想，半暝反 /san¹ gên¹ sion⁶, buan³ mê⁵ huang²/ 思來想去，反反覆覆。</li>\n<li>過跤事知歇 /goi¹ ka¹ su⁷ zai¹ hiah⁴/ 過去的事情就不要計較了</li>\n<li>無會少禮 /bhoi⁶ siao² li²/ 不害臊</li>\n<li>刣雞教猴 /tai⁵ goi¹ ga³ gao⁵/ 殺雞儆猴</li>\n<li>勞生拚死 /lu⁵ sên¹ bian³ si²/ 拚死拚活</li>\n<li>食呾會，躕人強 /ziah⁸ dan³ oi⁶, du⁵ nang⁵ kiang³/ 能吃會說還很頑皮</li>\n<li>勿踟躕我 /mai³ di¹ du⁵ ua⁷/ 別纏我，使得我不知所措。</li>\n<li>老過伯爺 /lao⁶ goi³ bêh⁴ ia⁵/ 比土地公還年長</li>\n<li>平樣平樣 /pên⁵ ion⁷ pên⁵ ion⁷/ 一模一樣</li>\n<li>假力洗茶渣 /gê² lag⁸ soi² dê⁵ za¹/ 該做的不做，做了不該做的。</li>\n<li>死無命凝 /si² bho⁵ mian⁷ ngang⁵/ 冷死了</li>\n<li>富到流油 /bu⁷ gao³ lao⁵ iu⁵/ 很富有</li>\n<li>人熟禮毋熟 /nang⁵ sêg⁸ li² m⁶ sêg⁸/ 雖然人很熟，但還是要講禮。</li>\n<li>熟人免行生禮 /sêg⁸ nang⁵ miang² gian⁵ cên¹ loi²/</li>\n<li>千人千般苦，無人苦平樣 /cain¹ nang⁵ cain¹ buan¹ kao², bho⁵ nang⁷ kao² pên⁵ ion⁷/ 各有各的煩惱</li>\n<li>蟹有橂奅，人有碩㦙 /hoi⁶ u⁶ dain⁷ pan³, nang⁵ u⁶ sêg⁴ nga³/ 有人聰明有人愚笨。橂，堅實。奅，中空。碩，學問高、聰明。㦙，愚笨。</li>\n<li>鳥飛會落毛，人行有跤跡 /ziao² boi¹ oi⁶ lo² mo⁵, nang⁵ gian⁵ u⁶ ka¹ ziah⁴/ 做過了的事總會留痕跡</li>\n<li>客情好過吊頷鬼 /kêh⁴ cêng⁵ ho² goi³ diao³ am⁶ gui²/ 吊死鬼熱情地勸人上吊好代替自己，比喻虛情假意。</li>\n<li>貓兒無葷無著茨，鴨囝無粟無會過暝 /ngiao¹ ri⁵ bho⁵ hung¹ bho⁵ dioh⁴ cu⁷, ah⁴ gian² bho⁵ cêg⁴ bhoi⁶ goi³ mê⁵/ 小貓沒有葷菜就不在家，小鴨沒有稻粒就不過夜。</li>\n<li>衰雞無會食粟 /soi¹ goi¹ bhoi⁶ ziah⁸ cêg⁴/ 如病雞般吃不下飯</li>\n<li>無會死大破相 /bhoi⁶ si² dua⁷ pua³ sion³/ 不死也會頭破血流</li>\n<li>十八棚頭做到透 /zab⁸ boih⁴ bên⁵ tao⁵ zo³ gao³ tao³/ 指每種事都嘗試，貶義。十八棚頭，指十八齣溫州南戲。</li>\n<li>無跤蟹 /bho⁵ ga¹ hoi⁶/ 孤立無援</li>\n<li>大細目 /dua⁷ soi³ mag⁸/ 偏心</li>\n<li>平安當大趁 /pêng⁵ ang¹ dng¹ dua⁷ tang⁷/ 平安無疾就當作是大賺一筆了</li>\n<li>大人彎，孥囝直 /dua⁷ nang⁷ uain¹, nao⁵ gian² dig⁸/ 大人說話拐彎抹角，小孩子則是直來直去。</li>\n<li>錢囝毋使使大錢 /zin⁵ gian² m⁶ sai² sai² dua⁷ zin⁵/ 小錢不花，久了就得要花大錢了。</li>\n<li>未學行，先學飛 /bhoi⁷ oh⁸ gian², sain¹ oh⁸ boi¹/ 還沒學走路就要學飛了，基礎未打好。</li>\n<li>一人主張，毋如二人參詳 /zêg⁸ nang⁷ zu² ziang¹, m⁶ ru⁵ no⁶ nang⁷ cam¹ ciang⁵/ 自作主張不如多個人一起商量</li>\n<li>通街市獵無 /tong¹ goi¹ ci⁶ lah⁸ bho⁵/ 整條街都找不到。獵，尋找。</li>\n<li>喙尖舌囝利 /cui³ ziamvi/ 牙尖嘴利</li>\n<li>九月狗吶日，無用諸娘理毋直 /gao² goi² gao² nah⁴ rig⁸, bho⁵ êng⁷ zu¹ nion⁵ li² m⁶ dig⁸/ 九月份開始晝短夜長，沒用的婦女家務事搞不定了。</li>\n<li>茶薄人情厚，茶厚有禮貌 /dê⁵ bo² nang⁵ cêng⁵ gao⁶, dê⁵ gao⁶ u⁶ li² mao⁶/</li>\n<li>三十歲無妻是孩童 /san¹ zab⁸ hoi³ bho⁵ ci¹ si⁶ hai⁵ tong⁵/</li>\n<li>目汁是財，愈哭愈來 /mag⁸ zab⁴ si⁶ cai⁵, ru² kao³ ru⁶ lai⁵/</li>\n<li>呾破無酒食 /dan³ pua³ bho⁵ ziu² ziah⁸/ 師傅教徒弟，徒弟設酒宴款待，師傅酒後授予秘方。之後徒弟不再宴請師傅。</li>\n<li>軟過豆腐 /nam³ goi³ dao⁷ hu⁷/</li>\n<li>車大炮 /cia¹ dua⁷ pao³/ 吹牛</li>\n<li>樹大分椏，囝大分家 /ciu⁷ dua⁷ bng¹ a¹, gian² dua⁷ bng¹ ga¹/ </li>\n<li>閒過仙 /ain⁵ goi³ siang¹/ 比神仙還閒</li>\n<li>雙目望無一寸長 /sang¹ mag⁸ mo⁷ bho⁵ zêg⁸ cung³ dng⁵/ 鼠目寸光</li>\n<li>一鼠二牛三虎四兔五龍六蛇七馬八羊九猴十雞十一狗十二豬 /ig⁴ cu² ri⁶ ghu⁵ san¹ haon² si³ tao³ ngao⁶ lêng⁵ lag⁸ zua⁵ cig⁴ bhê² boih⁴ ion⁵ gao² gao⁵ zab⁸ goi¹ zab⁸ ig⁴ gao² zab⁸ ri⁶ du¹/</li>\n<li>差豬差狗，不如家己走 /cê¹ du¹ cê¹ gao², bug⁴ ru⁵ ga¹ gi⁷ zao²/ 求人不如求己</li>\n<li>後生擔石，老人食藥 /hao⁶ sên¹ dan¹ zioh⁸, lao⁶ nang⁵ ziah⁸ ioh⁸/ 年少積勞，年老吃藥</li>\n<li>疑心生暗鬼 /ghi⁵ sim¹ sên¹ am³ gui²/ 因多疑而產生各種幻覺和錯誤判斷</li>\n<li>羊尾短短，遮毋著羊尻川 /ion⁵ bhoi² dê² dê², zia¹ m⁶ dioh⁴ ion⁵ ka¹ cng¹/ 自己的缺點尷尬能自己找個遮醜的就很好了，別去取笑別人的不堪。</li>\n<li>愛母著刻苦 /ain³ bhao² dioh⁴ kag⁴ kao²/ 要老婆就要努力了</li>\n<li>無好家神通外鬼 /bho⁵ ho² gê¹ sing⁵ tong¹ ghua⁷ gui²/</li>\n<li>How do you do，好事來堵 /hao³ su⁷ lai³ du²/ 嗨，要搞事情我不怕你。好事，喜歡搞事情。堵，應對、抵抗。</li>\n<li>秋瓜棚下無好人 /ciu¹ goi¹ bên⁵ ê⁶ bho⁵ ho² nang⁵/ 秋瓜，絲瓜。</li>\n<li>三跤椅囝毋知䆀 /san¹ ka¹ in² gian² m⁶ zai¹ bhai²/ 坐著少了一腿的椅子竟然不知道壞了，比喻身處困境而不自知。</li>\n</ol>\n<h3 id=\"🤣歇後語-hiah⁴-ao⁶-ngo²\"><a href=\"#🤣歇後語-hiah⁴-ao⁶-ngo²\" class=\"headerlink\" title=\"🤣歇後語(hiah⁴ ao⁶ ngo²)\"></a>🤣歇後語(hiah⁴ ao⁶ ngo²)</h3><ol>\n<li>柴目狗耳 — 假靈 /ca⁵ mag⁸ gao² hin⁶ — gê² lêng⁵/ 目雕的眼睛看不見，狗一般耳朵卻很靈，聽風是雨。</li>\n<li>雞跤長鴨跤短 — 有懸下 /goi¹ ka¹ dng⁵ ah⁴ ka¹ dê² — u⁶ guain⁵ gê⁶/ 雞腳長，鴨腳短，有高有矮。</li>\n<li>爐底碳 — 塊塊通 /lao⁵ doi² tuan³ — dê⁷ dê⁷ tang³/ 百事通</li>\n<li>孥囝食奶 — 坐亭 /nao⁶ gian² ziah⁸ nê¹ — zê⁶ dêng⁵/ 亭，直。</li>\n<li>菜頭面刺無血 — 面皮厚 /cai³ tao⁵ ming¹ ci³ bho⁵ hoih⁴ — ming¹ poi⁵ gao⁶/</li>\n<li>褪褲放屁 — 假工夫 /tng³ kao³ bang³ pui³ — gê² gang¹ hu¹/</li>\n<li>竹葉包沙 — 假壯 /dêg⁴ hio² bao¹ sua¹ — gê² zang³/ 壯，與「粽」諧音。</li>\n<li>元宵燈籠 — 一肚火 /nguang⁵ siao¹ dêng¹ lang⁵ — zêg⁸ dao² hoi²/</li>\n<li>半天吊燈籠 —四搭无向 /buan³ tin¹ diao³ dêng¹ lang⁵ — si³ dah⁴ bho⁵ hiang³/</li>\n<li>青暝睒鏡 — 無望 /cên¹ mên⁵ iam² gian³ — bho⁵ mo⁷/</li>\n<li>青暝睇天 — 張樣張相 /cên¹ mên⁵ toi² tin¹ — dion¹ ion⁷ dion¹ sion⁷/</li>\n<li>青暝點燈 — 照舊 /cên¹ mên⁵ diam² dêng¹ — zio³ gu⁷/ 對青暝人來說，點不點燈，一切照舊。</li>\n<li>青暝掠魚 — 散摸 /cên¹ mên⁵ liah⁸ hu⁵ — suan³ mong⁵/</li>\n<li>青暝娶母 — 稱重 /cên¹ mên⁵ cua⁷ bhao² — cing³ dang⁶/</li>\n<li>青暝擎手電 — 各人各人善 /cên¹ mên⁵ gia⁵ ciu² diang⁶ — gag⁴ nang⁵ gag⁴ nang⁵ siang⁶/</li>\n<li>青暝睇電影 — 聽聲 /cên¹ mên⁵ toi² diang⁶ ian² — tian¹ sian¹/</li>\n<li>啞人食苦瓜 — 有苦難言 /ê² nang⁵ ziah⁸ kao² goi¹ — u⁶ kao² nang⁵ ngiang⁵/</li>\n<li>啞囝食黃連 — 有苦難言 /ê² gian² ziah⁸ ng⁵ nain⁵ — u⁶ kao² nang⁵ ngiang⁵/</li>\n<li>閻羅王嫁諸母囝 — 鬼正敢愛 /ngiam⁵ lo⁵ uang⁵ gê³ za¹ bhao² gian² — gui² zian³ gan² ain³/</li>\n<li>閻羅王請人 — 鬼正敢食  /ngiam⁵ lo⁵ uang⁵ cian² nang⁵ — gui² zian³ gan² ziah⁸/</li>\n<li>閻羅王賣假貨 — 騙鬼 /ngiam⁵ lo⁵ uang⁵ bhoi⁷ gê² hoi⁷ — piang³ gui²/</li>\n<li>閻羅王出告示 — 無句人話 /ngiam⁵ lo⁵ uang⁵ cug⁴ go³ si⁷ — bho⁵ gu³ nang⁵ oi⁷/</li>\n<li>鬼簿無名 — 免死 /gui² pao⁶ bho⁵ mian⁵ — miang² si²/</li>\n<li>醫生開了棺材舖 — 死活都愛錢 /ui¹ sên¹ kui¹ liao² gua¹ ca⁵ pao⁷ — si² ua² do¹ ain³ zin⁵/</li>\n<li>身長棺材短 — 屈死人 /sing¹ dng⁵ gua¹ ca⁵ dê² — kug⁴ si² nang⁵/</li>\n<li>棺材頭畫老虎 — 驚死人 /gua¹ ca⁵ tao⁵ oi⁷ lao⁶ haon² — gian¹ si² nang⁵/</li>\n<li>歪喙和尚 — 唸無一句正經 /uain¹ cui³ hoi⁵ sion⁷ — niam⁷ bho⁵ zêg⁸ gu³ zian³ gêng⁵/</li>\n<li>師公和尚 — 毋同道 /sai¹ gong¹ hoi⁵ sion⁷ — m⁶ dang⁵ dao⁶/</li>\n<li>和尚抹粉 — 白勞 /hoi⁵ sion⁷ bhuah⁴ hung² — bêh⁸ lu⁵/ 勞，與「驢」諧音。</li>\n<li>和尚擎雨遮 — 無法無天 /hoi⁵ sion⁷ gia⁵ hao⁶ zia¹ — bho⁵ huab⁴ bho⁵ tin¹/ 法，與「髮」諧音。</li>\n<li>橄欖尻川 — 坐毋恬 /gan¹ na² ka¹ cng¹ — zê⁶ m⁶ diam⁷/ 屁股像橄榄一般尖，坐不住。恬，静、定。</li>\n<li>火燒豬頭 — 熟面熟面 /hoi² sio¹ du¹ tao⁵ — sêg⁸ ming⁷ sêg⁸ ming⁷/</li>\n<li>六月芥菜 — 假有心 /lag⁸ ghoih⁸ gua³ cai³ — gê² u⁶ sim¹/</li>\n<li>十月芥菜 — 大䀌心 /zab⁸ ghoih⁸ gua³ cai³ — dua⁷ gêg⁴ sim¹/ 䀌，與「激」諧音。</li>\n<li>六月蕃薯 — 雙死 /lag⁸ ghoih⁸ huang¹ zu⁵ — sang¹ si²/ 雙，與「鬆」諧音。</li>\n<li>阿媽生諸母囝 — 生菇 /a¹ ma² sên¹ za¹ bhao² gian² — sên¹ gao¹/ 生菇，發霉。菇，與「姑」諧音。</li>\n<li>老人跤纏 — 又長又臭 /lao⁶ nang⁵ ka¹ din⁵ — ui⁶ dng⁵ ui⁶ cao³/ 講話囉嗦像老人纏足一樣</li>\n<li>老人食豬跤 — 試味 /lao⁶ nang⁵ ziah⁸ du¹ ka¹ — ci³ bhi⁷/ 嘗試下而已</li>\n<li>老婆跋落水 — 淒涼 /lao⁶ pua⁵ buah⁸ lo² zui² — ci¹ liang⁵/ 跋，絆倒。淒，與「妻」諧音。</li>\n<li>老婆其阿兄 — 痴哥 /lao⁶ pua⁵ gai⁵ a¹ hian¹ — ci¹ go¹/ 痴，與「妻」諧音。</li>\n<li>菜頭粿熱單爿 — 自作多情 /cai³ tao⁵ goi² riah⁸ duan¹ bain⁵ — zu⁶ zag⁴ do¹ cêng⁵/ 菜頭粿，蘿蔔糕。热单爿，切片下鍋油煎，但只煎單邊，上焦下嫩。一頭熱（悅），單戀。</li>\n<li>龍眼核拭尻川 — 賽道行 /nging¹ ain² hug⁸ cih⁴ ka¹ cng¹ — sai³ dao⁶ hang⁵/ 「龍眼核拭尻川」比喻有難度的事情，看各家誰本領強了。</li>\n<li>水仙不開花 — 裝蒜 /zui² siang¹ bug⁴ kui¹ hoi¹ — zng¹ sng³/</li>\n<li>大炮拍麻雀 — 騙伊驚 /dua⁷ pao³ pah⁴ mua⁵ ziah⁴ — piang³ i¹ gian¹/</li>\n<li>有錢買蠓香，無錢買蠓罩 — 會算無會除 /u⁶ zin⁵ bhoi² mang² hion¹, bho⁵ zin⁵ bhoi² mang² dan³ — oi⁶ sng³ bhoi⁶ du⁵/</li>\n<li>天頂滴鳥屎 — 無好相覓 /tin¹ dêng² dig⁴ ziao² sai² — mo² sion¹ coi⁷/</li>\n<li>六月薄殼 — 假大頭 /lag⁸ ghoih⁸ boh⁸ kag⁴ — gê² dua⁷ tao⁵/ 大頭，一種比薄殼略大的小貝類海鮮。假大頭，愛充大頭。</li>\n<li>七角錢二人分 — 毋三毋四 /cig⁴ gag⁴ zin⁵ no⁶ nang⁵ bng¹ — m⁶ san¹ m⁶ si³/</li>\n<li>十二碗圓食賰一粒 — 假客氣 /zab⁸ ri⁶ liab⁸ in⁵ ziah⁸ cung⁵ zêg⁸ liab⁸ — gê² kêh⁴ ki⁷/ 圓，丸子。賰，剩下。</li>\n<li>狗母蛇 — 假靈 /gao² bho² zua⁵ — gê² lêng⁵/ 靈，與「龍」諧音。</li>\n<li>兄獨目弟缺喙 — 大無好樣，細無好相 /hian¹ dog⁸ mag⁸ di⁶ koih⁴ cui³ — dua⁷ bho⁵ ho² ion⁷, soi³ bho⁵ ho² sion³/</li>\n<li>山螟咬尾 — 食家己 /suan¹ mê¹ ga⁶ bhoi² — ziah⁸ ga¹ gi⁷/</li>\n<li>風吹牆頭草 — 就勢倚勢 /hong¹ coi¹ ciong⁵ tao⁵ cao² — ziu⁶ si³ ua² si³/</li>\n<li>老鼠跋落粟倉 — 倒好 /ngiao² cu² buah⁸ lo² cêg⁴ cng¹ — do³ ho²/</li>\n<li>老鼠心肝 — 頭食頭搬 /ngiao² cu² sim¹ guan¹ — tao⁵ ziah⁸ tao⁵ buan⁵/</li>\n<li>孥囝拍炮 — 又驚又好 /nao⁵ gian² pah⁴ pao⁷ — ui⁶ gian¹ ui⁶ hao⁷/</li>\n<li>五行缺一 — 欠金 /ngao⁶ hêng⁵ koih⁴ ig⁴ — kiang³ gim¹/</li>\n<li>茂生進酒 — 厚情 /mao⁶ sêng¹ zing³ ziu² — gao⁶ cêng⁵/</li>\n<li>食人雞肉還人豬肉 — 物來物去 /ziah⁸ nang⁷ goi¹ nê² hain⁵ nang⁷ du¹ nê² — moih⁸ lai⁵ moih⁸ ko³/</li>\n<li>刀截蕹菜 — 二頭空 /do¹ zoi² êng³ cai³ — no⁶ tao⁵ kong¹/</li>\n<li>三個半錢 — 趕勢 /san¹ gai⁵ buan³ zin⁵ — guan² si³/ 勢，與「四」諧音。</li>\n<li>隔暝皇帝 — 無權勢 /gêh⁴ mê⁵ huang⁵ di⁷ — bho⁵ kuang⁵ si³/</li>\n<li>大肚水蛙 — 假鮭 /dua⁷ dao² zui² goi¹ — gê² guai¹/ 水蛙，青蛙。鮭，河魨。</li>\n<li>五月龍船 — 相鬥 /ngao⁶ ghoih⁸ lêng⁵ zung⁵ — sion¹ dao³/</li>\n<li>燈籠照路 — 目前光 /dêng¹ lang⁵ zio³ lao⁷ — mag⁸ zain⁵ gng¹/ 比喻目光短淺</li>\n<li>暗室穿針 — 難過 /am³ sig⁴ cng¹ zam¹ — nang⁵ goi³/</li>\n<li>嫁諸母囝娶新婦 — 出入平安 /gê³ za¹ bhao² gian² cua⁷ sing¹ bu⁶ — cug⁴ rib⁸ pêng⁵ ang¹/ 安，與「翁」諧音。</li>\n<li>過關送文憑 — 做人情 /goi³ guan¹ sang³ bhung⁵ pêng⁵ — zo³ nang⁵ zian⁵/</li>\n<li>火燒草料場 — 事出有因 /hoi² sio¹ cao² liao⁷ dion⁵ — su⁷ cu⁷ u⁶ ing¹/ 因，與「煙」諧音。</li>\n<li>黑白電視 — 無彩 /hêg⁴ bêh⁸ dian⁶ si⁶ — bho⁵ cain²/ 無彩，可惜。</li>\n<li>小郎遇著雨 — 積惡 /sio² nng⁵ ngo⁶ dioh⁴ hao⁶ — zêg⁴ ag⁴/ 小郎，女子稱呼丈夫的弟弟。積惡，可憐；罪惡。積，與「叔」諧音。惡，與「沃」諧音。</li>\n</ol>\n<h3 id=\"🙂禮貌用語-li²-mao⁶-eng³-ngo²\"><a href=\"#🙂禮貌用語-li²-mao⁶-eng³-ngo²\" class=\"headerlink\" title=\"🙂禮貌用語(li² mao⁶ êng³ ngo²)\"></a>🙂禮貌用語(li² mao⁶ êng³ ngo²)</h3><ol>\n<li>汝食饱未 /lu² ziah⁸ ba² bhoi⁷/ 你吃飽了嗎</li>\n<li>汝愛去底地 /lu² ain³ ku³ di⁷ dê⁷/ 你要去哪裏</li>\n<li>汝好 /lu² ho²/ 你好</li>\n<li>㩼謝 /zoi⁷ sia⁷/ 多謝</li>\n<li>寬行 /kuan¹ gian⁵/ 慢走</li>\n<li>寬駛 /kuan¹ sai²/ 慢點開車</li>\n<li>对毋住 /dui³ m⁶ zu⁶/ 对不起</li>\n<li>对毋起 /dui³ m⁶ ki²/ 对不起</li>\n<li>無相干 /bho⁵ siang¹ gang¹/ 沒關係</li>\n<li>毋知頭 /m⁶ zai¹ tao⁵/ 不是故意的</li>\n<li>先這呾 /sain¹ zion² dan³/ 回頭再聊 </li>\n<li>萬事應想 /mang⁷ su⁷ êng³ sion⁶/ 萬事如意</li>\n<li>生理大趁 /sêng¹ li² dua⁷ tang⁷/ 生意興隆</li>\n<li>新年大趁 /sing¹ ni⁵ dua⁷ tang⁷/ 新年大賺</li>\n<li>新年合想 /sing¹ ni⁵ gah⁴ sion⁶/ 新年如意</li>\n<li>大吉大利 /dai⁶ gig⁴ dai⁶ li⁶/</li>\n</ol>\n<h3 id=\"🤐粗話-cao¹-oi⁷\"><a href=\"#🤐粗話-cao¹-oi⁷\" class=\"headerlink\" title=\"🤐粗話(cao¹ oi⁷)\"></a>🤐粗話(cao¹ oi⁷)</h3><ol>\n<li>咒誓 /ziu³ zua⁷/ 發誓、詛咒</li>\n<li>痟 /siao²/ 神經錯亂</li>\n<li>神經 /sing⁵ gêng¹/</li>\n<li>腦孬 /nao² mo³/ 腦子壞了</li>\n<li>破脑囝 /puah⁸ nao² gian²/ 弱智</li>\n<li>肚痛 /dao² tian³/ 「問候」別人是否肚子痛所以一直在叫。</li>\n<li>鬼叫 /gui² gio⁷/ 「問候」別人是否聽到鬼在叫。</li>\n<li>哭 cang¹ 哭 nain⁵ // 又哭又喊，吵死人了。</li>\n<li>哭父死母 /kao³ bê⁶ si² bho²/ 「問候」別人是否父母過世所以一直在哭叫。</li>\n<li>咋死人 /zag⁴ si² nang⁵/ 吵死了</li>\n<li>鬼囝 /gui² gian²/ 小鬼</li>\n<li>鬼卒囝 /gui² zug⁴ gian²/ 小鬼</li>\n<li>鬼然然 /gui² riang⁵ riang⁵/ 像鬼一樣</li>\n<li>鬼囉作禍 /gui² lo⁷ zo³ ho³/ 鬼在作祟、作怪</li>\n<li>妖怪精 /iao¹ guai³ zian¹/</li>\n<li>去死掉掉 /ku³ si² diao³ diao³/</li>\n<li>散哭父 /suan⁷ kao³ bê⁶/ 散，到處。</li>\n<li>吐屎 /tao³ sai²/ 亂說</li>\n<li>卵屎人 /lang⁶ sai² nang⁵/ 屌絲，沒前途的人。</li>\n<li>卵屎話 /lang⁶ sai² oi⁷/ 廢話</li>\n<li>臭喙卵面 /cao³ cui³ lang⁶ ming⁷/ 亂說、討人厭。</li>\n<li>關汝卵事 /guang¹ lu² lang⁶ dai⁷/ 與你何干</li>\n<li>膣精 /zi¹ zian¹/ 多管閒事</li>\n<li>臭膣 /cao³ zi¹/ 臭婊子</li>\n<li>豺狗 /sai² gao²/ 狗腿子</li>\n<li>怪卵 /guai³ lang⁶/ 古怪</li>\n<li>無卵 /bho⁵ lang⁶/ 沒膽量</li>\n<li>無腦 /bho⁵ nao²/ 沒腦子</li>\n<li>𠀾好 /bhoi⁶ ho²/ 咒別人倒霉</li>\n<li>痞囝 /pai² gian²/ 痞子、流氓。</li>\n<li>肏母囝 /pu² bho² gian²/</li>\n<li>早死囝 /za² si² gian²/</li>\n<li>短命囝 /dê² mian⁷ gian²/、/dêng² mian⁷ gian²/</li>\n<li>破家囝 /pua⁷ gê¹ gian²/ 败家子</li>\n<li>內仙囝  /lai⁶ siang¹ gian²/ 難伺候</li>\n<li>十惡囝 /zab⁸ ag⁴ gian²/ 十惡不赦</li>\n<li>棺材囝 /gua¹ ca⁵ gian²/</li>\n<li>痴哥囝 /ci¹ go¹ gian²/ 色狼</li>\n<li>吐血死囝 /tao³ hoih⁴ si² gian²/</li>\n<li>替人死囝 /toi⁵ nang⁵ si² gian²/</li>\n<li>半路死囝 /buan³ lao⁷ si² gian²/</li>\n<li>祭屎祭䷀ /zi³ sai² zi³ hê⁷/ 亂吃東西</li>\n<li>乞鬼侵著 /koh⁴ gui² cin⁵ dioh⁴/ 鬼上身了。乞，給。侵，本讀 /cim⁵/，音變爲 /cin⁵/，附身。</li>\n</ol>\n<h3 id=\"🧨娛樂-ngo⁵-log⁸\"><a href=\"#🧨娛樂-ngo⁵-log⁸\" class=\"headerlink\" title=\"🧨娛樂(ngo⁵ log⁸)\"></a>🧨娛樂(ngo⁵ log⁸)</h3><ol>\n<li>耍遊戲 /sng² iu⁵ hi³/ 玩遊戲</li>\n<li>䷀箭 /diong³ zin³/ 射箭</li>\n<li>䷀珠 /diong³ zu¹/ 打彈珠</li>\n<li>彈槍 /duan⁷ ciong¹/ 開槍</li>\n<li>跳索 /tiao³ soh⁴/ 跳繩</li>\n<li>踏孔 /dah⁸ kong²/ 捉迷藏</li>\n<li>泅水 /siu⁵ zui²/ 游泳</li>\n<li>釣魚 /dio³ hu⁵/</li>\n<li>掠魚 /liah⁸ hu⁵/ 抓魚</li>\n<li>行棋 /gian⁵ gi⁵/ 下棋</li>\n<li>放風箏 /bang³ hong¹ zêng¹/</li>\n<li>拍連炮 /pah⁴ liang⁵ pao³/ 放鞭炮</li>\n<li>扣人囝 /kob⁴ nang⁵ gian²/ 人囝，也叫公仔紙、洋畫，舊時供兒童玩樂用的紙牌。</li>\n<li>沃花 /ag⁴ hoi¹/ 澆花</li>\n<li>做戲 /zo³ hi³/ 演戲劇</li>\n</ol>\n<h3 id=\"⛩-神明-sing⁵-meng⁵\"><a href=\"#⛩-神明-sing⁵-meng⁵\" class=\"headerlink\" title=\"⛩ 神明(sing⁵ mêng⁵)\"></a>⛩ 神明(sing⁵ mêng⁵)</h3><ol>\n<li>天地父母 // 天地，原始信仰。</li>\n<li>月娘 // 月球，原始信仰。</li>\n<li>媽祖 // 原名林默，南海保護神，在甲子天后宮有供。</li>\n<li>七聖娘 // 又稱七星娘娘、七聖夫人，是織女神分化出的七位仙女，是兒童保護神。</li>\n<li>觀音娘 // 觀音菩薩</li>\n<li>慈悲娘 // 即普悲觀音，觀音菩薩化身之一（傳說觀音菩薩有三十三化身），普遍施給眾生慈悲。</li>\n<li>註生娘 // 全稱「大慈大悲救苦救難送子娘娘」，主管懷孕與生育。</li>\n<li>佛祖 // 釋迦牟尼佛，姓喬達摩，名悉達多，古印度思想家、教育家、宗教改革家，佛教的創始人。</li>\n<li>達摩祖師 // 南天竺人或波斯人，將佛教禪宗帶入中國，爲中國禪宗之開創者。</li>\n<li>元天上帝 // 玄武大帝，象徵北極星與二十八宿中的北宮玄武，爲統理北方之道教大神。</li>\n<li>水仙大帝 // 水仙尊王，海神之一，媽祖的從神之一。</li>\n<li>汾陽王帝 // 郭子儀，華州鄭縣（今陝西渭南市華州區）人，唐朝名將，平定安史之亂，封汾陽郡王。此人富貴壽考，權極一時，甲子天后宮媽祖廟有供之。</li>\n<li>王公 // 指隴尾王爺、王爺公，名鄒普勝，麻城花橋（今屬湖北）人，元末農民起義軍將領，陳友諒軍師。朱元璋建立明朝後流浪到甲子地區，爲甲子地區改造「風水」等，今甲子隴尾王爺廟有供之，大年初四在此求「落馬簽」。</li>\n<li>關公 // 關羽，河東郡解縣（今山西省運城市鹽湖區解州鎮）人，三國時期名將，與劉備、張飛桃園三結義。又稱伽藍老爺、伽藍尊者，是寺廟、道場守護神，也有稱之爲武財神。</li>\n<li>八仙公 // 傳說中的八位仙人，爲漢鍾離、張果老、韓湘子、鐵拐李、曹國舅、呂洞賓、藍采和、何仙姑八人。</li>\n<li>伯公 // 福德老爺、土地公。</li>\n<li>五穀公 // 神農大帝，相傳其發明耒耜，教民耕種五穀，並能以百草為民治病。農曆十月十五拜之。</li>\n<li>城隍公 // 古代城鎮保護神。</li>\n<li>皇帝公 // 南宋小皇帝趙昰，曾流亡到甲子待渡山。</li>\n<li>灶公 // 灶君，主掌廚房和飲食的神。</li>\n<li>百姓公 // 無主死者，集中掩埋於百姓公墓，稱爲百姓公(媽)，其中多喪於 1943 年的大飢荒，其時僅甲子一鎮亡者就近 2 萬人，慘絕。</li>\n<li>地主爺 // 住宅的守護靈。</li>\n<li>財神爺 // 常指陝西終南山的玄壇真君趙公明，也指關聖帝君關羽。</li>\n<li>三山國王 // 指現揭西縣河婆鎮北面的三座山——巾山、明山、獨山的三位山神。</li>\n</ol>\n<h2 id=\"風俗-hong¹-sioh⁸\"><a href=\"#風俗-hong¹-sioh⁸\" class=\"headerlink\" title=\"風俗(hong¹ sioh⁸)\"></a>風俗(hong¹ sioh⁸)</h2><ol>\n<li>大年初一：食齋菜（菠薐菜、粉絲、菜頭丸、豆腐乾）。</li>\n<li>人日(正月初七)：食七樣菜（厚合、蒜仔、芥藍、高麗菜、真珠菜、香菜、大菜芯）。</li>\n<li>元宵(正月十五)：食蔗。</li>\n<li>三月初三：食青草飯（雞屎藤、伸筋藤、苦刺心、臭草心、蠟裏葉、四方枝苦楝葉）。</li>\n<li>清明：食硬殼餅，掃墓掛紙。</li>\n<li>佛誕(四月初八)：食飯茶。</li>\n<li>端午：食梔粽、梔粿，洗午時水。</li>\n<li>七月初七：出花園。</li>\n<li>中秋：食月餅、芋頭、蔗。</li>\n<li>重陽(九月初九)：食雞湯。</li>\n<li>冬節：食冬節丸、羊肉。</li>\n<li>三十夜、廿九夜：食團圓飯、送壓腰錢（dêh⁴ io¹ zin⁵, 壓歲錢）。</li>\n</ol>\n<h2 id=\"歷史-leg⁸-su²\"><a href=\"#歷史-leg⁸-su²\" class=\"headerlink\" title=\"歷史(lêg⁸ su²)\"></a>歷史(lêg⁸ su²)</h2><ol>\n<li><p>甲子的名號是因爲港後有六十塊大石頭，應了干支紀年法一甲子的數目，故名。</p>\n</li>\n<li><p>漢文帝時曾派遣大臣陸賈（約公元前240年～公元前170年）到南越國，期間命令將士調查海岸線，到過甲子門。</p>\n</li>\n<li><p>三國時，吳侯孫權派遣將軍衛溫（？～231年）攻打福建、琉球和台灣（夷州），被風雨刮到甲子門。</p>\n</li>\n<li><p>南宋乾道五年(1169)，承奉郎致仕范有仁建順濟橋，橋從大膽山腳(今東宮社轄區)跨越瀛江到後庭（今甲東鎮雨亭村轄區）。</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2084.png\" alt=\"順濟橋（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）\"></p>\n</li>\n<li><p>宋嘉定甲申年(1224)，南宋承奉郎范良臣（范有仁之孫）登腹石山，因山對面可見甲子門奇石十八，屹立如人，遂刻「登瀛」二字於石，取十八學士登瀛洲之義。</p>\n</li>\n<li><p>1276 年，元兵攻陷南宋京城臨安，南宋擁立幼帝趙昰，從福州乘船經福建沿海入廣東，於冬十二月抵甲子門腹石山（後人爲紀念此事，更山名爲待渡山），范良臣給軍食三日，留帝像登瀛石上。</p>\n</li>\n<li><p>1277 年正月，漁民鄭復組織義兵509人乘船護送宋帝昺及隨臣去崖門。途中在現珠海橫琴島和澳門與元兵相遇，十六日宋室全軍覆滅，陸秀夫背幼帝昺投海自盡，鄭復等在激戰中全部士兵犧牲。</p>\n</li>\n<li><p>明永樂六年(1408)，順濟橋被拆。因「指揮花茂奉旨建甲子所，慮倭寇泊海易渡，拆之以為城基。」</p>\n</li>\n<li><p>明嘉靖三十九年(1560)，八萬洞資首黃啓薦扎寨惠來冰山頭（今邦山村）攻陷甲子所城，城中居民移至龍溪都（今惠來隆江以南）為逃避倭禍而暫居，該城之難民，慘遭殺害者甚眾，婦女被擄掠，有的全家罹難。</p>\n</li>\n<li><p>明隆慶二年(1568)，倭寇入侵甲子，千戶馬壽麻痹輕敵，城被攻陷，甲子和龍溪都一帶受害慘重。馬壽因失職罪下獄，死於獄中。</p>\n</li>\n<li><p>明隆慶四年(1570)，大旱，入春至初夏，天無滴雨，時又常遭賊寇蹂躪，田園拋荒，赤地千里，人民苦不堪言。</p>\n</li>\n<li><p>明隆慶四年(1570)九月，曾作倭寇嚮導之海寇楊老復，率賊眾攻陷甲子所城，擄掠男女上船，千戶董（佚名）戰死。次日，船遇颱風，賊與被擄者均溺死。</p>\n</li>\n<li><p>隆慶五年(1571)七月，海盜林道乾（又名林鳳，惠來人），於龍溪都一帶擄民劫捨，後聞朝廷將派兵進剿，遂遠循至甲子一帶搶劫，攻破新寨，劫擄李棠，其妻卓氏攜二子上船換夫歸，遂投海殉節。後朝廷封為「南海夫人」。</p>\n</li>\n<li><p>明萬曆二十六年(1598)，湯顯祖作《牡丹亭》，其第六齣中有詞句「榕樹梢頭訪古台，下看甲子海門開。越王歌舞今何在？時有鷓鴣飛去來。」</p>\n</li>\n<li><p>明萬曆二十八年(1600)八月二十三日，惠來及甲子一帶地震。</p>\n</li>\n<li><p>明萬曆三十三年(1605)三月，惠來及甲子一帶地震，七月初三至初七颱風暴雨，沿海田舍淹沒。</p>\n</li>\n<li><p>明萬曆三十五年(1607)，參將張萬紀、守備胡文烜在待渡山下建宋帝亭，即進食亭。</p>\n</li>\n<li><p>明萬曆四十二年(1620)春正月，海盜袁八老余黨林新老入甲子沃，把總金允武出戰死之。</p>\n</li>\n<li><p>明天啓七年(1627)三月，海寇入甲子門，守備葉台死亡。</p>\n</li>\n<li><p>明崇禎八年(1635)，海寇劉香攻陷甲子，擄去守道洪雲蒸。閩粵大兵突至，洪遇害，後劉香被擄伏誅。</p>\n</li>\n<li><p>明崇禎十四年(1641)十二月十四日夜，惠來地震，波及甲子。</p>\n</li>\n<li><p>民國32年(1943，癸未年)，甲子乃至整個海陸豐地區、潮汕地區遭遇大飢荒，時兵災、旱災、蝗災和瘟疫，餓殍遍野，僅甲子一鎮亡者就近 2 萬，佔當時鎮人口逾 45%。</p>\n</li>\n<li><p>1966年，中國大陸爆發文化大革命，「破四舊」。次年，有360年歷史的進食亭被炸毀！</p>\n</li>\n<li><p>2004年夏～2005年秋，甲子諸賢達捐資重建了進食亭。</p>\n</li>\n<li><p>2013年12月29日凌晨，廣東警方出動3000多人的警力對有「毒品村」之稱的甲西鎮博社村開展清繳行動，當天繳獲近3噸冰毒，抓捕180多名涉毒犯罪嫌疑人，原村委書記蔡東家名列其中。</p>\n</li>\n</ol>\n<h2 id=\"建置-giang³-di³\"><a href=\"#建置-giang³-di³\" class=\"headerlink\" title=\"建置(giang³ di³)\"></a>建置(giang³ di³)</h2><ol>\n<li><p>秦以前：屬南越國</p>\n</li>\n<li><p>秦：屬南海郡之博羅縣</p>\n</li>\n<li><p>漢：屬博羅縣</p>\n</li>\n<li><p>三國：屬博羅縣</p>\n</li>\n<li><p>晉：咸和六年（326）析博羅，置海豐縣，屬东官郡</p>\n</li>\n<li><p>宋：屬海豐縣</p>\n</li>\n<li><p>齊：屬海豐縣</p>\n</li>\n<li><p>梁：屬海豐縣</p>\n</li>\n<li><p>陳：屬海豐縣</p>\n</li>\n<li><p>隋：海豐縣屬循州</p>\n</li>\n<li><p>唐：海豐縣屬循州。武德五年（622）析置安陸縣；貞觀元年（627）復歸海豐縣。</p>\n</li>\n<li><p>五代：大寶元年（958）海豐縣属祯州。</p>\n</li>\n<li><p>宋：海豐縣屬祯州。天禧五年（1021）屬惠州。</p>\n</li>\n<li><p>元：海豐縣屬惠州路。</p>\n</li>\n<li><p>明：海豐縣屬惠州府。洪武二十七年(1394)，置甲子守禦千戸所，隸屬碣石衛。嘉靖三年（1524）海豐划出龍溪都、潮州府析出潮陽縣合置惠來縣。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2085.png\" alt=\"甲子所城範圍（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）\"></p>\n</li>\n<li><p>清：海豐縣屬惠州府。雍正九年（1731）海豐划出石帆（甲子屬石帆都）、吉康、坊廓3都置陸豐縣，並裁甲子所設立甲子巡檢司。</p>\n</li>\n<li><p>中華民國：陸豐縣屬潮循道。</p>\n</li>\n<li><p>中華人民共和國：1957年甲子鎮劃出甲東鎮、甲西鎮（取甲子之東、甲子之西義）；1958年鎮改爲人民公社，陸豐縣屬汕頭地區；1983年陸豐屬惠陽地區；1980年成立甲子鎮人民政府；1988年陸豐縣改屬汕尾市；1995年陸豐撤縣建市。</p>\n</li>\n</ol>\n<h2 id=\"拼音方案-peng³-im¹-huang¹-uan³\"><a href=\"#拼音方案-peng³-im¹-huang¹-uan³\" class=\"headerlink\" title=\"拼音方案(pêng³ im¹ huang¹ uan³)\"></a>拼音方案(pêng³ im¹ huang¹ uan³)</h2><h3 id=\"聲母表-sian¹-bho²-biao²\"><a href=\"#聲母表-sian¹-bho²-biao²\" class=\"headerlink\" title=\"聲母表(sian¹ bho² biao²)\"></a>聲母表(sian¹ bho² biao²)</h3><p>格式：<code>聲母 [國際音標] 例字</code></p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png\" alt></p>\n<h3 id=\"韻母表-ung¹-bho²-biao²\"><a href=\"#韻母表-ung¹-bho²-biao²\" class=\"headerlink\" title=\"韻母表(ung¹ bho² biao²)\"></a>韻母表(ung¹ bho² biao²)</h3><p>格式：<code>韻母 [國際音標] 例字 / 入聲韻 [國際音標] 例字</code></p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png\" alt></p>\n<h3 id=\"聲調-sian¹-diao⁶\"><a href=\"#聲調-sian¹-diao⁶\" class=\"headerlink\" title=\"聲調(sian¹ diao⁶)\"></a>聲調(sian¹ diao⁶)</h3><p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png\" alt></p>\n<h3 id=\"變調-biang³-diao⁶\"><a href=\"#變調-biang³-diao⁶\" class=\"headerlink\" title=\"變調(biang³ diao⁶)\"></a>變調(biang³ diao⁶)</h3><p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png\" alt></p>\n<h2 id=\"地圖-di⁷-dao⁵\"><a href=\"#地圖-di⁷-dao⁵\" class=\"headerlink\" title=\"地圖(di⁷ dao⁵)\"></a>地圖(di⁷ dao⁵)</h2><p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg\" alt=\"三甲地區（來源：騰訊地圖）\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"序言-su⁶-ngiang⁵\"><a href=\"#序言-su⁶-ngiang⁵\" class=\"headerlink\" title=\"序言(su⁶ ngiang⁵)\"></a>序言(su⁶ ngiang⁵)</h2><p>甲子鎮處在陸豐市，與惠來縣交界，語言文化上偏惠來（其實五百年前與惠來交界處同屬海豐縣）。甲子話是三甲地區（甲子、甲西、甲東三鎮）通行的語言，是甲子地方文化的重要載體之一。在學術上，甲子話被歸入粵東閩南語潮汕話片。 </p>\n<p>甲子話保留了好㩼中古乃至上古的漢語詞彙，比如：汝、諸母、新婦、箸、鼎、匏桸、雅、翹楚等等，還有極具地方特色的表達，比如：𨑨迌、走漆、理唔直、孤獨死相等等。然而無會寫甚至無會呾甲子話的人實在㩼，其中不少是受過義務教育其。 有鑑於此，本人草創此表，力求詞雅正且其音形義有所考據，權當拋磚引玉，歡迎大家儂做蜀討論改進。 </p>\n<p>另附本表主要參考資料：</p>\n<ol>\n<li>《潮汕方言詞考釋》（林倫倫）</li>\n<li>《海豐話分類辭表》（羅志海、鍾顯坤）</li>\n<li><a href=\"https://www.mogher.com/baike\">《潮典》</a> </li>\n<li>《新潮汕字典》（張曉山）</li>\n<li><a href=\"https://twblg.dict.edu.tw/holodict%5C_new/index.html\">《台灣閩南語常用詞辭典》</a> </li>\n<li><a href=\"https://xiaoxue.iis.sinica.edu.tw/minyu\">《小學堂閩語》</a></li>\n</ol>\n<p>阿華<br>2020年10月成稿，12月修訂</p>","more":"<h2 id=\"總表-zong²-biao²\"><a href=\"#總表-zong²-biao²\" class=\"headerlink\" title=\"總表(zong² biao²)\"></a>總表(zong² biao²)</h2><h3 id=\"🤵稱謂-ceng¹-ui⁶\"><a href=\"#🤵稱謂-ceng¹-ui⁶\" class=\"headerlink\" title=\"🤵稱謂(cêng¹ ui⁶)\"></a>🤵稱謂(cêng¹ ui⁶)</h3><ol>\n<li>我 /ua²/</li>\n<li>汝 /lu²/ 你</li>\n<li>伊 /i¹/ 他/她/它</li>\n<li>恁 /ning²/ 你們</li>\n<li>伊人 /i¹ nang⁷/ 他們</li>\n<li>家己 /ga¹ gi⁷/ 自己</li>\n<li>人家 /nang⁵ gê¹/ 別人</li>\n<li>諸夫 /za¹ bao¹/ 男人、男子</li>\n<li>諸母 /za¹ bhao²/ 女人</li>\n<li>諸娘 /zu¹ nion⁵/ 女子</li>\n<li>大人 /dua⁷ nang⁷/</li>\n<li>老人 /lao⁶ nang⁵/</li>\n<li>後生囝 /hao⁶ sên¹ gian²/ 年輕人</li>\n<li>孥囝 /nao⁵ gian²/、/nong⁶ gian²/ 小孩子</li>\n<li>諸夫囝 /za¹ bao¹ gian²/ 男孩子、兒子</li>\n<li>諸母囝 /za¹ bhao² gian²/ 女孩子、女兒</li>\n<li>諸娘囝 /zu¹ nion⁵ gian²/ 年輕女子</li>\n<li>阿公 /a¹ gong¹/ 爺爺</li>\n<li>阿媽 /a¹ ma²/ 奶奶</li>\n<li>媽人 /ma² nang⁵/ 婦女</li>\n<li>媽祖 /ma² zao²/ 原名林默，南海保護神</li>\n<li>爸爸 /ba¹ ba¹/ 爸爸</li>\n<li>媽媽 /ma¹ ma¹/</li>\n<li>父母 /bê⁶ bho²/</li>\n<li>兄 /hian¹/ 哥哥</li>\n<li>弟 /di⁶/ 弟弟</li>\n<li>姐 /zê²/ 姐姐</li>\n<li>妹 /moi⁷/ 妹妹</li>\n<li>姊妹 /zi² moi⁷/ 姐妹</li>\n<li>叔伯兄弟 /zêh⁴ bêh⁴ hian¹ di⁶/ 堂兄弟</li>\n<li>同沿 /dang⁵ iang⁵/ 同輩、同儕</li>\n<li>翁 /ang¹/ 丈夫</li>\n<li>母 /bhao²/ 妻子</li>\n<li>翁姐 /ang¹ zia²/ 夫妻</li>\n<li>新婦 /sing¹ bu⁶/ 媳婦</li>\n<li>大家 /dua⁷ gê¹/ 丈夫的母親、家婆</li>\n<li>大家官 /dua⁷ gê¹ guan¹/ 丈夫的父親、家公</li>\n<li>丈人 /dion⁶ nang⁵/ 岳父</li>\n<li>丈母 /dion⁶ m²/ 岳母</li>\n<li>妻舅 /ci¹ gu⁶/ 妻子的兄弟</li>\n<li>妻姨 /ci¹ i⁵/ 妻子的姐妹</li>\n<li>伯 /bêh⁴/ 伯伯</li>\n<li>姆 /m²/ 伯父的妻子</li>\n<li>叔 /zêh⁴/ 叔叔</li>\n<li>嬸 /sim²/ 叔父的妻子</li>\n<li>舅 /gu⁶/ 舅舅</li>\n<li>妗 /gim⁶/ 舅父的妻子</li>\n<li>姑 /gao¹/ 父親的姐妹、姑姑</li>\n<li>姑丈 /gou¹ dion⁶/ 姑姑的丈夫</li>\n<li>姨 /i⁵/ 母親的姐妹；母親</li>\n<li>姨丈 /i⁵ dion⁶/ 母親的姐妹的丈夫</li>\n<li>先生 /sing¹ sên¹/</li>\n<li>學生 /hag⁴ sêng¹/</li>\n<li>師父 /sai¹ bê⁶/ 工匠師傅</li>\n<li>師父 /su¹ hu⁶/ 出家人、和尚</li>\n<li>和尚 /hoi⁵ sion⁷/、/hua⁵ siang⁶/</li>\n<li>腳色 /ka¹ siao³/ 人手、幫手</li>\n<li>青暝囝 /cên¹ mên⁵ gian²/ 瞎子</li>\n</ol>\n<h3 id=\"🦶身體-sing¹-ti²\"><a href=\"#🦶身體-sing¹-ti²\" class=\"headerlink\" title=\"🦶身體(sing¹ ti²)\"></a>🦶身體(sing¹ ti²)</h3><ol>\n<li>頭毛 /tao⁵ mo⁵/ 頭髮</li>\n<li>頭神 /tao⁵ sing⁵/ 思維、記憶的能力</li>\n<li>頭碗骨 /tao⁵ uan² gug⁴/ 頭蓋骨</li>\n<li>旋 /zng⁷/ 頭髮呈漩渦狀的地方</li>\n<li>囟 /sing³/ 嬰兒頭頂骨未合縫處</li>\n<li>額頭 /hia² tao⁵/</li>\n<li>面 /ming⁷/ 臉</li>\n<li>頰溝 /gih⁴ gao¹/ 腮</li>\n<li>痣 /gi³/</li>\n<li>目 /mag⁸/ 眼睛</li>\n<li>目仁 /mag⁸ ring⁵/ 眼珠子</li>\n<li>目汁 /mag⁸ zab⁴/ 眼淚</li>\n<li>眉 /bhai⁵/ 眉毛</li>\n<li>耳 /hin⁶/ 耳朵</li>\n<li>耳空、耳孔 /hin⁶ kang¹/</li>\n<li>鼻 /pin⁷/ 鼻子</li>\n<li>鼻空、鼻孔 /pin⁷ kang¹/</li>\n<li>喙、嘴 /cui⁷/ 嘴巴</li>\n<li>䶕牙 /bha³ ghê⁵/ 龅牙</li>\n<li>涎 /nua⁶/ 唾液</li>\n<li>痰 /tam⁵/</li>\n<li>頷 /am⁶/ 脖子</li>\n<li>下頦 /ê⁶ hai⁵/ 下巴</li>\n<li>喙後肚 /cui⁷ ao⁶ dao²/ 下巴後面柔軟處</li>\n<li>鬚 /ciu¹/ 鬍鬚</li>\n<li>嚨喉 /na⁵ ao⁵/ 喉嚨</li>\n<li>手 /ciu²/</li>\n<li>正手 /zian³ ciu²/ 右手</li>\n<li>倒手 /do³ ciu²/ 左手</li>\n<li>胳囊跤 /goh⁴ lang⁵ ka¹/ 腋下</li>\n<li>手後曲 /ciu² ao⁶ kiao¹/ 手肘</li>\n<li>手模 /ciu² bhao⁵/ 手印</li>\n<li>腡 /lê⁵/ 圓形手指紋</li>\n<li>指頭公 /zain² tao⁵ gong¹/ 大拇指</li>\n<li>尾指囝 /bhoi² zain² gian²/ 小指</li>\n<li>胸 /hêng¹/</li>\n<li>嬭、奶 /nê¹/</li>\n<li>𩩍篱 /pian¹ li⁵/ 肋骨</li>\n<li>肚臍 /dao² zai⁵/</li>\n<li>背脊 /ba¹ ziah⁴/ 脊背</li>\n<li>腰 /io¹/</li>\n<li>跤、骹、腳 /ka¹/</li>\n<li>跤頭趺 /ka¹ tao⁵ u⁶/ 膝蓋</li>\n<li>大跤腿 /dua⁷ ka¹ tui²/ 大腿</li>\n<li>跤腸肚 /ka¹ dng⁵ dao²/ 小腿後部肌肉凸出處</li>\n<li>跤後蹬 /ka¹ ao⁶ dên¹/ 腳後跟</li>\n<li>跤盤 /ka¹ buan⁵/ 腳板</li>\n<li>跤目 /ka¹ mag⁸/ 腳踝</li>\n<li>跤指公 /ka¹ zain² gong¹/ 腳大拇趾</li>\n<li>跤液 /ka¹ sio²/ 腳汗</li>\n<li>卵 /lang⁶/ 陰莖、屌、勢</li>\n<li>卵鳥 /lang⁶ ziao²/ 陰莖、屌、勢</li>\n<li>卵脬 /lang⁶ pa¹/ 精囊</li>\n<li>卵核 /lang⁶ hug⁸/ 睪丸</li>\n<li>膣 /zi¹/ 女陰</li>\n<li>膣眉 /zi¹ bhai¹/ 女陰</li>\n<li>尻川 /ka¹ cng¹/ 屁股</li>\n<li>雞母皮 /goi¹ bho² poi⁵/ 雞皮疙瘩</li>\n<li>汗 /guan⁷/</li>\n<li>垢圿 /gao² goih⁴/ 體表污垢</li>\n</ol>\n<h3 id=\"🍵飲食-im²-ziah⁸\"><a href=\"#🍵飲食-im²-ziah⁸\" class=\"headerlink\" title=\"🍵飲食(im² ziah⁸)\"></a>🍵飲食(im² ziah⁸)</h3><ol>\n<li>食 /ziah⁸/ 吃、喝、抽</li>\n<li>祭 /zi³/ 狼吞虎咽；坐享其成</li>\n<li>咬 /ga⁶/</li>\n<li>哺 /bao⁷/ 咀嚼</li>\n<li>吞 /tung¹/</li>\n<li>舐 /zi⁶/ 舔</li>\n<li>含 /gam⁵/</li>\n<li>啜 /coih⁴/ 喝</li>\n<li>啉 /lim⁵/ 小口喝</li>\n<li>灌 /guang¹/ 大口喝</li>\n<li>吸 /kib⁴/</li>\n<li>搵 /ung³/ 蘸</li>\n<li>買鹹 /moi² giam⁵/ 買菜</li>\n<li>食透早 /ziah⁸ tao⁷ za²/ 吃早飯</li>\n<li>食眠起 /ziah⁸ mng⁵ ki²/ 吃早飯</li>\n<li>食晝 /ziah⁸ dao³/ 吃午飯</li>\n<li>食當晝 /ziah⁸ dêng¹ dao³/ 吃午飯</li>\n<li>食夜昏、食暝昏 /ziah⁸ mê⁵ hng⁵/ 吃晚飯</li>\n<li>飯 /bng⁷/</li>\n<li>米 /bhi²/</li>\n<li>糜 /moi⁵/ 粥</li>\n<li>飲 /am²/ 米湯</li>\n<li>配 /poi³/ 菜</li>\n<li>菜式 /cai³ sêg⁴/</li>\n<li>粿、餜 /goi²/</li>\n<li>丸、圓 /in⁵/</li>\n<li>油䭔 /iu⁵ zui¹/ 一種油炸食品</li>\n<li>汰米 /tua⁷ bhi²/ 淘米</li>\n<li>熬 /ngao⁵/ 長時間煮。～糜。</li>\n<li>煲 /bu⁵/ 煮、熬。～藥。</li>\n<li>潘 /png¹/ 餿水</li>\n<li>油 /iu⁵/</li>\n<li>鹽 /iam⁵/</li>\n<li>醋 /cao³/</li>\n<li>豉油 /si⁷ iu⁵/ 醬油</li>\n<li>豆汁 /dao⁷ zab⁴/ 醬油</li>\n<li>雞卵 /goi¹ nng⁶/ 雞蛋</li>\n<li>豬肉 /du¹ nêg⁸/</li>\n<li>澀肉 /siab⁴ nêg⁸/、/siab⁴ bhah⁴/ 瘦肉。澀，少油。</li>\n<li>肉脞 /nêg⁸ co³/ 肉末</li>\n<li>烏糖 /ao¹ tng⁵/ 紅糖、黑糖</li>\n<li>赤砂糖 /ciah⁴ sua¹ tng⁵/</li>\n<li>白砂糖 /bêh⁸ sua¹ tng⁵/</li>\n<li>薰 /hung¹/ 香菸</li>\n<li>茶 /dê⁵/</li>\n<li>酒 /ziu²/</li>\n<li>淖 /cioh⁴/ 粥稀</li>\n<li>凊 /cing³/ 飯菜涼了</li>\n<li>燒 /sio¹/ 熱呼呼</li>\n<li>燒烘燒烘 /sio¹ hang¹ sio¹ hang¹/ 熱呼呼</li>\n<li>芳 /pang¹/ 香</li>\n<li>甘 /gam¹/</li>\n<li>甜 /diam⁵/</li>\n<li>鹹 /giam⁵/</li>\n<li>薟 /hiam¹/ 辛辣</li>\n<li>䭕 /zian²/ 清淡</li>\n<li>臊 /co¹/ 腥</li>\n<li>臭 /cao³/</li>\n</ol>\n<h3 id=\"👔穿戴-ceng⁷-dua³\"><a href=\"#👔穿戴-ceng⁷-dua³\" class=\"headerlink\" title=\"👔穿戴(cêng⁷ dua³)\"></a>👔穿戴(cêng⁷ dua³)</h3><ol>\n<li>帽 /bho⁷/</li>\n<li>目鏡 /mah⁸ gian³/ 眼鏡</li>\n<li>圍巾 /ui⁵ ging¹/</li>\n<li>頷幔 /am⁶ muan¹/ 披肩</li>\n<li>衫褲 /san¹ kao³/ 衣服</li>\n<li>西裝 /sai¹ zuang¹/</li>\n<li>褸 /lao¹/ 大衣</li>\n<li>葵笠 /goi⁵ loih⁸/ 斗笠，竹編成的圓錐形大帽子。</li>\n<li>羊毛衫 /ion⁵ mo⁵ san¹/</li>\n<li>長䘼衫 /dng⁵ ng² san¹/ 長袖衫</li>\n<li>短䘼衫 /dê² ng² san¹/ 短袖衫</li>\n<li>貼身衫 /dah⁴ sing¹ san¹/ 貼身的上衣</li>\n<li>䘥囝 /gah⁴ gian²/ 無袖內衣</li>\n<li>底衫 /doi² san¹/ 內衣</li>\n<li>肚綰 /dao² guan⁶/ 肚兜</li>\n<li>長褲 /dng⁵ kao³/</li>\n<li>短褲 /dê² kao³/</li>\n<li>褲頭 /kao³ tao⁵/ 短褲、內褲</li>\n<li>褲橛 /kao³ goi²/ 短褲、內褲</li>\n<li>三角褲 /san¹ gag⁴ kao³/</li>\n<li>裙 /gung⁵/</li>\n<li>圍裙 /ui⁵ gung⁵/</li>\n<li>文胸 /bhung⁵ hêng¹/ 胸罩</li>\n<li>奶帕、嬭帕 /nê¹ pê³/ 胸罩</li>\n<li>皮帶 /poi⁵ dua³/</li>\n<li>手囊 /ciu² lob⁴/ 套袖</li>\n<li>手鐲 /ciu² sio²/</li>\n<li>鞋拖 /tua¹ oi⁵/ 拖鞋</li>\n<li>波鞋 /bo¹ oi⁵/ 球鞋。波，英文 ball 的音譯。</li>\n<li>釘鞋 /dêng¹ oi⁵/ 運動鞋的一種</li>\n<li>皮鞋 /poi⁵ oi⁵/</li>\n<li>高跟鞋 /gao¹ ging¹ oi⁵/</li>\n<li>靴 /hia¹/</li>\n<li>襪 /ghoih⁸/</li>\n<li>布 /bao³/</li>\n<li>襊 /zoi⁷/ 折痕</li>\n<li>頷領 /am⁶ nia²/ 領子</li>\n<li>褲袋 /kao³ dê⁷/ 位於褲子的口袋</li>\n<li>衫袋 /san¹ dê⁷/ 位於上衣的口袋</li>\n<li>暗袋 /am³ dê⁷/ 內側袋</li>\n<li>內裏 /lai⁶ li²/ 衣物不露出在外的裏層</li>\n<li>鈕 /liu²/ 鈕扣</li>\n<li>針 /zam¹/</li>\n<li>線 /suan³/</li>\n<li>拉鍊 /la¹ liang³/</li>\n<li>穿 /cêng⁷/</li>\n<li>褪 /tng⁷/ 脱</li>\n<li>紩 /tin⁷/ 縫</li>\n<li>補 /bao²/</li>\n<li>車衫褲 /cia¹ san¹ kao³/ 用縫紉機縫衣服</li>\n</ol>\n<h3 id=\"🎏物件-mi²-gian⁶、mian⁶\"><a href=\"#🎏物件-mi²-gian⁶、mian⁶\" class=\"headerlink\" title=\"🎏物件(mi² gian⁶、mian⁶)\"></a>🎏物件(mi² gian⁶、mian⁶)</h3><ol>\n<li><p>眠牀 /mng⁵ cng⁵/ 牀</p>\n</li>\n<li><p>鋪 /pao¹/ 牀</p>\n</li>\n<li><p>高低牀 /gao¹ di¹ cng⁵/ 上下鋪</p>\n</li>\n<li><p>蓆 /cioh⁸/</p>\n</li>\n<li><p>簟 /diam⁶/ 竹席</p>\n</li>\n<li><p>毡 /ziang¹/</p>\n</li>\n<li><p>被 /poi⁶/</p>\n</li>\n<li><p>棉被 /mi⁵ poi⁶/</p>\n</li>\n<li><p>被單 /poi⁶ duan¹/</p>\n</li>\n<li><p>枕頭 /zim² tao⁵/</p>\n</li>\n<li><p>枕頭囊 /zim² tao⁵ lob⁴/ 枕套</p>\n</li>\n<li><p>蠓罩、蚊罩 /mang² da³/ 蚊帳</p>\n</li>\n<li><p>蠓熏、蚊熏 /mang² hung¹/ 蚊香</p>\n</li>\n<li><p>窗罩 /têng¹ zao⁶/</p>\n</li>\n<li><p>口罩 /kao² zao⁶/</p>\n</li>\n<li><p>壁櫥 /biah⁴ du⁵/</p>\n</li>\n<li><p>椅 /in²/</p>\n</li>\n<li><p>桌 /doh⁴/</p>\n</li>\n<li><p>櫃 /gui⁷/</p>\n</li>\n<li><p>架 /gê³/</p>\n</li>\n<li><p>盒 /ab⁸/</p>\n</li>\n<li><p>籃 /na⁵/</p>\n</li>\n<li><p>瓶 /bang⁵/</p>\n</li>\n<li><p>鎖頭 /so² tao⁵/</p>\n</li>\n<li><p>鎖匙 /so² si⁵/ 鑰匙</p>\n</li>\n<li><p>葉疊 /iab² diab⁸/ 合葉</p>\n</li>\n<li><p>牙簽 /ghê⁵ ciam¹/</p>\n</li>\n<li><p>茶盤 /dê⁵ buan⁵/</p>\n</li>\n<li><p>茶壺 /dê⁵ hu⁵/</p>\n</li>\n<li><p>沖罐 /cong¹ guang³/ 茶壺</p>\n</li>\n<li><p>茶杯 /dê⁵ boi¹/</p>\n</li>\n<li><p>茶几 /dê⁵ gi²/</p>\n</li>\n<li><p>熏咬 /hung¹ ga⁶/ 煙斗</p>\n</li>\n<li><p>熏碟 /hung¹ dih⁸/ 煙灰缸</p>\n</li>\n<li><p>熱壺 /riag⁸ hu⁵/ 熱水瓶</p>\n</li>\n<li><p>熨斗 /ug⁴ dao²/</p>\n</li>\n<li><p>電燈 /diang⁶ dêng¹/</p>\n</li>\n<li><p>電泡 /diang⁶ pa⁶/</p>\n</li>\n<li><p>燈籠 /dêng¹ lang⁵/</p>\n</li>\n<li><p>燈火 /dêng¹ hoi²/ 電燈；燈光</p>\n</li>\n<li><p>風箏 /hong¹ zêng¹/</p>\n</li>\n<li><p>米甕 /bhi² ang³/ 米缸</p>\n</li>\n<li><p>水䀇 /zui² gao²/ 大型儲水器</p>\n</li>\n<li><p>跤桶 /ka¹ tang²/ 原指洗腳桶，後泛指洗衣盆，也可用來給小孩洗澡。</p>\n</li>\n<li><p>面盆 /ming⁷ png⁵/ 臉盆</p>\n</li>\n<li><p>瓠桸 /bu⁵ hia¹/ 水瓢</p>\n</li>\n<li><p>口㼦 /kao² gong²/ 漱口杯</p>\n</li>\n<li><p>碗 /uan²/</p>\n</li>\n<li><p>盤 /buan⁵/</p>\n</li>\n<li><p>碟 /dih⁸/</p>\n</li>\n<li><p>甌 /ao¹/ 大碗</p>\n</li>\n<li><p>箸 /du⁷/ 筷子</p>\n</li>\n<li><p>湯匙 /tng¹ si⁵/</p>\n</li>\n<li><p>調羹 /tiao⁵ gên¹/ 喝粥用的小勺子；湯匙</p>\n</li>\n<li><p>糜匙 /moi⁵ si⁵/ 舀粥用的勺子</p>\n</li>\n<li><p>飯匙 /bng⁷ si⁵/ 飯勺</p>\n</li>\n<li><p>飯添 /bng⁷ tin¹/ 飯勺</p>\n</li>\n<li><p>鼎 /dian²/ 鍋</p>\n</li>\n<li><p>鼎㧕 /dian² liu⁶/ 鍋鏟。㧕，存疑。</p>\n</li>\n<li><p>鼎蓋 /dian² kain³/ 鍋蓋</p>\n</li>\n<li><p>菜刀 /cai³ do¹/</p>\n</li>\n<li><p>瓜刨 /goi¹ pao⁵/</p>\n</li>\n<li><p>砧 /diam¹/</p>\n</li>\n<li><p>篩 /tai¹/</p>\n</li>\n<li><p>筅 /cain²/ 刷子</p>\n</li>\n<li><p>菜篩 /cai³ tai¹/</p>\n</li>\n<li><p>鉸刀 /ga¹ do¹/ 剪刀</p>\n</li>\n<li><p>螺絲批 /lo⁵ si¹ poi¹/ 螺絲刀</p>\n</li>\n<li><p>螺絲釘 /lo⁵ si¹ dêng¹/</p>\n</li>\n<li><p>旋螺絲 /suag⁸ lo⁵ si¹/ 擰螺絲</p>\n</li>\n<li><p>鐵錘 /tih⁴ tui⁵/</p>\n</li>\n<li><p>鉸夾 /ga¹ giab⁸/ 鉗子</p>\n</li>\n<li><p>扳手 /bang² ciu²/</p>\n</li>\n<li><p>電筆 /diang⁶ big⁴/ 測電筆</p>\n</li>\n<li><p>烏膠布 /ao¹ ga¹ bao³/ 電工膠帶</p>\n</li>\n<li><p>黏紙 /niam⁵ zua²/ 透明膠帶</p>\n</li>\n<li><p>布拖 /bao³ tu¹/ 拖把</p>\n</li>\n<li><p>掃帚 /sao³ siu²/ 掃把</p>\n</li>\n<li><p>畚斗 /bng³ dao²/ 垃圾鏟</p>\n</li>\n<li><p>畚箕 /bng³ gi¹/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled.png\" alt></p>\n</li>\n<li><p>梯 /tui¹/</p>\n</li>\n<li><p>吸石 /hiab⁴ zioh⁸/ 磁鐵、磁石</p>\n</li>\n<li><p>箠 /coi⁵/ 鞭子，可用來教育孩子。</p>\n</li>\n<li><p>火箠 /hoi² coi⁵/ 火筷子，夾爐中煤炭或通火的用具。</p>\n</li>\n<li><p>角畢 /gag⁴ big⁴/ 皮箱</p>\n</li>\n<li><p>樹嬭 /ciu⁷ ni⁵/ 橡皮、橡膠。嬭，樹之乳膠。</p>\n</li>\n<li><p>嬭漱 /ni⁵ ciu³/ 橡皮擦</p>\n</li>\n<li><p>毛筆 /mo⁵ big⁴/</p>\n</li>\n<li><p>鋼筆 /gng³ big⁴/</p>\n</li>\n<li><p>鉛筆 /iang⁵ big⁴/</p>\n</li>\n<li><p>鉛筆旋 /iang⁵ big⁴ suag⁸/ 卷筆刀、筆刨</p>\n</li>\n<li><p>模 /bhao⁵/ 模子</p>\n</li>\n<li><p>㨹 /zoi⁷/ 裂縫、痕跡</p>\n</li>\n<li><p>離衣機 /li⁵ i¹ gi¹/ 洗衣機</p>\n</li>\n</ol>\n<h3 id=\"🏠建築-giang³-dog⁴\"><a href=\"#🏠建築-giang³-dog⁴\" class=\"headerlink\" title=\"🏠建築(giang³ dog⁴)\"></a>🏠建築(giang³ dog⁴)</h3><ol>\n<li>茨、厝 /cu³/ 房子、家</li>\n<li>寮 /liao⁵/ 简陋小屋</li>\n<li>瓦茨 /hia⁶ cu³/ 瓦舍</li>\n<li>茨手 /cu³ ciu²/ 潮汕民居天井旁兩間廂房的名稱。</li>\n<li>兩間直 /no⁶ gain¹ dig⁸/ 傳統民居，兩房。</li>\n<li>獨腳靴 /dog⁸ ka¹ hia¹/ 傳統民居，一聽一茨手一房。</li>\n<li>下山虎 /hia⁶ suan¹ haon²/ 傳統民居，三合院，一廳二房二茨手。</li>\n<li>四點金 /si³ diam² gim¹/ 傳統民居，四合院，中軸爲前廳天井後聽，兩廳兩旁各有一房。</li>\n<li>竹竿茨 /dêg⁴ go¹ cu³/ 傳統民居，廚房客廳住房天井排列成狹長的空間，如竹竿。</li>\n<li>駟馬拖車 /si³ mê² tua¹ cia¹/ 傳統民居，在四點金上縱加一廳，橫加兩房，三廳二天丼。</li>\n<li>茨邊 /cu³ bin¹/ 鄰居</li>\n<li>起茨 /ki² cu³/ 蓋房子</li>\n<li>租茨 /zao¹ cu³/ 租房子</li>\n<li>搬茨 /buan⁵ cu³/ 搬家</li>\n<li>入新茨 /rib⁸ sing¹ cu³/ 搬入新家</li>\n<li>客廳 /kêh⁴ tian¹/</li>\n<li>客房 /kêh⁴ bang⁵/</li>\n<li>廚房 /dao⁵ bang⁵/</li>\n<li>浴室 /êg⁸ sig⁴/</li>\n<li>洗浴 /soi² êg⁸/ 洗澡</li>\n<li>廁所 /cê³ so²/</li>\n<li>屎壑 /sai² hag⁸/ 茅廁</li>\n<li>門窗 /mng⁵ têng¹/</li>\n<li>門閂 /mng⁵ cuan³/</li>\n<li>門楣 /mng⁵ bhai⁵/</li>\n<li>門橂 /mng⁵ dain⁶/ 門檻</li>\n<li>門扇後 /mng⁵ sin³ ao⁶/ 門後</li>\n<li>柱 /tiao⁶/</li>\n<li>牆壁 /cion⁵ biah⁴/</li>\n<li>庭、埕 /dian⁵/ 寬闊平地，可曬鹽、曬穀。</li>\n<li>临檐 /lim⁵ zin⁵/ 檐廊</li>\n<li>塗角 /tao⁵ gag⁴/ 土磚</li>\n<li>磚 /zng¹/</li>\n<li>廟 /bhio⁷/</li>\n<li>亭 /dêng⁵/</li>\n<li>祠堂 /su⁵ dng⁵/</li>\n<li>庵寺 /am¹ zin⁷/ 尼寺、僧寺的通稱。</li>\n<li>學校 /hag⁸ hao⁶/</li>\n<li>醫院 /ui¹ in⁷/</li>\n<li>鎮府 /ding³ hu²/ 鎮政府</li>\n<li>舖囝 /pao³ gian²/ 小賣部</li>\n</ol>\n<h3 id=\"🛵交通-gao¹-tong¹\"><a href=\"#🛵交通-gao¹-tong¹\" class=\"headerlink\" title=\"🛵交通(gao¹ tong¹)\"></a>🛵交通(gao¹ tong¹)</h3><ol>\n<li>腳車、跤車 /ka¹ cia¹/ 腳踏車、自行車</li>\n<li>摩托 /mo⁵ toh⁸/ 摩托，英文 motorcycle 音譯省。</li>\n<li>三輪車 /san¹ lung⁵ cia¹/</li>\n<li>的士 /dêg⁴ si⁶/ 計程車、出租車。的士，英文 taxi 音譯。</li>\n<li>小車 /sio² cia¹/ 小汽車</li>\n<li>麵包車 /min⁷ bao¹ cia¹/</li>\n<li>公交車 /gong¹ gao¹ cia¹/</li>\n<li>大巴 /dua⁷ ba¹/ 巴，英文 bus 音譯。</li>\n<li>車站 /cia¹ zam⁶/</li>\n<li>輪船 /lung⁵ zung⁵/</li>\n<li>龍船 /lêng⁵ zung⁵/ 龍舟</li>\n<li>火車 /hoi² cia¹/</li>\n<li>地鐵 /di⁷ tih⁴/</li>\n<li>高鐵 /gao¹ tih⁴/</li>\n<li>飛機 /boi¹ gi¹/</li>\n<li>行路 /gian⁵ lao⁷/ 走路</li>\n<li>踏腳車 /dah⁸ ka¹ cia¹/ 騎自行車</li>\n<li>駛車 /sai² cia¹/ 開車</li>\n<li>撐船 /tên¹ zung⁵/</li>\n<li>載客 /zai³ kêh⁴/</li>\n<li>拗䷀囝 /ao² gag⁴ gian²/ 摩托車司機。拗，載；扛。</li>\n<li>落車 /lo² cia¹/ 下車</li>\n<li>碼頭 /bhê² tao⁵/</li>\n<li>涵空、涵孔 /am⁵ kang¹/ 涵洞、涵管、地下水道</li>\n<li>橋墩 /gio⁵ dun¹/ 橋梁下面的圓柱狀基石</li>\n</ol>\n<h3 id=\"🐒眾生-zeng³-sen¹\"><a href=\"#🐒眾生-zeng³-sen¹\" class=\"headerlink\" title=\"🐒眾生(zêng³ sên¹)\"></a>🐒眾生(zêng³ sên¹)</h3><ol>\n<li><p>眾生 /zêng³ sên¹/ 牲畜</p>\n</li>\n<li><p>禽兽 /kim⁵ siu⁶/</p>\n</li>\n<li><p>害蟲 /hai⁷ tang⁵/</p>\n</li>\n<li><p>豬豭 /du¹ go¹/ 配種的公豬，也比喻好色之徒。</p>\n</li>\n<li><p>豬槽 /du¹ zo⁵/</p>\n</li>\n<li><p>羊牢 /ion⁵ lo⁵/</p>\n</li>\n<li><p>雞翁 /goi¹ ang¹/ 雄雞</p>\n</li>\n<li><p>雞母 /goi¹ bho²/ 母雞</p>\n</li>\n<li><p>鴨囝 /ah⁴ gian²/ 小鴨子</p>\n</li>\n<li><p>鵝 /gho⁵/</p>\n</li>\n<li><p>貓牯 /ngiao¹ gao²/ 母貓</p>\n</li>\n<li><p>鳥 /ziao²/</p>\n</li>\n<li><p>燕囝 /in³ gian²/ 小燕子</p>\n</li>\n<li><p>鶴 /hoh⁸/</p>\n</li>\n<li><p>鷹 /êng¹/</p>\n</li>\n<li><p>白鴿 /bêh⁸ gab⁴/</p>\n</li>\n<li><p>白鷺鷥 /bêh⁸ lao⁷ si¹/</p>\n</li>\n<li><p>鸚哥 /êng¹ go¹/ 鸚鵡</p>\n</li>\n<li><p>麻雀 /mua⁵ ziah⁴/</p>\n</li>\n<li><p>蝠婆 /big⁴ bo⁵/ 蝙蝠</p>\n</li>\n<li><p>蛇 /zua⁵/</p>\n</li>\n<li><p>雨傘節 /hao⁶ suan³ zag⁴/ 一种毒蛇。</p>\n</li>\n<li><p>狗母蛇 /gao² bho² zua⁵/ 蛇舅母、石龍子、四腳蛇，蜥蜴的一種</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%201.png\" alt></p>\n</li>\n<li><p>兩棲動物 /liang² ci¹ dong⁶ moih⁸/</p>\n</li>\n<li><p>蟾蜍 /ziong¹ zu⁵/</p>\n</li>\n<li><p>蛤虯 /gab⁴ giu²/ 青蛙</p>\n</li>\n<li><p>蛤蛙 /gab⁴ guai¹/ 蝌蚪</p>\n</li>\n<li><p>蚼蟻 /gao² hia⁶/ 螞蟻</p>\n</li>\n<li><p>白蟻 /bêh⁸ hia⁶/</p>\n</li>\n<li><p>蜜蜂 /bhig⁸ pang¹/</p>\n</li>\n<li><p>虎頭蜂 /hao² tao⁵ pang¹/ 黄蜂</p>\n</li>\n<li><p>龜 /gu¹/ 烏龜或像烏龜的昆蟲</p>\n</li>\n<li><p>金龜 /gim¹ gu¹/ 金龜子</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%202.png\" alt></p>\n</li>\n<li><p>鱉 /bih⁴/</p>\n</li>\n<li><p>土蚓 /dao⁶ ung²/ 蚯蚓</p>\n</li>\n<li><p>蜈蚣 /gê⁵ gang¹/</p>\n</li>\n<li><p>火金蛄 /hoi² gim¹ gao¹/ 螢火蟲</p>\n</li>\n<li><p>牛屎龜 /ghu⁵ sai² gu¹/ 屎殼郎、蜣螂</p>\n</li>\n<li><p>烏點龜 /ao¹ diam² gu¹/ 七星瓢蟲</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%203.png\" alt></p>\n</li>\n<li><p>紅新娘 /ang⁵ sing¹ nion⁵/ 紅姬緣椿象</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%204.png\" alt></p>\n</li>\n<li><p>山蛚 /sua¹ lê⁷/ 蟬；多指<a href=\"http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14818\">蚱蝉</a></p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%205.png\" alt></p>\n</li>\n<li><p>蝘悲蟬 /iam⁶ bi¹ sung⁵/ <a href=\"http://museum.ioz.ac.cn/topic%5C_detail.aspx?id=14817\">蟪蛄</a></p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/image.jpg\" alt=\"gahzi-oi-hung-lui-ci-biao/image.jpg\"></p>\n</li>\n<li><p>蟋蟀 /tih⁴ sug⁴/ 又稱烏龍。</p>\n</li>\n<li><p>䷀ // 螽斯、莎蟲、紡織娘、蟈蟈。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%206.png\" alt></p>\n</li>\n<li><p>草猴 // 稻蝦</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%207.png\" alt></p>\n</li>\n<li><p>䷀ // 金盾龜金花蟲</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%208.png\" alt></p>\n</li>\n<li><p>草蜢 /cao² mên²/ 螞蚱、蚱蜢。</p>\n</li>\n<li><p>螳螂、螳蜋 /tang⁵ lang⁵/</p>\n</li>\n<li><p>神螂 /sing⁵ lang⁵/ 壁虎，蜥蜴的一種。</p>\n</li>\n<li><p>蛤蚧蛇 /gab⁴ gai³ zua⁵/ 大壁虎，蜥蜴的一種。</p>\n</li>\n<li><p>土猴 /dao⁶ gao⁵/ 螻蛄</p>\n</li>\n<li><p>蝶、蜨 /iah⁸/ 蝴蝶</p>\n</li>\n<li><p>山螟 /suan¹ mê¹/ 蜻蜓</p>\n</li>\n<li><p>米龜 /bhi² gu¹/ 米象，蛀食稻穀、麥粒等米糧爲生。</p>\n</li>\n<li><p>蛀蟲 /zu³ tang⁵/</p>\n</li>\n<li><p>蛓毛蟲 /ci³ mo⁵ tang⁵/ 毛毛蟲</p>\n</li>\n<li><p>流鼻螺 /lao⁵ pin⁷ lê⁵/ 蝸牛</p>\n</li>\n<li><p>戶蠅 /hao⁵ sing⁵/ 蒼蠅</p>\n</li>\n<li><p>枯蠅 /gao¹ sing⁵/ 介殼蟲</p>\n</li>\n<li><p>蠓、蚊 /mang²/</p>\n</li>\n<li><p>蝨母 /sag⁴ bho²/ 蝨子</p>\n</li>\n<li><p>曱甴、虼蚻 /ga¹ zuah⁸/ 蟑螂</p>\n</li>\n<li><p>蜈蜞 /ghao⁵ ki⁵/ 水蛭，喜歡吸血人畜血液。</p>\n</li>\n</ol>\n<h3 id=\"🐳水產-zui²-suan²\"><a href=\"#🐳水產-zui²-suan²\" class=\"headerlink\" title=\"🐳水產(zui² suan²)\"></a>🐳水產(zui² suan²)</h3><ol>\n<li><p>䭕水魚 /zian² zui² hu⁵/ 淡水魚</p>\n</li>\n<li><p>鹹水魚 /giam⁵ zui² hu⁵/ 海水魚</p>\n</li>\n<li><p>刣魚 /tai⁵ hu⁵/ 宰魚</p>\n</li>\n<li><p>魚春 /hu⁵ cung¹/ 魚卵。屈大均《廣東新語》：「粵方言凡禽魚卵皆為春。唐時吳君貢魚春子，即魚子也。」 </p>\n</li>\n<li><p>魚鱗 /hu⁵ lang⁵/</p>\n</li>\n<li><p>魚鰾 /hu⁵ pio⁶/</p>\n</li>\n<li><p>魚鰓 /hu⁵ ci¹/</p>\n</li>\n<li><p>魚刺 /hu⁵ ci³/</p>\n</li>\n<li><p>鯁 /gên²/ 魚刺在喉</p>\n</li>\n<li><p>馬鮫 /mê² ga¹/</p>\n</li>\n<li><p>鯧 /cion¹/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%209.png\" alt></p>\n</li>\n<li><p>鰇魚 /riu⁵ hu⁵/ 魷魚</p>\n</li>\n<li><p>墨斗 /bhag⁸ dao²/、/mag⁸ dao²/ 墨魚</p>\n</li>\n<li><p>絲丁魚 /si¹ dêng⁶ hu⁵/ 龍頭魚、硬魚、橂魚(殿魚)、豆腐魚</p>\n</li>\n<li><p>狗母魚 // 蝦虎魚、狗魽仔魚、九甘魚</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2010.png\" alt></p>\n</li>\n<li><p>白目噯 /ain²/</p>\n</li>\n<li><p>狗母囝 // 身體透明，似魩仔鱼，有淡水和海水兩種</p>\n</li>\n<li><p>鰻魚 /muan⁵ hu⁵/</p>\n</li>\n<li><p>花仙魚 /hoi¹ siang¹ hu⁵/ 鮐魚</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2011.png\" alt></p>\n</li>\n<li><p>鸚哥魚 /êng¹ go¹ hu⁵/ 洛神項鰭魚、紅姑娘、紅新娘、碼頭魚</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2012.png\" alt></p>\n</li>\n<li><p>癩瘑魚 /na³ go¹ hu⁵/、/lai³ go¹ hu⁵/ 多齒蛇鯔，俗稱「那哥魚」，常用於製魚丸。</p>\n</li>\n<li><p>娘愛魚 /nion⁵ ain¹ hu⁵/ 泥猛魚、褐篮子鱼、臭肚鱼。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2013.png\" alt></p>\n</li>\n<li><p>䷀囝 /dêg⁸ gian²/ 又稱迪仔、綠鰭馬面魨、剝皮魚。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2014.png\" alt></p>\n</li>\n<li><p>䱛囝 /oig⁸ gian²/ 䱛仔、䱛魚</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2015.png\" alt></p>\n</li>\n<li><p>金龍䱛 /gim¹ lêng⁵ oig⁸/ 金龍魚、黃花魚，狀似䱛魚但個頭大、嘴圓、體黃。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2016.png\" alt></p>\n</li>\n<li><p>福壽魚 /hog⁴ siu⁶ hu⁵/ 羅非魚</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2017.png\" alt></p>\n</li>\n<li><p>鮭魚 /guai¹ hu⁵/ 河魨，俗稱「乖魚」，常指黃鰭東方魨。</p>\n</li>\n<li><p>黃牆 /ng⁵ cion⁵/ 黃鰭鯛</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2018.png\" alt></p>\n</li>\n<li><p>軟甘 /nng² gang¹/ 杜氏鰤、油甘，體側有黃色縱帶。 </p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2019.png\" alt></p>\n</li>\n<li><p>沙尖 /sua¹ ziam¹/ 多鱗鱚、沙鯪、北方稱沙丁魚。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2020.png\" alt></p>\n</li>\n<li><p>龍箭 /lang⁷ zin⁷/ 鯪魚 ，淡水魚，可用於做罐頭魚。</p>\n</li>\n<li><p>石剎 /zio² sag⁴/ 又稱烏雞，松鯛。</p>\n</li>\n<li><p>淡角魚 /dam⁶ gag⁴ hu⁵/ 鯒魚、辮子魚</p>\n</li>\n<li><p>烏魚 /ao¹ hu⁵/ 又稱烏頭，鯔魚。</p>\n</li>\n<li><p>烏前魚 /ao¹ zain⁵ hu⁵/</p>\n</li>\n<li><p>塗虱 /tao⁵ sag⁴/ 鬍子鯰</p>\n</li>\n<li><p>龍舌 /lêng⁵ zi²/ 龍利魚</p>\n</li>\n<li><p>巴浪 /ba¹ lang¹/ 藍圓鯵</p>\n</li>\n<li><p>鯇魚 /uang² hu⁵/ 草魚</p>\n</li>\n<li><p>姑魚 /gao¹ hu⁵/ 金色小沙丁魚</p>\n</li>\n<li><p>鯽魚 /zig⁴ hu⁵/</p>\n</li>\n<li><p>秋刀魚 /ciu¹ do¹ hu⁵/</p>\n</li>\n<li><p>紅目鰱 /ang⁵ mag⁸ liang⁵/ 紅目大眼鯛</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2021.png\" alt></p>\n</li>\n<li><p>田鱔 /cang⁵ cuan⁶/ 鱔魚、黃鱔</p>\n</li>\n<li><p>白帶魚 /bêh⁸ dua³ hu⁵/ 鞭魚、裙帶魚、海刀魚</p>\n</li>\n<li><p>鰐魚 /ngag⁸ hu⁵/</p>\n</li>\n<li><p>鯊魚 /sua¹ hu⁵/</p>\n</li>\n<li><p>鯨魚 /kêng⁵ hu⁵/</p>\n</li>\n<li><p>紅哥鯉 /ang⁵ go¹ li²/ 金線魚</p>\n</li>\n<li><p>蝦 /hê⁵/</p>\n</li>\n<li><p>蟹 /hoi⁶/</p>\n</li>\n<li><p>三目蠘 /san¹ mag⁸ cih⁸/ 紅星梭子蟹、三目蟹</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2022.png\" alt></p>\n</li>\n<li><p>海哲 /hai² diag⁴/</p>\n</li>\n<li><p>蠔、蚝、蚵 /o⁵/ 牡蠣</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2023.png\" alt></p>\n</li>\n<li><p>紅肉 /ang⁵ nê²/ 紅肉藍蛤</p>\n</li>\n<li><p>蚶 /ham¹/</p>\n</li>\n<li><p>蜆 /hain⁶/</p>\n</li>\n<li><p>青匙 /cên¹ si⁵/ 綠殼菜蛤、翡翠貽貝</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2024.png\" alt></p>\n</li>\n<li><p>花蛤 /hoi¹ gab⁴/ 菲律賓簾蛤、花甲</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2025.png\" alt></p>\n</li>\n<li><p>車白 /cia¹ bêh⁸/ 文蛤，邊緣弧度較花蛤圓。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2026.png\" alt></p>\n</li>\n<li><p>青蛤 /cên¹ gab⁴/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2027.png\" alt></p>\n</li>\n<li><p>毛蚶 /mo⁵ ham¹/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2028.png\" alt></p>\n</li>\n<li><p>薄殼 /bo² kag⁴/ 尋氏肌蛤、海蛔、海瓜子</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2029.png\" alt></p>\n</li>\n<li><p>指甲螳 /zain² gah⁴ tang⁵/ 又稱指甲蚌hong²，蟶sêng³子。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2030.png\" alt></p>\n</li>\n<li><p>田螺 /cang⁵ lê⁵/</p>\n</li>\n<li><p>尖螺 /ziang¹ lê⁵/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2031.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"🌾-蔬菜-so¹-cai³\"><a href=\"#🌾-蔬菜-so¹-cai³\" class=\"headerlink\" title=\"🌾 蔬菜(so¹ cai³)\"></a>🌾 蔬菜(so¹ cai³)</h3><ol>\n<li><p>五穀 /ngao⁶ gag⁴/</p>\n</li>\n<li><p>稻 /diu⁶/</p>\n</li>\n<li><p>粟 /cêg⁴/ 稻粒</p>\n</li>\n<li><p>麥 /mê²/</p>\n</li>\n<li><p>秫米 /zu² bhi²/ 糯米</p>\n</li>\n<li><p>薏米 /in³ bhi²/</p>\n</li>\n<li><p>薏仁 /in³ ring⁵/ 玉米</p>\n</li>\n<li><p>蕃薯 /huang¹ zu⁵/、/hang¹ zu⁵/</p>\n</li>\n<li><p>馬鈴薯 /mê² lêng¹ zu⁵/ 土豆</p>\n</li>\n<li><p>黃豆 /ng⁵ dao⁷/ 大豆、菽</p>\n</li>\n<li><p>綠豆 /lê² dao⁷/</p>\n</li>\n<li><p>烏豆 /ao¹ dao⁷/ 黑豆</p>\n</li>\n<li><p>赤豆 /ciah⁴ dao⁷/ 紅小豆</p>\n</li>\n<li><p>荷目豆 /ho⁵ mag⁸ dao⁷/ 荷蘭豆、豌豆</p>\n</li>\n<li><p>地豆 /di⁷ dao⁷/ 花生</p>\n</li>\n<li><p>豆仁 /dao⁷ ring⁵/ 花生米</p>\n</li>\n<li><p>油麻 /iu⁵ mua⁵/ 芝麻</p>\n</li>\n<li><p>菜豆 /cai³ dao⁷/ 常指四季豆</p>\n</li>\n<li><p>茄 /gio⁵/</p>\n</li>\n<li><p>苦瓜 /kao² goi¹/</p>\n</li>\n<li><p>角瓜 /gag⁴ goi¹/ 稜角絲瓜</p>\n</li>\n<li><p>秋瓜 /ciu¹ goi¹/ 絲瓜</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2032.png\" alt></p>\n</li>\n<li><p>嬭瓜、奶瓜 /nê¹ goi¹/ 木瓜</p>\n</li>\n<li><p>蓮藕 /nain⁵ nao⁶/</p>\n</li>\n<li><p>菠薐菜 /boi¹ lêng⁵ cai³/ 菠菜</p>\n</li>\n<li><p>蕹菜 /êng³ cai³/ 空心菜</p>\n</li>\n<li><p>春菜 /cung¹ cai³/ 長葉芥菜</p>\n</li>\n<li><p>菜花 /cai³ hoi¹/ 花椰菜</p>\n</li>\n<li><p>芥菜 /gua³ cai³/ 大芥菜、包心芥菜</p>\n</li>\n<li><p>芥藍 /gêg⁴ na⁵/</p>\n</li>\n<li><p>菜頭 /cai³ tao⁵/ 白蘿蔔</p>\n</li>\n<li><p>紅菜頭 /ang⁵ cai³ tao⁵/ 紅蘿蔔</p>\n</li>\n<li><p>薺蔥、錢蔥 /zin⁵ cang¹/ 荸薺</p>\n</li>\n<li><p>韭菜 /gu² cai³/</p>\n</li>\n<li><p>芫荽 /iang¹ sui¹/ 香菜</p>\n</li>\n<li><p>芳菜 /pang¹ cai³/</p>\n</li>\n<li><p>厚合 /gao⁶ hah⁸/ 厚皮菜、莙薘菜、葉用甜菜</p>\n</li>\n<li><p>九層塔 /gao² zang⁵ tah³/ 金不換、羅勒</p>\n</li>\n<li><p>萵菜 /oi¹ cai³/ 皺葉萵苣、生菜</p>\n</li>\n<li><p>劍菜 /giam³ cai³/ 油麥菜</p>\n</li>\n<li><p>上海青 /siang⁶ hai² cên¹/ 青菜的一種</p>\n</li>\n<li><p>芹菜 /king⁵ cai³/</p>\n</li>\n<li><p>津白 /gian¹ bêh⁸/ 又稱紹菜、黃芽白，天津盛產，是大白菜的一種。以下是大白菜的不同品種。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2033.png\" alt></p>\n<p>天津大白菜</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2034.png\" alt></p>\n<p>大白菜</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2035.png\" alt></p>\n<p>娃娃菜</p>\n</li>\n<li><p>高麗菜 /go¹ lê⁵ cai³/ 捲心菜、包菜、結球甘藍</p>\n</li>\n<li><p>菜花 /cai³ hoi¹/ 花椰菜</p>\n</li>\n<li><p>茼蒿 /dang⁵ o¹/</p>\n</li>\n<li><p>枸杞菜 /gao² gi² cai³/</p>\n</li>\n<li><p>真珠菜 /zing¹ zu¹ cai³/ 珍珠花菜、白苞蒿</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2036.png\" alt></p>\n</li>\n<li><p>薟椒 /hiam¹ tsio¹/ 辣椒</p>\n</li>\n<li><p>生果 /cên¹ goi²/ 水果</p>\n</li>\n<li><p>荔果 /nai⁶ goi²/ 荔枝</p>\n</li>\n<li><p>龍眼 /nging⁵ ain²/</p>\n</li>\n<li><p>桑垂 /siong¹ sui⁵/ 桑葚</p>\n</li>\n<li><p>草莓 /cao² bhoi⁵/</p>\n</li>\n<li><p>刺菠 /ci³ bo¹/ 蛇莓、覆盆子</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2037.png\" alt></p>\n</li>\n<li><p>弓蕉 /gêng¹ zio¹/ 香蕉</p>\n</li>\n<li><p>米蕉 /bhi² zio¹/</p>\n</li>\n<li><p>鳥梨 /ziao² lai⁵/</p>\n</li>\n<li><p>檨 /suain⁷/ 芒果</p>\n</li>\n<li><p>菝囝 /bag⁸ gian²/ 番石榴</p>\n</li>\n<li><p>西瓜 /si¹ goi¹/</p>\n</li>\n<li><p>香櫞 /hion¹ ng⁵/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2038.png\" alt></p>\n</li>\n<li><p>柚 /iu⁷/</p>\n</li>\n<li><p>柑 /gan¹/ 柑橘</p>\n</li>\n<li><p>桔 /gig⁴/</p>\n</li>\n<li><p>橙 /cêng⁵/</p>\n</li>\n<li><p>菠蘿 /bo¹ lo⁵/</p>\n</li>\n<li><p>油甘 /iu⁵ gam¹/ 餘甘果，先苦後甜，齒留餘甘。</p>\n</li>\n<li><p>番茄 /huang¹ gio⁵/</p>\n</li>\n<li><p>青竹梅 /cên¹ dêg⁴ bhoi⁵/</p>\n</li>\n<li><p>李 /li²/</p>\n</li>\n<li><p>棗 /zo²/</p>\n</li>\n<li><p>蔗 /zia³/ 甘蔗</p>\n</li>\n</ol>\n<h3 id=\"🌿草藥-cao²-ioh⁸\"><a href=\"#🌿草藥-cao²-ioh⁸\" class=\"headerlink\" title=\"🌿草藥 /cao² ioh⁸/\"></a>🌿草藥 /cao² ioh⁸/</h3><ol>\n<li><p>艾 /hia³/ 艾草 </p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2039.png\" alt></p>\n</li>\n<li><p>草粿草 /cao² goi² cao²/ 仙草</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2040.png\" alt></p>\n</li>\n<li><p>策草 /cêg⁴ cao²/ 又稱抹(bhuah⁴)草、廣防風、防風草，甲子地區神位常年插此草。策 ，大概是指其像馬鞭。</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2041.png\" alt></p>\n</li>\n<li><p>青菭 /cên¹ ti⁵/ 青苔</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2042.png\" alt></p>\n</li>\n<li><p>薄荷 /bo⁵ ho³/、/bon⁵ hon³/</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2043.png\" alt></p>\n</li>\n<li><p>金銀花 /gim¹ nging⁵ hoi¹/</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2044.png\" alt></p>\n</li>\n<li><p>午時花 /ngao² si⁵ hoi¹/</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2045.png\" alt></p>\n</li>\n<li><p>四季春 /si³ kui³ cung¹/ 四季春花</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2046.png\" alt></p>\n</li>\n<li><p>葉下紅 /hio² ê⁶ ang⁵/ 一點紅</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2047.png\" alt></p>\n</li>\n<li><p>臭草花 /cao³ cao² hoi¹/ 五色梅、馬纓丹</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2048.png\" alt></p>\n</li>\n<li><p>飛天蜈蚣 /boi¹ tin¹ ghê⁵ gang¹/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2049.png\" alt></p>\n</li>\n<li><p>金雞脫殼 /gim¹ goi¹ tug⁴ kag⁴/</p>\n</li>\n<li><p>路跤菊 /lao⁷ ka¹ gêg⁴/ 路邊菊</p>\n</li>\n<li><p>臘裏葉 /lah⁸ li² hioh⁸/ 金邊紅桑</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2050.png\" alt></p>\n</li>\n<li><p>芒囝筍 /mang⁵ gian² sung²/ 芒草的嫩芽</p>\n</li>\n<li><p>竹菜 /dêg⁴ cai³/ 竹葉草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2051.png\" alt></p>\n</li>\n<li><p>葛菜 /guah⁴ cai³/ 野葛菜，可食。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2052.png\" alt></p>\n</li>\n<li><p>烏規菜 /ao¹ gui¹ cai³/ 龍葵</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2053.png\" alt></p>\n</li>\n<li><p>豬母菜 /du¹ bho² cai³/ 馬齒莧</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2054.png\" alt></p>\n</li>\n<li><p>刺莧 /ci³ hain⁷/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2055.png\" alt></p>\n</li>\n<li><p>苦刺 /kao² ci³/ 白簕</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2056.png\" alt></p>\n</li>\n<li><p>苦草 /kao² cao²/ 豨薟草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2057.png\" alt></p>\n</li>\n<li><p>兩公根 /liang² gong¹ ging¹/ 崩大碗</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2058.png\" alt></p>\n</li>\n<li><p>鋪地錦 /pao¹ di⁷ gim²/ 滿天星</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2059.png\" alt></p>\n</li>\n<li><p>雞屎藤 /goi¹ sai² ding⁵/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2060.png\" alt></p>\n</li>\n<li><p>伸筋藤 /cung¹ ging¹ ding⁵/ 蔓九節</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2061.png\" alt></p>\n</li>\n<li><p>無頭藤 /bho⁵ tao⁵ ding⁵/ 寄生於其他植物之上</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2062.png\" alt></p>\n</li>\n<li><p>酒甕囝 /ziu² ang³ gian²/</p>\n</li>\n<li><p>盐酸鸡囝 /iam⁵ sng¹ goi¹ gian²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2063.png\" alt></p>\n</li>\n<li><p>見笑草 /giang³ siao³ cao²/ 含羞草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2064.png\" alt></p>\n</li>\n<li><p>燈籠草 /dêng¹ lang⁵ cao²/ 其果子稱爲「姑娘果」</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2065.png\" alt></p>\n</li>\n<li><p>車前草 /cia¹ zain⁵ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2066.png\" alt></p>\n</li>\n<li><p>馬鞭草 /bhê² bin¹ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2067.png\" alt></p>\n</li>\n<li><p>蟋蟀草 /tig⁴ sug⁴ cao²/ 烏龍草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2068.png\" alt></p>\n</li>\n<li><p>蒲公英 /pu⁵ gong¹ êng¹/</p>\n</li>\n<li><p>鸭舌草 /ah³ zih⁸ cao²/ 苦菜</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2069.png\" alt></p>\n</li>\n<li><p>魚腥草 /hu⁵ co³ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2070.png\" alt></p>\n</li>\n<li><p>益母草 /iah⁴ bho² cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2071.png\" alt></p>\n</li>\n<li><p>龍膽草 /lêng⁵ dan² cao²/ 苦地膽草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2072.png\" alt></p>\n</li>\n<li><p>奶汁草 /nê¹ zab⁴ cao²/ 乳汁草，草折斷會有白色液體流出。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2073.png\" alt></p>\n</li>\n<li><p>虎耳草 /haon² hin⁶ cao³/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2074.png\" alt></p>\n</li>\n<li><p>大號奶汁草 /dua⁷ ho⁷ nê¹ zab⁴ cao³/ 蠔割草、飛揚草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2075.png\" alt></p>\n</li>\n<li><p>貓毛兒 /ngiao¹ mo⁵ ri⁵/ 金絲草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2076.png\" alt></p>\n</li>\n<li><p>貓鬚草 /ngiao¹ ciu¹ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2077.png\" alt></p>\n</li>\n<li><p>鹅囝香 /gho⁵ gian² hiang¹/ 鹅不食草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2078.png\" alt></p>\n</li>\n<li><p>白花蛇舌草 /bêh⁸ hoi¹ zua⁵ zih⁸ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2079.png\" alt></p>\n</li>\n<li><p>白花蟛蜞草 /bêh⁸ hoi¹ pen⁵ ki⁵ cao²/、/bêh⁸ hoi¹ mua⁵ ki⁵ cao²/</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2080.png\" alt></p>\n</li>\n<li><p>四方枝苦楝 /si³ bang¹ gi¹ kao² nai⁷/ 鬼針草</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2081.png\" alt></p>\n</li>\n<li><p>苦楝 /kao² nai⁷/ 苦楝樹</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2082.png\" alt></p>\n</li>\n<li><p>挨礱被哺 /oi⁵ lang⁵ bi⁶ bu⁶/ 磨盤草、磨礱草、挨礱地堵，其果實似磨盤和礱。礱，磨谷農具。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2083.png\" alt></p>\n</li>\n</ol>\n<h3 id=\"🏮時節-si⁵-zoih⁴\"><a href=\"#🏮時節-si⁵-zoih⁴\" class=\"headerlink\" title=\"🏮時節(si⁵ zoih⁴)\"></a>🏮時節(si⁵ zoih⁴)</h3><ol>\n<li>今年 /gim¹ ni⁵/</li>\n<li>舊年 /gu⁷ ni⁵/ 去年</li>\n<li>前年 /zain³ ni⁵/、/zung³ ni⁵/</li>\n<li>下年 /ê⁶ ni⁵/ 明年</li>\n<li>熱天時 /ruah⁸ tin¹ si⁵/ 夏天</li>\n<li>寒天時 /guan⁵ tin¹ si⁵/ 冬天</li>\n<li>凝天時 /ngang⁵ tin¹ si⁵/ 冬天</li>\n<li>春夏秋冬 /cung¹ hê⁶ ciu¹ dang¹/</li>\n<li>老歷 /lao⁶ lê²/ 農曆</li>\n<li>新曆 /sing¹ lê²/ 公曆</li>\n<li>今日 /gim¹ rig⁸/</li>\n<li>明日 /mêng⁵ rig⁸/</li>\n<li>今旦日 /gian² rig⁸/ 今天</li>\n<li>明旦日 /man³ rig⁸/ 明天</li>\n<li>明眠起 /ma³ mng⁵ ki²/ 明天</li>\n<li>昨日 /za¹ rig⁸/</li>\n<li>前日 /zain⁵ rig⁸/、/zoh⁸ rig⁸/</li>\n<li>後日 /ao⁶ rig⁸/</li>\n<li>大前日 /dua⁷ zain⁵ rig⁸/、/dua⁷ zoh⁸ rig⁸/</li>\n<li>大後日 /dua⁷ ao⁶ rig⁸/</li>\n<li>天光 /tin¹ gng¹/ 天亮</li>\n<li>透早 /tao³ za²/ 黎明</li>\n<li>眠起 /mng⁵ ki²/ 早晨</li>\n<li>日時 /rig⁸ si⁷/ 白天</li>\n<li>早晝 /za² dao³/ 上午</li>\n<li>中晝 /dêng¹ dao³/ 中午</li>\n<li>中晝時 /dêng¹ dao³ si⁵/ 中午</li>\n<li>下晝 /ê⁶ dao³/ 下午</li>\n<li>下旰 /ê⁶ gua³/ 下午</li>\n<li>暗頭 /am³ tao⁵/ 傍晚</li>\n<li>暗頭時 /am³ tao⁵ si⁵/ 傍晚</li>\n<li>下昏 /ê⁶ hng⁵/ 晚上</li>\n<li>下昏時 /ê⁶ hng⁵ si⁵/、/êng² si⁵/ 晚上</li>\n<li>下昏囝 /êng² gian²/ 晚上</li>\n<li>暗時 /am³ si⁷/ 晚上</li>\n<li>暝時、夜時 /mê⁵ si⁷/ 晚上</li>\n<li>暝昏、夜昏 /mê⁵ hng⁵/ 晚上</li>\n<li>暝昏時、夜昏時 /mê⁵ hng⁵ si⁵/、/mêng² si⁵/ 晚上</li>\n<li>暝昏囝 /mêng² gian²/ 晚上</li>\n<li>半暝、半夜 /buan³ mê⁵/</li>\n<li>時分秒 /si⁵ hung⁵ miao²/</li>\n<li>個字 /gai⁵ ri⁷/ 五分鐘</li>\n<li>兩個字久 /no⁶ gai⁵ ri⁷ gu²/ 十分鐘</li>\n<li>頭前 /tao⁵ zain⁵/ 之前</li>\n<li>頭陣 /tao⁵ zung⁵/ 剛才</li>\n<li>下 /ê⁶ miag⁸/、/ê⁶ mig⁸/ 剛才</li>\n<li>一頃 /zêg⁸ kuang³/ 一會兒</li>\n<li>一頃頭 /zêg⁸ kuang³ tao⁵/ 一下子</li>\n<li>煞尾 /suah⁴ bhoi²/ 最後</li>\n<li>今 /dan¹/ 現在</li>\n<li>逐日 /dag⁸ rig⁸/ 每天</li>\n<li>逐暝 /dag⁸ mê⁵/ 每晚</li>\n<li>通日 /tang³ rig⁸/ 整天</li>\n<li>半日 /buan³ rig⁸/</li>\n<li>隔日 /gêh⁴ rig⁸/</li>\n<li>隔暝、隔夜 /gêh⁴ mê⁵/</li>\n<li>別日 /bag⁸ rig⁸/ 改天</li>\n<li>即時 /ziag⁴ si⁵/ 立刻、馬上</li>\n<li>平常時 /pêng⁵ sion⁵ si⁵/ 平時</li>\n<li>一日通通 /zêg⁸ rig⁸ tang³ tang³/ 一整天</li>\n<li>七早八早 /cig⁴ za² boih⁴ za²/ 一大早</li>\n<li>七早蒙流 /cig⁴ za² mo⁵ liu⁵/ 一大早</li>\n<li>烏暗天地 /ao¹ am³ tin¹ di¹/ 天昏地暗</li>\n<li>立春 /lib⁸ cung¹/</li>\n<li>雨水 /u² sui²/</li>\n<li>驚蟄 /gêng¹ dêg8/</li>\n<li>春分 /cung¹ hung¹/</li>\n<li>清明 /cêng¹ mêng⁵/</li>\n<li>谷雨 /gog⁴ u²/</li>\n<li>立夏 /lib⁸ hê⁶/</li>\n<li>小滿 /sio² muan²/</li>\n<li>芒種 /mang⁵ zêng²/</li>\n<li>夏至 /hê⁶ zi³/</li>\n<li>小暑 /siao² su²/</li>\n<li>大暑 /dai⁶ su²/</li>\n<li>立秋 /lib⁸ ciu¹/</li>\n<li>處暑 /cu³ su²/</li>\n<li>白露 /bêh⁸ lao⁷/</li>\n<li>秋分 /ciu¹ hung¹/</li>\n<li>寒露 /guan⁵ lao⁷/</li>\n<li>霜降 /sang¹ gang³/</li>\n<li>立冬 /lib⁸ dang¹/</li>\n<li>小雪 /siao² soh⁴/</li>\n<li>大雪 /dai⁶ soh⁴/</li>\n<li>冬至 /dang¹ zi³/</li>\n<li>小寒 /siao² hang⁵/</li>\n<li>大寒 /dai⁶ hang⁵/</li>\n<li>時年八節 /si⁵ ni⁵ boih⁴ zoih⁴/ 一年四季八個節，最早的八節指立春、春分、立夏、夏至、立秋、秋分、立冬和冬至。而在甲子時年八節指元宵、春分、清明、五月節、七月半、秋分、八月半、冬節，過此八節要拜祖，除春分、秋分外的節還需要拜神。<ul>\n<li>四時，四季、春夏秋冬。</li>\n<li>年，甲骨文象人負禾之形，會穀物豐收之意，古時禾穀一年一熟，於是「年」被（引申）用作周年之年。【爾雅•釋天】夏曰歲，商曰祀，周日年，唐虞曰載。古時一度流行歲星（即木星、朱比特星，公轉週期爲 398.88 天）紀年，故一年又稱一歲。</li>\n<li>時年，一年四季。</li>\n<li>節，中國曆法把一年分為二十四段，每段的開始即爲節。早期只有春分、秋分、夏至、冬至四節，後又加入立春、立夏、立秋、立冬，形成八節，再來後逐漸形成了二十四節。「節」早期是天文曆法上的概念，與氣候相關，後又逐漸加入了紀念或慶祝的元素。</li>\n</ul>\n</li>\n<li>元宵節 /nguang⁵ siao¹ zoih⁴/</li>\n<li>公忌節 /gong¹ gi⁷ zoih⁴/ 春分和秋分，祭拜先祖，但不拜神。</li>\n<li>清明節 /cêng¹ mêng⁵ zoih⁴/</li>\n<li>五月節 /ngao⁶ ghoih⁸ zoih⁴/ 端午節</li>\n<li>七月半 /cig⁴ ghoih⁸ buan³/ 中元節、鬼節</li>\n<li>八月半 /boih⁴ ghoih⁸ buan³/ 中秋節</li>\n<li>冬節 /dang¹ zoih⁴/ 冬至節的簡稱。</li>\n<li>廿九暝、廿九夜 /rig⁸ gao² mê⁵/ 除夕（小月）</li>\n<li>三十暝、三十夜 /san¹ zab⁸ mê⁵/ 除夕（大月）</li>\n<li>春節 /cung¹ zoih⁴/</li>\n<li>重陽 /ciang⁵ iang⁵/、/dêng⁵ iang⁵/</li>\n<li>國慶節 /gog⁴ kêng³ zoih⁴/</li>\n<li>勞動節 /lao⁵ dong⁶ zoih⁴/</li>\n<li>婦女節 /hu⁶ nng² zoih⁴/</li>\n<li>兒童節 /ri⁵ tong⁵ zoih⁴/</li>\n<li>教師節 /ga³ su¹ zoih⁴/</li>\n<li>做節 /zo³ zoih⁴/ 過節日</li>\n<li>做壽 /zo³ siu⁶/ 過壽辰</li>\n<li>做生日 /zo³ sên¹ rig⁸/ 過生日</li>\n<li>公忌 /gong¹ gi⁷/ 先祖忌日</li>\n<li>拜公忌 /bai³ gong¹ gi⁷/ 在忌日祭拜先祖</li>\n<li>拜祖 // 祭拜先祖</li>\n<li>拜老爺 // 拜神</li>\n<li>假日 /gia² rig⁸/</li>\n<li>放假 /bang³ gia²/、/bang³ gian²/</li>\n<li>暑假 /su² gia²/</li>\n<li>寒假 /hang⁵ gia²/</li>\n</ol>\n<h3 id=\"🌀天時-tin¹-si⁵\"><a href=\"#🌀天時-tin¹-si⁵\" class=\"headerlink\" title=\"🌀天時(tin¹ si⁵)\"></a>🌀天時(tin¹ si⁵)</h3><ol>\n<li>晴 /zên⁵/ 晴朗</li>\n<li>出日 /cug⁴ rig⁸/ 太陽出來了</li>\n<li>透堂白日 /tao³ dng⁵ bêh⁸ rig⁸/ 大白天</li>\n<li>烏陰天 /ao¹ im¹ tin¹/ 陰天</li>\n<li>透風 /tao³ hong¹/ 刮大風</li>\n<li>風颱 /hong¹ tai¹/ 颱風</li>\n<li>南風天 /nang¹ hong¹ tin¹/ 刮南風，濕氣加重</li>\n<li>轉南風 /dng² nang¹ hong¹/ 南風天來了</li>\n<li>透南風 /tao³ nang¹ hong¹/ 刮南風，伍佰有一 Live 同名。</li>\n<li>蒙煙天 /mong⁵ iang¹ tin¹/ 霧霾天</li>\n<li>落雨 /lo² hao⁶/ 下雨</li>\n<li>一陣雨 /zêg⁸ zung⁵ hao⁶/</li>\n<li>日頭雨 /rig⁸ tao⁵ hao⁶/ 一邊下雨，一邊出太陽</li>\n<li>烏寒雨 /ao¹ guan⁵ hao⁶/ 天時烏陰落寒雨</li>\n<li>爍焰 /sih⁴ iam⁶/ 閃電</li>\n<li>敲雷 /ka³ lui⁵/ 打雷</li>\n<li>冷空氣 /lêng² kong¹ ki⁷/</li>\n<li>落雪 /lo² soh⁴/ 下雪</li>\n<li>落雹 /lo² pag⁸/ 下冰雹</li>\n<li>旱 /uan⁶/ 乾旱</li>\n<li>寒 /guan⁵/ 寒冷</li>\n<li>冷 /lêng²/ 寒冷</li>\n<li>凝 /ngang⁵/ 寒冷</li>\n<li>熱 /ruah⁸/</li>\n<li>翕熱 /hib⁴ ruah⁸/ 悶熱</li>\n<li>乾燥 /gang¹ cao³/</li>\n<li>濕 /sib⁴/ 濕潤</li>\n<li>涼 /liang⁵/ 涼爽</li>\n</ol>\n<h3 id=\"🌛天文-tiang¹-bhung⁵\"><a href=\"#🌛天文-tiang¹-bhung⁵\" class=\"headerlink\" title=\"🌛天文(tiang¹ bhung⁵)\"></a>🌛天文(tiang¹ bhung⁵)</h3><ol>\n<li>天頂 /tin¹ dêng²/ 天上</li>\n<li>日頭 /rig⁸ tao⁵/ 太陽</li>\n<li>蝕日 /sih⁸ rig⁸/ 日食</li>\n<li>狗齧日 /gao² na² rig⁸/ 天狗食日</li>\n<li>西照日 /sai¹ zio³ rig⁸/ 夕陽</li>\n<li>月娘 /ghoih⁸ nion⁵/ 月亮</li>\n<li>月眉 /ghoih⁸ bhai⁵/ 弦月</li>\n<li>蝕月 /sih⁸ ghoih⁸/ 月食</li>\n<li>河溪 /ho⁵ koi¹/ 銀河、天河</li>\n<li>落屎星 /lo² sai² cên¹/ 流星</li>\n<li>星宿 /cên¹ siu³/</li>\n</ol>\n<h3 id=\"⛰️地理-di⁷-li²\"><a href=\"#⛰️地理-di⁷-li²\" class=\"headerlink\" title=\"⛰️地理(di⁷ li²)\"></a>⛰️地理(di⁷ li²)</h3><ol>\n<li>中央 /diong¹ iang¹/ 中間</li>\n<li>內底 /lai⁶ doi²/ 裏面</li>\n<li>外口 /ghua⁷ kao²/、/la¹ kao²/ 外面</li>\n<li>頭頂 /tao⁵ dêng²/ 上面</li>\n<li>下跤 /ê⁶ ka¹/ 下面</li>\n<li>下底 /ê⁶ doi²/ 下面</li>\n<li>正手爿 /ziang³ ciu² bain⁵/ 左邊</li>\n<li>倒手爿 /do³ ciu² bain⁵/ 右邊</li>\n<li>頭前 /tao⁵ zain⁵/ 前面</li>\n<li>後底 /ao⁶ doi²/ 後面</li>\n<li>後壁 /ao⁶ biah⁴/ 後面</li>\n<li>對面 /dui³ ming⁷/</li>\n<li>隔壁 /gêh⁴ biah⁴/</li>\n<li>鄰近 /lim¹ ging⁶/</li>\n<li>塗跤 /tao⁵ ka¹/</li>\n<li>番爿 /huang¹ bain⁵/</li>\n<li>北爿 /bag⁴ bain⁵/</li>\n<li>東南西北 /dang¹ nam⁵ sai¹ bag⁴/</li>\n<li>地盤 /di⁷ buan⁵/</li>\n<li>領域 /nia² oig⁸/</li>\n<li>境內 /gêng² lai⁶/</li>\n<li>世界 /si³ gai³/</li>\n<li>宇宙 /u² diu²/</li>\n<li>全球 /cuang¹ giu⁵/</li>\n<li>天涯 /tiang¹ ngai⁵/</li>\n<li>山頂 /suan¹ dêng²/</li>\n<li>山跤 /suan¹ ka¹/</li>\n<li>外地 /ghua⁷ dê³/</li>\n<li>本地 /bng² di⁷/</li>\n<li>別地 /bag⁸ dê³/ 外地</li>\n<li>別地地 /bag⁸ di⁷ dê³/ 外地</li>\n<li>塗 /tao⁵/ 泥</li>\n<li>塗膏 /tao⁵ go¹/ 泥巴</li>\n<li>石頭 /zioh⁸ tao⁵/</li>\n<li>田園 /cang⁵ hng⁵/</li>\n<li>溪墘 /koi¹ gin⁵/ 溪邊</li>\n<li>草埔 /cao² bao¹/ 草坪</li>\n<li>崎 /gia⁶/ 小山坡</li>\n<li>坑 /kên/ 山谷、溪谷。</li>\n<li>嶺 /nia²/ 有路可通的山頂</li>\n<li>岑 /ngim⁵/、/cam⁵/ 小而高的山</li>\n<li>墟 /hu¹/ 大土山</li>\n<li>壩 /ba³/ 沙灘、沙洲。</li>\n<li>潭 /tam⁵/ 深水池</li>\n<li>溪 /koi¹/</li>\n<li>江 /gang¹/</li>\n<li>河 /ho⁵/</li>\n<li>湖 /ao⁵/</li>\n<li>海 /hai²/</li>\n<li>海拔 /hai² buag⁸/</li>\n<li>洲 /ziu¹/</li>\n<li>港 /gang²/</li>\n<li>灣 /uang¹/</li>\n<li>溝 /gao¹/</li>\n<li>渠 /ku⁵/ 水道，特指人工開的河道。</li>\n<li>浦 /pao²/ 水邊或江河入海處</li>\n<li>澳 /o³/ 海邊彎曲且可停泊船隻的地方</li>\n<li>汕 /suan³/ 河流沖刷或沖刷而積成的沙灘</li>\n<li>汕頭 /suan¹ tao⁵/</li>\n<li>汕尾 /suan³ bhoi²/</li>\n<li>海湧 /hai² êng²/ 海浪。湧，波浪。</li>\n<li>東濠湧 /dang¹ hao⁵ cong¹/ 地名，在廣州越秀。濠，溝渠。湧，河流分叉處。</li>\n<li>湧泉相報 /iong³ zuan⁵ siang¹ bo³/ 湧，水冒出。</li>\n<li>庭、埕 /dian⁵/ 院子、宽阔处</li>\n<li>礦物 /kuang³ moih⁸/</li>\n<li>化石 /hoi³ zioh⁸/</li>\n<li>原油 /nguang¹ iu⁵/</li>\n<li>燃料 /riang⁵ liao⁷/</li>\n<li>金屬 /gim¹ siog⁸/</li>\n<li>金銀財寶 /gim¹ nging⁵ cai⁵ bo²/</li>\n<li>鋼鐵 /gng³ tih⁴/</li>\n<li>蘇打 /so³ da²/ 英文 soda 的音譯，常指小蘇打，即碳酸氫鈉。</li>\n<li>蘇州 /sao¹ ziu¹/</li>\n<li>蠟 /la²/</li>\n<li>硫磺 /liu⁵ ng⁵/</li>\n<li>砒霜 /bi¹ sng¹/</li>\n<li>砂石 /sua¹ zioh⁸/</li>\n<li>大理石 /dai⁶ li² zioh⁸/</li>\n<li>碳 /tuan³/</li>\n<li>水銀 /zui² nging⁵/</li>\n<li>水龍水 /zui² lêng⁵ zui²/ 自來水</li>\n<li>地牛換肩 /di⁷ ghu⁵ uang⁷ gain¹/ 地震</li>\n<li>許婆寮 /kao² pua⁵ liao⁵/ 今可和村</li>\n<li>北輋 /bag⁴ sia⁵/ 今博社村</li>\n<li>四捻石 /si³ niam³ zio²/ 四片石</li>\n<li>甲子八景：六十甲子欄、潮來人字水、雙帆跨海島、五馬渡江邊、仙人踏石積、海甲蓮花山、西峯古寺、雷廟天堂。（《陸豐縣誌》卷之二疆域四 P21）</li>\n<li>擎天石：位於甲秀書院的側邊的一塊巨石。《陸豐縣誌》記載：在甲子所北門內峙立聳拔高出雉堞丈余，中開一痕，俗謂雷打石。胡文烜銘其上曰：「天開甲子，巨石臨門，一聲霹靂，振動乾坤 ……」。字大如鬥，余銘苔蝕莫辨。（《陸豐縣誌》卷之二古蹟十二 ）</li>\n<li>甲秀書院：甲秀書院位於陸豐縣甲子鎮北門內。甲秀書院建於明代，歷來為粵東文人會萃講學之所。至今院內仍保存著不少歷代的石碑石刻。解放后，人民政府在此興辦中學。</li>\n<li>福源寺：座落於甲子鎮北郊雨亭路，原名「復元寺」，又稱「蓮花山草庵」。據傳，福源寺建於宋代。因歷史久遠，原址僅遺存牆基。1990年由光茂法師主持重建。經過10多年的建造，先後建成天王殿、大雄寶殿、觀音殿、地藏殿、鐘樓、鼓樓和禪房等，重塑了諸位菩薩聖像。寺區佔地面積1.2萬多平方米，建築面積3000多平方米。</li>\n<li>南海夫人廟：位於甲子鎮城西社區環城路東。明萬曆元年（1573），李棠中舉後爲其妻卓氏而建的紀念祠，御史鄧練題匾「南海夫人」，故稱南海夫人廟。</li>\n<li>烈士墓</li>\n</ol>\n<h3 id=\"📐計量-goi³-liang⁶\"><a href=\"#📐計量-goi³-liang⁶\" class=\"headerlink\" title=\"📐計量(goi³ liang⁶)\"></a>📐計量(goi³ liang⁶)</h3><ol>\n<li>〇、零 /lêng⁵/、/lang⁵/</li>\n<li>一、壹 /zêg⁸/、/ig⁴/</li>\n<li>二、贰 /no⁶/、/ri⁶/</li>\n<li>三、叁 /san¹/、/sam¹/</li>\n<li>四、肆 /si³/、/su³/</li>\n<li>五、伍 /ngao⁶/、/u²/</li>\n<li>六、陆 /lag⁸/</li>\n<li>七、柒 /cig⁴/</li>\n<li>八、捌 /boih⁴/、/bag⁴/</li>\n<li>九、玖 /gao²/、/giu²/</li>\n<li>十、拾 /zab⁸/</li>\n<li>百、佰 /bêh⁴/</li>\n<li>千、仟 /cain¹/、/ciang¹/</li>\n<li>萬 /mang⁷/</li>\n<li>億 /êg⁸/</li>\n<li>一二個 /zêg⁸ no² gai⁵/</li>\n<li>二十六 /ri⁸ ab⁸ lag⁸/、/ri⁸ zab⁸ lag⁸/</li>\n<li>廿六號 /rig⁸ lag⁸ ho⁷/ 二十六號</li>\n<li>五十外個 /ngao⁶ zab⁸ ghua⁷ gai⁵/</li>\n<li>一百空八 /zêg⁸ bêh⁴ kang³ boih⁴/ 一百零八</li>\n<li>第一 /doi⁷ ig⁴/</li>\n<li>第二 /doi⁷ ri⁶/</li>\n<li>第三 /doi⁷ san¹/</li>\n<li>一個人 /zêg⁸ gai⁵ nang⁵/</li>\n<li>一爿花 /zêg⁸ bain⁵ hoi¹/ 一片花瓣</li>\n<li>一蕊花 /zêg⁸ lui² hoi¹/ 一朵花</li>\n<li>一葩花 /zêg⁸ pa¹ hoi¹/ 一朵花</li>\n<li>一枝花 /zêg⁸ gi¹ hoi¹/</li>\n<li>一縛花 /zêg⁸ ba² hoi¹/ 一束花</li>\n<li>一叢樹 /zêg⁸ zang⁵ hoi¹/ 一棵樹</li>\n<li>一簇頭毛 /zêg⁸ cog⁴ tao⁵ mo⁵/ 一撮頭髮</li>\n<li>一粒糖 /zêg⁸ liab⁸ tng⁵/</li>\n<li>一隻車 /zêg⁸ ziah⁴ cia¹/ 一輛車</li>\n<li>一架車 /zêg⁸ gê³ cia¹/ 一輛車</li>\n<li>一杯茶 /zêg⁸ boi¹ dê⁵/</li>\n<li>一碗水 /zêg⁸ uan² zui²/</li>\n<li>一喙水、一嘴水 /zêg⁸ cui³ zui²/ 一口水</li>\n<li>一條弓蕉 /zêg⁸ diao⁵ gêng¹ zio¹/ 一條香蕉</li>\n<li>一本書 /zêg⁸ bng² zu¹/</li>\n<li>一枝手機 /zêg⁸ gi¹ ciu² gi¹/ 一隻手機</li>\n<li>一枝鎖匙 /zêg⁸ gi¹ so² si⁵/ 一把鑰匙</li>\n<li>一個銀 /zêg⁸ gai⁵ nging⁵/ 一塊錢</li>\n<li>一領被 /zêg⁸ nia² poi⁶/ 一席被子</li>\n<li>一個鋪 /zêg⁸ gai⁵ pao¹/ 一張床</li>\n<li>一個鐘頭 /zêg⁸ gai⁵ zêng¹ tao⁵/ 一個小時</li>\n<li>一副衫褲 /zêg⁸ hu³ san¹ kao³/ 一套衣服</li>\n<li>一腰裙 /zêg⁸ io¹ gung⁵/ 一件裙子</li>\n<li>一尾魚 /zêg⁸ bhoi² hu⁵/ 一條魚</li>\n<li>一墩物件 /zêg⁸ dung¹ mi² gian⁶/ 一堆東西</li>\n<li>一橛蔗 /zêg⁸ goi² zia³/ 一截甘蔗</li>\n<li>一葩電火 /zêg⁸ pa¹ diang⁶ hoi²/ 一盞電燈</li>\n<li>一跤箸、一腳箸 /zêg⁸ ka¹ du⁷/ 一隻筷子</li>\n<li>一雙箸 /zêg⁸ sang¹ du⁷/ 一雙筷子</li>\n<li>一腹火 /zêg⁸ bag⁴ hoi²/ 一肚子火</li>\n<li>一脬屎 /zêg⁸ bu⁵ sai²/ 一坨屎</li>\n<li>一脬尿 /zêg⁸ bu⁵ rio⁷/ 一泡尿</li>\n<li>一逝路 /zêg⁸ zua⁷ lao⁷/ 一趟路</li>\n<li>一丸塗 /zêg⁸ uang⁵ tao⁵/ 一團泥土</li>\n<li>一過 /zêg⁸ goi³/ 一次</li>\n</ol>\n<h3 id=\"🧭-指代-zi²-toi³\"><a href=\"#🧭-指代-zi²-toi³\" class=\"headerlink\" title=\"🧭 指代(zi² toi³)\"></a>🧭 指代(zi² toi³)</h3><ol>\n<li>只 /zi²/ 這，近指。</li>\n<li>許 /hi²/ 那，遠指。</li>\n<li>者、這 /zê²/、/zia²/ 這，近指。</li>\n<li>遐 /hê²/、/hia²/ 那，遠指。</li>\n<li>底個 /di⁷ gai⁵/ 哪個</li>\n<li>者個 /zê² gai⁷/、/zia² gai⁷/ 這個</li>\n<li>遐個 /hê² gai⁷/、/hia² gai⁷/ 那個</li>\n<li>怎樣 /za³ ion⁷/、/zion²/</li>\n<li>乜樣 /mig⁴ ion⁷/ 怎樣</li>\n<li>底樣 /di⁷ ion⁷/ 怎樣</li>\n<li>怎生 /za³ sên¹/、/zai¹ sên¹/怎樣</li>\n<li>怎樣生 /zion² sên¹/ 怎樣</li>\n<li>怎樣然 /zion² ni⁵/、/zo⁵ ni⁵/ 怎麼、幹啥</li>\n<li>怎樣麼 /zion² mo⁷/、/ziom²/</li>\n<li>者樣 /zê² ion⁷/、/zion¹/</li>\n<li>遐樣 /hê² ion⁷/、/hion¹/</li>\n<li>者樣生 /zion¹ sên¹/ 這樣</li>\n<li>遐樣生 /hion¹ sên¹/ 那樣</li>\n<li>底搭 /di⁷ dah⁴/ 哪裏</li>\n<li>者搭 /zê² dah⁴/ 這裏</li>\n<li>遐搭 /hê² dah⁴/ 那裏</li>\n<li>底地 /di⁷ dê³/ 哪裏</li>\n<li>者地方 /zê² ding¹/ 這裏</li>\n<li>遐地方 /hê² ding¹/ 那裏</li>\n<li>底囝 /di⁷ gian²/ 哪兒</li>\n<li>者囝 /zê gian²/ 這兒</li>\n<li>遐囝 /hê² gian²/ 那兒</li>\n<li>底人 /di⁷ nang⁵/、/diang⁶/、/di⁷ diang⁶/ 誰</li>\n<li>底位 /di⁷ ui⁷/ 哪位</li>\n<li>者位 /zê² ui⁷/</li>\n<li>遐位 /hê² ui⁷/ 那位</li>\n<li>底時 /di⁷ si⁵/ 什麼時候</li>\n<li>底當時 /diang⁶ si⁵/ 什麼時候</li>\n<li>者時 /zê² si⁵/</li>\n<li>遐時 /hê² si⁵/ 那時</li>\n<li>乜事 /mig⁴ su⁷/ 什麼事情</li>\n<li>若㩼 /rioh⁸ zoi⁷/、/rua⁷ zoi⁷/ 多少</li>\n<li>幾 /gui²/</li>\n<li>豈是 /ka³ si⁷/ 是否是</li>\n<li>敢是 /gam² si⁷/ 是否是</li>\n</ol>\n<h3 id=\"🏃‍♀️動詞-dong⁶-su⁵\"><a href=\"#🏃‍♀️動詞-dong⁶-su⁵\" class=\"headerlink\" title=\"🏃‍♀️動詞(dong⁶ su⁵)\"></a>🏃‍♀️動詞(dong⁶ su⁵)</h3><p><strong>第一部分</strong></p>\n<ol>\n<li>會 /oi⁶/</li>\n<li>無會、袂、𠀾 /bhoi⁶/ 不會</li>\n<li>未 /bhoi⁷/ 沒有（事情還沒做）</li>\n<li>無 /bho⁵/ 沒有</li>\n<li>有 /u⁶/</li>\n<li>好 /ho²/</li>\n<li>毋好、孬 /mo²/ 不好</li>\n<li>欲 /bhêh⁴/ 要</li>\n<li>毋、唔 /m⁶/ 不要</li>\n<li>欲毋 /bhêh⁴ m⁶/、/bhên⁶/ 要不要</li>\n<li>愛 /ain³/ 要</li>\n<li>無愛 /bho⁵ ain³/ 不要</li>\n<li>毋愛、勿、嫑 /main³/ 不要</li>\n<li>用 /êng⁶/ 需要</li>\n<li>免 /miang²/ 不需要</li>\n<li>肯 /kêng²/、/kiang²/ 願意</li>\n<li>毋肯 /m⁶ kêng²/、/m⁶ kiang²/ 不願意</li>\n<li>架勢是 /gê³ si³ si⁷/ 看這情形是。例如：舖關了，架勢是去做節了。 </li>\n</ol>\n<p><strong>第二部分 頭、喙</strong></p>\n<ol>\n<li>dag⁴ 頭 // 點頭</li>\n<li>搖頭 /io⁵ tao⁵/</li>\n<li>攲頭 /ki¹ tao⁵/ 歪頭</li>\n<li>呾 /dan³/ 說</li>\n<li>參詳 // 商量</li>\n<li>學古 /oh⁴ gao²/ 講故事</li>\n<li>罵 /mê⁷/</li>\n<li>詏 /a³/ 爭辯</li>\n<li>冤家 /uang¹ gê¹/ 吵架</li>\n<li>恬 /diam⁷/ 閉嘴、安靜</li>\n<li>咬 /ga⁶/</li>\n<li>哺 /bao⁷/ 咀嚼</li>\n<li>唵 /am⁶/ 將食物放進嘴巴</li>\n<li>喷 /pung³/ 散射</li>\n<li>啡痰 /pui³ tam⁵/ 吐痰</li>\n<li>歕 /bung⁵/ 吹氣</li>\n<li>嗾？ /zag⁸/ 呛到、岔到 </li>\n</ol>\n<p><strong>第三部分 目、心</strong></p>\n<ol>\n<li>睇 /toi²/ 看</li>\n<li>看詳睇 /kang³ siang⁵ toi²/ 仔細看</li>\n<li>經心 /gêng¹ sim¹/ 用心</li>\n<li>經心衋事 // 操心</li>\n<li>經破頭腦 // 想破頭 </li>\n</ol>\n<p><strong>第四部分 手、跤</strong></p>\n<ol>\n<li>揨 /dian¹/ 觸、碰</li>\n<li>拍 /pah⁴/ 打</li>\n<li>舂 /cêng⁵/ 用力打</li>\n<li>/dng⁷/ 打</li>\n<li>刜 /hug⁴/ 揮、打</li>\n<li>剚、倳 /sai⁷/ 打</li>\n<li>抶 /diag⁴/ 用鞭、杖或竹板打。～手</li>\n<li>摔 /sug⁴/ 抽打、鞭打</li>\n<li>拗折 /a² zi²/ 折斷</li>\n<li>盖 /kain³/ 由上往下覆。～頭</li>\n<li>掃 /sao³/ 迅速掠過。～面</li>\n<li>揞 /an¹/ 掩。～面</li>\n<li>diu³ 竹囝</li>\n<li>擎 /gia⁵/ 舉、握、拿</li>\n<li>𢭪 /kioh⁴/ 撿、拾</li>\n<li>挈 /kioh⁸/ 取、拿</li>\n<li>摜 /guan⁶/ 提</li>\n<li>厾 /doh⁴/ 戳</li>\n<li>割 /guah⁴/</li>\n<li>殺 /suah⁴/</li>\n<li>斬 /zam²/</li>\n<li>斫 /dog⁴/ 剁</li>\n<li>宰 /zai²/ 殺</li>\n<li>刣 /tai⁵/ 殺</li>\n<li>拭 /cig⁴/ 擦</li>\n<li>濡 /ru⁵/ 用濕布擦或用拖把拖</li>\n<li>爬 /bê⁵/ 搔(癢)</li>\n<li>掊 /boi²/ 扒開</li>\n<li>揂 /ciu⁵/ 拉引繩子</li>\n<li>𠡒 /dui²/ 用力拉</li>\n<li>捏 /dên⁶/ 掐</li>\n<li>漱牙 /ciu³ ghê⁵/ 刷牙</li>\n<li>跋 /buah⁸/ 摔倒</li>\n<li>踏 /dah⁴/ 踩</li>\n<li>踢 /tag⁴/</li>\n<li>去 /ku³/、/ka³/</li>\n<li>轉 /dng²/ 回來</li>\n<li>綴 /doi³/ 跟著；縫合。</li>\n<li>修理 /siu¹ li²/、/su¹ li²/</li>\n<li>泊車 /pag⁴ cia¹/ 停車。泊，粵語音譯英文 park 得來，停車的意思。</li>\n</ol>\n<p><strong>第五部分</strong></p>\n<ol>\n<li>曳、𤆬 /cua⁷/ 帶、領</li>\n<li>娶 /cua⁷/ 取婦</li>\n<li>徙 /sua²/ 移動</li>\n<li>歇 /hiah⁴/ 放置、休息</li>\n<li>煩惱 /huang⁵ lo²/ 擔心</li>\n<li>相信 /sion¹ siang³/、/siang¹ sing⁷/ 相信</li>\n<li>相輔 /sion³ hu⁶/ 幫忙</li>\n<li>排比 /bai⁵ bi²/ 安排</li>\n<li>含包 /ham⁵ bao¹/ 包含</li>\n<li>拚頭前 /bian³ tao⁵ zain⁵/ 爭先</li>\n<li>輸服 /su¹ hog⁸/ 佩服</li>\n<li>䷀䷀ /dag⁴ nng⁷/ 浪費</li>\n<li>䷀落 /ga¹ lao⁵/ 掉落</li>\n<li>沕 /bhih⁴/ 躲藏</li>\n<li>支 /zin¹/ 預付</li>\n<li>圖賴 /tu⁵ tai²/ 耍賴</li>\n<li>放惰 /bang¹ dua⁶/ 懶得</li>\n</ol>\n<h3 id=\"🧜‍♀️形容-heng⁵-iong⁵\"><a href=\"#🧜‍♀️形容-heng⁵-iong⁵\" class=\"headerlink\" title=\"🧜‍♀️形容(hêng⁵ iong⁵)\"></a>🧜‍♀️形容(hêng⁵ iong⁵)</h3><ol>\n<li>媠 /sui²/ 好、漂亮</li>\n<li>雅 /ngia²/ 正、漂亮</li>\n<li>生好 /sên¹ ho²/ 漂亮、好看</li>\n<li>䆀 /bhai²/ 差、醜陋</li>\n<li>好 /ho²/</li>\n<li>痞、歹 /pai²/</li>\n<li>大細 /dua⁷ soi³/ 大小</li>\n<li>㩼少 /zoi⁷ zio²/ 多少</li>\n<li>加加減減 /gê¹ gê¹ giam² giam²/ 多多少少</li>\n<li>稀罕 // 稀少，罕見。</li>\n<li>賤 /la¹ zuan⁷/ 繁多，低賤。物以稀為貴，多則賤。</li>\n<li>猛慢 /mê² mang⁷/ 快慢、早晚。猛，快。</li>\n<li>肥 /bui⁵/ 胖</li>\n<li>肥腯肥腯 /bui⁵ tuh⁸ bui⁵ tuh⁸/ 胖嘟嘟</li>\n<li>㾪 /sang²/ 瘦</li>\n<li>㾪猴 /sang² gao⁵/ 瘦得跟猴子一樣</li>\n<li>㾪脯皺 /sang² bao² niao³/ 又瘦又缺水又褶皺，形容飢瘦。</li>\n<li>懸下 /guai⁵/ 高低</li>\n<li>早 /za²/</li>\n<li>晏 /uang³/ 晚</li>\n<li>粗 /cao¹/</li>\n<li>幼 /iun³/ 細</li>\n<li>粗殘 /cao¹ cang⁵/ 粗魯</li>\n<li>仔細 /zu² soi⁷/ 小心</li>\n<li>芳 /pang¹/ 香</li>\n<li>臭 /cao³/</li>\n<li>僫 /oh⁴/ 困難</li>\n<li>易 /goi⁷/ 容易</li>\n<li>闊 /kuah⁴/ 寬</li>\n<li>狹 /oih⁸/ 窄</li>\n<li>光 /gng¹/ 亮</li>\n<li>暗 /am³/</li>\n<li>恬 /diam⁷/ 安靜</li>\n<li>吵 /cao¹/ 吵鬧</li>\n<li>吵吵著 /cao¹ cao¹ dioh⁴/ 吵吵鬧鬧的</li>\n<li>飽 /ba²/</li>\n<li>枵 /iao¹/ 餓</li>\n<li>橂 /dain⁷/ 堅實、堅硬</li>\n<li>軟 /nam³/ 軟弱。本字不明，訓用「軟」。</li>\n<li>韌 /rung⁷/ 堅強；不容易斷裂。</li>\n<li>脆 /cê³/ 脆弱；容易斷裂。</li>\n<li>聰明 /cong¹ mêng⁵/</li>\n<li>愚蠢 /ngo⁵ cung²/</li>\n<li>戇 /gong³/ 愚笨</li>\n<li>賰 /cung⁵/ 剩餘</li>\n<li>欠 /kiam³/ 缺少</li>\n<li>清 // 清晰、乾淨</li>\n<li>雾 /bhu⁷/ 模糊</li>\n<li>清氣 /cêng¹ ki³/ 乾淨</li>\n<li>清氣相 /cêng¹ ki³ sion³/ 乾淨的樣子</li>\n<li>垃圾 /lah⁴ sab⁴/ 骯臟</li>\n<li>垃圾相 /lah⁴ sab⁴ sion³/ 骯臟的樣子</li>\n<li>無沙無圾 /bho⁵ sua¹ bho⁵ sab⁴/ 一塵不染</li>\n<li>灱 /da¹/ 乾燥</li>\n<li>㴷 /dam⁵/ 濕潤</li>\n<li>落雨㴷渧 /lo² hao⁶ dam⁵ di³/ 下雨濕漉漉的樣子</li>\n<li>著 /dioh⁸/ 對、正確</li>\n<li>毋著 /m⁷ dioh⁸/ 不對</li>\n<li>錯 /co³/</li>\n<li>熟 /sêg⁸/</li>\n<li>生 /cên¹/ (瓜果等)未成熟</li>\n<li>臭生 /cao³ cên¹/ 未煮熟或瓜果未成熟</li>\n<li>臭酸 /cao³ sng¹/ 食物變質</li>\n<li>黐黐 /ti¹ ti¹/ 黏稠</li>\n<li>切要 /ciag⁴ iao³/ 要緊</li>\n<li>無要緊 /bho⁵ iao³ ging²/ 不要緊</li>\n<li>大扮</li>\n<li>咸澀</li>\n<li>力相 // 努力</li>\n<li>惰 /duan⁶/ 懶惰</li>\n<li>鬧熱 /nao⁶ ria²/ 熱鬧</li>\n<li>活神 // 精神好，灵活</li>\n<li>健 /gian⁷/ 身體好</li>\n<li>碩㦙 /sêg⁴ ngo³/ 聰明和愚蠢</li>\n<li>夠力 /gao³ lag⁸/ 厲害</li>\n<li>夠強 /gao³ kiang³/ 厲害</li>\n<li>夠衰 /gao³ soi¹/ 好慘</li>\n<li>緊要 /ging² iao³/ 要緊</li>\n<li>切要 /ciag⁴ iao³/ 要緊</li>\n<li>癩瘑糜烂 //</li>\n<li>枝毛小節、枝毛細節 // 無關緊要</li>\n<li>偪側 /bêg⁴ cêg⁴/ 心中有氣，煩躁不安。</li>\n<li>生分 /cên¹ hung⁷/ 陌生、疏遠</li>\n<li>無影無跡 // 沒有根據</li>\n<li>一生跪跋 /zêg⁸ sên¹ gui⁶ buah⁸/ 一生坎坷</li>\n</ol>\n<h3 id=\"🐴副詞-hu³-su⁵\"><a href=\"#🐴副詞-hu³-su⁵\" class=\"headerlink\" title=\"🐴副詞(hu³ su⁵)\"></a>🐴副詞(hu³ su⁵)</h3><ol>\n<li>好 /hoh⁴/ 表示程度深。例如：好㩼人 // 好多人。</li>\n<li>死 /si²/ 表示程度特別深。例如：死㩼人 // 超級多人。死雅 // 超漂亮的。</li>\n<li>若 /rua⁷/ 多麼。例如：若雅 // 多麼漂亮。</li>\n<li>者 /zia²/ 這麼。例如：者細 // 這麼小。</li>\n<li>遐 /hia²/ 那麼。例如：遐好 // 那麼好。</li>\n<li>上好 /siang⁶ ho²/ 最好。</li>\n<li>上減 /siang⁶ giam²/ 最少。</li>\n<li>上加 /siang⁶ gê¹/ 最多。</li>\n<li>較 /ga³/ 比較地。例如：伊較厲害 // 他比較厲害。</li>\n<li>曾 /bhah⁴/ 曾經。例如：我毋曾來過 // 我不曾來過。</li>\n<li>攏總 /long² zong²/ 全部。例如：攏總 100 銀 // 總共 100 塊。</li>\n<li>煞 /sua⁵/ 竟然。例如：汝煞毋知 // 你竟然不知道。</li>\n<li>顛倒 /ding¹ do³/ 反而。例如：六月顛倒來落雪 // 六月反而下起雪。</li>\n<li>做蜀 /zo³ zêg⁸/ 一起。例如：做蜀 ka³ // 一起去。</li>\n</ol>\n<h3 id=\"😲象聲詞-siang⁶-sian¹-su⁵\"><a href=\"#😲象聲詞-siang⁶-sian¹-su⁵\" class=\"headerlink\" title=\"😲象聲詞(siang⁶ sian¹ su⁵)\"></a>😲象聲詞(siang⁶ sian¹ su⁵)</h3><ol>\n<li>喏 /no⁷/ 使人注意某物</li>\n<li>囉、咯 /lo⁷/ 表示事情完成</li>\n<li>/hoin⁷/ 呼人</li>\n<li>/oin⁷/ 應人</li>\n<li>喂 /uê⁷/ 打招呼。</li>\n<li>啊 /a⁷/ 加強語氣</li>\n<li>呀 /ia⁷/ 表示贊同</li>\n<li>喔、噢 /o⁷/ 表示醒悟、驚訝或了解</li>\n<li>哇 /ua⁷/ 表示驚訝</li>\n<li>嗯 /ng⁷/ 表示同意或了解</li>\n<li>哼 /hng²/ 表示不滿</li>\n<li>哎、噯 /ai⁷/ 嘆氣</li>\n<li>嗐 /hai⁷/ 嘆氣，比「哎」重些。</li>\n<li>/ho⁷～/、/o⁷～/ 長吁，含有一種無力、操碎了心的感覺。</li>\n</ol>\n<h3 id=\"🙃俗語-siog⁸-ngo²\"><a href=\"#🙃俗語-siog⁸-ngo²\" class=\"headerlink\" title=\"🙃俗語(siog⁸ ngo²)\"></a>🙃俗語(siog⁸ ngo²)</h3><ol>\n<li>哇浪、我卵 /ua² lang⁶/ 哇噻</li>\n<li>我無閒 /ua² bho⁵ ain⁵/ 我沒空</li>\n<li>走街邊 /zao² goi¹ bin¹/ 擺地攤</li>\n<li>汝愛去怎樣麼緊 /lu² ain³ ku³ zion² mo⁷ ging⁷/ 你趕著去幹嗎</li>\n<li>勿者樣生 /mai³ zion¹ sên¹/ 不要這樣</li>\n<li>知收煞 /zai¹ siu¹ suah⁴/ 適時停手</li>\n<li>毋別世代 /m⁶ bhag⁴ si³ dê³/ 不懂事</li>\n<li>無變 /bho⁵ biang³/ 沒有辦法</li>\n<li>堵著無變 /du² dioh⁴ bho⁵ biang³/ 碰到沒有辦法</li>\n<li>無理路 /bho⁵ li² lao⁷/ 無道理。路，道。</li>\n<li>無奈何 /bho⁵ da¹ ua⁵/ 無可奈何</li>\n<li>無奈寫作不得已 /bho⁵ nai⁶ sia² zo³ bug⁴ dêg⁴ in²/ </li>\n<li>呾死無會變 /dan⁵ si² bhoi⁶ bin³/ 冥頑不靈</li>\n<li>橂過石部 /dain⁷ goi³ zio² bao⁶/ 比石頭還硬</li>\n<li>三斗油麻倒無一粒落耳 /san¹ dao² iu⁵ mua⁵ do³ bho⁵ zêg⁸ liab⁴ lo² hin⁶/ 怎麼說都聽不進去</li>\n<li>瀉衰人 /sia³ soi¹ nang⁵/ 丟人、令人蒙羞</li>\n<li>見笑 /giang³ siao³/ 丟人、令人蒙羞</li>\n<li>雙目囥著褲底 /sang¹ mag⁸ kng³ dioh⁴ kao³ doi²/ 看不見</li>\n<li>無目睇 /bho⁵ mag⁸ toin³/ 不想看</li>\n<li>鴨囝聽雷 /ah⁴ gian² tian¹ lui⁵/ 聽不懂</li>\n<li>戅過隻鴨 /gong⁵ goi³ ziah⁴ ah⁴/ 比鴨子還戇</li>\n<li>一樣糜飯飼千外樣人 /zêg⁸ ion⁷ moi⁵ bng⁷ ci⁷ cain¹ ghua⁷ ion⁷ nang⁵/ 社會人各種各樣</li>\n<li>暗過魂宫 /am³ goi³ hung⁵ gêng¹/ 比陰間還暗</li>\n<li>三更想，半暝反 /san¹ gên¹ sion⁶, buan³ mê⁵ huang²/ 思來想去，反反覆覆。</li>\n<li>過跤事知歇 /goi¹ ka¹ su⁷ zai¹ hiah⁴/ 過去的事情就不要計較了</li>\n<li>無會少禮 /bhoi⁶ siao² li²/ 不害臊</li>\n<li>刣雞教猴 /tai⁵ goi¹ ga³ gao⁵/ 殺雞儆猴</li>\n<li>勞生拚死 /lu⁵ sên¹ bian³ si²/ 拚死拚活</li>\n<li>食呾會，躕人強 /ziah⁸ dan³ oi⁶, du⁵ nang⁵ kiang³/ 能吃會說還很頑皮</li>\n<li>勿踟躕我 /mai³ di¹ du⁵ ua⁷/ 別纏我，使得我不知所措。</li>\n<li>老過伯爺 /lao⁶ goi³ bêh⁴ ia⁵/ 比土地公還年長</li>\n<li>平樣平樣 /pên⁵ ion⁷ pên⁵ ion⁷/ 一模一樣</li>\n<li>假力洗茶渣 /gê² lag⁸ soi² dê⁵ za¹/ 該做的不做，做了不該做的。</li>\n<li>死無命凝 /si² bho⁵ mian⁷ ngang⁵/ 冷死了</li>\n<li>富到流油 /bu⁷ gao³ lao⁵ iu⁵/ 很富有</li>\n<li>人熟禮毋熟 /nang⁵ sêg⁸ li² m⁶ sêg⁸/ 雖然人很熟，但還是要講禮。</li>\n<li>熟人免行生禮 /sêg⁸ nang⁵ miang² gian⁵ cên¹ loi²/</li>\n<li>千人千般苦，無人苦平樣 /cain¹ nang⁵ cain¹ buan¹ kao², bho⁵ nang⁷ kao² pên⁵ ion⁷/ 各有各的煩惱</li>\n<li>蟹有橂奅，人有碩㦙 /hoi⁶ u⁶ dain⁷ pan³, nang⁵ u⁶ sêg⁴ nga³/ 有人聰明有人愚笨。橂，堅實。奅，中空。碩，學問高、聰明。㦙，愚笨。</li>\n<li>鳥飛會落毛，人行有跤跡 /ziao² boi¹ oi⁶ lo² mo⁵, nang⁵ gian⁵ u⁶ ka¹ ziah⁴/ 做過了的事總會留痕跡</li>\n<li>客情好過吊頷鬼 /kêh⁴ cêng⁵ ho² goi³ diao³ am⁶ gui²/ 吊死鬼熱情地勸人上吊好代替自己，比喻虛情假意。</li>\n<li>貓兒無葷無著茨，鴨囝無粟無會過暝 /ngiao¹ ri⁵ bho⁵ hung¹ bho⁵ dioh⁴ cu⁷, ah⁴ gian² bho⁵ cêg⁴ bhoi⁶ goi³ mê⁵/ 小貓沒有葷菜就不在家，小鴨沒有稻粒就不過夜。</li>\n<li>衰雞無會食粟 /soi¹ goi¹ bhoi⁶ ziah⁸ cêg⁴/ 如病雞般吃不下飯</li>\n<li>無會死大破相 /bhoi⁶ si² dua⁷ pua³ sion³/ 不死也會頭破血流</li>\n<li>十八棚頭做到透 /zab⁸ boih⁴ bên⁵ tao⁵ zo³ gao³ tao³/ 指每種事都嘗試，貶義。十八棚頭，指十八齣溫州南戲。</li>\n<li>無跤蟹 /bho⁵ ga¹ hoi⁶/ 孤立無援</li>\n<li>大細目 /dua⁷ soi³ mag⁸/ 偏心</li>\n<li>平安當大趁 /pêng⁵ ang¹ dng¹ dua⁷ tang⁷/ 平安無疾就當作是大賺一筆了</li>\n<li>大人彎，孥囝直 /dua⁷ nang⁷ uain¹, nao⁵ gian² dig⁸/ 大人說話拐彎抹角，小孩子則是直來直去。</li>\n<li>錢囝毋使使大錢 /zin⁵ gian² m⁶ sai² sai² dua⁷ zin⁵/ 小錢不花，久了就得要花大錢了。</li>\n<li>未學行，先學飛 /bhoi⁷ oh⁸ gian², sain¹ oh⁸ boi¹/ 還沒學走路就要學飛了，基礎未打好。</li>\n<li>一人主張，毋如二人參詳 /zêg⁸ nang⁷ zu² ziang¹, m⁶ ru⁵ no⁶ nang⁷ cam¹ ciang⁵/ 自作主張不如多個人一起商量</li>\n<li>通街市獵無 /tong¹ goi¹ ci⁶ lah⁸ bho⁵/ 整條街都找不到。獵，尋找。</li>\n<li>喙尖舌囝利 /cui³ ziamvi/ 牙尖嘴利</li>\n<li>九月狗吶日，無用諸娘理毋直 /gao² goi² gao² nah⁴ rig⁸, bho⁵ êng⁷ zu¹ nion⁵ li² m⁶ dig⁸/ 九月份開始晝短夜長，沒用的婦女家務事搞不定了。</li>\n<li>茶薄人情厚，茶厚有禮貌 /dê⁵ bo² nang⁵ cêng⁵ gao⁶, dê⁵ gao⁶ u⁶ li² mao⁶/</li>\n<li>三十歲無妻是孩童 /san¹ zab⁸ hoi³ bho⁵ ci¹ si⁶ hai⁵ tong⁵/</li>\n<li>目汁是財，愈哭愈來 /mag⁸ zab⁴ si⁶ cai⁵, ru² kao³ ru⁶ lai⁵/</li>\n<li>呾破無酒食 /dan³ pua³ bho⁵ ziu² ziah⁸/ 師傅教徒弟，徒弟設酒宴款待，師傅酒後授予秘方。之後徒弟不再宴請師傅。</li>\n<li>軟過豆腐 /nam³ goi³ dao⁷ hu⁷/</li>\n<li>車大炮 /cia¹ dua⁷ pao³/ 吹牛</li>\n<li>樹大分椏，囝大分家 /ciu⁷ dua⁷ bng¹ a¹, gian² dua⁷ bng¹ ga¹/ </li>\n<li>閒過仙 /ain⁵ goi³ siang¹/ 比神仙還閒</li>\n<li>雙目望無一寸長 /sang¹ mag⁸ mo⁷ bho⁵ zêg⁸ cung³ dng⁵/ 鼠目寸光</li>\n<li>一鼠二牛三虎四兔五龍六蛇七馬八羊九猴十雞十一狗十二豬 /ig⁴ cu² ri⁶ ghu⁵ san¹ haon² si³ tao³ ngao⁶ lêng⁵ lag⁸ zua⁵ cig⁴ bhê² boih⁴ ion⁵ gao² gao⁵ zab⁸ goi¹ zab⁸ ig⁴ gao² zab⁸ ri⁶ du¹/</li>\n<li>差豬差狗，不如家己走 /cê¹ du¹ cê¹ gao², bug⁴ ru⁵ ga¹ gi⁷ zao²/ 求人不如求己</li>\n<li>後生擔石，老人食藥 /hao⁶ sên¹ dan¹ zioh⁸, lao⁶ nang⁵ ziah⁸ ioh⁸/ 年少積勞，年老吃藥</li>\n<li>疑心生暗鬼 /ghi⁵ sim¹ sên¹ am³ gui²/ 因多疑而產生各種幻覺和錯誤判斷</li>\n<li>羊尾短短，遮毋著羊尻川 /ion⁵ bhoi² dê² dê², zia¹ m⁶ dioh⁴ ion⁵ ka¹ cng¹/ 自己的缺點尷尬能自己找個遮醜的就很好了，別去取笑別人的不堪。</li>\n<li>愛母著刻苦 /ain³ bhao² dioh⁴ kag⁴ kao²/ 要老婆就要努力了</li>\n<li>無好家神通外鬼 /bho⁵ ho² gê¹ sing⁵ tong¹ ghua⁷ gui²/</li>\n<li>How do you do，好事來堵 /hao³ su⁷ lai³ du²/ 嗨，要搞事情我不怕你。好事，喜歡搞事情。堵，應對、抵抗。</li>\n<li>秋瓜棚下無好人 /ciu¹ goi¹ bên⁵ ê⁶ bho⁵ ho² nang⁵/ 秋瓜，絲瓜。</li>\n<li>三跤椅囝毋知䆀 /san¹ ka¹ in² gian² m⁶ zai¹ bhai²/ 坐著少了一腿的椅子竟然不知道壞了，比喻身處困境而不自知。</li>\n</ol>\n<h3 id=\"🤣歇後語-hiah⁴-ao⁶-ngo²\"><a href=\"#🤣歇後語-hiah⁴-ao⁶-ngo²\" class=\"headerlink\" title=\"🤣歇後語(hiah⁴ ao⁶ ngo²)\"></a>🤣歇後語(hiah⁴ ao⁶ ngo²)</h3><ol>\n<li>柴目狗耳 — 假靈 /ca⁵ mag⁸ gao² hin⁶ — gê² lêng⁵/ 目雕的眼睛看不見，狗一般耳朵卻很靈，聽風是雨。</li>\n<li>雞跤長鴨跤短 — 有懸下 /goi¹ ka¹ dng⁵ ah⁴ ka¹ dê² — u⁶ guain⁵ gê⁶/ 雞腳長，鴨腳短，有高有矮。</li>\n<li>爐底碳 — 塊塊通 /lao⁵ doi² tuan³ — dê⁷ dê⁷ tang³/ 百事通</li>\n<li>孥囝食奶 — 坐亭 /nao⁶ gian² ziah⁸ nê¹ — zê⁶ dêng⁵/ 亭，直。</li>\n<li>菜頭面刺無血 — 面皮厚 /cai³ tao⁵ ming¹ ci³ bho⁵ hoih⁴ — ming¹ poi⁵ gao⁶/</li>\n<li>褪褲放屁 — 假工夫 /tng³ kao³ bang³ pui³ — gê² gang¹ hu¹/</li>\n<li>竹葉包沙 — 假壯 /dêg⁴ hio² bao¹ sua¹ — gê² zang³/ 壯，與「粽」諧音。</li>\n<li>元宵燈籠 — 一肚火 /nguang⁵ siao¹ dêng¹ lang⁵ — zêg⁸ dao² hoi²/</li>\n<li>半天吊燈籠 —四搭无向 /buan³ tin¹ diao³ dêng¹ lang⁵ — si³ dah⁴ bho⁵ hiang³/</li>\n<li>青暝睒鏡 — 無望 /cên¹ mên⁵ iam² gian³ — bho⁵ mo⁷/</li>\n<li>青暝睇天 — 張樣張相 /cên¹ mên⁵ toi² tin¹ — dion¹ ion⁷ dion¹ sion⁷/</li>\n<li>青暝點燈 — 照舊 /cên¹ mên⁵ diam² dêng¹ — zio³ gu⁷/ 對青暝人來說，點不點燈，一切照舊。</li>\n<li>青暝掠魚 — 散摸 /cên¹ mên⁵ liah⁸ hu⁵ — suan³ mong⁵/</li>\n<li>青暝娶母 — 稱重 /cên¹ mên⁵ cua⁷ bhao² — cing³ dang⁶/</li>\n<li>青暝擎手電 — 各人各人善 /cên¹ mên⁵ gia⁵ ciu² diang⁶ — gag⁴ nang⁵ gag⁴ nang⁵ siang⁶/</li>\n<li>青暝睇電影 — 聽聲 /cên¹ mên⁵ toi² diang⁶ ian² — tian¹ sian¹/</li>\n<li>啞人食苦瓜 — 有苦難言 /ê² nang⁵ ziah⁸ kao² goi¹ — u⁶ kao² nang⁵ ngiang⁵/</li>\n<li>啞囝食黃連 — 有苦難言 /ê² gian² ziah⁸ ng⁵ nain⁵ — u⁶ kao² nang⁵ ngiang⁵/</li>\n<li>閻羅王嫁諸母囝 — 鬼正敢愛 /ngiam⁵ lo⁵ uang⁵ gê³ za¹ bhao² gian² — gui² zian³ gan² ain³/</li>\n<li>閻羅王請人 — 鬼正敢食  /ngiam⁵ lo⁵ uang⁵ cian² nang⁵ — gui² zian³ gan² ziah⁸/</li>\n<li>閻羅王賣假貨 — 騙鬼 /ngiam⁵ lo⁵ uang⁵ bhoi⁷ gê² hoi⁷ — piang³ gui²/</li>\n<li>閻羅王出告示 — 無句人話 /ngiam⁵ lo⁵ uang⁵ cug⁴ go³ si⁷ — bho⁵ gu³ nang⁵ oi⁷/</li>\n<li>鬼簿無名 — 免死 /gui² pao⁶ bho⁵ mian⁵ — miang² si²/</li>\n<li>醫生開了棺材舖 — 死活都愛錢 /ui¹ sên¹ kui¹ liao² gua¹ ca⁵ pao⁷ — si² ua² do¹ ain³ zin⁵/</li>\n<li>身長棺材短 — 屈死人 /sing¹ dng⁵ gua¹ ca⁵ dê² — kug⁴ si² nang⁵/</li>\n<li>棺材頭畫老虎 — 驚死人 /gua¹ ca⁵ tao⁵ oi⁷ lao⁶ haon² — gian¹ si² nang⁵/</li>\n<li>歪喙和尚 — 唸無一句正經 /uain¹ cui³ hoi⁵ sion⁷ — niam⁷ bho⁵ zêg⁸ gu³ zian³ gêng⁵/</li>\n<li>師公和尚 — 毋同道 /sai¹ gong¹ hoi⁵ sion⁷ — m⁶ dang⁵ dao⁶/</li>\n<li>和尚抹粉 — 白勞 /hoi⁵ sion⁷ bhuah⁴ hung² — bêh⁸ lu⁵/ 勞，與「驢」諧音。</li>\n<li>和尚擎雨遮 — 無法無天 /hoi⁵ sion⁷ gia⁵ hao⁶ zia¹ — bho⁵ huab⁴ bho⁵ tin¹/ 法，與「髮」諧音。</li>\n<li>橄欖尻川 — 坐毋恬 /gan¹ na² ka¹ cng¹ — zê⁶ m⁶ diam⁷/ 屁股像橄榄一般尖，坐不住。恬，静、定。</li>\n<li>火燒豬頭 — 熟面熟面 /hoi² sio¹ du¹ tao⁵ — sêg⁸ ming⁷ sêg⁸ ming⁷/</li>\n<li>六月芥菜 — 假有心 /lag⁸ ghoih⁸ gua³ cai³ — gê² u⁶ sim¹/</li>\n<li>十月芥菜 — 大䀌心 /zab⁸ ghoih⁸ gua³ cai³ — dua⁷ gêg⁴ sim¹/ 䀌，與「激」諧音。</li>\n<li>六月蕃薯 — 雙死 /lag⁸ ghoih⁸ huang¹ zu⁵ — sang¹ si²/ 雙，與「鬆」諧音。</li>\n<li>阿媽生諸母囝 — 生菇 /a¹ ma² sên¹ za¹ bhao² gian² — sên¹ gao¹/ 生菇，發霉。菇，與「姑」諧音。</li>\n<li>老人跤纏 — 又長又臭 /lao⁶ nang⁵ ka¹ din⁵ — ui⁶ dng⁵ ui⁶ cao³/ 講話囉嗦像老人纏足一樣</li>\n<li>老人食豬跤 — 試味 /lao⁶ nang⁵ ziah⁸ du¹ ka¹ — ci³ bhi⁷/ 嘗試下而已</li>\n<li>老婆跋落水 — 淒涼 /lao⁶ pua⁵ buah⁸ lo² zui² — ci¹ liang⁵/ 跋，絆倒。淒，與「妻」諧音。</li>\n<li>老婆其阿兄 — 痴哥 /lao⁶ pua⁵ gai⁵ a¹ hian¹ — ci¹ go¹/ 痴，與「妻」諧音。</li>\n<li>菜頭粿熱單爿 — 自作多情 /cai³ tao⁵ goi² riah⁸ duan¹ bain⁵ — zu⁶ zag⁴ do¹ cêng⁵/ 菜頭粿，蘿蔔糕。热单爿，切片下鍋油煎，但只煎單邊，上焦下嫩。一頭熱（悅），單戀。</li>\n<li>龍眼核拭尻川 — 賽道行 /nging¹ ain² hug⁸ cih⁴ ka¹ cng¹ — sai³ dao⁶ hang⁵/ 「龍眼核拭尻川」比喻有難度的事情，看各家誰本領強了。</li>\n<li>水仙不開花 — 裝蒜 /zui² siang¹ bug⁴ kui¹ hoi¹ — zng¹ sng³/</li>\n<li>大炮拍麻雀 — 騙伊驚 /dua⁷ pao³ pah⁴ mua⁵ ziah⁴ — piang³ i¹ gian¹/</li>\n<li>有錢買蠓香，無錢買蠓罩 — 會算無會除 /u⁶ zin⁵ bhoi² mang² hion¹, bho⁵ zin⁵ bhoi² mang² dan³ — oi⁶ sng³ bhoi⁶ du⁵/</li>\n<li>天頂滴鳥屎 — 無好相覓 /tin¹ dêng² dig⁴ ziao² sai² — mo² sion¹ coi⁷/</li>\n<li>六月薄殼 — 假大頭 /lag⁸ ghoih⁸ boh⁸ kag⁴ — gê² dua⁷ tao⁵/ 大頭，一種比薄殼略大的小貝類海鮮。假大頭，愛充大頭。</li>\n<li>七角錢二人分 — 毋三毋四 /cig⁴ gag⁴ zin⁵ no⁶ nang⁵ bng¹ — m⁶ san¹ m⁶ si³/</li>\n<li>十二碗圓食賰一粒 — 假客氣 /zab⁸ ri⁶ liab⁸ in⁵ ziah⁸ cung⁵ zêg⁸ liab⁸ — gê² kêh⁴ ki⁷/ 圓，丸子。賰，剩下。</li>\n<li>狗母蛇 — 假靈 /gao² bho² zua⁵ — gê² lêng⁵/ 靈，與「龍」諧音。</li>\n<li>兄獨目弟缺喙 — 大無好樣，細無好相 /hian¹ dog⁸ mag⁸ di⁶ koih⁴ cui³ — dua⁷ bho⁵ ho² ion⁷, soi³ bho⁵ ho² sion³/</li>\n<li>山螟咬尾 — 食家己 /suan¹ mê¹ ga⁶ bhoi² — ziah⁸ ga¹ gi⁷/</li>\n<li>風吹牆頭草 — 就勢倚勢 /hong¹ coi¹ ciong⁵ tao⁵ cao² — ziu⁶ si³ ua² si³/</li>\n<li>老鼠跋落粟倉 — 倒好 /ngiao² cu² buah⁸ lo² cêg⁴ cng¹ — do³ ho²/</li>\n<li>老鼠心肝 — 頭食頭搬 /ngiao² cu² sim¹ guan¹ — tao⁵ ziah⁸ tao⁵ buan⁵/</li>\n<li>孥囝拍炮 — 又驚又好 /nao⁵ gian² pah⁴ pao⁷ — ui⁶ gian¹ ui⁶ hao⁷/</li>\n<li>五行缺一 — 欠金 /ngao⁶ hêng⁵ koih⁴ ig⁴ — kiang³ gim¹/</li>\n<li>茂生進酒 — 厚情 /mao⁶ sêng¹ zing³ ziu² — gao⁶ cêng⁵/</li>\n<li>食人雞肉還人豬肉 — 物來物去 /ziah⁸ nang⁷ goi¹ nê² hain⁵ nang⁷ du¹ nê² — moih⁸ lai⁵ moih⁸ ko³/</li>\n<li>刀截蕹菜 — 二頭空 /do¹ zoi² êng³ cai³ — no⁶ tao⁵ kong¹/</li>\n<li>三個半錢 — 趕勢 /san¹ gai⁵ buan³ zin⁵ — guan² si³/ 勢，與「四」諧音。</li>\n<li>隔暝皇帝 — 無權勢 /gêh⁴ mê⁵ huang⁵ di⁷ — bho⁵ kuang⁵ si³/</li>\n<li>大肚水蛙 — 假鮭 /dua⁷ dao² zui² goi¹ — gê² guai¹/ 水蛙，青蛙。鮭，河魨。</li>\n<li>五月龍船 — 相鬥 /ngao⁶ ghoih⁸ lêng⁵ zung⁵ — sion¹ dao³/</li>\n<li>燈籠照路 — 目前光 /dêng¹ lang⁵ zio³ lao⁷ — mag⁸ zain⁵ gng¹/ 比喻目光短淺</li>\n<li>暗室穿針 — 難過 /am³ sig⁴ cng¹ zam¹ — nang⁵ goi³/</li>\n<li>嫁諸母囝娶新婦 — 出入平安 /gê³ za¹ bhao² gian² cua⁷ sing¹ bu⁶ — cug⁴ rib⁸ pêng⁵ ang¹/ 安，與「翁」諧音。</li>\n<li>過關送文憑 — 做人情 /goi³ guan¹ sang³ bhung⁵ pêng⁵ — zo³ nang⁵ zian⁵/</li>\n<li>火燒草料場 — 事出有因 /hoi² sio¹ cao² liao⁷ dion⁵ — su⁷ cu⁷ u⁶ ing¹/ 因，與「煙」諧音。</li>\n<li>黑白電視 — 無彩 /hêg⁴ bêh⁸ dian⁶ si⁶ — bho⁵ cain²/ 無彩，可惜。</li>\n<li>小郎遇著雨 — 積惡 /sio² nng⁵ ngo⁶ dioh⁴ hao⁶ — zêg⁴ ag⁴/ 小郎，女子稱呼丈夫的弟弟。積惡，可憐；罪惡。積，與「叔」諧音。惡，與「沃」諧音。</li>\n</ol>\n<h3 id=\"🙂禮貌用語-li²-mao⁶-eng³-ngo²\"><a href=\"#🙂禮貌用語-li²-mao⁶-eng³-ngo²\" class=\"headerlink\" title=\"🙂禮貌用語(li² mao⁶ êng³ ngo²)\"></a>🙂禮貌用語(li² mao⁶ êng³ ngo²)</h3><ol>\n<li>汝食饱未 /lu² ziah⁸ ba² bhoi⁷/ 你吃飽了嗎</li>\n<li>汝愛去底地 /lu² ain³ ku³ di⁷ dê⁷/ 你要去哪裏</li>\n<li>汝好 /lu² ho²/ 你好</li>\n<li>㩼謝 /zoi⁷ sia⁷/ 多謝</li>\n<li>寬行 /kuan¹ gian⁵/ 慢走</li>\n<li>寬駛 /kuan¹ sai²/ 慢點開車</li>\n<li>对毋住 /dui³ m⁶ zu⁶/ 对不起</li>\n<li>对毋起 /dui³ m⁶ ki²/ 对不起</li>\n<li>無相干 /bho⁵ siang¹ gang¹/ 沒關係</li>\n<li>毋知頭 /m⁶ zai¹ tao⁵/ 不是故意的</li>\n<li>先這呾 /sain¹ zion² dan³/ 回頭再聊 </li>\n<li>萬事應想 /mang⁷ su⁷ êng³ sion⁶/ 萬事如意</li>\n<li>生理大趁 /sêng¹ li² dua⁷ tang⁷/ 生意興隆</li>\n<li>新年大趁 /sing¹ ni⁵ dua⁷ tang⁷/ 新年大賺</li>\n<li>新年合想 /sing¹ ni⁵ gah⁴ sion⁶/ 新年如意</li>\n<li>大吉大利 /dai⁶ gig⁴ dai⁶ li⁶/</li>\n</ol>\n<h3 id=\"🤐粗話-cao¹-oi⁷\"><a href=\"#🤐粗話-cao¹-oi⁷\" class=\"headerlink\" title=\"🤐粗話(cao¹ oi⁷)\"></a>🤐粗話(cao¹ oi⁷)</h3><ol>\n<li>咒誓 /ziu³ zua⁷/ 發誓、詛咒</li>\n<li>痟 /siao²/ 神經錯亂</li>\n<li>神經 /sing⁵ gêng¹/</li>\n<li>腦孬 /nao² mo³/ 腦子壞了</li>\n<li>破脑囝 /puah⁸ nao² gian²/ 弱智</li>\n<li>肚痛 /dao² tian³/ 「問候」別人是否肚子痛所以一直在叫。</li>\n<li>鬼叫 /gui² gio⁷/ 「問候」別人是否聽到鬼在叫。</li>\n<li>哭 cang¹ 哭 nain⁵ // 又哭又喊，吵死人了。</li>\n<li>哭父死母 /kao³ bê⁶ si² bho²/ 「問候」別人是否父母過世所以一直在哭叫。</li>\n<li>咋死人 /zag⁴ si² nang⁵/ 吵死了</li>\n<li>鬼囝 /gui² gian²/ 小鬼</li>\n<li>鬼卒囝 /gui² zug⁴ gian²/ 小鬼</li>\n<li>鬼然然 /gui² riang⁵ riang⁵/ 像鬼一樣</li>\n<li>鬼囉作禍 /gui² lo⁷ zo³ ho³/ 鬼在作祟、作怪</li>\n<li>妖怪精 /iao¹ guai³ zian¹/</li>\n<li>去死掉掉 /ku³ si² diao³ diao³/</li>\n<li>散哭父 /suan⁷ kao³ bê⁶/ 散，到處。</li>\n<li>吐屎 /tao³ sai²/ 亂說</li>\n<li>卵屎人 /lang⁶ sai² nang⁵/ 屌絲，沒前途的人。</li>\n<li>卵屎話 /lang⁶ sai² oi⁷/ 廢話</li>\n<li>臭喙卵面 /cao³ cui³ lang⁶ ming⁷/ 亂說、討人厭。</li>\n<li>關汝卵事 /guang¹ lu² lang⁶ dai⁷/ 與你何干</li>\n<li>膣精 /zi¹ zian¹/ 多管閒事</li>\n<li>臭膣 /cao³ zi¹/ 臭婊子</li>\n<li>豺狗 /sai² gao²/ 狗腿子</li>\n<li>怪卵 /guai³ lang⁶/ 古怪</li>\n<li>無卵 /bho⁵ lang⁶/ 沒膽量</li>\n<li>無腦 /bho⁵ nao²/ 沒腦子</li>\n<li>𠀾好 /bhoi⁶ ho²/ 咒別人倒霉</li>\n<li>痞囝 /pai² gian²/ 痞子、流氓。</li>\n<li>肏母囝 /pu² bho² gian²/</li>\n<li>早死囝 /za² si² gian²/</li>\n<li>短命囝 /dê² mian⁷ gian²/、/dêng² mian⁷ gian²/</li>\n<li>破家囝 /pua⁷ gê¹ gian²/ 败家子</li>\n<li>內仙囝  /lai⁶ siang¹ gian²/ 難伺候</li>\n<li>十惡囝 /zab⁸ ag⁴ gian²/ 十惡不赦</li>\n<li>棺材囝 /gua¹ ca⁵ gian²/</li>\n<li>痴哥囝 /ci¹ go¹ gian²/ 色狼</li>\n<li>吐血死囝 /tao³ hoih⁴ si² gian²/</li>\n<li>替人死囝 /toi⁵ nang⁵ si² gian²/</li>\n<li>半路死囝 /buan³ lao⁷ si² gian²/</li>\n<li>祭屎祭䷀ /zi³ sai² zi³ hê⁷/ 亂吃東西</li>\n<li>乞鬼侵著 /koh⁴ gui² cin⁵ dioh⁴/ 鬼上身了。乞，給。侵，本讀 /cim⁵/，音變爲 /cin⁵/，附身。</li>\n</ol>\n<h3 id=\"🧨娛樂-ngo⁵-log⁸\"><a href=\"#🧨娛樂-ngo⁵-log⁸\" class=\"headerlink\" title=\"🧨娛樂(ngo⁵ log⁸)\"></a>🧨娛樂(ngo⁵ log⁸)</h3><ol>\n<li>耍遊戲 /sng² iu⁵ hi³/ 玩遊戲</li>\n<li>䷀箭 /diong³ zin³/ 射箭</li>\n<li>䷀珠 /diong³ zu¹/ 打彈珠</li>\n<li>彈槍 /duan⁷ ciong¹/ 開槍</li>\n<li>跳索 /tiao³ soh⁴/ 跳繩</li>\n<li>踏孔 /dah⁸ kong²/ 捉迷藏</li>\n<li>泅水 /siu⁵ zui²/ 游泳</li>\n<li>釣魚 /dio³ hu⁵/</li>\n<li>掠魚 /liah⁸ hu⁵/ 抓魚</li>\n<li>行棋 /gian⁵ gi⁵/ 下棋</li>\n<li>放風箏 /bang³ hong¹ zêng¹/</li>\n<li>拍連炮 /pah⁴ liang⁵ pao³/ 放鞭炮</li>\n<li>扣人囝 /kob⁴ nang⁵ gian²/ 人囝，也叫公仔紙、洋畫，舊時供兒童玩樂用的紙牌。</li>\n<li>沃花 /ag⁴ hoi¹/ 澆花</li>\n<li>做戲 /zo³ hi³/ 演戲劇</li>\n</ol>\n<h3 id=\"⛩-神明-sing⁵-meng⁵\"><a href=\"#⛩-神明-sing⁵-meng⁵\" class=\"headerlink\" title=\"⛩ 神明(sing⁵ mêng⁵)\"></a>⛩ 神明(sing⁵ mêng⁵)</h3><ol>\n<li>天地父母 // 天地，原始信仰。</li>\n<li>月娘 // 月球，原始信仰。</li>\n<li>媽祖 // 原名林默，南海保護神，在甲子天后宮有供。</li>\n<li>七聖娘 // 又稱七星娘娘、七聖夫人，是織女神分化出的七位仙女，是兒童保護神。</li>\n<li>觀音娘 // 觀音菩薩</li>\n<li>慈悲娘 // 即普悲觀音，觀音菩薩化身之一（傳說觀音菩薩有三十三化身），普遍施給眾生慈悲。</li>\n<li>註生娘 // 全稱「大慈大悲救苦救難送子娘娘」，主管懷孕與生育。</li>\n<li>佛祖 // 釋迦牟尼佛，姓喬達摩，名悉達多，古印度思想家、教育家、宗教改革家，佛教的創始人。</li>\n<li>達摩祖師 // 南天竺人或波斯人，將佛教禪宗帶入中國，爲中國禪宗之開創者。</li>\n<li>元天上帝 // 玄武大帝，象徵北極星與二十八宿中的北宮玄武，爲統理北方之道教大神。</li>\n<li>水仙大帝 // 水仙尊王，海神之一，媽祖的從神之一。</li>\n<li>汾陽王帝 // 郭子儀，華州鄭縣（今陝西渭南市華州區）人，唐朝名將，平定安史之亂，封汾陽郡王。此人富貴壽考，權極一時，甲子天后宮媽祖廟有供之。</li>\n<li>王公 // 指隴尾王爺、王爺公，名鄒普勝，麻城花橋（今屬湖北）人，元末農民起義軍將領，陳友諒軍師。朱元璋建立明朝後流浪到甲子地區，爲甲子地區改造「風水」等，今甲子隴尾王爺廟有供之，大年初四在此求「落馬簽」。</li>\n<li>關公 // 關羽，河東郡解縣（今山西省運城市鹽湖區解州鎮）人，三國時期名將，與劉備、張飛桃園三結義。又稱伽藍老爺、伽藍尊者，是寺廟、道場守護神，也有稱之爲武財神。</li>\n<li>八仙公 // 傳說中的八位仙人，爲漢鍾離、張果老、韓湘子、鐵拐李、曹國舅、呂洞賓、藍采和、何仙姑八人。</li>\n<li>伯公 // 福德老爺、土地公。</li>\n<li>五穀公 // 神農大帝，相傳其發明耒耜，教民耕種五穀，並能以百草為民治病。農曆十月十五拜之。</li>\n<li>城隍公 // 古代城鎮保護神。</li>\n<li>皇帝公 // 南宋小皇帝趙昰，曾流亡到甲子待渡山。</li>\n<li>灶公 // 灶君，主掌廚房和飲食的神。</li>\n<li>百姓公 // 無主死者，集中掩埋於百姓公墓，稱爲百姓公(媽)，其中多喪於 1943 年的大飢荒，其時僅甲子一鎮亡者就近 2 萬人，慘絕。</li>\n<li>地主爺 // 住宅的守護靈。</li>\n<li>財神爺 // 常指陝西終南山的玄壇真君趙公明，也指關聖帝君關羽。</li>\n<li>三山國王 // 指現揭西縣河婆鎮北面的三座山——巾山、明山、獨山的三位山神。</li>\n</ol>\n<h2 id=\"風俗-hong¹-sioh⁸\"><a href=\"#風俗-hong¹-sioh⁸\" class=\"headerlink\" title=\"風俗(hong¹ sioh⁸)\"></a>風俗(hong¹ sioh⁸)</h2><ol>\n<li>大年初一：食齋菜（菠薐菜、粉絲、菜頭丸、豆腐乾）。</li>\n<li>人日(正月初七)：食七樣菜（厚合、蒜仔、芥藍、高麗菜、真珠菜、香菜、大菜芯）。</li>\n<li>元宵(正月十五)：食蔗。</li>\n<li>三月初三：食青草飯（雞屎藤、伸筋藤、苦刺心、臭草心、蠟裏葉、四方枝苦楝葉）。</li>\n<li>清明：食硬殼餅，掃墓掛紙。</li>\n<li>佛誕(四月初八)：食飯茶。</li>\n<li>端午：食梔粽、梔粿，洗午時水。</li>\n<li>七月初七：出花園。</li>\n<li>中秋：食月餅、芋頭、蔗。</li>\n<li>重陽(九月初九)：食雞湯。</li>\n<li>冬節：食冬節丸、羊肉。</li>\n<li>三十夜、廿九夜：食團圓飯、送壓腰錢（dêh⁴ io¹ zin⁵, 壓歲錢）。</li>\n</ol>\n<h2 id=\"歷史-leg⁸-su²\"><a href=\"#歷史-leg⁸-su²\" class=\"headerlink\" title=\"歷史(lêg⁸ su²)\"></a>歷史(lêg⁸ su²)</h2><ol>\n<li><p>甲子的名號是因爲港後有六十塊大石頭，應了干支紀年法一甲子的數目，故名。</p>\n</li>\n<li><p>漢文帝時曾派遣大臣陸賈（約公元前240年～公元前170年）到南越國，期間命令將士調查海岸線，到過甲子門。</p>\n</li>\n<li><p>三國時，吳侯孫權派遣將軍衛溫（？～231年）攻打福建、琉球和台灣（夷州），被風雨刮到甲子門。</p>\n</li>\n<li><p>南宋乾道五年(1169)，承奉郎致仕范有仁建順濟橋，橋從大膽山腳(今東宮社轄區)跨越瀛江到後庭（今甲東鎮雨亭村轄區）。</p>\n<p> <img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2084.png\" alt=\"順濟橋（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）\"></p>\n</li>\n<li><p>宋嘉定甲申年(1224)，南宋承奉郎范良臣（范有仁之孫）登腹石山，因山對面可見甲子門奇石十八，屹立如人，遂刻「登瀛」二字於石，取十八學士登瀛洲之義。</p>\n</li>\n<li><p>1276 年，元兵攻陷南宋京城臨安，南宋擁立幼帝趙昰，從福州乘船經福建沿海入廣東，於冬十二月抵甲子門腹石山（後人爲紀念此事，更山名爲待渡山），范良臣給軍食三日，留帝像登瀛石上。</p>\n</li>\n<li><p>1277 年正月，漁民鄭復組織義兵509人乘船護送宋帝昺及隨臣去崖門。途中在現珠海橫琴島和澳門與元兵相遇，十六日宋室全軍覆滅，陸秀夫背幼帝昺投海自盡，鄭復等在激戰中全部士兵犧牲。</p>\n</li>\n<li><p>明永樂六年(1408)，順濟橋被拆。因「指揮花茂奉旨建甲子所，慮倭寇泊海易渡，拆之以為城基。」</p>\n</li>\n<li><p>明嘉靖三十九年(1560)，八萬洞資首黃啓薦扎寨惠來冰山頭（今邦山村）攻陷甲子所城，城中居民移至龍溪都（今惠來隆江以南）為逃避倭禍而暫居，該城之難民，慘遭殺害者甚眾，婦女被擄掠，有的全家罹難。</p>\n</li>\n<li><p>明隆慶二年(1568)，倭寇入侵甲子，千戶馬壽麻痹輕敵，城被攻陷，甲子和龍溪都一帶受害慘重。馬壽因失職罪下獄，死於獄中。</p>\n</li>\n<li><p>明隆慶四年(1570)，大旱，入春至初夏，天無滴雨，時又常遭賊寇蹂躪，田園拋荒，赤地千里，人民苦不堪言。</p>\n</li>\n<li><p>明隆慶四年(1570)九月，曾作倭寇嚮導之海寇楊老復，率賊眾攻陷甲子所城，擄掠男女上船，千戶董（佚名）戰死。次日，船遇颱風，賊與被擄者均溺死。</p>\n</li>\n<li><p>隆慶五年(1571)七月，海盜林道乾（又名林鳳，惠來人），於龍溪都一帶擄民劫捨，後聞朝廷將派兵進剿，遂遠循至甲子一帶搶劫，攻破新寨，劫擄李棠，其妻卓氏攜二子上船換夫歸，遂投海殉節。後朝廷封為「南海夫人」。</p>\n</li>\n<li><p>明萬曆二十六年(1598)，湯顯祖作《牡丹亭》，其第六齣中有詞句「榕樹梢頭訪古台，下看甲子海門開。越王歌舞今何在？時有鷓鴣飛去來。」</p>\n</li>\n<li><p>明萬曆二十八年(1600)八月二十三日，惠來及甲子一帶地震。</p>\n</li>\n<li><p>明萬曆三十三年(1605)三月，惠來及甲子一帶地震，七月初三至初七颱風暴雨，沿海田舍淹沒。</p>\n</li>\n<li><p>明萬曆三十五年(1607)，參將張萬紀、守備胡文烜在待渡山下建宋帝亭，即進食亭。</p>\n</li>\n<li><p>明萬曆四十二年(1620)春正月，海盜袁八老余黨林新老入甲子沃，把總金允武出戰死之。</p>\n</li>\n<li><p>明天啓七年(1627)三月，海寇入甲子門，守備葉台死亡。</p>\n</li>\n<li><p>明崇禎八年(1635)，海寇劉香攻陷甲子，擄去守道洪雲蒸。閩粵大兵突至，洪遇害，後劉香被擄伏誅。</p>\n</li>\n<li><p>明崇禎十四年(1641)十二月十四日夜，惠來地震，波及甲子。</p>\n</li>\n<li><p>民國32年(1943，癸未年)，甲子乃至整個海陸豐地區、潮汕地區遭遇大飢荒，時兵災、旱災、蝗災和瘟疫，餓殍遍野，僅甲子一鎮亡者就近 2 萬，佔當時鎮人口逾 45%。</p>\n</li>\n<li><p>1966年，中國大陸爆發文化大革命，「破四舊」。次年，有360年歷史的進食亭被炸毀！</p>\n</li>\n<li><p>2004年夏～2005年秋，甲子諸賢達捐資重建了進食亭。</p>\n</li>\n<li><p>2013年12月29日凌晨，廣東警方出動3000多人的警力對有「毒品村」之稱的甲西鎮博社村開展清繳行動，當天繳獲近3噸冰毒，抓捕180多名涉毒犯罪嫌疑人，原村委書記蔡東家名列其中。</p>\n</li>\n</ol>\n<h2 id=\"建置-giang³-di³\"><a href=\"#建置-giang³-di³\" class=\"headerlink\" title=\"建置(giang³ di³)\"></a>建置(giang³ di³)</h2><ol>\n<li><p>秦以前：屬南越國</p>\n</li>\n<li><p>秦：屬南海郡之博羅縣</p>\n</li>\n<li><p>漢：屬博羅縣</p>\n</li>\n<li><p>三國：屬博羅縣</p>\n</li>\n<li><p>晉：咸和六年（326）析博羅，置海豐縣，屬东官郡</p>\n</li>\n<li><p>宋：屬海豐縣</p>\n</li>\n<li><p>齊：屬海豐縣</p>\n</li>\n<li><p>梁：屬海豐縣</p>\n</li>\n<li><p>陳：屬海豐縣</p>\n</li>\n<li><p>隋：海豐縣屬循州</p>\n</li>\n<li><p>唐：海豐縣屬循州。武德五年（622）析置安陸縣；貞觀元年（627）復歸海豐縣。</p>\n</li>\n<li><p>五代：大寶元年（958）海豐縣属祯州。</p>\n</li>\n<li><p>宋：海豐縣屬祯州。天禧五年（1021）屬惠州。</p>\n</li>\n<li><p>元：海豐縣屬惠州路。</p>\n</li>\n<li><p>明：海豐縣屬惠州府。洪武二十七年(1394)，置甲子守禦千戸所，隸屬碣石衛。嘉靖三年（1524）海豐划出龍溪都、潮州府析出潮陽縣合置惠來縣。</p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/Untitled%2085.png\" alt=\"甲子所城範圍（來源：[BTG](http://www.iobtg.com/Cc.Jiazi.htm#1)）\"></p>\n</li>\n<li><p>清：海豐縣屬惠州府。雍正九年（1731）海豐划出石帆（甲子屬石帆都）、吉康、坊廓3都置陸豐縣，並裁甲子所設立甲子巡檢司。</p>\n</li>\n<li><p>中華民國：陸豐縣屬潮循道。</p>\n</li>\n<li><p>中華人民共和國：1957年甲子鎮劃出甲東鎮、甲西鎮（取甲子之東、甲子之西義）；1958年鎮改爲人民公社，陸豐縣屬汕頭地區；1983年陸豐屬惠陽地區；1980年成立甲子鎮人民政府；1988年陸豐縣改屬汕尾市；1995年陸豐撤縣建市。</p>\n</li>\n</ol>\n<h2 id=\"拼音方案-peng³-im¹-huang¹-uan³\"><a href=\"#拼音方案-peng³-im¹-huang¹-uan³\" class=\"headerlink\" title=\"拼音方案(pêng³ im¹ huang¹ uan³)\"></a>拼音方案(pêng³ im¹ huang¹ uan³)</h2><h3 id=\"聲母表-sian¹-bho²-biao²\"><a href=\"#聲母表-sian¹-bho²-biao²\" class=\"headerlink\" title=\"聲母表(sian¹ bho² biao²)\"></a>聲母表(sian¹ bho² biao²)</h3><p>格式：<code>聲母 [國際音標] 例字</code></p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png\" alt></p>\n<h3 id=\"韻母表-ung¹-bho²-biao²\"><a href=\"#韻母表-ung¹-bho²-biao²\" class=\"headerlink\" title=\"韻母表(ung¹ bho² biao²)\"></a>韻母表(ung¹ bho² biao²)</h3><p>格式：<code>韻母 [國際音標] 例字 / 入聲韻 [國際音標] 例字</code></p>\n<p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png\" alt></p>\n<h3 id=\"聲調-sian¹-diao⁶\"><a href=\"#聲調-sian¹-diao⁶\" class=\"headerlink\" title=\"聲調(sian¹ diao⁶)\"></a>聲調(sian¹ diao⁶)</h3><p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png\" alt></p>\n<h3 id=\"變調-biang³-diao⁶\"><a href=\"#變調-biang³-diao⁶\" class=\"headerlink\" title=\"變調(biang³ diao⁶)\"></a>變調(biang³ diao⁶)</h3><p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png\" alt></p>\n<h2 id=\"地圖-di⁷-dao⁵\"><a href=\"#地圖-di⁷-dao⁵\" class=\"headerlink\" title=\"地圖(di⁷ dao⁵)\"></a>地圖(di⁷ dao⁵)</h2><p><img src=\"/2021/02/06/language/min/gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg\" alt=\"三甲地區（來源：騰訊地圖）\"></p>"}],"PostAsset":[{"_id":"source/_posts/music/listen-chopin-raindrop/cdefgab.jpg","slug":"cdefgab.jpg","post":"ckt7c7wo600019a9kh2gm6od2","modified":0,"renderable":0},{"_id":"source/_posts/music/listen-chopin-raindrop/piano-keys.gif","slug":"piano-keys.gif","post":"ckt7c7wo600019a9kh2gm6od2","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled 1.png","slug":"Untitled 1.png","post":"ckt7c7wo900049a9khw360xtn","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled 2.png","slug":"Untitled 2.png","post":"ckt7c7wo900049a9khw360xtn","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-02/Untitled.png","slug":"Untitled.png","post":"ckt7c7wo900049a9khw360xtn","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 1.png","slug":"Untitled 1.png","post":"ckt7c7woa00059a9kc7ku484w","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 2.png","slug":"Untitled 2.png","post":"ckt7c7woa00059a9kc7ku484w","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled 3.png","slug":"Untitled 3.png","post":"ckt7c7woa00059a9kc7ku484w","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-design-and-implementation-01/Untitled.png","slug":"Untitled.png","post":"ckt7c7woa00059a9kc7ku484w","modified":0,"renderable":0},{"_id":"source/_posts/language/min/sigêng-giamgia/202010060948.jpg","slug":"202010060948.jpg","post":"ckt7c7wod000b9a9k4atlbnyk","modified":0,"renderable":0},{"_id":"source/_posts/language/min/sigêng-giamgia/蒹葭.m4a","slug":"蒹葭.m4a","post":"ckt7c7wod000b9a9k4atlbnyk","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png","slug":"2020-10-14-12.41.34.png","post":"ckt7c7wom000y9a9khvzs32aa","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png","slug":"2020-10-15-1.10.20.png","post":"ckt7c7wom000y9a9khvzs32aa","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png","slug":"2020-10-15-1.11.30.png","post":"ckt7c7wom000y9a9khvzs32aa","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png","slug":"2020-10-15-1.12.28.png","post":"ckt7c7wom000y9a9khvzs32aa","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-kahtsi-vowel/202010042112.png","slug":"202010042112.png","post":"ckt7c7wom000z9a9kgcw78jbg","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-basic/Untitled 1.png","slug":"Untitled 1.png","post":"ckt7c7woo00119a9k5flu72j4","modified":0,"renderable":0},{"_id":"source/_posts/it/go/go-basic/Untitled.png","slug":"Untitled.png","post":"ckt7c7woo00119a9k5flu72j4","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 1.png","slug":"Untitled 1.png","post":"ckt7c7woo00129a9kdsh31etv","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 2.png","slug":"Untitled 2.png","post":"ckt7c7woo00129a9kdsh31etv","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 3.png","slug":"Untitled 3.png","post":"ckt7c7woo00129a9kdsh31etv","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 4.png","slug":"Untitled 4.png","post":"ckt7c7woo00129a9kdsh31etv","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 5.png","slug":"Untitled 5.png","post":"ckt7c7woo00129a9kdsh31etv","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 6.png","slug":"Untitled 6.png","post":"ckt7c7woo00129a9kdsh31etv","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled.png","slug":"Untitled.png","post":"ckt7c7woo00129a9kdsh31etv","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 1.png","slug":"Untitled 1.png","post":"ckt7c7wop00149a9k872i7cir","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 2.png","slug":"Untitled 2.png","post":"ckt7c7wop00149a9k872i7cir","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 3.png","slug":"Untitled 3.png","post":"ckt7c7wop00149a9k872i7cir","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 4.png","slug":"Untitled 4.png","post":"ckt7c7wop00149a9k872i7cir","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 5.png","slug":"Untitled 5.png","post":"ckt7c7wop00149a9k872i7cir","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 6.png","slug":"Untitled 6.png","post":"ckt7c7wop00149a9k872i7cir","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 7.png","slug":"Untitled 7.png","post":"ckt7c7wop00149a9k872i7cir","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled 8.png","slug":"Untitled 8.png","post":"ckt7c7wop00149a9k872i7cir","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-jvm/Untitled.png","slug":"Untitled.png","post":"ckt7c7wop00149a9k872i7cir","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/20201114_101407.png","slug":"20201114_101407.png","post":"ckt7c7wov001h9a9k0sjk7tvr","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/20201202_24328.png","slug":"20201202_24328.png","post":"ckt7c7wov001h9a9k0sjk7tvr","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 1.png","slug":"Untitled 1.png","post":"ckt7c7wov001h9a9k0sjk7tvr","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 2.png","slug":"Untitled 2.png","post":"ckt7c7wov001h9a9k0sjk7tvr","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 3.png","slug":"Untitled 3.png","post":"ckt7c7wov001h9a9k0sjk7tvr","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 4.png","slug":"Untitled 4.png","post":"ckt7c7wov001h9a9k0sjk7tvr","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled.png","slug":"Untitled.png","post":"ckt7c7wov001h9a9k0sjk7tvr","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 1.png","slug":"Untitled 1.png","post":"ckt7c7wov001i9a9kfown9dph","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 2.png","slug":"Untitled 2.png","post":"ckt7c7wov001i9a9kfown9dph","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 3.png","slug":"Untitled 3.png","post":"ckt7c7wov001i9a9kfown9dph","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 4.png","slug":"Untitled 4.png","post":"ckt7c7wov001i9a9kfown9dph","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 5.png","slug":"Untitled 5.png","post":"ckt7c7wov001i9a9kfown9dph","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 6.png","slug":"Untitled 6.png","post":"ckt7c7wov001i9a9kfown9dph","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 7.png","slug":"Untitled 7.png","post":"ckt7c7wov001i9a9kfown9dph","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled 8.png","slug":"Untitled 8.png","post":"ckt7c7wov001i9a9kfown9dph","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-concurrent/Untitled.png","slug":"Untitled.png","post":"ckt7c7wov001i9a9kfown9dph","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 1.png","slug":"Untitled 1.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 10.png","slug":"Untitled 10.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 11.png","slug":"Untitled 11.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 12.png","slug":"Untitled 12.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 13.png","slug":"Untitled 13.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 14.png","slug":"Untitled 14.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 15.png","slug":"Untitled 15.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 16.png","slug":"Untitled 16.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 17.png","slug":"Untitled 17.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 18.png","slug":"Untitled 18.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 19.png","slug":"Untitled 19.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 2.png","slug":"Untitled 2.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 20.png","slug":"Untitled 20.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 21.png","slug":"Untitled 21.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 22.png","slug":"Untitled 22.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 23.png","slug":"Untitled 23.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 24.png","slug":"Untitled 24.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 25.png","slug":"Untitled 25.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 26.png","slug":"Untitled 26.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 27.png","slug":"Untitled 27.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 28.png","slug":"Untitled 28.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 29.png","slug":"Untitled 29.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 3.png","slug":"Untitled 3.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 30.png","slug":"Untitled 30.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 31.png","slug":"Untitled 31.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 32.png","slug":"Untitled 32.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 33.png","slug":"Untitled 33.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 34.png","slug":"Untitled 34.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 35.png","slug":"Untitled 35.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 36.png","slug":"Untitled 36.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 37.png","slug":"Untitled 37.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 38.png","slug":"Untitled 38.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 39.png","slug":"Untitled 39.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 4.png","slug":"Untitled 4.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 40.png","slug":"Untitled 40.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 41.png","slug":"Untitled 41.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 42.png","slug":"Untitled 42.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 43.png","slug":"Untitled 43.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 44.png","slug":"Untitled 44.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 45.png","slug":"Untitled 45.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 46.png","slug":"Untitled 46.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 47.png","slug":"Untitled 47.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 48.png","slug":"Untitled 48.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 49.png","slug":"Untitled 49.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 5.png","slug":"Untitled 5.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 50.png","slug":"Untitled 50.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 51.png","slug":"Untitled 51.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 52.png","slug":"Untitled 52.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 53.png","slug":"Untitled 53.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 54.png","slug":"Untitled 54.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 55.png","slug":"Untitled 55.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 56.png","slug":"Untitled 56.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 57.png","slug":"Untitled 57.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 58.png","slug":"Untitled 58.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 59.png","slug":"Untitled 59.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 6.png","slug":"Untitled 6.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 60.png","slug":"Untitled 60.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 61.png","slug":"Untitled 61.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 62.png","slug":"Untitled 62.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 63.png","slug":"Untitled 63.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 64.png","slug":"Untitled 64.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 65.png","slug":"Untitled 65.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 66.png","slug":"Untitled 66.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 67.png","slug":"Untitled 67.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 68.png","slug":"Untitled 68.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 69.png","slug":"Untitled 69.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 7.png","slug":"Untitled 7.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 70.png","slug":"Untitled 70.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 71.png","slug":"Untitled 71.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 72.png","slug":"Untitled 72.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 73.png","slug":"Untitled 73.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 74.png","slug":"Untitled 74.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 75.png","slug":"Untitled 75.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 76.png","slug":"Untitled 76.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 77.png","slug":"Untitled 77.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 78.png","slug":"Untitled 78.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 79.png","slug":"Untitled 79.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 8.png","slug":"Untitled 8.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 80.png","slug":"Untitled 80.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 81.png","slug":"Untitled 81.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 82.png","slug":"Untitled 82.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 83.png","slug":"Untitled 83.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 84.png","slug":"Untitled 84.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 85.png","slug":"Untitled 85.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled 9.png","slug":"Untitled 9.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/Untitled.png","slug":"Untitled.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-biang-diao.png","slug":"gahzi-biang-diao.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-bho.png","slug":"gahzi-sian-bho.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-sian-diao.png","slug":"gahzi-sian-diao.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/gahzi-ung-bho.png","slug":"gahzi-ung-bho.png","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/image.jpg","slug":"image.jpg","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0},{"_id":"source/_posts/language/min/gahzi-oi-hung-lui-ci-biao/jiazi-map.jpg","slug":"jiazi-map.jpg","post":"ckt7c7wp2001l9a9k6w61gy4s","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ckt7c7wo300009a9k9he6c7xz","tag_id":"ckt7c7wo700029a9k8vcsfo31","_id":"ckt7c7wob00079a9k4lkb8rxr"},{"post_id":"ckt7c7wo600019a9kh2gm6od2","tag_id":"ckt7c7wob00069a9k81gogt08","_id":"ckt7c7woe000c9a9kajrpa6x9"},{"post_id":"ckt7c7wo800039a9k0do7hn31","tag_id":"ckt7c7wod000a9a9k6vz9067t","_id":"ckt7c7wof000e9a9k43x89udg"},{"post_id":"ckt7c7wo900049a9khw360xtn","tag_id":"ckt7c7woe000d9a9kbf7e2t7b","_id":"ckt7c7wog000g9a9k61ni5dij"},{"post_id":"ckt7c7woa00059a9kc7ku484w","tag_id":"ckt7c7woe000d9a9kbf7e2t7b","_id":"ckt7c7woh000i9a9k55fjgs30"},{"post_id":"ckt7c7wob00089a9k66j2biw3","tag_id":"ckt7c7woh000h9a9kgi4e895j","_id":"ckt7c7woi000n9a9k7af1by70"},{"post_id":"ckt7c7wob00089a9k66j2biw3","tag_id":"ckt7c7woh000j9a9k3ws5f4ew","_id":"ckt7c7woi000o9a9k3nrkghrw"},{"post_id":"ckt7c7wob00089a9k66j2biw3","tag_id":"ckt7c7woh000k9a9k1x5e0shz","_id":"ckt7c7woj000q9a9kh5u32n4p"},{"post_id":"ckt7c7wob00089a9k66j2biw3","tag_id":"ckt7c7woe000d9a9kbf7e2t7b","_id":"ckt7c7woj000r9a9k7hs7ajye"},{"post_id":"ckt7c7woc00099a9kf6cagxvw","tag_id":"ckt7c7woi000m9a9kfui5bmoq","_id":"ckt7c7woj000t9a9k645kaf1d"},{"post_id":"ckt7c7wod000b9a9k4atlbnyk","tag_id":"ckt7c7woi000p9a9kgf954klf","_id":"ckt7c7woj000v9a9kdmzw2l9y"},{"post_id":"ckt7c7wod000b9a9k4atlbnyk","tag_id":"ckt7c7woh000h9a9kgi4e895j","_id":"ckt7c7woj000w9a9k68b4h8yb"},{"post_id":"ckt7c7wod000b9a9k4atlbnyk","tag_id":"ckt7c7woj000u9a9k8rkr0xwz","_id":"ckt7c7wok000x9a9k5s3hhl2m"},{"post_id":"ckt7c7woo00119a9k5flu72j4","tag_id":"ckt7c7woe000d9a9kbf7e2t7b","_id":"ckt7c7wop00139a9k6ycae20q"},{"post_id":"ckt7c7wom000y9a9khvzs32aa","tag_id":"ckt7c7won00109a9kbl5r6mxc","_id":"ckt7c7wos00179a9k4b4lb3x4"},{"post_id":"ckt7c7wom000y9a9khvzs32aa","tag_id":"ckt7c7wor00159a9k4xkr5xrl","_id":"ckt7c7wot00189a9k2dus43yd"},{"post_id":"ckt7c7wom000y9a9khvzs32aa","tag_id":"ckt7c7woj000u9a9k8rkr0xwz","_id":"ckt7c7wot001a9a9k6dbi8ioi"},{"post_id":"ckt7c7wom000z9a9kgcw78jbg","tag_id":"ckt7c7woj000u9a9k8rkr0xwz","_id":"ckt7c7wot001b9a9k8vfj8abp"},{"post_id":"ckt7c7wom000z9a9kgcw78jbg","tag_id":"ckt7c7wor00159a9k4xkr5xrl","_id":"ckt7c7wot001d9a9kdo23g0yp"},{"post_id":"ckt7c7wom000z9a9kgcw78jbg","tag_id":"ckt7c7woh000h9a9kgi4e895j","_id":"ckt7c7wot001e9a9k11x23vwt"},{"post_id":"ckt7c7woo00129a9kdsh31etv","tag_id":"ckt7c7wot00199a9k2mpnavym","_id":"ckt7c7wou001f9a9kb7ggc631"},{"post_id":"ckt7c7wop00149a9k872i7cir","tag_id":"ckt7c7wot00199a9k2mpnavym","_id":"ckt7c7wou001g9a9kguesdfun"},{"post_id":"ckt7c7wov001h9a9k0sjk7tvr","tag_id":"ckt7c7wot00199a9k2mpnavym","_id":"ckt7c7wow001j9a9k0yab2xza"},{"post_id":"ckt7c7wov001i9a9kfown9dph","tag_id":"ckt7c7wot00199a9k2mpnavym","_id":"ckt7c7wow001k9a9kg3lmbew4"},{"post_id":"ckt7c7wp2001l9a9k6w61gy4s","tag_id":"ckt7c7woh000h9a9kgi4e895j","_id":"ckt7c7wp4001m9a9kbhoa4h2o"},{"post_id":"ckt7c7wp2001l9a9k6w61gy4s","tag_id":"ckt7c7woj000u9a9k8rkr0xwz","_id":"ckt7c7wp5001n9a9khmr31fid"}],"Tag":[{"name":"Hello","_id":"ckt7c7wo700029a9k8vcsfo31"},{"name":"聆聽音樂","_id":"ckt7c7wob00069a9k81gogt08"},{"name":"隨筆","_id":"ckt7c7wod000a9a9k6vz9067t"},{"name":"Go","_id":"ckt7c7woe000d9a9kbf7e2t7b"},{"name":"甲子話","_id":"ckt7c7woh000h9a9kgi4e895j"},{"name":"十二生肖","_id":"ckt7c7woh000j9a9k3ws5f4ew"},{"name":"干支紀年法","_id":"ckt7c7woh000k9a9k1x5e0shz"},{"name":"日本語","_id":"ckt7c7woi000m9a9kfui5bmoq"},{"name":"詩經","_id":"ckt7c7woi000p9a9kgf954klf"},{"name":"閩南語","_id":"ckt7c7woj000u9a9k8rkr0xwz"},{"name":"潮劇","_id":"ckt7c7won00109a9kbl5r6mxc"},{"name":"潮州話","_id":"ckt7c7wor00159a9k4xkr5xrl"},{"name":"Java","_id":"ckt7c7wot00199a9k2mpnavym"}]}}