---
title: Go内存模型
p: it/go/go-memory-model.md
date: 2021-12-31 10:50:00
tags:
- Go
---

本文讲述在何种情况下，一个协程（goroutine）中写入的变量值可被另一个协程中观察到。

## 先发生（happens before）

让我们来理清下时间的发生顺序。

如果事件 e1在事件 e2 之前发生，那么事件 e2 在事件 e1 之后发生。同样，如果 e1 既不在事件 e2 之前也不在 e2 之后发生，那么事件 e1 和 e2 同时发生。

<!--more-->

> 规则1: 在单个协程中，事件的发生顺序就是程序语句的先后顺序。

当满足以下条件时，对变量 v 的读取 r 可以观察到对 v 的写入 w：

1. r 不在 w 之前发生；
2. 在 w 之后 r 之前，没有其他的写入。

换句话说：

1. w 在 r 之前发生；
2. 其他的写入要么发生在 w 之前，要么发生在 r 之后。

单个协程下这两种表述没什么不同，但在多协程下需要通过同步来建立先发生条件以保证观察到其他协程对共享变量的写入。

## 同步（synchronization）

（1）初始化（initialization）

> 规则2: 若包 p 导入了包 q，则 q 的初始化方法（init）先发生于 p 的。主方法（main.main）发生在所有 init 方法完成之后。

（2）协程创建（channel creation）

> 规则3: go 语句新起一个协程先发生于协程执行。

（3）协程销毁（channel destruction）

协程的销毁不保证发生在任何事件之前。

（4）通道通信（channel communication）

通道是Go中最常用的同步方式，对于通道的事件顺序有如下规则：

> 规则4: 发送消息到 channel 先发生于对应的接收完成。

> 规则5: 通道的关闭先发生于因通道关闭而接收到零值。

> 规则6: 从无缓冲通道接收消息先发生于发送消息完成。

> 规则7: 对于容量为 C 的缓冲通道，第 k 次接收消息先发生于第 k+C 次发送消息完成。

（5）锁（locks）

当使用锁进行同步时，需要注意锁是一加一放的，不会先后加两次锁，也不会先后释放两次锁。

> 规则8: 对于任意类型为 sync.Mutex 或 sync.RWMutex 的变量 l，以及 n < m，第 n 次调用 l.Unlock() 先发生于第 m 次调用 l.Lock()。

（6）仅执行一次（once）

once.Do(f) 能保证函数 f() 能在多协程环境下仅被调用一次。是 Go 中实现单例常用方法。

> 规则9: 对函数 f() 的单次调用先发生（先返回）于 once.Do(f) 返回。

## 延伸阅读

- [The Go Memory Model](http://docscn.studygolang.com/ref/mem)
